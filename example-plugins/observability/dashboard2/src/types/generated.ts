import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  bigint: { input: number; output: number; }
  bpchar: { input: string; output: string; }
  date: { input: string; output: string; }
  float8: { input: number; output: number; }
  geography: { input: any; output: object; }
  geometry: { input: any; output: object; }
  jsonb: { input: any; output: object; }
  numeric: { input: number; output: number; }
  smallint: { input: number; output: number; }
  time: { input: any; output: any; }
  timestamp: { input: string; output: string; }
  timestamptz: { input: string; output: string; }
  uuid: { input: string; output: string; }
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** Correlated to moves in the operations system, this table holds accessorial charges applied to a move for various reasons such as delay charges for drivers spending extra time at pickup and/or delivery locations, fuel, towing of broke-down vehicles, etc. */
export type Accessorials = {
  __typename?: 'accessorials';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount: Scalars['numeric']['output'];
  /** An object relationship */
  appayment?: Maybe<Appayments>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount: Scalars['numeric']['output'];
  /** An object relationship */
  authorization?: Maybe<Authorizations>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['bigint']['output']>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code: Scalars['String']['output'];
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost: Scalars['numeric']['output'];
  /** Timestamp the accessorial was created. */
  createdat: Scalars['timestamptz']['output'];
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documents_aggregate: Documents_Aggregate;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  move: Moves;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id: Scalars['bigint']['output'];
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes: Scalars['String']['output'];
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status: Scalars['String']['output'];
  /** Timestamp the accessorial was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** Correlated to moves in the operations system, this table holds accessorial charges applied to a move for various reasons such as delay charges for drivers spending extra time at pickup and/or delivery locations, fuel, towing of broke-down vehicles, etc. */
export type AccessorialsDocumentsArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


/** Correlated to moves in the operations system, this table holds accessorial charges applied to a move for various reasons such as delay charges for drivers spending extra time at pickup and/or delivery locations, fuel, towing of broke-down vehicles, etc. */
export type AccessorialsDocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};

/** aggregated selection of "accessorials" */
export type Accessorials_Aggregate = {
  __typename?: 'accessorials_aggregate';
  aggregate?: Maybe<Accessorials_Aggregate_Fields>;
  nodes: Array<Accessorials>;
};

export type Accessorials_Aggregate_Bool_Exp = {
  count?: InputMaybe<Accessorials_Aggregate_Bool_Exp_Count>;
};

export type Accessorials_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Accessorials_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Accessorials_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "accessorials" */
export type Accessorials_Aggregate_Fields = {
  __typename?: 'accessorials_aggregate_fields';
  avg?: Maybe<Accessorials_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Accessorials_Max_Fields>;
  min?: Maybe<Accessorials_Min_Fields>;
  stddev?: Maybe<Accessorials_Stddev_Fields>;
  stddev_pop?: Maybe<Accessorials_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Accessorials_Stddev_Samp_Fields>;
  sum?: Maybe<Accessorials_Sum_Fields>;
  var_pop?: Maybe<Accessorials_Var_Pop_Fields>;
  var_samp?: Maybe<Accessorials_Var_Samp_Fields>;
  variance?: Maybe<Accessorials_Variance_Fields>;
};


/** aggregate fields of "accessorials" */
export type Accessorials_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Accessorials_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "accessorials" */
export type Accessorials_Aggregate_Order_By = {
  avg?: InputMaybe<Accessorials_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Accessorials_Max_Order_By>;
  min?: InputMaybe<Accessorials_Min_Order_By>;
  stddev?: InputMaybe<Accessorials_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Accessorials_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Accessorials_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Accessorials_Sum_Order_By>;
  var_pop?: InputMaybe<Accessorials_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Accessorials_Var_Samp_Order_By>;
  variance?: InputMaybe<Accessorials_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "accessorials" */
export type Accessorials_Arr_Rel_Insert_Input = {
  data: Array<Accessorials_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Accessorials_On_Conflict>;
};

/** aggregate avg on columns */
export type Accessorials_Avg_Fields = {
  __typename?: 'accessorials_avg_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "accessorials" */
export type Accessorials_Avg_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "accessorials". All fields are combined with a logical 'AND'. */
export type Accessorials_Bool_Exp = {
  _and?: InputMaybe<Array<Accessorials_Bool_Exp>>;
  _not?: InputMaybe<Accessorials_Bool_Exp>;
  _or?: InputMaybe<Array<Accessorials_Bool_Exp>>;
  ap_amount?: InputMaybe<Numeric_Comparison_Exp>;
  appayment?: InputMaybe<Appayments_Bool_Exp>;
  ar_amount?: InputMaybe<Numeric_Comparison_Exp>;
  authorization?: InputMaybe<Authorizations_Bool_Exp>;
  authorization_id?: InputMaybe<Bigint_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  document_reference_id?: InputMaybe<Uuid_Comparison_Exp>;
  documents?: InputMaybe<Documents_Bool_Exp>;
  documents_aggregate?: InputMaybe<Documents_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "accessorials" */
export enum Accessorials_Constraint {
  /** unique or primary key constraint on columns "id" */
  AccessorialsPkey = 'accessorials_pkey'
}

/** input type for incrementing numeric columns in table "accessorials" */
export type Accessorials_Inc_Input = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "accessorials" */
export type Accessorials_Insert_Input = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Scalars['numeric']['input']>;
  appayment?: InputMaybe<Appayments_Obj_Rel_Insert_Input>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Scalars['numeric']['input']>;
  authorization?: InputMaybe<Authorizations_Obj_Rel_Insert_Input>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: InputMaybe<Scalars['String']['input']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp the accessorial was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  documents?: InputMaybe<Documents_Arr_Rel_Insert_Input>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the accessorial was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Accessorials_Max_Fields = {
  __typename?: 'accessorials_max_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['numeric']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['bigint']['output']>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: Maybe<Scalars['String']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp the accessorial was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: Maybe<Scalars['String']['output']>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: Maybe<Scalars['String']['output']>;
  /** Timestamp the accessorial was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "accessorials" */
export type Accessorials_Max_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Timestamp the accessorial was created. */
  createdat?: InputMaybe<Order_By>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: InputMaybe<Order_By>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: InputMaybe<Order_By>;
  /** Timestamp the accessorial was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Accessorials_Min_Fields = {
  __typename?: 'accessorials_min_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['numeric']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['bigint']['output']>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: Maybe<Scalars['String']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp the accessorial was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: Maybe<Scalars['String']['output']>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: Maybe<Scalars['String']['output']>;
  /** Timestamp the accessorial was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "accessorials" */
export type Accessorials_Min_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Timestamp the accessorial was created. */
  createdat?: InputMaybe<Order_By>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: InputMaybe<Order_By>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: InputMaybe<Order_By>;
  /** Timestamp the accessorial was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "accessorials" */
export type Accessorials_Mutation_Response = {
  __typename?: 'accessorials_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Accessorials>;
};

/** input type for inserting object relation for remote table "accessorials" */
export type Accessorials_Obj_Rel_Insert_Input = {
  data: Accessorials_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Accessorials_On_Conflict>;
};

/** on_conflict condition type for table "accessorials" */
export type Accessorials_On_Conflict = {
  constraint: Accessorials_Constraint;
  update_columns?: Array<Accessorials_Update_Column>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};

/** Ordering options when selecting data from "accessorials". */
export type Accessorials_Order_By = {
  ap_amount?: InputMaybe<Order_By>;
  appayment?: InputMaybe<Appayments_Order_By>;
  ar_amount?: InputMaybe<Order_By>;
  authorization?: InputMaybe<Authorizations_Order_By>;
  authorization_id?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  document_reference_id?: InputMaybe<Order_By>;
  documents_aggregate?: InputMaybe<Documents_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: accessorials */
export type Accessorials_Pk_Columns_Input = {
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** select columns of table "accessorials" */
export enum Accessorials_Select_Column {
  /** column name */
  ApAmount = 'ap_amount',
  /** column name */
  ArAmount = 'ar_amount',
  /** column name */
  AuthorizationId = 'authorization_id',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "accessorials" */
export type Accessorials_Set_Input = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: InputMaybe<Scalars['String']['input']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp the accessorial was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the accessorial was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Accessorials_Stddev_Fields = {
  __typename?: 'accessorials_stddev_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "accessorials" */
export type Accessorials_Stddev_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Accessorials_Stddev_Pop_Fields = {
  __typename?: 'accessorials_stddev_pop_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "accessorials" */
export type Accessorials_Stddev_Pop_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Accessorials_Stddev_Samp_Fields = {
  __typename?: 'accessorials_stddev_samp_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "accessorials" */
export type Accessorials_Stddev_Samp_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "accessorials" */
export type Accessorials_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Accessorials_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Accessorials_Stream_Cursor_Value_Input = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The value referencing the event that caused a change of cost of the move. |delay - The move was delayed from being completed on time at no fault to driver or customer|fuel - The driver needed to add fuel to the gas tank of the vehicle|insurance - The insurance cost was different than originally known|partial- catch-all for extra payment to driver due to driver doing work that was not originally paid for|ride - payment for an originally unaccounted rideshare or other transport|surge - The driver uses a rideshare and the price is increased due to a "surge" timeframe|toll - toll reimbursement to the driver|tow - The vehicle had to be towed during the move duration|waived - Cancellation fee waived| */
  code?: InputMaybe<Scalars['String']['input']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp the accessorial was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this accessorial has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Operations team notes input through the admin system describing the additional charge and its context/reasoning for being applied to the move. This will be customer and/or driver facing. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** (Currently we don't use the approval process of accessorials, all statuses are entered as accepted) The value referencing the approval status of the accessorial cost change |accepted - Lesser used approval of cost, should be coupled with "approved"|approved - Approval of accessorial cost, should be coupled with "accepted"|declined - Denial of accessorial cost|expired|failed|pending - the accessorial was added but first requires approval from management before it is added to the charges and/or driver pay| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the accessorial was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Accessorials_Sum_Fields = {
  __typename?: 'accessorials_sum_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['numeric']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['bigint']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['numeric']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "accessorials" */
export type Accessorials_Sum_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** update columns of table "accessorials" */
export enum Accessorials_Update_Column {
  /** column name */
  ApAmount = 'ap_amount',
  /** column name */
  ArAmount = 'ar_amount',
  /** column name */
  AuthorizationId = 'authorization_id',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

export type Accessorials_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Accessorials_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Accessorials_Set_Input>;
  /** filter the rows which have to be updated */
  where: Accessorials_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Accessorials_Var_Pop_Fields = {
  __typename?: 'accessorials_var_pop_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "accessorials" */
export type Accessorials_Var_Pop_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Accessorials_Var_Samp_Fields = {
  __typename?: 'accessorials_var_samp_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "accessorials" */
export type Accessorials_Var_Samp_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Accessorials_Variance_Fields = {
  __typename?: 'accessorials_variance_fields';
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: Maybe<Scalars['Float']['output']>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "accessorials" */
export type Accessorials_Variance_Order_By = {
  /** The monetary value representing the amount this accessorial will be paid to the driver as a reimbursement. */
  ap_amount?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial will be charged to the customer as a charge included in the armovedetails that make up the total amount due for a move. */
  ar_amount?: InputMaybe<Order_By>;
  /** Foreign key to the authorizations table. In order for an authorization to be approved, this record must exist in a pending status as well as the related authorization record. */
  authorization_id?: InputMaybe<Order_By>;
  /** The monetary value representing the amount this accessorial costed to HopDrive. This is an internal number that is not expected to be shown to a driver or customer. */
  cost?: InputMaybe<Order_By>;
  /** Primary key for the accessorial table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the accessorial table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** A link between accessorials and algorithms. These can be default, region, organization or customer-specific algorithms to run for each accessorial type. */
export type Accessorialstoalgorithms = {
  __typename?: 'accessorialstoalgorithms';
  /** Code of the accessorial. */
  accessorial_code: Scalars['String']['output'];
  /** An object relationship */
  algorithm?: Maybe<Algorithms>;
  /** ID of the algorithm. */
  algorithm_id: Scalars['bigint']['output'];
  /** An object relationship */
  customer?: Maybe<Customers>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  organization?: Maybe<Organizations>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  region?: Maybe<Regions>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Aggregate = {
  __typename?: 'accessorialstoalgorithms_aggregate';
  aggregate?: Maybe<Accessorialstoalgorithms_Aggregate_Fields>;
  nodes: Array<Accessorialstoalgorithms>;
};

/** aggregate fields of "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Aggregate_Fields = {
  __typename?: 'accessorialstoalgorithms_aggregate_fields';
  avg?: Maybe<Accessorialstoalgorithms_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Accessorialstoalgorithms_Max_Fields>;
  min?: Maybe<Accessorialstoalgorithms_Min_Fields>;
  stddev?: Maybe<Accessorialstoalgorithms_Stddev_Fields>;
  stddev_pop?: Maybe<Accessorialstoalgorithms_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Accessorialstoalgorithms_Stddev_Samp_Fields>;
  sum?: Maybe<Accessorialstoalgorithms_Sum_Fields>;
  var_pop?: Maybe<Accessorialstoalgorithms_Var_Pop_Fields>;
  var_samp?: Maybe<Accessorialstoalgorithms_Var_Samp_Fields>;
  variance?: Maybe<Accessorialstoalgorithms_Variance_Fields>;
};


/** aggregate fields of "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Accessorialstoalgorithms_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Accessorialstoalgorithms_Avg_Fields = {
  __typename?: 'accessorialstoalgorithms_avg_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "accessorialstoalgorithms". All fields are combined with a logical 'AND'. */
export type Accessorialstoalgorithms_Bool_Exp = {
  _and?: InputMaybe<Array<Accessorialstoalgorithms_Bool_Exp>>;
  _not?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
  _or?: InputMaybe<Array<Accessorialstoalgorithms_Bool_Exp>>;
  accessorial_code?: InputMaybe<String_Comparison_Exp>;
  algorithm?: InputMaybe<Algorithms_Bool_Exp>;
  algorithm_id?: InputMaybe<Bigint_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "accessorialstoalgorithms" */
export enum Accessorialstoalgorithms_Constraint {
  /** unique or primary key constraint on columns "id" */
  AccessorialstoalgorithmsPkey = 'accessorialstoalgorithms_pkey'
}

/** input type for incrementing numeric columns in table "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Inc_Input = {
  /** ID of the algorithm. */
  algorithm_id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Insert_Input = {
  /** Code of the accessorial. */
  accessorial_code?: InputMaybe<Scalars['String']['input']>;
  algorithm?: InputMaybe<Algorithms_Obj_Rel_Insert_Input>;
  /** ID of the algorithm. */
  algorithm_id?: InputMaybe<Scalars['bigint']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Accessorialstoalgorithms_Max_Fields = {
  __typename?: 'accessorialstoalgorithms_max_fields';
  /** Code of the accessorial. */
  accessorial_code?: Maybe<Scalars['String']['output']>;
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Accessorialstoalgorithms_Min_Fields = {
  __typename?: 'accessorialstoalgorithms_min_fields';
  /** Code of the accessorial. */
  accessorial_code?: Maybe<Scalars['String']['output']>;
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Mutation_Response = {
  __typename?: 'accessorialstoalgorithms_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Accessorialstoalgorithms>;
};

/** on_conflict condition type for table "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_On_Conflict = {
  constraint: Accessorialstoalgorithms_Constraint;
  update_columns?: Array<Accessorialstoalgorithms_Update_Column>;
  where?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
};

/** Ordering options when selecting data from "accessorialstoalgorithms". */
export type Accessorialstoalgorithms_Order_By = {
  accessorial_code?: InputMaybe<Order_By>;
  algorithm?: InputMaybe<Algorithms_Order_By>;
  algorithm_id?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: accessorialstoalgorithms */
export type Accessorialstoalgorithms_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "accessorialstoalgorithms" */
export enum Accessorialstoalgorithms_Select_Column {
  /** column name */
  AccessorialCode = 'accessorial_code',
  /** column name */
  AlgorithmId = 'algorithm_id',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  RegionId = 'region_id'
}

/** input type for updating data in table "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Set_Input = {
  /** Code of the accessorial. */
  accessorial_code?: InputMaybe<Scalars['String']['input']>;
  /** ID of the algorithm. */
  algorithm_id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Accessorialstoalgorithms_Stddev_Fields = {
  __typename?: 'accessorialstoalgorithms_stddev_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Accessorialstoalgorithms_Stddev_Pop_Fields = {
  __typename?: 'accessorialstoalgorithms_stddev_pop_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Accessorialstoalgorithms_Stddev_Samp_Fields = {
  __typename?: 'accessorialstoalgorithms_stddev_samp_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "accessorialstoalgorithms" */
export type Accessorialstoalgorithms_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Accessorialstoalgorithms_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Accessorialstoalgorithms_Stream_Cursor_Value_Input = {
  /** Code of the accessorial. */
  accessorial_code?: InputMaybe<Scalars['String']['input']>;
  /** ID of the algorithm. */
  algorithm_id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Accessorialstoalgorithms_Sum_Fields = {
  __typename?: 'accessorialstoalgorithms_sum_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "accessorialstoalgorithms" */
export enum Accessorialstoalgorithms_Update_Column {
  /** column name */
  AccessorialCode = 'accessorial_code',
  /** column name */
  AlgorithmId = 'algorithm_id',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  RegionId = 'region_id'
}

export type Accessorialstoalgorithms_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Accessorialstoalgorithms_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Accessorialstoalgorithms_Set_Input>;
  /** filter the rows which have to be updated */
  where: Accessorialstoalgorithms_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Accessorialstoalgorithms_Var_Pop_Fields = {
  __typename?: 'accessorialstoalgorithms_var_pop_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Accessorialstoalgorithms_Var_Samp_Fields = {
  __typename?: 'accessorialstoalgorithms_var_samp_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Accessorialstoalgorithms_Variance_Fields = {
  __typename?: 'accessorialstoalgorithms_variance_fields';
  /** ID of the algorithm. */
  algorithm_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the customer. If this value is present, customers with this customer_id will use this algorithm for this accessorial. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** ID of the organization. If this value is present, customers with this organization_id will use this algorithm for this accessorial. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** ID of the region. If this value is present, customers with this region_id will use this algorithm for this accessorial. */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Stores the name and metadata schemas of different action types for eventlogs table */
export type Actiontypes = {
  __typename?: 'actiontypes';
  /** The explanation of the function for each actiontype */
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry: Scalars['Int']['output'];
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id: Scalars['smallint']['output'];
  /** Schema for metadata associated with actiontype */
  metadata_schema?: Maybe<Scalars['jsonb']['output']>;
  /** Dot notation description of action |move.created - A move has been created|move.deleted - A move has been deleted|move.details.updated - Values on the move details have been updated|accessorial.created - An accessorial has been created|accessorial.updated - Values on the accessorial have been updated successfully|accessorial.deleted - An accessorial has been deleted|sms.sent - Text message has been sent successfully to customer|sms.failed - Text message failed to send to customer|lyftride.created - A Lyft ride has been created|lyftride.updated - Values on the Lyft ride have been updated successfully|lyftride.deleted - A Lyft ride has been deleted|lyftride.updated.failed - Attempt to update values on the Lyft ride failed|move.updated.failed  - Attempt to update values on the move failed|accessorial.updated.failed - Attempt to update values on the accessorial failed|lyftride.created.failed - Attempt to create a Lyft ride failed|accessorial.created.failed - Attempt to create an accessorial failed|move.created.failed - Attempt to create a move failed|move.deleted.failed - Attempt to delete a move failed|accessorial.deleted.failed - Attempt to delete an accessorial failed|lyftride.deleted.failed - Attempt to delete a Lyft ride failed|move.cancel.pending - Move is in pending status waiting for approval of cancellation|move.cancel.seen - Move placed in canceled seen status, it is acknowledged by the dispatcher and can be removed from dispatcher notifications|move.cancel.partial - come back to this ------------------|move.cancel.succeeded - Move put in canceled status|move.cancel.failed - Attempt to put move in canceled status failed|move.status.overridden - Status of move manually updated|move.times.updated - come back to this ---------------|move.unplanned - Move have been unplanned from a drivers schedule on the plan screen |return.ride.canceled - Ride after move has been successfully canceled|rideshare.called -Driver or Dispatcher has initiated the rideshare to be called|move.pickup.started - Driver has indicated they've arrived at the pickup location and is no longer in dispatched status|move.status.updated - Move status has been successfully updated|move.dispatched - A move has been assigned to a driver and no longer in draft status|move.planned - Move has been assigned to a drivers plan|move.undispatched - A move previously dispatched to a driver has been removed from their plan|move.return.ready - Move has been marked as return ready through the hangtag workflow|move.return.created - A move return has been created through the hangtag workflow|hangtag.unassigned - A hangtag has been unassigned from a move|hangtag.assigned - A hangtag has been assigned to a move| */
  name: Scalars['String']['output'];
};


/** Stores the name and metadata schemas of different action types for eventlogs table */
export type ActiontypesEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** Stores the name and metadata schemas of different action types for eventlogs table */
export type ActiontypesEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** Stores the name and metadata schemas of different action types for eventlogs table */
export type ActiontypesMetadata_SchemaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "actiontypes" */
export type Actiontypes_Aggregate = {
  __typename?: 'actiontypes_aggregate';
  aggregate?: Maybe<Actiontypes_Aggregate_Fields>;
  nodes: Array<Actiontypes>;
};

/** aggregate fields of "actiontypes" */
export type Actiontypes_Aggregate_Fields = {
  __typename?: 'actiontypes_aggregate_fields';
  avg?: Maybe<Actiontypes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Actiontypes_Max_Fields>;
  min?: Maybe<Actiontypes_Min_Fields>;
  stddev?: Maybe<Actiontypes_Stddev_Fields>;
  stddev_pop?: Maybe<Actiontypes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Actiontypes_Stddev_Samp_Fields>;
  sum?: Maybe<Actiontypes_Sum_Fields>;
  var_pop?: Maybe<Actiontypes_Var_Pop_Fields>;
  var_samp?: Maybe<Actiontypes_Var_Samp_Fields>;
  variance?: Maybe<Actiontypes_Variance_Fields>;
};


/** aggregate fields of "actiontypes" */
export type Actiontypes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Actiontypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Actiontypes_Append_Input = {
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Actiontypes_Avg_Fields = {
  __typename?: 'actiontypes_avg_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "actiontypes". All fields are combined with a logical 'AND'. */
export type Actiontypes_Bool_Exp = {
  _and?: InputMaybe<Array<Actiontypes_Bool_Exp>>;
  _not?: InputMaybe<Actiontypes_Bool_Exp>;
  _or?: InputMaybe<Array<Actiontypes_Bool_Exp>>;
  description?: InputMaybe<String_Comparison_Exp>;
  eventlogs?: InputMaybe<Eventlogs_Bool_Exp>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Bool_Exp>;
  expiry?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Smallint_Comparison_Exp>;
  metadata_schema?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "actiontypes" */
export enum Actiontypes_Constraint {
  /** unique or primary key constraint on columns "id" */
  ActiontypesPkey = 'actiontypes_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Actiontypes_Delete_At_Path_Input = {
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Actiontypes_Delete_Elem_Input = {
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Actiontypes_Delete_Key_Input = {
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "actiontypes" */
export type Actiontypes_Inc_Input = {
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: InputMaybe<Scalars['Int']['input']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "actiontypes" */
export type Actiontypes_Insert_Input = {
  /** The explanation of the function for each actiontype */
  description?: InputMaybe<Scalars['String']['input']>;
  eventlogs?: InputMaybe<Eventlogs_Arr_Rel_Insert_Input>;
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: InputMaybe<Scalars['Int']['input']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: InputMaybe<Scalars['smallint']['input']>;
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['jsonb']['input']>;
  /** Dot notation description of action |move.created - A move has been created|move.deleted - A move has been deleted|move.details.updated - Values on the move details have been updated|accessorial.created - An accessorial has been created|accessorial.updated - Values on the accessorial have been updated successfully|accessorial.deleted - An accessorial has been deleted|sms.sent - Text message has been sent successfully to customer|sms.failed - Text message failed to send to customer|lyftride.created - A Lyft ride has been created|lyftride.updated - Values on the Lyft ride have been updated successfully|lyftride.deleted - A Lyft ride has been deleted|lyftride.updated.failed - Attempt to update values on the Lyft ride failed|move.updated.failed  - Attempt to update values on the move failed|accessorial.updated.failed - Attempt to update values on the accessorial failed|lyftride.created.failed - Attempt to create a Lyft ride failed|accessorial.created.failed - Attempt to create an accessorial failed|move.created.failed - Attempt to create a move failed|move.deleted.failed - Attempt to delete a move failed|accessorial.deleted.failed - Attempt to delete an accessorial failed|lyftride.deleted.failed - Attempt to delete a Lyft ride failed|move.cancel.pending - Move is in pending status waiting for approval of cancellation|move.cancel.seen - Move placed in canceled seen status, it is acknowledged by the dispatcher and can be removed from dispatcher notifications|move.cancel.partial - come back to this ------------------|move.cancel.succeeded - Move put in canceled status|move.cancel.failed - Attempt to put move in canceled status failed|move.status.overridden - Status of move manually updated|move.times.updated - come back to this ---------------|move.unplanned - Move have been unplanned from a drivers schedule on the plan screen |return.ride.canceled - Ride after move has been successfully canceled|rideshare.called -Driver or Dispatcher has initiated the rideshare to be called|move.pickup.started - Driver has indicated they've arrived at the pickup location and is no longer in dispatched status|move.status.updated - Move status has been successfully updated|move.dispatched - A move has been assigned to a driver and no longer in draft status|move.planned - Move has been assigned to a drivers plan|move.undispatched - A move previously dispatched to a driver has been removed from their plan|move.return.ready - Move has been marked as return ready through the hangtag workflow|move.return.created - A move return has been created through the hangtag workflow|hangtag.unassigned - A hangtag has been unassigned from a move|hangtag.assigned - A hangtag has been assigned to a move| */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Actiontypes_Max_Fields = {
  __typename?: 'actiontypes_max_fields';
  /** The explanation of the function for each actiontype */
  description?: Maybe<Scalars['String']['output']>;
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Int']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['smallint']['output']>;
  /** Dot notation description of action |move.created - A move has been created|move.deleted - A move has been deleted|move.details.updated - Values on the move details have been updated|accessorial.created - An accessorial has been created|accessorial.updated - Values on the accessorial have been updated successfully|accessorial.deleted - An accessorial has been deleted|sms.sent - Text message has been sent successfully to customer|sms.failed - Text message failed to send to customer|lyftride.created - A Lyft ride has been created|lyftride.updated - Values on the Lyft ride have been updated successfully|lyftride.deleted - A Lyft ride has been deleted|lyftride.updated.failed - Attempt to update values on the Lyft ride failed|move.updated.failed  - Attempt to update values on the move failed|accessorial.updated.failed - Attempt to update values on the accessorial failed|lyftride.created.failed - Attempt to create a Lyft ride failed|accessorial.created.failed - Attempt to create an accessorial failed|move.created.failed - Attempt to create a move failed|move.deleted.failed - Attempt to delete a move failed|accessorial.deleted.failed - Attempt to delete an accessorial failed|lyftride.deleted.failed - Attempt to delete a Lyft ride failed|move.cancel.pending - Move is in pending status waiting for approval of cancellation|move.cancel.seen - Move placed in canceled seen status, it is acknowledged by the dispatcher and can be removed from dispatcher notifications|move.cancel.partial - come back to this ------------------|move.cancel.succeeded - Move put in canceled status|move.cancel.failed - Attempt to put move in canceled status failed|move.status.overridden - Status of move manually updated|move.times.updated - come back to this ---------------|move.unplanned - Move have been unplanned from a drivers schedule on the plan screen |return.ride.canceled - Ride after move has been successfully canceled|rideshare.called -Driver or Dispatcher has initiated the rideshare to be called|move.pickup.started - Driver has indicated they've arrived at the pickup location and is no longer in dispatched status|move.status.updated - Move status has been successfully updated|move.dispatched - A move has been assigned to a driver and no longer in draft status|move.planned - Move has been assigned to a drivers plan|move.undispatched - A move previously dispatched to a driver has been removed from their plan|move.return.ready - Move has been marked as return ready through the hangtag workflow|move.return.created - A move return has been created through the hangtag workflow|hangtag.unassigned - A hangtag has been unassigned from a move|hangtag.assigned - A hangtag has been assigned to a move| */
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Actiontypes_Min_Fields = {
  __typename?: 'actiontypes_min_fields';
  /** The explanation of the function for each actiontype */
  description?: Maybe<Scalars['String']['output']>;
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Int']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['smallint']['output']>;
  /** Dot notation description of action |move.created - A move has been created|move.deleted - A move has been deleted|move.details.updated - Values on the move details have been updated|accessorial.created - An accessorial has been created|accessorial.updated - Values on the accessorial have been updated successfully|accessorial.deleted - An accessorial has been deleted|sms.sent - Text message has been sent successfully to customer|sms.failed - Text message failed to send to customer|lyftride.created - A Lyft ride has been created|lyftride.updated - Values on the Lyft ride have been updated successfully|lyftride.deleted - A Lyft ride has been deleted|lyftride.updated.failed - Attempt to update values on the Lyft ride failed|move.updated.failed  - Attempt to update values on the move failed|accessorial.updated.failed - Attempt to update values on the accessorial failed|lyftride.created.failed - Attempt to create a Lyft ride failed|accessorial.created.failed - Attempt to create an accessorial failed|move.created.failed - Attempt to create a move failed|move.deleted.failed - Attempt to delete a move failed|accessorial.deleted.failed - Attempt to delete an accessorial failed|lyftride.deleted.failed - Attempt to delete a Lyft ride failed|move.cancel.pending - Move is in pending status waiting for approval of cancellation|move.cancel.seen - Move placed in canceled seen status, it is acknowledged by the dispatcher and can be removed from dispatcher notifications|move.cancel.partial - come back to this ------------------|move.cancel.succeeded - Move put in canceled status|move.cancel.failed - Attempt to put move in canceled status failed|move.status.overridden - Status of move manually updated|move.times.updated - come back to this ---------------|move.unplanned - Move have been unplanned from a drivers schedule on the plan screen |return.ride.canceled - Ride after move has been successfully canceled|rideshare.called -Driver or Dispatcher has initiated the rideshare to be called|move.pickup.started - Driver has indicated they've arrived at the pickup location and is no longer in dispatched status|move.status.updated - Move status has been successfully updated|move.dispatched - A move has been assigned to a driver and no longer in draft status|move.planned - Move has been assigned to a drivers plan|move.undispatched - A move previously dispatched to a driver has been removed from their plan|move.return.ready - Move has been marked as return ready through the hangtag workflow|move.return.created - A move return has been created through the hangtag workflow|hangtag.unassigned - A hangtag has been unassigned from a move|hangtag.assigned - A hangtag has been assigned to a move| */
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "actiontypes" */
export type Actiontypes_Mutation_Response = {
  __typename?: 'actiontypes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Actiontypes>;
};

/** input type for inserting object relation for remote table "actiontypes" */
export type Actiontypes_Obj_Rel_Insert_Input = {
  data: Actiontypes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Actiontypes_On_Conflict>;
};

/** on_conflict condition type for table "actiontypes" */
export type Actiontypes_On_Conflict = {
  constraint: Actiontypes_Constraint;
  update_columns?: Array<Actiontypes_Update_Column>;
  where?: InputMaybe<Actiontypes_Bool_Exp>;
};

/** Ordering options when selecting data from "actiontypes". */
export type Actiontypes_Order_By = {
  description?: InputMaybe<Order_By>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Order_By>;
  expiry?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  metadata_schema?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: actiontypes */
export type Actiontypes_Pk_Columns_Input = {
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id: Scalars['smallint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Actiontypes_Prepend_Input = {
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "actiontypes" */
export enum Actiontypes_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  Id = 'id',
  /** column name */
  MetadataSchema = 'metadata_schema',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "actiontypes" */
export type Actiontypes_Set_Input = {
  /** The explanation of the function for each actiontype */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: InputMaybe<Scalars['Int']['input']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: InputMaybe<Scalars['smallint']['input']>;
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['jsonb']['input']>;
  /** Dot notation description of action |move.created - A move has been created|move.deleted - A move has been deleted|move.details.updated - Values on the move details have been updated|accessorial.created - An accessorial has been created|accessorial.updated - Values on the accessorial have been updated successfully|accessorial.deleted - An accessorial has been deleted|sms.sent - Text message has been sent successfully to customer|sms.failed - Text message failed to send to customer|lyftride.created - A Lyft ride has been created|lyftride.updated - Values on the Lyft ride have been updated successfully|lyftride.deleted - A Lyft ride has been deleted|lyftride.updated.failed - Attempt to update values on the Lyft ride failed|move.updated.failed  - Attempt to update values on the move failed|accessorial.updated.failed - Attempt to update values on the accessorial failed|lyftride.created.failed - Attempt to create a Lyft ride failed|accessorial.created.failed - Attempt to create an accessorial failed|move.created.failed - Attempt to create a move failed|move.deleted.failed - Attempt to delete a move failed|accessorial.deleted.failed - Attempt to delete an accessorial failed|lyftride.deleted.failed - Attempt to delete a Lyft ride failed|move.cancel.pending - Move is in pending status waiting for approval of cancellation|move.cancel.seen - Move placed in canceled seen status, it is acknowledged by the dispatcher and can be removed from dispatcher notifications|move.cancel.partial - come back to this ------------------|move.cancel.succeeded - Move put in canceled status|move.cancel.failed - Attempt to put move in canceled status failed|move.status.overridden - Status of move manually updated|move.times.updated - come back to this ---------------|move.unplanned - Move have been unplanned from a drivers schedule on the plan screen |return.ride.canceled - Ride after move has been successfully canceled|rideshare.called -Driver or Dispatcher has initiated the rideshare to be called|move.pickup.started - Driver has indicated they've arrived at the pickup location and is no longer in dispatched status|move.status.updated - Move status has been successfully updated|move.dispatched - A move has been assigned to a driver and no longer in draft status|move.planned - Move has been assigned to a drivers plan|move.undispatched - A move previously dispatched to a driver has been removed from their plan|move.return.ready - Move has been marked as return ready through the hangtag workflow|move.return.created - A move return has been created through the hangtag workflow|hangtag.unassigned - A hangtag has been unassigned from a move|hangtag.assigned - A hangtag has been assigned to a move| */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Actiontypes_Stddev_Fields = {
  __typename?: 'actiontypes_stddev_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Actiontypes_Stddev_Pop_Fields = {
  __typename?: 'actiontypes_stddev_pop_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Actiontypes_Stddev_Samp_Fields = {
  __typename?: 'actiontypes_stddev_samp_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "actiontypes" */
export type Actiontypes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Actiontypes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Actiontypes_Stream_Cursor_Value_Input = {
  /** The explanation of the function for each actiontype */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: InputMaybe<Scalars['Int']['input']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: InputMaybe<Scalars['smallint']['input']>;
  /** Schema for metadata associated with actiontype */
  metadata_schema?: InputMaybe<Scalars['jsonb']['input']>;
  /** Dot notation description of action |move.created - A move has been created|move.deleted - A move has been deleted|move.details.updated - Values on the move details have been updated|accessorial.created - An accessorial has been created|accessorial.updated - Values on the accessorial have been updated successfully|accessorial.deleted - An accessorial has been deleted|sms.sent - Text message has been sent successfully to customer|sms.failed - Text message failed to send to customer|lyftride.created - A Lyft ride has been created|lyftride.updated - Values on the Lyft ride have been updated successfully|lyftride.deleted - A Lyft ride has been deleted|lyftride.updated.failed - Attempt to update values on the Lyft ride failed|move.updated.failed  - Attempt to update values on the move failed|accessorial.updated.failed - Attempt to update values on the accessorial failed|lyftride.created.failed - Attempt to create a Lyft ride failed|accessorial.created.failed - Attempt to create an accessorial failed|move.created.failed - Attempt to create a move failed|move.deleted.failed - Attempt to delete a move failed|accessorial.deleted.failed - Attempt to delete an accessorial failed|lyftride.deleted.failed - Attempt to delete a Lyft ride failed|move.cancel.pending - Move is in pending status waiting for approval of cancellation|move.cancel.seen - Move placed in canceled seen status, it is acknowledged by the dispatcher and can be removed from dispatcher notifications|move.cancel.partial - come back to this ------------------|move.cancel.succeeded - Move put in canceled status|move.cancel.failed - Attempt to put move in canceled status failed|move.status.overridden - Status of move manually updated|move.times.updated - come back to this ---------------|move.unplanned - Move have been unplanned from a drivers schedule on the plan screen |return.ride.canceled - Ride after move has been successfully canceled|rideshare.called -Driver or Dispatcher has initiated the rideshare to be called|move.pickup.started - Driver has indicated they've arrived at the pickup location and is no longer in dispatched status|move.status.updated - Move status has been successfully updated|move.dispatched - A move has been assigned to a driver and no longer in draft status|move.planned - Move has been assigned to a drivers plan|move.undispatched - A move previously dispatched to a driver has been removed from their plan|move.return.ready - Move has been marked as return ready through the hangtag workflow|move.return.created - A move return has been created through the hangtag workflow|hangtag.unassigned - A hangtag has been unassigned from a move|hangtag.assigned - A hangtag has been assigned to a move| */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Actiontypes_Sum_Fields = {
  __typename?: 'actiontypes_sum_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Int']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['smallint']['output']>;
};

/** update columns of table "actiontypes" */
export enum Actiontypes_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Expiry = 'expiry',
  /** column name */
  Id = 'id',
  /** column name */
  MetadataSchema = 'metadata_schema',
  /** column name */
  Name = 'name'
}

export type Actiontypes_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Actiontypes_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Actiontypes_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Actiontypes_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Actiontypes_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Actiontypes_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Actiontypes_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Actiontypes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Actiontypes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Actiontypes_Var_Pop_Fields = {
  __typename?: 'actiontypes_var_pop_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Actiontypes_Var_Samp_Fields = {
  __typename?: 'actiontypes_var_samp_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Actiontypes_Variance_Fields = {
  __typename?: 'actiontypes_variance_fields';
  /** The amount of time in seconds this type of eventlog will be retained before deletion. The default value is equivalent to two weeks */
  expiry?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the actiontypes table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the actiontypes table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "activetimes" */
export type Activetimes = {
  __typename?: 'activetimes';
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** Total time calculation done by the backend. */
  duration_minutes: Scalars['numeric']['output'];
  /** Factors that went into recording the duration_minutes. */
  factors?: Maybe<Scalars['jsonb']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  move: Moves;
  move_id: Scalars['bigint']['output'];
  /** Notes to explain an override. */
  notes?: Maybe<Scalars['String']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['numeric']['output']>;
  /** "audit" - Needs to be reviewed by system or admin to get approved. | "approved" - Approved by system or admin. */
  status: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "activetimes" */
export type ActivetimesFactorsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "activetimes" */
export type Activetimes_Aggregate = {
  __typename?: 'activetimes_aggregate';
  aggregate?: Maybe<Activetimes_Aggregate_Fields>;
  nodes: Array<Activetimes>;
};

/** aggregate fields of "activetimes" */
export type Activetimes_Aggregate_Fields = {
  __typename?: 'activetimes_aggregate_fields';
  avg?: Maybe<Activetimes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Activetimes_Max_Fields>;
  min?: Maybe<Activetimes_Min_Fields>;
  stddev?: Maybe<Activetimes_Stddev_Fields>;
  stddev_pop?: Maybe<Activetimes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Activetimes_Stddev_Samp_Fields>;
  sum?: Maybe<Activetimes_Sum_Fields>;
  var_pop?: Maybe<Activetimes_Var_Pop_Fields>;
  var_samp?: Maybe<Activetimes_Var_Samp_Fields>;
  variance?: Maybe<Activetimes_Variance_Fields>;
};


/** aggregate fields of "activetimes" */
export type Activetimes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Activetimes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Activetimes_Append_Input = {
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Activetimes_Avg_Fields = {
  __typename?: 'activetimes_avg_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "activetimes". All fields are combined with a logical 'AND'. */
export type Activetimes_Bool_Exp = {
  _and?: InputMaybe<Array<Activetimes_Bool_Exp>>;
  _not?: InputMaybe<Activetimes_Bool_Exp>;
  _or?: InputMaybe<Array<Activetimes_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  duration_minutes?: InputMaybe<Numeric_Comparison_Exp>;
  factors?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  override_minutes?: InputMaybe<Numeric_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "activetimes" */
export enum Activetimes_Constraint {
  /** unique or primary key constraint on columns "move_id" */
  ActiveTimeMoveIdKey = 'active_time_move_id_key',
  /** unique or primary key constraint on columns "id" */
  ActiveTimePkey = 'active_time_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Activetimes_Delete_At_Path_Input = {
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Activetimes_Delete_Elem_Input = {
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Activetimes_Delete_Key_Input = {
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "activetimes" */
export type Activetimes_Inc_Input = {
  /** Total time calculation done by the backend. */
  duration_minutes?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "activetimes" */
export type Activetimes_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Total time calculation done by the backend. */
  duration_minutes?: InputMaybe<Scalars['numeric']['input']>;
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes to explain an override. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: InputMaybe<Scalars['numeric']['input']>;
  /** "audit" - Needs to be reviewed by system or admin to get approved. | "approved" - Approved by system or admin. */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Activetimes_Max_Fields = {
  __typename?: 'activetimes_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Notes to explain an override. */
  notes?: Maybe<Scalars['String']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['numeric']['output']>;
  /** "audit" - Needs to be reviewed by system or admin to get approved. | "approved" - Approved by system or admin. */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Activetimes_Min_Fields = {
  __typename?: 'activetimes_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Notes to explain an override. */
  notes?: Maybe<Scalars['String']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['numeric']['output']>;
  /** "audit" - Needs to be reviewed by system or admin to get approved. | "approved" - Approved by system or admin. */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "activetimes" */
export type Activetimes_Mutation_Response = {
  __typename?: 'activetimes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Activetimes>;
};

/** input type for inserting object relation for remote table "activetimes" */
export type Activetimes_Obj_Rel_Insert_Input = {
  data: Activetimes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Activetimes_On_Conflict>;
};

/** on_conflict condition type for table "activetimes" */
export type Activetimes_On_Conflict = {
  constraint: Activetimes_Constraint;
  update_columns?: Array<Activetimes_Update_Column>;
  where?: InputMaybe<Activetimes_Bool_Exp>;
};

/** Ordering options when selecting data from "activetimes". */
export type Activetimes_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  duration_minutes?: InputMaybe<Order_By>;
  factors?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  override_minutes?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: activetimes */
export type Activetimes_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Activetimes_Prepend_Input = {
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "activetimes" */
export enum Activetimes_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DurationMinutes = 'duration_minutes',
  /** column name */
  Factors = 'factors',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  OverrideMinutes = 'override_minutes',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "activetimes" */
export type Activetimes_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Total time calculation done by the backend. */
  duration_minutes?: InputMaybe<Scalars['numeric']['input']>;
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes to explain an override. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: InputMaybe<Scalars['numeric']['input']>;
  /** "audit" - Needs to be reviewed by system or admin to get approved. | "approved" - Approved by system or admin. */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Activetimes_Stddev_Fields = {
  __typename?: 'activetimes_stddev_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Activetimes_Stddev_Pop_Fields = {
  __typename?: 'activetimes_stddev_pop_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Activetimes_Stddev_Samp_Fields = {
  __typename?: 'activetimes_stddev_samp_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "activetimes" */
export type Activetimes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Activetimes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Activetimes_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Total time calculation done by the backend. */
  duration_minutes?: InputMaybe<Scalars['numeric']['input']>;
  /** Factors that went into recording the duration_minutes. */
  factors?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes to explain an override. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: InputMaybe<Scalars['numeric']['input']>;
  /** "audit" - Needs to be reviewed by system or admin to get approved. | "approved" - Approved by system or admin. */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Activetimes_Sum_Fields = {
  __typename?: 'activetimes_sum_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "activetimes" */
export enum Activetimes_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DurationMinutes = 'duration_minutes',
  /** column name */
  Factors = 'factors',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  OverrideMinutes = 'override_minutes',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Activetimes_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Activetimes_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Activetimes_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Activetimes_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Activetimes_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Activetimes_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Activetimes_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Activetimes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Activetimes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Activetimes_Var_Pop_Fields = {
  __typename?: 'activetimes_var_pop_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Activetimes_Var_Samp_Fields = {
  __typename?: 'activetimes_var_samp_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Activetimes_Variance_Fields = {
  __typename?: 'activetimes_variance_fields';
  /** Total time calculation done by the backend. */
  duration_minutes?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Override to duration_minutes. This is done during the audit. */
  override_minutes?: Maybe<Scalars['Float']['output']>;
};

/** A list of algorithms that refer to a module on our back-end. These algorithms provide parameters inside of a JSONB to serve as arguments to their respective module. */
export type Algorithms = {
  __typename?: 'algorithms';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** A thorough explanation of the algorithm and each of its parameters. */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  /** Human-readable name of the algorithm. An extremely brief explanation of the algorithm that can fit on one line. */
  label?: Maybe<Scalars['String']['output']>;
  /** Code-friendly, camel-cased name that matches the module to run in the code. */
  name: Scalars['String']['output'];
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: Maybe<Scalars['jsonb']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};


/** A list of algorithms that refer to a module on our back-end. These algorithms provide parameters inside of a JSONB to serve as arguments to their respective module. */
export type AlgorithmsParamsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "algorithms" */
export type Algorithms_Aggregate = {
  __typename?: 'algorithms_aggregate';
  aggregate?: Maybe<Algorithms_Aggregate_Fields>;
  nodes: Array<Algorithms>;
};

/** aggregate fields of "algorithms" */
export type Algorithms_Aggregate_Fields = {
  __typename?: 'algorithms_aggregate_fields';
  avg?: Maybe<Algorithms_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Algorithms_Max_Fields>;
  min?: Maybe<Algorithms_Min_Fields>;
  stddev?: Maybe<Algorithms_Stddev_Fields>;
  stddev_pop?: Maybe<Algorithms_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Algorithms_Stddev_Samp_Fields>;
  sum?: Maybe<Algorithms_Sum_Fields>;
  var_pop?: Maybe<Algorithms_Var_Pop_Fields>;
  var_samp?: Maybe<Algorithms_Var_Samp_Fields>;
  variance?: Maybe<Algorithms_Variance_Fields>;
};


/** aggregate fields of "algorithms" */
export type Algorithms_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Algorithms_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Algorithms_Append_Input = {
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Algorithms_Avg_Fields = {
  __typename?: 'algorithms_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "algorithms". All fields are combined with a logical 'AND'. */
export type Algorithms_Bool_Exp = {
  _and?: InputMaybe<Array<Algorithms_Bool_Exp>>;
  _not?: InputMaybe<Algorithms_Bool_Exp>;
  _or?: InputMaybe<Array<Algorithms_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  label?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  params?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "algorithms" */
export enum Algorithms_Constraint {
  /** unique or primary key constraint on columns "name" */
  AlgorithmsNameKey = 'algorithms_name_key',
  /** unique or primary key constraint on columns "id" */
  AlgorithmsPkey = 'algorithms_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Algorithms_Delete_At_Path_Input = {
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Algorithms_Delete_Elem_Input = {
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Algorithms_Delete_Key_Input = {
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "algorithms" */
export type Algorithms_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "algorithms" */
export type Algorithms_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** A thorough explanation of the algorithm and each of its parameters. */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Human-readable name of the algorithm. An extremely brief explanation of the algorithm that can fit on one line. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Code-friendly, camel-cased name that matches the module to run in the code. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Algorithms_Max_Fields = {
  __typename?: 'algorithms_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** A thorough explanation of the algorithm and each of its parameters. */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Human-readable name of the algorithm. An extremely brief explanation of the algorithm that can fit on one line. */
  label?: Maybe<Scalars['String']['output']>;
  /** Code-friendly, camel-cased name that matches the module to run in the code. */
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Algorithms_Min_Fields = {
  __typename?: 'algorithms_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** A thorough explanation of the algorithm and each of its parameters. */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Human-readable name of the algorithm. An extremely brief explanation of the algorithm that can fit on one line. */
  label?: Maybe<Scalars['String']['output']>;
  /** Code-friendly, camel-cased name that matches the module to run in the code. */
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "algorithms" */
export type Algorithms_Mutation_Response = {
  __typename?: 'algorithms_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Algorithms>;
};

/** input type for inserting object relation for remote table "algorithms" */
export type Algorithms_Obj_Rel_Insert_Input = {
  data: Algorithms_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Algorithms_On_Conflict>;
};

/** on_conflict condition type for table "algorithms" */
export type Algorithms_On_Conflict = {
  constraint: Algorithms_Constraint;
  update_columns?: Array<Algorithms_Update_Column>;
  where?: InputMaybe<Algorithms_Bool_Exp>;
};

/** Ordering options when selecting data from "algorithms". */
export type Algorithms_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  params?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: algorithms */
export type Algorithms_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Algorithms_Prepend_Input = {
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "algorithms" */
export enum Algorithms_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name',
  /** column name */
  Params = 'params',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "algorithms" */
export type Algorithms_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** A thorough explanation of the algorithm and each of its parameters. */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Human-readable name of the algorithm. An extremely brief explanation of the algorithm that can fit on one line. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Code-friendly, camel-cased name that matches the module to run in the code. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Algorithms_Stddev_Fields = {
  __typename?: 'algorithms_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Algorithms_Stddev_Pop_Fields = {
  __typename?: 'algorithms_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Algorithms_Stddev_Samp_Fields = {
  __typename?: 'algorithms_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "algorithms" */
export type Algorithms_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Algorithms_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Algorithms_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** A thorough explanation of the algorithm and each of its parameters. */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Human-readable name of the algorithm. An extremely brief explanation of the algorithm that can fit on one line. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Code-friendly, camel-cased name that matches the module to run in the code. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Parameters that serve as arguments to the algorithm. We can make our functions reusable while passing in these parameters to yield different results. */
  params?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Algorithms_Sum_Fields = {
  __typename?: 'algorithms_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "algorithms" */
export enum Algorithms_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name',
  /** column name */
  Params = 'params',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Algorithms_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Algorithms_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Algorithms_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Algorithms_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Algorithms_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Algorithms_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Algorithms_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Algorithms_Set_Input>;
  /** filter the rows which have to be updated */
  where: Algorithms_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Algorithms_Var_Pop_Fields = {
  __typename?: 'algorithms_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Algorithms_Var_Samp_Fields = {
  __typename?: 'algorithms_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Algorithms_Variance_Fields = {
  __typename?: 'algorithms_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Charges related directly to a driver. */
export type Apcharges = {
  __typename?: 'apcharges';
  active: Scalars['Boolean']['output'];
  /** Amount of the charge that the driver needs to cover. */
  amount: Scalars['numeric']['output'];
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  driver: Drivers;
  driver_id: Scalars['bigint']['output'];
  /** An object relationship */
  driverpayout?: Maybe<Driverpayouts>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date: Scalars['timestamptz']['output'];
  /** External notes that show to the driver. */
  external_notes?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  /** Notes for internal use. */
  internal_notes?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  move?: Maybe<Moves>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  paycycle?: Maybe<Paycycles>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status: Scalars['String']['output'];
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "apcharges" */
export type Apcharges_Aggregate = {
  __typename?: 'apcharges_aggregate';
  aggregate?: Maybe<Apcharges_Aggregate_Fields>;
  nodes: Array<Apcharges>;
};

export type Apcharges_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Apcharges_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Apcharges_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Apcharges_Aggregate_Bool_Exp_Count>;
};

export type Apcharges_Aggregate_Bool_Exp_Bool_And = {
  arguments: Apcharges_Select_Column_Apcharges_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Apcharges_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Apcharges_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Apcharges_Select_Column_Apcharges_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Apcharges_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Apcharges_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Apcharges_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Apcharges_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "apcharges" */
export type Apcharges_Aggregate_Fields = {
  __typename?: 'apcharges_aggregate_fields';
  avg?: Maybe<Apcharges_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Apcharges_Max_Fields>;
  min?: Maybe<Apcharges_Min_Fields>;
  stddev?: Maybe<Apcharges_Stddev_Fields>;
  stddev_pop?: Maybe<Apcharges_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Apcharges_Stddev_Samp_Fields>;
  sum?: Maybe<Apcharges_Sum_Fields>;
  var_pop?: Maybe<Apcharges_Var_Pop_Fields>;
  var_samp?: Maybe<Apcharges_Var_Samp_Fields>;
  variance?: Maybe<Apcharges_Variance_Fields>;
};


/** aggregate fields of "apcharges" */
export type Apcharges_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Apcharges_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "apcharges" */
export type Apcharges_Aggregate_Order_By = {
  avg?: InputMaybe<Apcharges_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Apcharges_Max_Order_By>;
  min?: InputMaybe<Apcharges_Min_Order_By>;
  stddev?: InputMaybe<Apcharges_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Apcharges_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Apcharges_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Apcharges_Sum_Order_By>;
  var_pop?: InputMaybe<Apcharges_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Apcharges_Var_Samp_Order_By>;
  variance?: InputMaybe<Apcharges_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "apcharges" */
export type Apcharges_Arr_Rel_Insert_Input = {
  data: Array<Apcharges_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Apcharges_On_Conflict>;
};

/** aggregate avg on columns */
export type Apcharges_Avg_Fields = {
  __typename?: 'apcharges_avg_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "apcharges" */
export type Apcharges_Avg_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "apcharges". All fields are combined with a logical 'AND'. */
export type Apcharges_Bool_Exp = {
  _and?: InputMaybe<Array<Apcharges_Bool_Exp>>;
  _not?: InputMaybe<Apcharges_Bool_Exp>;
  _or?: InputMaybe<Array<Apcharges_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driverpayout?: InputMaybe<Driverpayouts_Bool_Exp>;
  driverpayout_id?: InputMaybe<Bigint_Comparison_Exp>;
  earliest_chargeable_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  external_notes?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  internal_notes?: InputMaybe<String_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  paycycle?: InputMaybe<Paycycles_Bool_Exp>;
  paycycle_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "apcharges" */
export enum Apcharges_Constraint {
  /** unique or primary key constraint on columns "id" */
  ApchargesPkey = 'apcharges_pkey'
}

/** input type for incrementing numeric columns in table "apcharges" */
export type Apcharges_Inc_Input = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "apcharges" */
export type Apcharges_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driverpayout?: InputMaybe<Driverpayouts_Obj_Rel_Insert_Input>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** External notes that show to the driver. */
  external_notes?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes for internal use. */
  internal_notes?: InputMaybe<Scalars['String']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  paycycle?: InputMaybe<Paycycles_Obj_Rel_Insert_Input>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Apcharges_Max_Fields = {
  __typename?: 'apcharges_max_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: Maybe<Scalars['timestamptz']['output']>;
  /** External notes that show to the driver. */
  external_notes?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Notes for internal use. */
  internal_notes?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: Maybe<Scalars['String']['output']>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "apcharges" */
export type Apcharges_Max_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: InputMaybe<Order_By>;
  /** External notes that show to the driver. */
  external_notes?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Notes for internal use. */
  internal_notes?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: InputMaybe<Order_By>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Apcharges_Min_Fields = {
  __typename?: 'apcharges_min_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: Maybe<Scalars['timestamptz']['output']>;
  /** External notes that show to the driver. */
  external_notes?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Notes for internal use. */
  internal_notes?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: Maybe<Scalars['String']['output']>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "apcharges" */
export type Apcharges_Min_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: InputMaybe<Order_By>;
  /** External notes that show to the driver. */
  external_notes?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Notes for internal use. */
  internal_notes?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: InputMaybe<Order_By>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "apcharges" */
export type Apcharges_Mutation_Response = {
  __typename?: 'apcharges_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Apcharges>;
};

/** on_conflict condition type for table "apcharges" */
export type Apcharges_On_Conflict = {
  constraint: Apcharges_Constraint;
  update_columns?: Array<Apcharges_Update_Column>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};

/** Ordering options when selecting data from "apcharges". */
export type Apcharges_Order_By = {
  active?: InputMaybe<Order_By>;
  amount?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driverpayout?: InputMaybe<Driverpayouts_Order_By>;
  driverpayout_id?: InputMaybe<Order_By>;
  earliest_chargeable_date?: InputMaybe<Order_By>;
  external_notes?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  internal_notes?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  paycycle?: InputMaybe<Paycycles_Order_By>;
  paycycle_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: apcharges */
export type Apcharges_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "apcharges" */
export enum Apcharges_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverpayoutId = 'driverpayout_id',
  /** column name */
  EarliestChargeableDate = 'earliest_chargeable_date',
  /** column name */
  ExternalNotes = 'external_notes',
  /** column name */
  Id = 'id',
  /** column name */
  InternalNotes = 'internal_notes',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PaycycleId = 'paycycle_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** select "apcharges_aggregate_bool_exp_bool_and_arguments_columns" columns of table "apcharges" */
export enum Apcharges_Select_Column_Apcharges_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** select "apcharges_aggregate_bool_exp_bool_or_arguments_columns" columns of table "apcharges" */
export enum Apcharges_Select_Column_Apcharges_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** input type for updating data in table "apcharges" */
export type Apcharges_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** External notes that show to the driver. */
  external_notes?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes for internal use. */
  internal_notes?: InputMaybe<Scalars['String']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Apcharges_Stddev_Fields = {
  __typename?: 'apcharges_stddev_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "apcharges" */
export type Apcharges_Stddev_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Apcharges_Stddev_Pop_Fields = {
  __typename?: 'apcharges_stddev_pop_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "apcharges" */
export type Apcharges_Stddev_Pop_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Apcharges_Stddev_Samp_Fields = {
  __typename?: 'apcharges_stddev_samp_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "apcharges" */
export type Apcharges_Stddev_Samp_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "apcharges" */
export type Apcharges_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Apcharges_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Apcharges_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Earliest possible time that this charge can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_chargeable_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** External notes that show to the driver. */
  external_notes?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes for internal use. */
  internal_notes?: InputMaybe<Scalars['String']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** "unpaid" - The charge has yet to be paid. | "paid" - The charge has been paid by the driver. | "waived" - The driver did not need to cover the charge. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Type of charge that was generated - For now, we only know of "onboarding fee". */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Apcharges_Sum_Fields = {
  __typename?: 'apcharges_sum_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['numeric']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "apcharges" */
export type Apcharges_Sum_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** update columns of table "apcharges" */
export enum Apcharges_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverpayoutId = 'driverpayout_id',
  /** column name */
  EarliestChargeableDate = 'earliest_chargeable_date',
  /** column name */
  ExternalNotes = 'external_notes',
  /** column name */
  Id = 'id',
  /** column name */
  InternalNotes = 'internal_notes',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PaycycleId = 'paycycle_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Apcharges_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Apcharges_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Apcharges_Set_Input>;
  /** filter the rows which have to be updated */
  where: Apcharges_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Apcharges_Var_Pop_Fields = {
  __typename?: 'apcharges_var_pop_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "apcharges" */
export type Apcharges_Var_Pop_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Apcharges_Var_Samp_Fields = {
  __typename?: 'apcharges_var_samp_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "apcharges" */
export type Apcharges_Var_Samp_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Apcharges_Variance_Fields = {
  __typename?: 'apcharges_variance_fields';
  /** Amount of the charge that the driver needs to cover. */
  amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "apcharges" */
export type Apcharges_Variance_Order_By = {
  /** Amount of the charge that the driver needs to cover. */
  amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** Which driverpayout record is charge this associated with? */
  driverpayout_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a charge with its earliest_chargeable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** Correlated to moves in the operations system, this table holds payments due to driver partners that will be aggregated up and paid via ACH on a weekly basis by an administrator using the account system. Payment status here will be changed to paid once that manual process is completed by an administrator. */
export type Appayments = {
  __typename?: 'appayments';
  /** An object relationship */
  accessorial?: Maybe<Accessorials>;
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['bigint']['output']>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active: Scalars['smallint']['output'];
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount: Scalars['numeric']['output'];
  /** The name/username of whomever wrote the record */
  author: Scalars['String']['output'];
  /** The timestamp the payment was created. */
  createdat: Scalars['timestamptz']['output'];
  /** An object relationship */
  driver?: Maybe<Drivers>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  driverpayout?: Maybe<Driverpayouts>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date: Scalars['timestamptz']['output'];
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  move?: Maybe<Moves>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes: Scalars['String']['output'];
  /** An object relationship */
  paycycle?: Maybe<Paycycles>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: Maybe<Scalars['String']['output']>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status: Scalars['String']['output'];
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type: Scalars['String']['output'];
  /** The timestamp the payment was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "appayments" */
export type Appayments_Aggregate = {
  __typename?: 'appayments_aggregate';
  aggregate?: Maybe<Appayments_Aggregate_Fields>;
  nodes: Array<Appayments>;
};

export type Appayments_Aggregate_Bool_Exp = {
  count?: InputMaybe<Appayments_Aggregate_Bool_Exp_Count>;
};

export type Appayments_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Appayments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Appayments_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "appayments" */
export type Appayments_Aggregate_Fields = {
  __typename?: 'appayments_aggregate_fields';
  avg?: Maybe<Appayments_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Appayments_Max_Fields>;
  min?: Maybe<Appayments_Min_Fields>;
  stddev?: Maybe<Appayments_Stddev_Fields>;
  stddev_pop?: Maybe<Appayments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Appayments_Stddev_Samp_Fields>;
  sum?: Maybe<Appayments_Sum_Fields>;
  var_pop?: Maybe<Appayments_Var_Pop_Fields>;
  var_samp?: Maybe<Appayments_Var_Samp_Fields>;
  variance?: Maybe<Appayments_Variance_Fields>;
};


/** aggregate fields of "appayments" */
export type Appayments_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Appayments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "appayments" */
export type Appayments_Aggregate_Order_By = {
  avg?: InputMaybe<Appayments_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Appayments_Max_Order_By>;
  min?: InputMaybe<Appayments_Min_Order_By>;
  stddev?: InputMaybe<Appayments_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Appayments_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Appayments_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Appayments_Sum_Order_By>;
  var_pop?: InputMaybe<Appayments_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Appayments_Var_Samp_Order_By>;
  variance?: InputMaybe<Appayments_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "appayments" */
export type Appayments_Arr_Rel_Insert_Input = {
  data: Array<Appayments_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Appayments_On_Conflict>;
};

/** aggregate avg on columns */
export type Appayments_Avg_Fields = {
  __typename?: 'appayments_avg_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "appayments" */
export type Appayments_Avg_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "appayments". All fields are combined with a logical 'AND'. */
export type Appayments_Bool_Exp = {
  _and?: InputMaybe<Array<Appayments_Bool_Exp>>;
  _not?: InputMaybe<Appayments_Bool_Exp>;
  _or?: InputMaybe<Array<Appayments_Bool_Exp>>;
  accessorial?: InputMaybe<Accessorials_Bool_Exp>;
  accessorial_id?: InputMaybe<Bigint_Comparison_Exp>;
  ach_transaction_id?: InputMaybe<String_Comparison_Exp>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  author?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driverpayout?: InputMaybe<Driverpayouts_Bool_Exp>;
  driverpayout_id?: InputMaybe<Bigint_Comparison_Exp>;
  earliest_payable_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  paycycle?: InputMaybe<Paycycles_Bool_Exp>;
  paycycle_id?: InputMaybe<Bigint_Comparison_Exp>;
  source_event_id?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "appayments" */
export enum Appayments_Constraint {
  /** unique or primary key constraint on columns "accessorial_id" */
  AppaymentsAccessorialIdKey = 'appayments_accessorial_id_key',
  /** unique or primary key constraint on columns "id" */
  AppaymentsIdKey = 'appayments_id_key',
  /** unique or primary key constraint on columns "type", "move_id" */
  AppaymentsMoveIdOnMovePay = 'appayments_move_id_on_move_pay',
  /** unique or primary key constraint on columns "id" */
  AppaymentsPkey = 'appayments_pkey'
}

/** input type for incrementing numeric columns in table "appayments" */
export type Appayments_Inc_Input = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "appayments" */
export type Appayments_Insert_Input = {
  accessorial?: InputMaybe<Accessorials_Obj_Rel_Insert_Input>;
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** The name/username of whomever wrote the record */
  author?: InputMaybe<Scalars['String']['input']>;
  /** The timestamp the payment was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driverpayout?: InputMaybe<Driverpayouts_Obj_Rel_Insert_Input>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: InputMaybe<Scalars['String']['input']>;
  paycycle?: InputMaybe<Paycycles_Obj_Rel_Insert_Input>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: InputMaybe<Scalars['String']['input']>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** The timestamp the payment was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Appayments_Max_Fields = {
  __typename?: 'appayments_max_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['bigint']['output']>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['smallint']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** The name/username of whomever wrote the record */
  author?: Maybe<Scalars['String']['output']>;
  /** The timestamp the payment was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: Maybe<Scalars['String']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: Maybe<Scalars['String']['output']>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: Maybe<Scalars['String']['output']>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: Maybe<Scalars['String']['output']>;
  /** The timestamp the payment was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "appayments" */
export type Appayments_Max_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** The name/username of whomever wrote the record */
  author?: InputMaybe<Order_By>;
  /** The timestamp the payment was created. */
  createdat?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: InputMaybe<Order_By>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: InputMaybe<Order_By>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: InputMaybe<Order_By>;
  /** The timestamp the payment was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Appayments_Min_Fields = {
  __typename?: 'appayments_min_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['bigint']['output']>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: Maybe<Scalars['String']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['smallint']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** The name/username of whomever wrote the record */
  author?: Maybe<Scalars['String']['output']>;
  /** The timestamp the payment was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: Maybe<Scalars['String']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: Maybe<Scalars['String']['output']>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: Maybe<Scalars['String']['output']>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: Maybe<Scalars['String']['output']>;
  /** The timestamp the payment was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "appayments" */
export type Appayments_Min_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** The name/username of whomever wrote the record */
  author?: InputMaybe<Order_By>;
  /** The timestamp the payment was created. */
  createdat?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: InputMaybe<Order_By>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: InputMaybe<Order_By>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: InputMaybe<Order_By>;
  /** The timestamp the payment was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "appayments" */
export type Appayments_Mutation_Response = {
  __typename?: 'appayments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Appayments>;
};

/** input type for inserting object relation for remote table "appayments" */
export type Appayments_Obj_Rel_Insert_Input = {
  data: Appayments_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Appayments_On_Conflict>;
};

/** on_conflict condition type for table "appayments" */
export type Appayments_On_Conflict = {
  constraint: Appayments_Constraint;
  update_columns?: Array<Appayments_Update_Column>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};

/** Ordering options when selecting data from "appayments". */
export type Appayments_Order_By = {
  accessorial?: InputMaybe<Accessorials_Order_By>;
  accessorial_id?: InputMaybe<Order_By>;
  ach_transaction_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  amount?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driverpayout?: InputMaybe<Driverpayouts_Order_By>;
  driverpayout_id?: InputMaybe<Order_By>;
  earliest_payable_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paycycle?: InputMaybe<Paycycles_Order_By>;
  paycycle_id?: InputMaybe<Order_By>;
  source_event_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: appayments */
export type Appayments_Pk_Columns_Input = {
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** select columns of table "appayments" */
export enum Appayments_Select_Column {
  /** column name */
  AccessorialId = 'accessorial_id',
  /** column name */
  AchTransactionId = 'ach_transaction_id',
  /** column name */
  Active = 'active',
  /** column name */
  Amount = 'amount',
  /** column name */
  Author = 'author',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverpayoutId = 'driverpayout_id',
  /** column name */
  EarliestPayableDate = 'earliest_payable_date',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PaycycleId = 'paycycle_id',
  /** column name */
  SourceEventId = 'source_event_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "appayments" */
export type Appayments_Set_Input = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** The name/username of whomever wrote the record */
  author?: InputMaybe<Scalars['String']['input']>;
  /** The timestamp the payment was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: InputMaybe<Scalars['String']['input']>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** The timestamp the payment was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Appayments_Stddev_Fields = {
  __typename?: 'appayments_stddev_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "appayments" */
export type Appayments_Stddev_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Appayments_Stddev_Pop_Fields = {
  __typename?: 'appayments_stddev_pop_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "appayments" */
export type Appayments_Stddev_Pop_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Appayments_Stddev_Samp_Fields = {
  __typename?: 'appayments_stddev_samp_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "appayments" */
export type Appayments_Stddev_Samp_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "appayments" */
export type Appayments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Appayments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Appayments_Stream_Cursor_Value_Input = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The accounting system generated transaction id recording the ACH transaction this was a part of. Grouping by this and totaling the amount column in a query will result in a match to the accounting system payment made to the driver over ACH. */
  ach_transaction_id?: InputMaybe<Scalars['String']['input']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** The name/username of whomever wrote the record */
  author?: InputMaybe<Scalars['String']['input']>;
  /** The timestamp the payment was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Earliest possible time that this payment can be applied. This is used to help determine which pay cycle it needs to be on when the pay cycle is created. */
  earliest_payable_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes input by the author describing the payment and its context/reasoning for being set outside of the automated process. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Unique ID of the event Hasura sends to trigger APEngine.Payable() */
  source_event_id?: InputMaybe<Scalars['String']['input']>;
  /** an enumeration of valid payment lifecycle status values.|estimated - default value calculated at move creation, remains in this status until the move has reached a completed state|unpaid - assigned at move completion, stays until at least a partial or full payment has been received|paid - a final status indicating that payment to the driver has been made in full| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** "accessorial" - When the payment to a driver is an extra amount because of circumstances that caused a delay or payment from the drivers pocket that needs reimbursed. | "move pay" - Standard driver pay for working a move. | "bonus" - Bonus given to a driver depending on specific circumstances. | "promo" - Additional pay due to a company promo for drivers. | "true-up" - Additional pay in order to meet a minimum pay compliance. | "healthcare" - Paid out every quarter. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** The timestamp the payment was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Appayments_Sum_Fields = {
  __typename?: 'appayments_sum_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['bigint']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['smallint']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "appayments" */
export type Appayments_Sum_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** update columns of table "appayments" */
export enum Appayments_Update_Column {
  /** column name */
  AccessorialId = 'accessorial_id',
  /** column name */
  AchTransactionId = 'ach_transaction_id',
  /** column name */
  Active = 'active',
  /** column name */
  Amount = 'amount',
  /** column name */
  Author = 'author',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverpayoutId = 'driverpayout_id',
  /** column name */
  EarliestPayableDate = 'earliest_payable_date',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PaycycleId = 'paycycle_id',
  /** column name */
  SourceEventId = 'source_event_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Appayments_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Appayments_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Appayments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Appayments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Appayments_Var_Pop_Fields = {
  __typename?: 'appayments_var_pop_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "appayments" */
export type Appayments_Var_Pop_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Appayments_Var_Samp_Fields = {
  __typename?: 'appayments_var_samp_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "appayments" */
export type Appayments_Var_Samp_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Appayments_Variance_Fields = {
  __typename?: 'appayments_variance_fields';
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: Maybe<Scalars['Float']['output']>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: Maybe<Scalars['Float']['output']>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "appayments" */
export type Appayments_Variance_Order_By = {
  /** Foreign key to the accessorials table. This field is used to link the current record to a specific accessorial. The value of this field references a valid ID of an accessorial in the accessorials table. */
  accessorial_id?: InputMaybe<Order_By>;
  /** Indicates whether the payment is still active. This field can be used to track payments that have been made but not yet processed.|1- the payment is active and can be processed|0 - indicate that the payment is inactive and is no longer being processed| */
  active?: InputMaybe<Order_By>;
  /** Monetary value representing the amount the driver is to be paid for this move. This number is made up of the base and stranded pay (if applicable) combined with any driver payable accessorial charges related to the move. */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the driver table. This field is used to link the current record to a specific driver. The value of this field references a valid ID of a driver in the driver table. */
  driver_id?: InputMaybe<Order_By>;
  /** Foreign key to the driverpayouts table. This field is used to link the current record to a specific driverpayout. The value of this field references a valid ID of a driverpayout in the driverpayouts table. */
  driverpayout_id?: InputMaybe<Order_By>;
  /** Primary key for the appayments table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appayments table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** This key is added when a pay cycle is created and finds a payment with its earliest_payable_date inside of the range. */
  paycycle_id?: InputMaybe<Order_By>;
};

/** Table containing appointment information  */
export type Appointments = {
  __typename?: 'appointments';
  /** Flag to indicate if the consumer has accepted the terms of the appointment */
  accepted_terms: Scalars['Boolean']['output'];
  /** The appointment time, nullable because the consumer may fill in this in after the appointment is created by the customer */
  appointment_time?: Maybe<Scalars['timestamptz']['output']>;
  /** The charge id returned by Stripe for successful payment */
  charge_id?: Maybe<Scalars['String']['output']>;
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: Maybe<Scalars['jsonb']['output']>;
  /** Flag to differentiate where the consumer car is located. True if the car is at the consumer, false if the car is at the customer location */
  consumer_at_pickup: Scalars['Boolean']['output'];
  /** Name of the consumer, used for SMS. Nullable as the consumer may fill this portion in */
  consumer_name?: Maybe<Scalars['String']['output']>;
  /** The consumer's mobile phone for SMS. Nullable as the consumer may fill this portion in */
  consumer_phone?: Maybe<Scalars['String']['output']>;
  /** Time that the appointment was created at */
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  customer: Customers;
  /** The customer id that this appointment belongs to */
  customer_id: Scalars['Int']['output'];
  /** An object relationship */
  delivery?: Maybe<Locations>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Int']['output']>;
  /** Text notes to provide the driver instructions to pickup the vehicle. ie: Gate code, instructions .. */
  driver_notes?: Maybe<Scalars['String']['output']>;
  /** Unique key for appointments */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  lane?: Maybe<Lanes>;
  /** An object relationship */
  move?: Maybe<Moves>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Int']['output']>;
  /** Time the appointment was offered to the consumer via SMS */
  offered_at?: Maybe<Scalars['timestamptz']['output']>;
  /** User that triggered the SMS to be sent to the consumer with the appointment link */
  offered_by?: Maybe<Scalars['String']['output']>;
  payment_failure_reason?: Maybe<Scalars['String']['output']>;
  payment_transaction_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  pickup?: Maybe<Locations>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  smsmessages: Array<Smsmessages>;
  /** An aggregate relationship */
  smsmessages_aggregate: Smsmessages_Aggregate;
  /** Status of an appointment. Valid values are  NEW -> Form in newly created state    PENDING -> incomplete or error in the form    READY -> Ready for the consumer to fill out/ validate    PAYING -> Payment is being processed    PAID  -> Customer has successfully paid and a move has been created    FAILED -> Payment has failed and customer can retry    CANCELED -> Customer has canceled the appointment    REFUNDED -> Move was refunded to the consumer */
  status: Scalars['String']['output'];
  /** Time the appointment was last modified */
  updatedat: Scalars['timestamptz']['output'];
  /** Who last modified the appointment */
  updatedby: Scalars['String']['output'];
  /** The color of the vehicle */
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** The make of the vehicle */
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_manual?: Maybe<Scalars['Boolean']['output']>;
  /** The model of the vehicle */
  vehicle_model?: Maybe<Scalars['String']['output']>;
  /** The vin of the vehicle */
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Int']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id: Scalars['Int']['output'];
  /** An object relationship */
  workflowset: Workflowsets;
};


/** Table containing appointment information  */
export type AppointmentsConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Table containing appointment information  */
export type AppointmentsSmsmessagesArgs = {
  distinct_on?: InputMaybe<Array<Smsmessages_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmessages_Order_By>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};


/** Table containing appointment information  */
export type AppointmentsSmsmessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smsmessages_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmessages_Order_By>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};

/** aggregated selection of "appointments" */
export type Appointments_Aggregate = {
  __typename?: 'appointments_aggregate';
  aggregate?: Maybe<Appointments_Aggregate_Fields>;
  nodes: Array<Appointments>;
};

/** aggregate fields of "appointments" */
export type Appointments_Aggregate_Fields = {
  __typename?: 'appointments_aggregate_fields';
  avg?: Maybe<Appointments_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Appointments_Max_Fields>;
  min?: Maybe<Appointments_Min_Fields>;
  stddev?: Maybe<Appointments_Stddev_Fields>;
  stddev_pop?: Maybe<Appointments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Appointments_Stddev_Samp_Fields>;
  sum?: Maybe<Appointments_Sum_Fields>;
  var_pop?: Maybe<Appointments_Var_Pop_Fields>;
  var_samp?: Maybe<Appointments_Var_Samp_Fields>;
  variance?: Maybe<Appointments_Variance_Fields>;
};


/** aggregate fields of "appointments" */
export type Appointments_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Appointments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Appointments_Append_Input = {
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Appointments_Avg_Fields = {
  __typename?: 'appointments_avg_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "appointments". All fields are combined with a logical 'AND'. */
export type Appointments_Bool_Exp = {
  _and?: InputMaybe<Array<Appointments_Bool_Exp>>;
  _not?: InputMaybe<Appointments_Bool_Exp>;
  _or?: InputMaybe<Array<Appointments_Bool_Exp>>;
  accepted_terms?: InputMaybe<Boolean_Comparison_Exp>;
  appointment_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  charge_id?: InputMaybe<String_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  consumer_at_pickup?: InputMaybe<Boolean_Comparison_Exp>;
  consumer_name?: InputMaybe<String_Comparison_Exp>;
  consumer_phone?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Int_Comparison_Exp>;
  delivery?: InputMaybe<Locations_Bool_Exp>;
  delivery_location_id?: InputMaybe<Int_Comparison_Exp>;
  driver_notes?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  lane?: InputMaybe<Lanes_Bool_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Int_Comparison_Exp>;
  offered_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  offered_by?: InputMaybe<String_Comparison_Exp>;
  payment_failure_reason?: InputMaybe<String_Comparison_Exp>;
  payment_transaction_id?: InputMaybe<String_Comparison_Exp>;
  pickup?: InputMaybe<Locations_Bool_Exp>;
  pickup_location_id?: InputMaybe<Int_Comparison_Exp>;
  smsmessages?: InputMaybe<Smsmessages_Bool_Exp>;
  smsmessages_aggregate?: InputMaybe<Smsmessages_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  vehicle_color?: InputMaybe<String_Comparison_Exp>;
  vehicle_make?: InputMaybe<String_Comparison_Exp>;
  vehicle_manual?: InputMaybe<Boolean_Comparison_Exp>;
  vehicle_model?: InputMaybe<String_Comparison_Exp>;
  vehicle_vin?: InputMaybe<String_Comparison_Exp>;
  vehicle_year?: InputMaybe<Int_Comparison_Exp>;
  workflow_set_id?: InputMaybe<Int_Comparison_Exp>;
  workflowset?: InputMaybe<Workflowsets_Bool_Exp>;
};

/** unique or primary key constraints on table "appointments" */
export enum Appointments_Constraint {
  /** unique or primary key constraint on columns "id" */
  AppointmentsPkey = 'appointments_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Appointments_Delete_At_Path_Input = {
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Appointments_Delete_Elem_Input = {
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Appointments_Delete_Key_Input = {
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "appointments" */
export type Appointments_Inc_Input = {
  /** The customer id that this appointment belongs to */
  customer_id?: InputMaybe<Scalars['Int']['input']>;
  /** location id for the delivery location */
  delivery_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** Unique key for appointments */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: InputMaybe<Scalars['Int']['input']>;
  /** location id for the pickup location */
  pickup_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** The year of the vehicle */
  vehicle_year?: InputMaybe<Scalars['Int']['input']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "appointments" */
export type Appointments_Insert_Input = {
  /** Flag to indicate if the consumer has accepted the terms of the appointment */
  accepted_terms?: InputMaybe<Scalars['Boolean']['input']>;
  /** The appointment time, nullable because the consumer may fill in this in after the appointment is created by the customer */
  appointment_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The charge id returned by Stripe for successful payment */
  charge_id?: InputMaybe<Scalars['String']['input']>;
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Flag to differentiate where the consumer car is located. True if the car is at the consumer, false if the car is at the customer location */
  consumer_at_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the consumer, used for SMS. Nullable as the consumer may fill this portion in */
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  /** The consumer's mobile phone for SMS. Nullable as the consumer may fill this portion in */
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  /** Time that the appointment was created at */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** The customer id that this appointment belongs to */
  customer_id?: InputMaybe<Scalars['Int']['input']>;
  delivery?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  /** location id for the delivery location */
  delivery_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** Text notes to provide the driver instructions to pickup the vehicle. ie: Gate code, instructions .. */
  driver_notes?: InputMaybe<Scalars['String']['input']>;
  /** Unique key for appointments */
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane?: InputMaybe<Lanes_Obj_Rel_Insert_Input>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: InputMaybe<Scalars['Int']['input']>;
  /** Time the appointment was offered to the consumer via SMS */
  offered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User that triggered the SMS to be sent to the consumer with the appointment link */
  offered_by?: InputMaybe<Scalars['String']['input']>;
  payment_failure_reason?: InputMaybe<Scalars['String']['input']>;
  payment_transaction_id?: InputMaybe<Scalars['String']['input']>;
  pickup?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  /** location id for the pickup location */
  pickup_location_id?: InputMaybe<Scalars['Int']['input']>;
  smsmessages?: InputMaybe<Smsmessages_Arr_Rel_Insert_Input>;
  /** Status of an appointment. Valid values are  NEW -> Form in newly created state    PENDING -> incomplete or error in the form    READY -> Ready for the consumer to fill out/ validate    PAYING -> Payment is being processed    PAID  -> Customer has successfully paid and a move has been created    FAILED -> Payment has failed and customer can retry    CANCELED -> Customer has canceled the appointment    REFUNDED -> Move was refunded to the consumer */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Time the appointment was last modified */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who last modified the appointment */
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** The color of the vehicle */
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** The make of the vehicle */
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_manual?: InputMaybe<Scalars['Boolean']['input']>;
  /** The model of the vehicle */
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  /** The vin of the vehicle */
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  /** The year of the vehicle */
  vehicle_year?: InputMaybe<Scalars['Int']['input']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: InputMaybe<Scalars['Int']['input']>;
  workflowset?: InputMaybe<Workflowsets_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Appointments_Max_Fields = {
  __typename?: 'appointments_max_fields';
  /** The appointment time, nullable because the consumer may fill in this in after the appointment is created by the customer */
  appointment_time?: Maybe<Scalars['timestamptz']['output']>;
  /** The charge id returned by Stripe for successful payment */
  charge_id?: Maybe<Scalars['String']['output']>;
  /** Name of the consumer, used for SMS. Nullable as the consumer may fill this portion in */
  consumer_name?: Maybe<Scalars['String']['output']>;
  /** The consumer's mobile phone for SMS. Nullable as the consumer may fill this portion in */
  consumer_phone?: Maybe<Scalars['String']['output']>;
  /** Time that the appointment was created at */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Int']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Int']['output']>;
  /** Text notes to provide the driver instructions to pickup the vehicle. ie: Gate code, instructions .. */
  driver_notes?: Maybe<Scalars['String']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['bigint']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Int']['output']>;
  /** Time the appointment was offered to the consumer via SMS */
  offered_at?: Maybe<Scalars['timestamptz']['output']>;
  /** User that triggered the SMS to be sent to the consumer with the appointment link */
  offered_by?: Maybe<Scalars['String']['output']>;
  payment_failure_reason?: Maybe<Scalars['String']['output']>;
  payment_transaction_id?: Maybe<Scalars['String']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Int']['output']>;
  /** Status of an appointment. Valid values are  NEW -> Form in newly created state    PENDING -> incomplete or error in the form    READY -> Ready for the consumer to fill out/ validate    PAYING -> Payment is being processed    PAID  -> Customer has successfully paid and a move has been created    FAILED -> Payment has failed and customer can retry    CANCELED -> Customer has canceled the appointment    REFUNDED -> Move was refunded to the consumer */
  status?: Maybe<Scalars['String']['output']>;
  /** Time the appointment was last modified */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** Who last modified the appointment */
  updatedby?: Maybe<Scalars['String']['output']>;
  /** The color of the vehicle */
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** The make of the vehicle */
  vehicle_make?: Maybe<Scalars['String']['output']>;
  /** The model of the vehicle */
  vehicle_model?: Maybe<Scalars['String']['output']>;
  /** The vin of the vehicle */
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Int']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Appointments_Min_Fields = {
  __typename?: 'appointments_min_fields';
  /** The appointment time, nullable because the consumer may fill in this in after the appointment is created by the customer */
  appointment_time?: Maybe<Scalars['timestamptz']['output']>;
  /** The charge id returned by Stripe for successful payment */
  charge_id?: Maybe<Scalars['String']['output']>;
  /** Name of the consumer, used for SMS. Nullable as the consumer may fill this portion in */
  consumer_name?: Maybe<Scalars['String']['output']>;
  /** The consumer's mobile phone for SMS. Nullable as the consumer may fill this portion in */
  consumer_phone?: Maybe<Scalars['String']['output']>;
  /** Time that the appointment was created at */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Int']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Int']['output']>;
  /** Text notes to provide the driver instructions to pickup the vehicle. ie: Gate code, instructions .. */
  driver_notes?: Maybe<Scalars['String']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['bigint']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Int']['output']>;
  /** Time the appointment was offered to the consumer via SMS */
  offered_at?: Maybe<Scalars['timestamptz']['output']>;
  /** User that triggered the SMS to be sent to the consumer with the appointment link */
  offered_by?: Maybe<Scalars['String']['output']>;
  payment_failure_reason?: Maybe<Scalars['String']['output']>;
  payment_transaction_id?: Maybe<Scalars['String']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Int']['output']>;
  /** Status of an appointment. Valid values are  NEW -> Form in newly created state    PENDING -> incomplete or error in the form    READY -> Ready for the consumer to fill out/ validate    PAYING -> Payment is being processed    PAID  -> Customer has successfully paid and a move has been created    FAILED -> Payment has failed and customer can retry    CANCELED -> Customer has canceled the appointment    REFUNDED -> Move was refunded to the consumer */
  status?: Maybe<Scalars['String']['output']>;
  /** Time the appointment was last modified */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** Who last modified the appointment */
  updatedby?: Maybe<Scalars['String']['output']>;
  /** The color of the vehicle */
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** The make of the vehicle */
  vehicle_make?: Maybe<Scalars['String']['output']>;
  /** The model of the vehicle */
  vehicle_model?: Maybe<Scalars['String']['output']>;
  /** The vin of the vehicle */
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Int']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "appointments" */
export type Appointments_Mutation_Response = {
  __typename?: 'appointments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Appointments>;
};

/** input type for inserting object relation for remote table "appointments" */
export type Appointments_Obj_Rel_Insert_Input = {
  data: Appointments_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Appointments_On_Conflict>;
};

/** on_conflict condition type for table "appointments" */
export type Appointments_On_Conflict = {
  constraint: Appointments_Constraint;
  update_columns?: Array<Appointments_Update_Column>;
  where?: InputMaybe<Appointments_Bool_Exp>;
};

/** Ordering options when selecting data from "appointments". */
export type Appointments_Order_By = {
  accepted_terms?: InputMaybe<Order_By>;
  appointment_time?: InputMaybe<Order_By>;
  charge_id?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery?: InputMaybe<Locations_Order_By>;
  delivery_location_id?: InputMaybe<Order_By>;
  driver_notes?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane?: InputMaybe<Lanes_Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  offered_at?: InputMaybe<Order_By>;
  offered_by?: InputMaybe<Order_By>;
  payment_failure_reason?: InputMaybe<Order_By>;
  payment_transaction_id?: InputMaybe<Order_By>;
  pickup?: InputMaybe<Locations_Order_By>;
  pickup_location_id?: InputMaybe<Order_By>;
  smsmessages_aggregate?: InputMaybe<Smsmessages_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_manual?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  workflow_set_id?: InputMaybe<Order_By>;
  workflowset?: InputMaybe<Workflowsets_Order_By>;
};

/** primary key columns input for table: appointments */
export type Appointments_Pk_Columns_Input = {
  /** Unique key for appointments */
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Appointments_Prepend_Input = {
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "appointments" */
export enum Appointments_Select_Column {
  /** column name */
  AcceptedTerms = 'accepted_terms',
  /** column name */
  AppointmentTime = 'appointment_time',
  /** column name */
  ChargeId = 'charge_id',
  /** column name */
  Config = 'config',
  /** column name */
  ConsumerAtPickup = 'consumer_at_pickup',
  /** column name */
  ConsumerName = 'consumer_name',
  /** column name */
  ConsumerPhone = 'consumer_phone',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DeliveryLocationId = 'delivery_location_id',
  /** column name */
  DriverNotes = 'driver_notes',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  OfferedAt = 'offered_at',
  /** column name */
  OfferedBy = 'offered_by',
  /** column name */
  PaymentFailureReason = 'payment_failure_reason',
  /** column name */
  PaymentTransactionId = 'payment_transaction_id',
  /** column name */
  PickupLocationId = 'pickup_location_id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleManual = 'vehicle_manual',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  WorkflowSetId = 'workflow_set_id'
}

/** input type for updating data in table "appointments" */
export type Appointments_Set_Input = {
  /** Flag to indicate if the consumer has accepted the terms of the appointment */
  accepted_terms?: InputMaybe<Scalars['Boolean']['input']>;
  /** The appointment time, nullable because the consumer may fill in this in after the appointment is created by the customer */
  appointment_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The charge id returned by Stripe for successful payment */
  charge_id?: InputMaybe<Scalars['String']['input']>;
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Flag to differentiate where the consumer car is located. True if the car is at the consumer, false if the car is at the customer location */
  consumer_at_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the consumer, used for SMS. Nullable as the consumer may fill this portion in */
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  /** The consumer's mobile phone for SMS. Nullable as the consumer may fill this portion in */
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  /** Time that the appointment was created at */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** The customer id that this appointment belongs to */
  customer_id?: InputMaybe<Scalars['Int']['input']>;
  /** location id for the delivery location */
  delivery_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** Text notes to provide the driver instructions to pickup the vehicle. ie: Gate code, instructions .. */
  driver_notes?: InputMaybe<Scalars['String']['input']>;
  /** Unique key for appointments */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: InputMaybe<Scalars['Int']['input']>;
  /** Time the appointment was offered to the consumer via SMS */
  offered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User that triggered the SMS to be sent to the consumer with the appointment link */
  offered_by?: InputMaybe<Scalars['String']['input']>;
  payment_failure_reason?: InputMaybe<Scalars['String']['input']>;
  payment_transaction_id?: InputMaybe<Scalars['String']['input']>;
  /** location id for the pickup location */
  pickup_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** Status of an appointment. Valid values are  NEW -> Form in newly created state    PENDING -> incomplete or error in the form    READY -> Ready for the consumer to fill out/ validate    PAYING -> Payment is being processed    PAID  -> Customer has successfully paid and a move has been created    FAILED -> Payment has failed and customer can retry    CANCELED -> Customer has canceled the appointment    REFUNDED -> Move was refunded to the consumer */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Time the appointment was last modified */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who last modified the appointment */
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** The color of the vehicle */
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** The make of the vehicle */
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_manual?: InputMaybe<Scalars['Boolean']['input']>;
  /** The model of the vehicle */
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  /** The vin of the vehicle */
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  /** The year of the vehicle */
  vehicle_year?: InputMaybe<Scalars['Int']['input']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Appointments_Stddev_Fields = {
  __typename?: 'appointments_stddev_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Appointments_Stddev_Pop_Fields = {
  __typename?: 'appointments_stddev_pop_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Appointments_Stddev_Samp_Fields = {
  __typename?: 'appointments_stddev_samp_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "appointments" */
export type Appointments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Appointments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Appointments_Stream_Cursor_Value_Input = {
  /** Flag to indicate if the consumer has accepted the terms of the appointment */
  accepted_terms?: InputMaybe<Scalars['Boolean']['input']>;
  /** The appointment time, nullable because the consumer may fill in this in after the appointment is created by the customer */
  appointment_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The charge id returned by Stripe for successful payment */
  charge_id?: InputMaybe<Scalars['String']['input']>;
  /** Holds metadata needed to maintain the appointment or configuration to create the move */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Flag to differentiate where the consumer car is located. True if the car is at the consumer, false if the car is at the customer location */
  consumer_at_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the consumer, used for SMS. Nullable as the consumer may fill this portion in */
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  /** The consumer's mobile phone for SMS. Nullable as the consumer may fill this portion in */
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  /** Time that the appointment was created at */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** The customer id that this appointment belongs to */
  customer_id?: InputMaybe<Scalars['Int']['input']>;
  /** location id for the delivery location */
  delivery_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** Text notes to provide the driver instructions to pickup the vehicle. ie: Gate code, instructions .. */
  driver_notes?: InputMaybe<Scalars['String']['input']>;
  /** Unique key for appointments */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: InputMaybe<Scalars['Int']['input']>;
  /** Time the appointment was offered to the consumer via SMS */
  offered_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User that triggered the SMS to be sent to the consumer with the appointment link */
  offered_by?: InputMaybe<Scalars['String']['input']>;
  payment_failure_reason?: InputMaybe<Scalars['String']['input']>;
  payment_transaction_id?: InputMaybe<Scalars['String']['input']>;
  /** location id for the pickup location */
  pickup_location_id?: InputMaybe<Scalars['Int']['input']>;
  /** Status of an appointment. Valid values are  NEW -> Form in newly created state    PENDING -> incomplete or error in the form    READY -> Ready for the consumer to fill out/ validate    PAYING -> Payment is being processed    PAID  -> Customer has successfully paid and a move has been created    FAILED -> Payment has failed and customer can retry    CANCELED -> Customer has canceled the appointment    REFUNDED -> Move was refunded to the consumer */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Time the appointment was last modified */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who last modified the appointment */
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** The color of the vehicle */
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** The make of the vehicle */
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_manual?: InputMaybe<Scalars['Boolean']['input']>;
  /** The model of the vehicle */
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  /** The vin of the vehicle */
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  /** The year of the vehicle */
  vehicle_year?: InputMaybe<Scalars['Int']['input']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Appointments_Sum_Fields = {
  __typename?: 'appointments_sum_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Int']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Int']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['bigint']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Int']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Int']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Int']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "appointments" */
export enum Appointments_Update_Column {
  /** column name */
  AcceptedTerms = 'accepted_terms',
  /** column name */
  AppointmentTime = 'appointment_time',
  /** column name */
  ChargeId = 'charge_id',
  /** column name */
  Config = 'config',
  /** column name */
  ConsumerAtPickup = 'consumer_at_pickup',
  /** column name */
  ConsumerName = 'consumer_name',
  /** column name */
  ConsumerPhone = 'consumer_phone',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DeliveryLocationId = 'delivery_location_id',
  /** column name */
  DriverNotes = 'driver_notes',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  OfferedAt = 'offered_at',
  /** column name */
  OfferedBy = 'offered_by',
  /** column name */
  PaymentFailureReason = 'payment_failure_reason',
  /** column name */
  PaymentTransactionId = 'payment_transaction_id',
  /** column name */
  PickupLocationId = 'pickup_location_id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleManual = 'vehicle_manual',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  WorkflowSetId = 'workflow_set_id'
}

export type Appointments_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Appointments_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Appointments_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Appointments_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Appointments_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Appointments_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Appointments_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Appointments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Appointments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Appointments_Var_Pop_Fields = {
  __typename?: 'appointments_var_pop_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Appointments_Var_Samp_Fields = {
  __typename?: 'appointments_var_samp_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Appointments_Variance_Fields = {
  __typename?: 'appointments_variance_fields';
  /** The customer id that this appointment belongs to */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the delivery location */
  delivery_location_id?: Maybe<Scalars['Float']['output']>;
  /** Unique key for appointments */
  id?: Maybe<Scalars['Float']['output']>;
  /** If the appointment is paid and created a move, its move id is recorded here */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** location id for the pickup location */
  pickup_location_id?: Maybe<Scalars['Float']['output']>;
  /** The year of the vehicle */
  vehicle_year?: Maybe<Scalars['Float']['output']>;
  /** The workflow set id to create the move with. Defaults to the customer's default workflow */
  workflow_set_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "appraisal_vehicles" */
export type Appraisal_Vehicles = {
  __typename?: 'appraisal_vehicles';
  /** An object relationship */
  appraisal?: Maybe<Appraisals>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  max_move_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  move?: Maybe<Moves>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "appraisal_vehicles" */
export type Appraisal_Vehicles_Aggregate = {
  __typename?: 'appraisal_vehicles_aggregate';
  aggregate?: Maybe<Appraisal_Vehicles_Aggregate_Fields>;
  nodes: Array<Appraisal_Vehicles>;
};

/** aggregate fields of "appraisal_vehicles" */
export type Appraisal_Vehicles_Aggregate_Fields = {
  __typename?: 'appraisal_vehicles_aggregate_fields';
  avg?: Maybe<Appraisal_Vehicles_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Appraisal_Vehicles_Max_Fields>;
  min?: Maybe<Appraisal_Vehicles_Min_Fields>;
  stddev?: Maybe<Appraisal_Vehicles_Stddev_Fields>;
  stddev_pop?: Maybe<Appraisal_Vehicles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Appraisal_Vehicles_Stddev_Samp_Fields>;
  sum?: Maybe<Appraisal_Vehicles_Sum_Fields>;
  var_pop?: Maybe<Appraisal_Vehicles_Var_Pop_Fields>;
  var_samp?: Maybe<Appraisal_Vehicles_Var_Samp_Fields>;
  variance?: Maybe<Appraisal_Vehicles_Variance_Fields>;
};


/** aggregate fields of "appraisal_vehicles" */
export type Appraisal_Vehicles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Appraisal_Vehicles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Appraisal_Vehicles_Avg_Fields = {
  __typename?: 'appraisal_vehicles_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "appraisal_vehicles". All fields are combined with a logical 'AND'. */
export type Appraisal_Vehicles_Bool_Exp = {
  _and?: InputMaybe<Array<Appraisal_Vehicles_Bool_Exp>>;
  _not?: InputMaybe<Appraisal_Vehicles_Bool_Exp>;
  _or?: InputMaybe<Array<Appraisal_Vehicles_Bool_Exp>>;
  appraisal?: InputMaybe<Appraisals_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  max_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  vin?: InputMaybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Appraisal_Vehicles_Max_Fields = {
  __typename?: 'appraisal_vehicles_max_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  max_move_id?: Maybe<Scalars['bigint']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Appraisal_Vehicles_Min_Fields = {
  __typename?: 'appraisal_vehicles_min_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  max_move_id?: Maybe<Scalars['bigint']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "appraisal_vehicles". */
export type Appraisal_Vehicles_Order_By = {
  appraisal?: InputMaybe<Appraisals_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  max_move_id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  vin?: InputMaybe<Order_By>;
};

/** select columns of table "appraisal_vehicles" */
export enum Appraisal_Vehicles_Select_Column {
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  MaxMoveId = 'max_move_id',
  /** column name */
  Vin = 'vin'
}

/** aggregate stddev on columns */
export type Appraisal_Vehicles_Stddev_Fields = {
  __typename?: 'appraisal_vehicles_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Appraisal_Vehicles_Stddev_Pop_Fields = {
  __typename?: 'appraisal_vehicles_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Appraisal_Vehicles_Stddev_Samp_Fields = {
  __typename?: 'appraisal_vehicles_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "appraisal_vehicles" */
export type Appraisal_Vehicles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Appraisal_Vehicles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Appraisal_Vehicles_Stream_Cursor_Value_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  max_move_id?: InputMaybe<Scalars['bigint']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Appraisal_Vehicles_Sum_Fields = {
  __typename?: 'appraisal_vehicles_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  max_move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Appraisal_Vehicles_Var_Pop_Fields = {
  __typename?: 'appraisal_vehicles_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Appraisal_Vehicles_Var_Samp_Fields = {
  __typename?: 'appraisal_vehicles_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Appraisal_Vehicles_Variance_Fields = {
  __typename?: 'appraisal_vehicles_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  max_move_id?: Maybe<Scalars['Float']['output']>;
};

/** Table for dealer appraisals */
export type Appraisals = {
  __typename?: 'appraisals';
  /** Contact info from the appraiser */
  appraiser_contact?: Maybe<Scalars['String']['output']>;
  /** Credentials provided about the appraiser */
  appraiser_credentials?: Maybe<Scalars['String']['output']>;
  /** Appraiser's set time for the appraisal to expire (for the print/pdf screen) */
  appraiser_expire_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Name of the appraiser */
  appraiser_name?: Maybe<Scalars['String']['output']>;
  /** Notes from the appraiser */
  appraiser_notes?: Maybe<Scalars['String']['output']>;
  /** Conditional status of the vehicle (ie. What shape is it in?) [ mint | good | fair | poor ] */
  condition: Scalars['String']['output'];
  /** An object relationship */
  customer?: Maybe<Customers>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  favorite: Scalars['Boolean']['output'];
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** Last time the vehicle_data was fetched from our 3rd party API */
  last_fetch_time_utc: Scalars['timestamptz']['output'];
  /** Timestamp of when the appraisal was last saved */
  last_save_time_utc: Scalars['timestamptz']['output'];
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** Current status of the appraisal |new - newly generated appraisal| generated - appraisal has been generated in the last 24 hours and will continue to be used for the vehicle until it expires in 24 hours| no data - no data was found for the vehicle's value| expired - 24 hours has gone by and the appraisal is no longer valid| */
  status: Scalars['String']['output'];
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: Maybe<Scalars['jsonb']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment: Scalars['bigint']['output'];
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total: Scalars['bigint']['output'];
  /** Selected value type depending on how the dealer is trying to buy [ retail | wholesale | tradein ] */
  value_type: Scalars['String']['output'];
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: Maybe<Scalars['jsonb']['output']>;
  /** Notes specifically about the vehicle */
  vehicle_notes?: Maybe<Scalars['String']['output']>;
  /** Vehicle Identification Number */
  vin: Scalars['String']['output'];
};


/** Table for dealer appraisals */
export type AppraisalsMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** Table for dealer appraisals */
export type AppraisalsMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** Table for dealer appraisals */
export type AppraisalsTrim_OverridesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Table for dealer appraisals */
export type AppraisalsVehicle_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "appraisals" */
export type Appraisals_Aggregate = {
  __typename?: 'appraisals_aggregate';
  aggregate?: Maybe<Appraisals_Aggregate_Fields>;
  nodes: Array<Appraisals>;
};

/** aggregate fields of "appraisals" */
export type Appraisals_Aggregate_Fields = {
  __typename?: 'appraisals_aggregate_fields';
  avg?: Maybe<Appraisals_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Appraisals_Max_Fields>;
  min?: Maybe<Appraisals_Min_Fields>;
  stddev?: Maybe<Appraisals_Stddev_Fields>;
  stddev_pop?: Maybe<Appraisals_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Appraisals_Stddev_Samp_Fields>;
  sum?: Maybe<Appraisals_Sum_Fields>;
  var_pop?: Maybe<Appraisals_Var_Pop_Fields>;
  var_samp?: Maybe<Appraisals_Var_Samp_Fields>;
  variance?: Maybe<Appraisals_Variance_Fields>;
};


/** aggregate fields of "appraisals" */
export type Appraisals_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Appraisals_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Appraisals_Append_Input = {
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['jsonb']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Appraisals_Avg_Fields = {
  __typename?: 'appraisals_avg_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "appraisals". All fields are combined with a logical 'AND'. */
export type Appraisals_Bool_Exp = {
  _and?: InputMaybe<Array<Appraisals_Bool_Exp>>;
  _not?: InputMaybe<Appraisals_Bool_Exp>;
  _or?: InputMaybe<Array<Appraisals_Bool_Exp>>;
  appraiser_contact?: InputMaybe<String_Comparison_Exp>;
  appraiser_credentials?: InputMaybe<String_Comparison_Exp>;
  appraiser_expire_time_utc?: InputMaybe<Timestamptz_Comparison_Exp>;
  appraiser_name?: InputMaybe<String_Comparison_Exp>;
  appraiser_notes?: InputMaybe<String_Comparison_Exp>;
  condition?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  favorite?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  last_fetch_time_utc?: InputMaybe<Timestamptz_Comparison_Exp>;
  last_save_time_utc?: InputMaybe<Timestamptz_Comparison_Exp>;
  mileage_override?: InputMaybe<Bigint_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  trim_overrides?: InputMaybe<Jsonb_Comparison_Exp>;
  value_adjustment?: InputMaybe<Bigint_Comparison_Exp>;
  value_total?: InputMaybe<Bigint_Comparison_Exp>;
  value_type?: InputMaybe<String_Comparison_Exp>;
  vehicle_data?: InputMaybe<Jsonb_Comparison_Exp>;
  vehicle_notes?: InputMaybe<String_Comparison_Exp>;
  vin?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "appraisals" */
export enum Appraisals_Constraint {
  /** unique or primary key constraint on columns "id" */
  AppraisalsPkey = 'appraisals_pkey',
  /** unique or primary key constraint on columns "vin", "customer_id" */
  AppraisalsVinCustomerIdKey = 'appraisals_vin_customer_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Appraisals_Delete_At_Path_Input = {
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Appraisals_Delete_Elem_Input = {
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['Int']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Appraisals_Delete_Key_Input = {
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['String']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "appraisals" */
export type Appraisals_Inc_Input = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: InputMaybe<Scalars['bigint']['input']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: InputMaybe<Scalars['bigint']['input']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "appraisals" */
export type Appraisals_Insert_Input = {
  /** Contact info from the appraiser */
  appraiser_contact?: InputMaybe<Scalars['String']['input']>;
  /** Credentials provided about the appraiser */
  appraiser_credentials?: InputMaybe<Scalars['String']['input']>;
  /** Appraiser's set time for the appraisal to expire (for the print/pdf screen) */
  appraiser_expire_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Name of the appraiser */
  appraiser_name?: InputMaybe<Scalars['String']['input']>;
  /** Notes from the appraiser */
  appraiser_notes?: InputMaybe<Scalars['String']['input']>;
  /** Conditional status of the vehicle (ie. What shape is it in?) [ mint | good | fair | poor ] */
  condition?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Last time the vehicle_data was fetched from our 3rd party API */
  last_fetch_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Timestamp of when the appraisal was last saved */
  last_save_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: InputMaybe<Scalars['bigint']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  /** Current status of the appraisal |new - newly generated appraisal| generated - appraisal has been generated in the last 24 hours and will continue to be used for the vehicle until it expires in 24 hours| no data - no data was found for the vehicle's value| expired - 24 hours has gone by and the appraisal is no longer valid| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['jsonb']['input']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: InputMaybe<Scalars['bigint']['input']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: InputMaybe<Scalars['bigint']['input']>;
  /** Selected value type depending on how the dealer is trying to buy [ retail | wholesale | tradein ] */
  value_type?: InputMaybe<Scalars['String']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Notes specifically about the vehicle */
  vehicle_notes?: InputMaybe<Scalars['String']['input']>;
  /** Vehicle Identification Number */
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Appraisals_Max_Fields = {
  __typename?: 'appraisals_max_fields';
  /** Contact info from the appraiser */
  appraiser_contact?: Maybe<Scalars['String']['output']>;
  /** Credentials provided about the appraiser */
  appraiser_credentials?: Maybe<Scalars['String']['output']>;
  /** Appraiser's set time for the appraisal to expire (for the print/pdf screen) */
  appraiser_expire_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Name of the appraiser */
  appraiser_name?: Maybe<Scalars['String']['output']>;
  /** Notes from the appraiser */
  appraiser_notes?: Maybe<Scalars['String']['output']>;
  /** Conditional status of the vehicle (ie. What shape is it in?) [ mint | good | fair | poor ] */
  condition?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Last time the vehicle_data was fetched from our 3rd party API */
  last_fetch_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Timestamp of when the appraisal was last saved */
  last_save_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['bigint']['output']>;
  /** Current status of the appraisal |new - newly generated appraisal| generated - appraisal has been generated in the last 24 hours and will continue to be used for the vehicle until it expires in 24 hours| no data - no data was found for the vehicle's value| expired - 24 hours has gone by and the appraisal is no longer valid| */
  status?: Maybe<Scalars['String']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['bigint']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['bigint']['output']>;
  /** Selected value type depending on how the dealer is trying to buy [ retail | wholesale | tradein ] */
  value_type?: Maybe<Scalars['String']['output']>;
  /** Notes specifically about the vehicle */
  vehicle_notes?: Maybe<Scalars['String']['output']>;
  /** Vehicle Identification Number */
  vin?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Appraisals_Min_Fields = {
  __typename?: 'appraisals_min_fields';
  /** Contact info from the appraiser */
  appraiser_contact?: Maybe<Scalars['String']['output']>;
  /** Credentials provided about the appraiser */
  appraiser_credentials?: Maybe<Scalars['String']['output']>;
  /** Appraiser's set time for the appraisal to expire (for the print/pdf screen) */
  appraiser_expire_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Name of the appraiser */
  appraiser_name?: Maybe<Scalars['String']['output']>;
  /** Notes from the appraiser */
  appraiser_notes?: Maybe<Scalars['String']['output']>;
  /** Conditional status of the vehicle (ie. What shape is it in?) [ mint | good | fair | poor ] */
  condition?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Last time the vehicle_data was fetched from our 3rd party API */
  last_fetch_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Timestamp of when the appraisal was last saved */
  last_save_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['bigint']['output']>;
  /** Current status of the appraisal |new - newly generated appraisal| generated - appraisal has been generated in the last 24 hours and will continue to be used for the vehicle until it expires in 24 hours| no data - no data was found for the vehicle's value| expired - 24 hours has gone by and the appraisal is no longer valid| */
  status?: Maybe<Scalars['String']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['bigint']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['bigint']['output']>;
  /** Selected value type depending on how the dealer is trying to buy [ retail | wholesale | tradein ] */
  value_type?: Maybe<Scalars['String']['output']>;
  /** Notes specifically about the vehicle */
  vehicle_notes?: Maybe<Scalars['String']['output']>;
  /** Vehicle Identification Number */
  vin?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "appraisals" */
export type Appraisals_Mutation_Response = {
  __typename?: 'appraisals_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Appraisals>;
};

/** on_conflict condition type for table "appraisals" */
export type Appraisals_On_Conflict = {
  constraint: Appraisals_Constraint;
  update_columns?: Array<Appraisals_Update_Column>;
  where?: InputMaybe<Appraisals_Bool_Exp>;
};

/** Ordering options when selecting data from "appraisals". */
export type Appraisals_Order_By = {
  appraiser_contact?: InputMaybe<Order_By>;
  appraiser_credentials?: InputMaybe<Order_By>;
  appraiser_expire_time_utc?: InputMaybe<Order_By>;
  appraiser_name?: InputMaybe<Order_By>;
  appraiser_notes?: InputMaybe<Order_By>;
  condition?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  favorite?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_fetch_time_utc?: InputMaybe<Order_By>;
  last_save_time_utc?: InputMaybe<Order_By>;
  mileage_override?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  trim_overrides?: InputMaybe<Order_By>;
  value_adjustment?: InputMaybe<Order_By>;
  value_total?: InputMaybe<Order_By>;
  value_type?: InputMaybe<Order_By>;
  vehicle_data?: InputMaybe<Order_By>;
  vehicle_notes?: InputMaybe<Order_By>;
  vin?: InputMaybe<Order_By>;
};

/** primary key columns input for table: appraisals */
export type Appraisals_Pk_Columns_Input = {
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Appraisals_Prepend_Input = {
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['jsonb']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "appraisals" */
export enum Appraisals_Select_Column {
  /** column name */
  AppraiserContact = 'appraiser_contact',
  /** column name */
  AppraiserCredentials = 'appraiser_credentials',
  /** column name */
  AppraiserExpireTimeUtc = 'appraiser_expire_time_utc',
  /** column name */
  AppraiserName = 'appraiser_name',
  /** column name */
  AppraiserNotes = 'appraiser_notes',
  /** column name */
  Condition = 'condition',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Favorite = 'favorite',
  /** column name */
  Id = 'id',
  /** column name */
  LastFetchTimeUtc = 'last_fetch_time_utc',
  /** column name */
  LastSaveTimeUtc = 'last_save_time_utc',
  /** column name */
  MileageOverride = 'mileage_override',
  /** column name */
  Status = 'status',
  /** column name */
  TrimOverrides = 'trim_overrides',
  /** column name */
  ValueAdjustment = 'value_adjustment',
  /** column name */
  ValueTotal = 'value_total',
  /** column name */
  ValueType = 'value_type',
  /** column name */
  VehicleData = 'vehicle_data',
  /** column name */
  VehicleNotes = 'vehicle_notes',
  /** column name */
  Vin = 'vin'
}

/** input type for updating data in table "appraisals" */
export type Appraisals_Set_Input = {
  /** Contact info from the appraiser */
  appraiser_contact?: InputMaybe<Scalars['String']['input']>;
  /** Credentials provided about the appraiser */
  appraiser_credentials?: InputMaybe<Scalars['String']['input']>;
  /** Appraiser's set time for the appraisal to expire (for the print/pdf screen) */
  appraiser_expire_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Name of the appraiser */
  appraiser_name?: InputMaybe<Scalars['String']['input']>;
  /** Notes from the appraiser */
  appraiser_notes?: InputMaybe<Scalars['String']['input']>;
  /** Conditional status of the vehicle (ie. What shape is it in?) [ mint | good | fair | poor ] */
  condition?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Last time the vehicle_data was fetched from our 3rd party API */
  last_fetch_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Timestamp of when the appraisal was last saved */
  last_save_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: InputMaybe<Scalars['bigint']['input']>;
  /** Current status of the appraisal |new - newly generated appraisal| generated - appraisal has been generated in the last 24 hours and will continue to be used for the vehicle until it expires in 24 hours| no data - no data was found for the vehicle's value| expired - 24 hours has gone by and the appraisal is no longer valid| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['jsonb']['input']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: InputMaybe<Scalars['bigint']['input']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: InputMaybe<Scalars['bigint']['input']>;
  /** Selected value type depending on how the dealer is trying to buy [ retail | wholesale | tradein ] */
  value_type?: InputMaybe<Scalars['String']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Notes specifically about the vehicle */
  vehicle_notes?: InputMaybe<Scalars['String']['input']>;
  /** Vehicle Identification Number */
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Appraisals_Stddev_Fields = {
  __typename?: 'appraisals_stddev_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Appraisals_Stddev_Pop_Fields = {
  __typename?: 'appraisals_stddev_pop_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Appraisals_Stddev_Samp_Fields = {
  __typename?: 'appraisals_stddev_samp_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "appraisals" */
export type Appraisals_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Appraisals_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Appraisals_Stream_Cursor_Value_Input = {
  /** Contact info from the appraiser */
  appraiser_contact?: InputMaybe<Scalars['String']['input']>;
  /** Credentials provided about the appraiser */
  appraiser_credentials?: InputMaybe<Scalars['String']['input']>;
  /** Appraiser's set time for the appraisal to expire (for the print/pdf screen) */
  appraiser_expire_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Name of the appraiser */
  appraiser_name?: InputMaybe<Scalars['String']['input']>;
  /** Notes from the appraiser */
  appraiser_notes?: InputMaybe<Scalars['String']['input']>;
  /** Conditional status of the vehicle (ie. What shape is it in?) [ mint | good | fair | poor ] */
  condition?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Last time the vehicle_data was fetched from our 3rd party API */
  last_fetch_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Timestamp of when the appraisal was last saved */
  last_save_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: InputMaybe<Scalars['bigint']['input']>;
  /** Current status of the appraisal |new - newly generated appraisal| generated - appraisal has been generated in the last 24 hours and will continue to be used for the vehicle until it expires in 24 hours| no data - no data was found for the vehicle's value| expired - 24 hours has gone by and the appraisal is no longer valid| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Additions/Deductions from our 3rd party API that affect the final price */
  trim_overrides?: InputMaybe<Scalars['jsonb']['input']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: InputMaybe<Scalars['bigint']['input']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: InputMaybe<Scalars['bigint']['input']>;
  /** Selected value type depending on how the dealer is trying to buy [ retail | wholesale | tradein ] */
  value_type?: InputMaybe<Scalars['String']['input']>;
  /** Refers to the vehicle and value data from our 3rd party API */
  vehicle_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Notes specifically about the vehicle */
  vehicle_notes?: InputMaybe<Scalars['String']['input']>;
  /** Vehicle Identification Number */
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Appraisals_Sum_Fields = {
  __typename?: 'appraisals_sum_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['bigint']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['bigint']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "appraisals" */
export enum Appraisals_Update_Column {
  /** column name */
  AppraiserContact = 'appraiser_contact',
  /** column name */
  AppraiserCredentials = 'appraiser_credentials',
  /** column name */
  AppraiserExpireTimeUtc = 'appraiser_expire_time_utc',
  /** column name */
  AppraiserName = 'appraiser_name',
  /** column name */
  AppraiserNotes = 'appraiser_notes',
  /** column name */
  Condition = 'condition',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Favorite = 'favorite',
  /** column name */
  Id = 'id',
  /** column name */
  LastFetchTimeUtc = 'last_fetch_time_utc',
  /** column name */
  LastSaveTimeUtc = 'last_save_time_utc',
  /** column name */
  MileageOverride = 'mileage_override',
  /** column name */
  Status = 'status',
  /** column name */
  TrimOverrides = 'trim_overrides',
  /** column name */
  ValueAdjustment = 'value_adjustment',
  /** column name */
  ValueTotal = 'value_total',
  /** column name */
  ValueType = 'value_type',
  /** column name */
  VehicleData = 'vehicle_data',
  /** column name */
  VehicleNotes = 'vehicle_notes',
  /** column name */
  Vin = 'vin'
}

export type Appraisals_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Appraisals_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Appraisals_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Appraisals_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Appraisals_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Appraisals_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Appraisals_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Appraisals_Set_Input>;
  /** filter the rows which have to be updated */
  where: Appraisals_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Appraisals_Var_Pop_Fields = {
  __typename?: 'appraisals_var_pop_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Appraisals_Var_Samp_Fields = {
  __typename?: 'appraisals_var_samp_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Appraisals_Variance_Fields = {
  __typename?: 'appraisals_variance_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the appraisals table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the appraisals table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Mileage override on the vehicle (just in case we get a bad vehicle_odometer reading) */
  mileage_override?: Maybe<Scalars['Float']['output']>;
  /** Adjustment to value_total to form a final value for the dealer to use */
  value_adjustment?: Maybe<Scalars['Float']['output']>;
  /** Final appraisal value based on condition, trim_overrides, value_type, value_adjustment, and vehicle_history */
  value_total?: Maybe<Scalars['Float']['output']>;
};

/** For storing log messages generated by the AR Engine during the calculation of the charges for a move or the processing of invoices once they have matured. In the event that the AR Engine fails to write the ARMoves record, the AREvents rows are also related to the move_id from the moves table and the invoice_id from the invoices table. */
export type Arevents = {
  __typename?: 'arevents';
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id: Scalars['String']['output'];
  /** An object relationship */
  arinvoice?: Maybe<Arinvoices>;
  /** Timestamp the arevent was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level: Scalars['smallint']['output'];
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message: Scalars['String']['output'];
  /** An object relationship */
  move?: Maybe<Moves>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the arevent was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "arevents" */
export type Arevents_Aggregate = {
  __typename?: 'arevents_aggregate';
  aggregate?: Maybe<Arevents_Aggregate_Fields>;
  nodes: Array<Arevents>;
};

export type Arevents_Aggregate_Bool_Exp = {
  count?: InputMaybe<Arevents_Aggregate_Bool_Exp_Count>;
};

export type Arevents_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Arevents_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arevents_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "arevents" */
export type Arevents_Aggregate_Fields = {
  __typename?: 'arevents_aggregate_fields';
  avg?: Maybe<Arevents_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arevents_Max_Fields>;
  min?: Maybe<Arevents_Min_Fields>;
  stddev?: Maybe<Arevents_Stddev_Fields>;
  stddev_pop?: Maybe<Arevents_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arevents_Stddev_Samp_Fields>;
  sum?: Maybe<Arevents_Sum_Fields>;
  var_pop?: Maybe<Arevents_Var_Pop_Fields>;
  var_samp?: Maybe<Arevents_Var_Samp_Fields>;
  variance?: Maybe<Arevents_Variance_Fields>;
};


/** aggregate fields of "arevents" */
export type Arevents_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arevents_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "arevents" */
export type Arevents_Aggregate_Order_By = {
  avg?: InputMaybe<Arevents_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Arevents_Max_Order_By>;
  min?: InputMaybe<Arevents_Min_Order_By>;
  stddev?: InputMaybe<Arevents_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Arevents_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Arevents_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Arevents_Sum_Order_By>;
  var_pop?: InputMaybe<Arevents_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Arevents_Var_Samp_Order_By>;
  variance?: InputMaybe<Arevents_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "arevents" */
export type Arevents_Arr_Rel_Insert_Input = {
  data: Array<Arevents_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Arevents_On_Conflict>;
};

/** aggregate avg on columns */
export type Arevents_Avg_Fields = {
  __typename?: 'arevents_avg_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "arevents" */
export type Arevents_Avg_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "arevents". All fields are combined with a logical 'AND'. */
export type Arevents_Bool_Exp = {
  _and?: InputMaybe<Array<Arevents_Bool_Exp>>;
  _not?: InputMaybe<Arevents_Bool_Exp>;
  _or?: InputMaybe<Array<Arevents_Bool_Exp>>;
  arevent_id?: InputMaybe<String_Comparison_Exp>;
  arinvoice?: InputMaybe<Arinvoices_Bool_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  invoice_id?: InputMaybe<Bigint_Comparison_Exp>;
  level?: InputMaybe<Smallint_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arevents" */
export enum Arevents_Constraint {
  /** unique or primary key constraint on columns "id" */
  AreventsPkey = 'arevents_pkey'
}

/** input type for incrementing numeric columns in table "arevents" */
export type Arevents_Inc_Input = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Scalars['smallint']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "arevents" */
export type Arevents_Insert_Input = {
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  arinvoice?: InputMaybe<Arinvoices_Obj_Rel_Insert_Input>;
  /** Timestamp the arevent was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Scalars['smallint']['input']>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: InputMaybe<Scalars['String']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the arevent was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arevents_Max_Fields = {
  __typename?: 'arevents_max_fields';
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: Maybe<Scalars['String']['output']>;
  /** Timestamp the arevent was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['smallint']['output']>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the arevent was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "arevents" */
export type Arevents_Max_Order_By = {
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: InputMaybe<Order_By>;
  /** Timestamp the arevent was created. */
  createdat?: InputMaybe<Order_By>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** Timestamp the arevent was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Arevents_Min_Fields = {
  __typename?: 'arevents_min_fields';
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: Maybe<Scalars['String']['output']>;
  /** Timestamp the arevent was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['smallint']['output']>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the arevent was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "arevents" */
export type Arevents_Min_Order_By = {
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: InputMaybe<Order_By>;
  /** Timestamp the arevent was created. */
  createdat?: InputMaybe<Order_By>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
  /** Timestamp the arevent was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "arevents" */
export type Arevents_Mutation_Response = {
  __typename?: 'arevents_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arevents>;
};

/** on_conflict condition type for table "arevents" */
export type Arevents_On_Conflict = {
  constraint: Arevents_Constraint;
  update_columns?: Array<Arevents_Update_Column>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};

/** Ordering options when selecting data from "arevents". */
export type Arevents_Order_By = {
  arevent_id?: InputMaybe<Order_By>;
  arinvoice?: InputMaybe<Arinvoices_Order_By>;
  createdat?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arevents */
export type Arevents_Pk_Columns_Input = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** select columns of table "arevents" */
export enum Arevents_Select_Column {
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  Level = 'level',
  /** column name */
  Message = 'message',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "arevents" */
export type Arevents_Set_Input = {
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arevent was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Scalars['smallint']['input']>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the arevent was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arevents_Stddev_Fields = {
  __typename?: 'arevents_stddev_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "arevents" */
export type Arevents_Stddev_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Arevents_Stddev_Pop_Fields = {
  __typename?: 'arevents_stddev_pop_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "arevents" */
export type Arevents_Stddev_Pop_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Arevents_Stddev_Samp_Fields = {
  __typename?: 'arevents_stddev_samp_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "arevents" */
export type Arevents_Stddev_Samp_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "arevents" */
export type Arevents_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arevents_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arevents_Stream_Cursor_Value_Input = {
  /** generated by JS at the start of a new orchestration triggered by one of the process triggers listed in this document. Used for writing all events from that instance of the Run or Nightly function. */
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arevent was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Scalars['smallint']['input']>;
  /** a string describing the event which occurred in the code which triggered - the writing of the event record */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the arevent was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arevents_Sum_Fields = {
  __typename?: 'arevents_sum_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['smallint']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "arevents" */
export type Arevents_Sum_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** update columns of table "arevents" */
export enum Arevents_Update_Column {
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  Level = 'level',
  /** column name */
  Message = 'message',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Arevents_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arevents_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arevents_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arevents_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arevents_Var_Pop_Fields = {
  __typename?: 'arevents_var_pop_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "arevents" */
export type Arevents_Var_Pop_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Arevents_Var_Samp_Fields = {
  __typename?: 'arevents_var_samp_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "arevents" */
export type Arevents_Var_Samp_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Arevents_Variance_Fields = {
  __typename?: 'arevents_variance_fields';
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: Maybe<Scalars['Float']['output']>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "arevents" */
export type Arevents_Variance_Order_By = {
  /** Primary key for the arevents table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arevents table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Foreign key to the arinvoice table. This field is used to link the current record to a specific invoice. The value of this field references a valid ID of a invoice in the arinvoice table. */
  invoice_id?: InputMaybe<Order_By>;
  /** an integer representing one of the common logging levels as defined by the log4j standard |off - 0|fatal - 100|error - 200|warn - 300|info - 400|debug - 500|trace - 600|all - integer.max_value| */
  level?: InputMaybe<Order_By>;
  /** Foreign key to the moves table. This field is used to link the current record to a specific move. The value of this field references a valid ID of a move in the moves table. */
  move_id?: InputMaybe<Order_By>;
};

/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type Arinvoices = {
  __typename?: 'arinvoices';
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id: Scalars['String']['output'];
  /** An array relationship */
  armoves: Array<Armoves>;
  /** An aggregate relationship */
  armoves_aggregate: Armoves_Aggregate;
  /** An array relationship */
  arpayments: Array<Arpayments>;
  /** An aggregate relationship */
  arpayments_aggregate: Arpayments_Aggregate;
  /** Timestamp the arinvoice was created. */
  createdat: Scalars['timestamptz']['output'];
  /** An object relationship */
  customer: Customers;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id: Scalars['bigint']['output'];
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime: Scalars['timestamptz']['output'];
  /** An array relationship */
  eventsByEventId: Array<Arevents>;
  /** An aggregate relationship */
  eventsByEventId_aggregate: Arevents_Aggregate;
  /** An array relationship */
  eventsByInvoice: Array<Armoveshistory>;
  /** An aggregate relationship */
  eventsByInvoice_aggregate: Armoveshistory_Aggregate;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: Maybe<Scalars['String']['output']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime: Scalars['timestamptz']['output'];
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status: Scalars['String']['output'];
  /** Timestamp the arinvoice was updated. */
  updatedat: Scalars['timestamptz']['output'];
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesArmovesArgs = {
  distinct_on?: InputMaybe<Array<Armoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoves_Order_By>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesArmoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoves_Order_By>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesArpaymentsArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesArpayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesEventsByEventIdArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesEventsByEventId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesEventsByInvoiceArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


/** Correlated to invoices in the accounting system, this table holds invoices that collect multiple armoves as children into a group typically dictated by a date range for moves performed around the customers payment frequency. */
export type ArinvoicesEventsByInvoice_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};

/** aggregated selection of "arinvoices" */
export type Arinvoices_Aggregate = {
  __typename?: 'arinvoices_aggregate';
  aggregate?: Maybe<Arinvoices_Aggregate_Fields>;
  nodes: Array<Arinvoices>;
};

export type Arinvoices_Aggregate_Bool_Exp = {
  count?: InputMaybe<Arinvoices_Aggregate_Bool_Exp_Count>;
};

export type Arinvoices_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Arinvoices_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arinvoices_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "arinvoices" */
export type Arinvoices_Aggregate_Fields = {
  __typename?: 'arinvoices_aggregate_fields';
  avg?: Maybe<Arinvoices_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arinvoices_Max_Fields>;
  min?: Maybe<Arinvoices_Min_Fields>;
  stddev?: Maybe<Arinvoices_Stddev_Fields>;
  stddev_pop?: Maybe<Arinvoices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arinvoices_Stddev_Samp_Fields>;
  sum?: Maybe<Arinvoices_Sum_Fields>;
  var_pop?: Maybe<Arinvoices_Var_Pop_Fields>;
  var_samp?: Maybe<Arinvoices_Var_Samp_Fields>;
  variance?: Maybe<Arinvoices_Variance_Fields>;
};


/** aggregate fields of "arinvoices" */
export type Arinvoices_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arinvoices_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "arinvoices" */
export type Arinvoices_Aggregate_Order_By = {
  avg?: InputMaybe<Arinvoices_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Arinvoices_Max_Order_By>;
  min?: InputMaybe<Arinvoices_Min_Order_By>;
  stddev?: InputMaybe<Arinvoices_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Arinvoices_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Arinvoices_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Arinvoices_Sum_Order_By>;
  var_pop?: InputMaybe<Arinvoices_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Arinvoices_Var_Samp_Order_By>;
  variance?: InputMaybe<Arinvoices_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "arinvoices" */
export type Arinvoices_Arr_Rel_Insert_Input = {
  data: Array<Arinvoices_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Arinvoices_On_Conflict>;
};

/** aggregate avg on columns */
export type Arinvoices_Avg_Fields = {
  __typename?: 'arinvoices_avg_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "arinvoices" */
export type Arinvoices_Avg_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "arinvoices". All fields are combined with a logical 'AND'. */
export type Arinvoices_Bool_Exp = {
  _and?: InputMaybe<Array<Arinvoices_Bool_Exp>>;
  _not?: InputMaybe<Arinvoices_Bool_Exp>;
  _or?: InputMaybe<Array<Arinvoices_Bool_Exp>>;
  accounting_num?: InputMaybe<String_Comparison_Exp>;
  arevent_id?: InputMaybe<String_Comparison_Exp>;
  armoves?: InputMaybe<Armoves_Bool_Exp>;
  armoves_aggregate?: InputMaybe<Armoves_Aggregate_Bool_Exp>;
  arpayments?: InputMaybe<Arpayments_Bool_Exp>;
  arpayments_aggregate?: InputMaybe<Arpayments_Aggregate_Bool_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  end_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  eventsByEventId?: InputMaybe<Arevents_Bool_Exp>;
  eventsByEventId_aggregate?: InputMaybe<Arevents_Aggregate_Bool_Exp>;
  eventsByInvoice?: InputMaybe<Armoveshistory_Bool_Exp>;
  eventsByInvoice_aggregate?: InputMaybe<Armoveshistory_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  pdf?: InputMaybe<String_Comparison_Exp>;
  start_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arinvoices" */
export enum Arinvoices_Constraint {
  /** unique or primary key constraint on columns "customer_id", "start_datetime" */
  ArinvoicesCustomerIdStartDatetimeKey = 'arinvoices_customer_id_start_datetime_key',
  /** unique or primary key constraint on columns "id" */
  ArinvoicesPkey = 'arinvoices_pkey'
}

/** input type for incrementing numeric columns in table "arinvoices" */
export type Arinvoices_Inc_Input = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "arinvoices" */
export type Arinvoices_Insert_Input = {
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  armoves?: InputMaybe<Armoves_Arr_Rel_Insert_Input>;
  arpayments?: InputMaybe<Arpayments_Arr_Rel_Insert_Input>;
  /** Timestamp the arinvoice was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  eventsByEventId?: InputMaybe<Arevents_Arr_Rel_Insert_Input>;
  eventsByInvoice?: InputMaybe<Armoveshistory_Arr_Rel_Insert_Input>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: InputMaybe<Scalars['String']['input']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arinvoices_Max_Fields = {
  __typename?: 'arinvoices_max_fields';
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: Maybe<Scalars['String']['output']>;
  /** Timestamp the arinvoice was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: Maybe<Scalars['String']['output']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: Maybe<Scalars['timestamptz']['output']>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: Maybe<Scalars['String']['output']>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "arinvoices" */
export type Arinvoices_Max_Order_By = {
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: InputMaybe<Order_By>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: InputMaybe<Order_By>;
  /** Timestamp the arinvoice was created. */
  createdat?: InputMaybe<Order_By>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: InputMaybe<Order_By>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: InputMaybe<Order_By>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: InputMaybe<Order_By>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Arinvoices_Min_Fields = {
  __typename?: 'arinvoices_min_fields';
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: Maybe<Scalars['String']['output']>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: Maybe<Scalars['String']['output']>;
  /** Timestamp the arinvoice was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: Maybe<Scalars['timestamptz']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: Maybe<Scalars['String']['output']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: Maybe<Scalars['timestamptz']['output']>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: Maybe<Scalars['String']['output']>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "arinvoices" */
export type Arinvoices_Min_Order_By = {
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: InputMaybe<Order_By>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: InputMaybe<Order_By>;
  /** Timestamp the arinvoice was created. */
  createdat?: InputMaybe<Order_By>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: InputMaybe<Order_By>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: InputMaybe<Order_By>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: InputMaybe<Order_By>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "arinvoices" */
export type Arinvoices_Mutation_Response = {
  __typename?: 'arinvoices_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arinvoices>;
};

/** input type for inserting object relation for remote table "arinvoices" */
export type Arinvoices_Obj_Rel_Insert_Input = {
  data: Arinvoices_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Arinvoices_On_Conflict>;
};

/** on_conflict condition type for table "arinvoices" */
export type Arinvoices_On_Conflict = {
  constraint: Arinvoices_Constraint;
  update_columns?: Array<Arinvoices_Update_Column>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};

/** Ordering options when selecting data from "arinvoices". */
export type Arinvoices_Order_By = {
  accounting_num?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  armoves_aggregate?: InputMaybe<Armoves_Aggregate_Order_By>;
  arpayments_aggregate?: InputMaybe<Arpayments_Aggregate_Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  end_datetime?: InputMaybe<Order_By>;
  eventsByEventId_aggregate?: InputMaybe<Arevents_Aggregate_Order_By>;
  eventsByInvoice_aggregate?: InputMaybe<Armoveshistory_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  pdf?: InputMaybe<Order_By>;
  start_datetime?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arinvoices */
export type Arinvoices_Pk_Columns_Input = {
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** select columns of table "arinvoices" */
export enum Arinvoices_Select_Column {
  /** column name */
  AccountingNum = 'accounting_num',
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  EndDatetime = 'end_datetime',
  /** column name */
  Id = 'id',
  /** column name */
  Pdf = 'pdf',
  /** column name */
  StartDatetime = 'start_datetime',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "arinvoices" */
export type Arinvoices_Set_Input = {
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arinvoice was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: InputMaybe<Scalars['String']['input']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arinvoices_Stddev_Fields = {
  __typename?: 'arinvoices_stddev_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "arinvoices" */
export type Arinvoices_Stddev_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Arinvoices_Stddev_Pop_Fields = {
  __typename?: 'arinvoices_stddev_pop_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "arinvoices" */
export type Arinvoices_Stddev_Pop_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Arinvoices_Stddev_Samp_Fields = {
  __typename?: 'arinvoices_stddev_samp_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "arinvoices" */
export type Arinvoices_Stddev_Samp_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "arinvoices" */
export type Arinvoices_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arinvoices_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arinvoices_Stream_Cursor_Value_Input = {
  /** the accounting system generated invoice id provided by the API after the invoice is sent to the accounting system */
  accounting_num?: InputMaybe<Scalars['String']['input']>;
  /** Foreign key to the arevents table. This field is used to link the current record to a specific arevents. The value of this field references a valid ID of an arevent in the arevents table. */
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arinvoice was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime less than this date time. */
  end_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** an optional URL to a generated PDF stored in an S3 bucket on AWS */
  pdf?: InputMaybe<Scalars['String']['input']>;
  /** a datetime field representing the starting range for the moves collected onto the invoice. ARMoves records which are child to an invoice will typically have a billable_datetime equal to or greater than this date time. */
  start_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** a list of string values that represent the state of an invoice as it moves through its lifecycle. While its tempting to think of the invoice life cycle here as if it were from an accounting perspective, really its more from the perspective of building the invoice rather than its to-cash life cycle. The to-cash process will be represented in the accounting system.|acquiring - (default) a newly created invoice generated automatically by the first move, for that customer and time period, that became billable. An invoice in this state is still acquiring new moves as they become billable|closed - the invoice has been fully processed in the nightly job meaning it is no longer acquiring new billable moves, the customer has been notified and all automatic payments processed, the invoice status will change to closed| */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp the arinvoice was updated. */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arinvoices_Sum_Fields = {
  __typename?: 'arinvoices_sum_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "arinvoices" */
export type Arinvoices_Sum_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** update columns of table "arinvoices" */
export enum Arinvoices_Update_Column {
  /** column name */
  AccountingNum = 'accounting_num',
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  EndDatetime = 'end_datetime',
  /** column name */
  Id = 'id',
  /** column name */
  Pdf = 'pdf',
  /** column name */
  StartDatetime = 'start_datetime',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

export type Arinvoices_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arinvoices_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arinvoices_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arinvoices_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arinvoices_Var_Pop_Fields = {
  __typename?: 'arinvoices_var_pop_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "arinvoices" */
export type Arinvoices_Var_Pop_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Arinvoices_Var_Samp_Fields = {
  __typename?: 'arinvoices_var_samp_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "arinvoices" */
export type Arinvoices_Var_Samp_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Arinvoices_Variance_Fields = {
  __typename?: 'arinvoices_variance_fields';
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "arinvoices" */
export type Arinvoices_Variance_Order_By = {
  /** Foreign key to the customers table. This field is used to link the current record to a specific customer. The value of this field references a valid ID of a customer in the customers table. */
  customer_id?: InputMaybe<Order_By>;
  /** Primary key for the arinvoices table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the arinvoices table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
};

/** Each record represents a detailed line item making up the total due amount on a ARMoves record. For instance, this table will always hold at least one record representing the transfer of the vehicle where the amount charged for this service is calculated using the rate engine referencing the rate rules table, but may also contain additional rows representing additional charges that make up the total due amount such as tolls, unexpected costs such as towing, refueling of the vehicle, and additional time pay caused by delays during the pickup and/or delivery of the vehicle. */
export type Armovedetails = {
  __typename?: 'armovedetails';
  /** monetary amount charged for the services represented by the row */
  amount: Scalars['numeric']['output'];
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id: Scalars['bigint']['output'];
  /** Timestamp the armovedetail was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documents_aggregate: Documents_Aggregate;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name: Scalars['String']['output'];
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes: Scalars['String']['output'];
  /** An object relationship */
  parent: Armoves;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  raterule?: Maybe<Raterules>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the armovedetail was updated */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** Each record represents a detailed line item making up the total due amount on a ARMoves record. For instance, this table will always hold at least one record representing the transfer of the vehicle where the amount charged for this service is calculated using the rate engine referencing the rate rules table, but may also contain additional rows representing additional charges that make up the total due amount such as tolls, unexpected costs such as towing, refueling of the vehicle, and additional time pay caused by delays during the pickup and/or delivery of the vehicle. */
export type ArmovedetailsDocumentsArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


/** Each record represents a detailed line item making up the total due amount on a ARMoves record. For instance, this table will always hold at least one record representing the transfer of the vehicle where the amount charged for this service is calculated using the rate engine referencing the rate rules table, but may also contain additional rows representing additional charges that make up the total due amount such as tolls, unexpected costs such as towing, refueling of the vehicle, and additional time pay caused by delays during the pickup and/or delivery of the vehicle. */
export type ArmovedetailsDocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};

/** aggregated selection of "armovedetails" */
export type Armovedetails_Aggregate = {
  __typename?: 'armovedetails_aggregate';
  aggregate?: Maybe<Armovedetails_Aggregate_Fields>;
  nodes: Array<Armovedetails>;
};

export type Armovedetails_Aggregate_Bool_Exp = {
  count?: InputMaybe<Armovedetails_Aggregate_Bool_Exp_Count>;
};

export type Armovedetails_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Armovedetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armovedetails_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "armovedetails" */
export type Armovedetails_Aggregate_Fields = {
  __typename?: 'armovedetails_aggregate_fields';
  avg?: Maybe<Armovedetails_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Armovedetails_Max_Fields>;
  min?: Maybe<Armovedetails_Min_Fields>;
  stddev?: Maybe<Armovedetails_Stddev_Fields>;
  stddev_pop?: Maybe<Armovedetails_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Armovedetails_Stddev_Samp_Fields>;
  sum?: Maybe<Armovedetails_Sum_Fields>;
  var_pop?: Maybe<Armovedetails_Var_Pop_Fields>;
  var_samp?: Maybe<Armovedetails_Var_Samp_Fields>;
  variance?: Maybe<Armovedetails_Variance_Fields>;
};


/** aggregate fields of "armovedetails" */
export type Armovedetails_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Armovedetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "armovedetails" */
export type Armovedetails_Aggregate_Order_By = {
  avg?: InputMaybe<Armovedetails_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Armovedetails_Max_Order_By>;
  min?: InputMaybe<Armovedetails_Min_Order_By>;
  stddev?: InputMaybe<Armovedetails_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Armovedetails_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Armovedetails_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Armovedetails_Sum_Order_By>;
  var_pop?: InputMaybe<Armovedetails_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Armovedetails_Var_Samp_Order_By>;
  variance?: InputMaybe<Armovedetails_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "armovedetails" */
export type Armovedetails_Arr_Rel_Insert_Input = {
  data: Array<Armovedetails_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Armovedetails_On_Conflict>;
};

/** aggregate avg on columns */
export type Armovedetails_Avg_Fields = {
  __typename?: 'armovedetails_avg_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "armovedetails" */
export type Armovedetails_Avg_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "armovedetails". All fields are combined with a logical 'AND'. */
export type Armovedetails_Bool_Exp = {
  _and?: InputMaybe<Array<Armovedetails_Bool_Exp>>;
  _not?: InputMaybe<Armovedetails_Bool_Exp>;
  _or?: InputMaybe<Array<Armovedetails_Bool_Exp>>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  armove_id?: InputMaybe<Bigint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  document_reference_id?: InputMaybe<Uuid_Comparison_Exp>;
  documents?: InputMaybe<Documents_Bool_Exp>;
  documents_aggregate?: InputMaybe<Documents_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  parent?: InputMaybe<Armoves_Bool_Exp>;
  rate_source?: InputMaybe<String_Comparison_Exp>;
  raterule?: InputMaybe<Raterules_Bool_Exp>;
  raterule_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "armovedetails" */
export enum Armovedetails_Constraint {
  /** unique or primary key constraint on columns "id" */
  ArmovedetailsPkey = 'armovedetails_pkey'
}

/** input type for incrementing numeric columns in table "armovedetails" */
export type Armovedetails_Inc_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "armovedetails" */
export type Armovedetails_Insert_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the armovedetail was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  documents?: InputMaybe<Documents_Arr_Rel_Insert_Input>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Scalars['String']['input']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<Armoves_Obj_Rel_Insert_Input>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Scalars['String']['input']>;
  raterule?: InputMaybe<Raterules_Obj_Rel_Insert_Input>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the armovedetail was updated */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Armovedetails_Max_Fields = {
  __typename?: 'armovedetails_max_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the armovedetail was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: Maybe<Scalars['String']['output']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: Maybe<Scalars['String']['output']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: Maybe<Scalars['String']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the armovedetail was updated */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "armovedetails" */
export type Armovedetails_Max_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Timestamp the armovedetail was created. */
  createdat?: InputMaybe<Order_By>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Order_By>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Order_By>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
  /** Timestamp the armovedetail was updated */
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Armovedetails_Min_Fields = {
  __typename?: 'armovedetails_min_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the armovedetail was created. */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: Maybe<Scalars['String']['output']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: Maybe<Scalars['String']['output']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: Maybe<Scalars['String']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
  /** Timestamp the armovedetail was updated */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "armovedetails" */
export type Armovedetails_Min_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Timestamp the armovedetail was created. */
  createdat?: InputMaybe<Order_By>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Order_By>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Order_By>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
  /** Timestamp the armovedetail was updated */
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "armovedetails" */
export type Armovedetails_Mutation_Response = {
  __typename?: 'armovedetails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Armovedetails>;
};

/** on_conflict condition type for table "armovedetails" */
export type Armovedetails_On_Conflict = {
  constraint: Armovedetails_Constraint;
  update_columns?: Array<Armovedetails_Update_Column>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};

/** Ordering options when selecting data from "armovedetails". */
export type Armovedetails_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  document_reference_id?: InputMaybe<Order_By>;
  documents_aggregate?: InputMaybe<Documents_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  parent?: InputMaybe<Armoves_Order_By>;
  rate_source?: InputMaybe<Order_By>;
  raterule?: InputMaybe<Raterules_Order_By>;
  raterule_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: armovedetails */
export type Armovedetails_Pk_Columns_Input = {
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** select columns of table "armovedetails" */
export enum Armovedetails_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ArmoveId = 'armove_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  RateSource = 'rate_source',
  /** column name */
  RateruleId = 'raterule_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "armovedetails" */
export type Armovedetails_Set_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the armovedetail was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Scalars['String']['input']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Scalars['String']['input']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the armovedetail was updated */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Armovedetails_Stddev_Fields = {
  __typename?: 'armovedetails_stddev_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "armovedetails" */
export type Armovedetails_Stddev_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Armovedetails_Stddev_Pop_Fields = {
  __typename?: 'armovedetails_stddev_pop_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "armovedetails" */
export type Armovedetails_Stddev_Pop_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Armovedetails_Stddev_Samp_Fields = {
  __typename?: 'armovedetails_stddev_samp_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "armovedetails" */
export type Armovedetails_Stddev_Samp_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "armovedetails" */
export type Armovedetails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Armovedetails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Armovedetails_Stream_Cursor_Value_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the armovedetail was created. */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this armovedetail has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Scalars['String']['input']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Scalars['String']['input']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Timestamp the armovedetail was updated */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Armovedetails_Sum_Fields = {
  __typename?: 'armovedetails_sum_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "armovedetails" */
export type Armovedetails_Sum_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** update columns of table "armovedetails" */
export enum Armovedetails_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ArmoveId = 'armove_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  RateSource = 'rate_source',
  /** column name */
  RateruleId = 'raterule_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Armovedetails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Armovedetails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Armovedetails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Armovedetails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Armovedetails_Var_Pop_Fields = {
  __typename?: 'armovedetails_var_pop_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "armovedetails" */
export type Armovedetails_Var_Pop_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Armovedetails_Var_Samp_Fields = {
  __typename?: 'armovedetails_var_samp_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "armovedetails" */
export type Armovedetails_Var_Samp_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Armovedetails_Variance_Fields = {
  __typename?: 'armovedetails_variance_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "armovedetails" */
export type Armovedetails_Variance_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoves table. This field is used to link the current record to a specific armove. The value of this field references a valid ID of an armove in the armoves table. */
  armove_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetails table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetails table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** Enabling a copy of the ARMoves and it's child ARMovesDetail rows for the purposes of storing revisions to the billed amounts over time. This table will only be populated in the process of introducing a new recalculation of the AR and it's detail for a move.  */
export type Armovedetailshistory = {
  __typename?: 'armovedetailshistory';
  /** monetary amount charged for the services represented by the row */
  amount: Scalars['numeric']['output'];
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id: Scalars['bigint']['output'];
  /** timestamp the armovedetailshistory was created */
  createdat: Scalars['timestamptz']['output'];
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documents_aggregate: Documents_Aggregate;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id: Scalars['bigint']['output'];
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name: Scalars['String']['output'];
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes: Scalars['String']['output'];
  /** An object relationship */
  parent: Armoveshistory;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  raterule?: Maybe<Raterules>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
  /** timestamp the armovedetailshistory was updated */
  updatedat: Scalars['timestamptz']['output'];
};


/** Enabling a copy of the ARMoves and it's child ARMovesDetail rows for the purposes of storing revisions to the billed amounts over time. This table will only be populated in the process of introducing a new recalculation of the AR and it's detail for a move.  */
export type ArmovedetailshistoryDocumentsArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


/** Enabling a copy of the ARMoves and it's child ARMovesDetail rows for the purposes of storing revisions to the billed amounts over time. This table will only be populated in the process of introducing a new recalculation of the AR and it's detail for a move.  */
export type ArmovedetailshistoryDocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};

/** aggregated selection of "armovedetailshistory" */
export type Armovedetailshistory_Aggregate = {
  __typename?: 'armovedetailshistory_aggregate';
  aggregate?: Maybe<Armovedetailshistory_Aggregate_Fields>;
  nodes: Array<Armovedetailshistory>;
};

export type Armovedetailshistory_Aggregate_Bool_Exp = {
  count?: InputMaybe<Armovedetailshistory_Aggregate_Bool_Exp_Count>;
};

export type Armovedetailshistory_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armovedetailshistory_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "armovedetailshistory" */
export type Armovedetailshistory_Aggregate_Fields = {
  __typename?: 'armovedetailshistory_aggregate_fields';
  avg?: Maybe<Armovedetailshistory_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Armovedetailshistory_Max_Fields>;
  min?: Maybe<Armovedetailshistory_Min_Fields>;
  stddev?: Maybe<Armovedetailshistory_Stddev_Fields>;
  stddev_pop?: Maybe<Armovedetailshistory_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Armovedetailshistory_Stddev_Samp_Fields>;
  sum?: Maybe<Armovedetailshistory_Sum_Fields>;
  var_pop?: Maybe<Armovedetailshistory_Var_Pop_Fields>;
  var_samp?: Maybe<Armovedetailshistory_Var_Samp_Fields>;
  variance?: Maybe<Armovedetailshistory_Variance_Fields>;
};


/** aggregate fields of "armovedetailshistory" */
export type Armovedetailshistory_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "armovedetailshistory" */
export type Armovedetailshistory_Aggregate_Order_By = {
  avg?: InputMaybe<Armovedetailshistory_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Armovedetailshistory_Max_Order_By>;
  min?: InputMaybe<Armovedetailshistory_Min_Order_By>;
  stddev?: InputMaybe<Armovedetailshistory_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Armovedetailshistory_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Armovedetailshistory_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Armovedetailshistory_Sum_Order_By>;
  var_pop?: InputMaybe<Armovedetailshistory_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Armovedetailshistory_Var_Samp_Order_By>;
  variance?: InputMaybe<Armovedetailshistory_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "armovedetailshistory" */
export type Armovedetailshistory_Arr_Rel_Insert_Input = {
  data: Array<Armovedetailshistory_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Armovedetailshistory_On_Conflict>;
};

/** aggregate avg on columns */
export type Armovedetailshistory_Avg_Fields = {
  __typename?: 'armovedetailshistory_avg_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Avg_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "armovedetailshistory". All fields are combined with a logical 'AND'. */
export type Armovedetailshistory_Bool_Exp = {
  _and?: InputMaybe<Array<Armovedetailshistory_Bool_Exp>>;
  _not?: InputMaybe<Armovedetailshistory_Bool_Exp>;
  _or?: InputMaybe<Array<Armovedetailshistory_Bool_Exp>>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  armovehistory_id?: InputMaybe<Bigint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  document_reference_id?: InputMaybe<Uuid_Comparison_Exp>;
  documents?: InputMaybe<Documents_Bool_Exp>;
  documents_aggregate?: InputMaybe<Documents_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  parent?: InputMaybe<Armoveshistory_Bool_Exp>;
  rate_source?: InputMaybe<String_Comparison_Exp>;
  raterule?: InputMaybe<Raterules_Bool_Exp>;
  raterule_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "armovedetailshistory" */
export enum Armovedetailshistory_Constraint {
  /** unique or primary key constraint on columns "id" */
  ArmovedetailshistoryPkey = 'armovedetailshistory_pkey'
}

/** input type for incrementing numeric columns in table "armovedetailshistory" */
export type Armovedetailshistory_Inc_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "armovedetailshistory" */
export type Armovedetailshistory_Insert_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Scalars['bigint']['input']>;
  /** timestamp the armovedetailshistory was created */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  documents?: InputMaybe<Documents_Arr_Rel_Insert_Input>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Scalars['String']['input']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<Armoveshistory_Obj_Rel_Insert_Input>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Scalars['String']['input']>;
  raterule?: InputMaybe<Raterules_Obj_Rel_Insert_Input>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Armovedetailshistory_Max_Fields = {
  __typename?: 'armovedetailshistory_max_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['bigint']['output']>;
  /** timestamp the armovedetailshistory was created */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: Maybe<Scalars['String']['output']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: Maybe<Scalars['String']['output']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: Maybe<Scalars['String']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Max_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** timestamp the armovedetailshistory was created */
  createdat?: InputMaybe<Order_By>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Order_By>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Order_By>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Armovedetailshistory_Min_Fields = {
  __typename?: 'armovedetailshistory_min_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['bigint']['output']>;
  /** timestamp the armovedetailshistory was created */
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: Maybe<Scalars['String']['output']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: Maybe<Scalars['String']['output']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: Maybe<Scalars['String']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Min_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** timestamp the armovedetailshistory was created */
  createdat?: InputMaybe<Order_By>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Order_By>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Order_By>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "armovedetailshistory" */
export type Armovedetailshistory_Mutation_Response = {
  __typename?: 'armovedetailshistory_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Armovedetailshistory>;
};

/** on_conflict condition type for table "armovedetailshistory" */
export type Armovedetailshistory_On_Conflict = {
  constraint: Armovedetailshistory_Constraint;
  update_columns?: Array<Armovedetailshistory_Update_Column>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};

/** Ordering options when selecting data from "armovedetailshistory". */
export type Armovedetailshistory_Order_By = {
  amount?: InputMaybe<Order_By>;
  armovehistory_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  document_reference_id?: InputMaybe<Order_By>;
  documents_aggregate?: InputMaybe<Documents_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  parent?: InputMaybe<Armoveshistory_Order_By>;
  rate_source?: InputMaybe<Order_By>;
  raterule?: InputMaybe<Raterules_Order_By>;
  raterule_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: armovedetailshistory */
export type Armovedetailshistory_Pk_Columns_Input = {
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id: Scalars['bigint']['input'];
};

/** select columns of table "armovedetailshistory" */
export enum Armovedetailshistory_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ArmovehistoryId = 'armovehistory_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  RateSource = 'rate_source',
  /** column name */
  RateruleId = 'raterule_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "armovedetailshistory" */
export type Armovedetailshistory_Set_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Scalars['bigint']['input']>;
  /** timestamp the armovedetailshistory was created */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Scalars['String']['input']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Scalars['String']['input']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Armovedetailshistory_Stddev_Fields = {
  __typename?: 'armovedetailshistory_stddev_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Stddev_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Armovedetailshistory_Stddev_Pop_Fields = {
  __typename?: 'armovedetailshistory_stddev_pop_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Stddev_Pop_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Armovedetailshistory_Stddev_Samp_Fields = {
  __typename?: 'armovedetailshistory_stddev_samp_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Stddev_Samp_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "armovedetailshistory" */
export type Armovedetailshistory_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Armovedetailshistory_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Armovedetailshistory_Stream_Cursor_Value_Input = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Scalars['bigint']['input']>;
  /** timestamp the armovedetailshistory was created */
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If this armovehistory has associated documents, the document(s) reference id is added here. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** name of the charge to be shown to the customer when viewing the details behind the due_amount of a armoves record */
  name?: InputMaybe<Scalars['String']['input']>;
  /** string written by the AR engine when the detail record was added to the move to provide an explanation for why it was added */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** String with hyphen representing the rate type used to calculate amount (e.g. "class-3-rate") */
  rate_source?: InputMaybe<Scalars['String']['input']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Scalars['bigint']['input']>;
  /** timestamp the armovedetailshistory was updated */
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Armovedetailshistory_Sum_Fields = {
  __typename?: 'armovedetailshistory_sum_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['bigint']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Sum_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** update columns of table "armovedetailshistory" */
export enum Armovedetailshistory_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ArmovehistoryId = 'armovehistory_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  RateSource = 'rate_source',
  /** column name */
  RateruleId = 'raterule_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Armovedetailshistory_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Armovedetailshistory_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Armovedetailshistory_Set_Input>;
  /** filter the rows which have to be updated */
  where: Armovedetailshistory_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Armovedetailshistory_Var_Pop_Fields = {
  __typename?: 'armovedetailshistory_var_pop_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Var_Pop_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Armovedetailshistory_Var_Samp_Fields = {
  __typename?: 'armovedetailshistory_var_samp_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Var_Samp_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Armovedetailshistory_Variance_Fields = {
  __typename?: 'armovedetailshistory_variance_fields';
  /** monetary amount charged for the services represented by the row */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: Maybe<Scalars['Float']['output']>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "armovedetailshistory" */
export type Armovedetailshistory_Variance_Order_By = {
  /** monetary amount charged for the services represented by the row */
  amount?: InputMaybe<Order_By>;
  /** Foreign key to the armoveshistory table. This field is used to link the current record to a specific armovehistory. The value of this field references a valid ID of an armovehistory in the armoveshistory table. */
  armovehistory_id?: InputMaybe<Order_By>;
  /** Primary key for the armovedetailshistory table. This field is a unique integer value that is assigned to each record when it is created. It is used to uniquely identify each record in the armovedetailshistory table and to link records in different tables. */
  id?: InputMaybe<Order_By>;
  /** Relates armove detail row with the rate rule used to calculate its amount */
  raterule_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "armoves" */
export type Armoves = {
  __typename?: 'armoves';
  accounting_item_id?: Maybe<Scalars['String']['output']>;
  active: Scalars['smallint']['output'];
  arevent_id: Scalars['String']['output'];
  author: Scalars['String']['output'];
  billable_datetime: Scalars['timestamptz']['output'];
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  details: Array<Armovedetails>;
  /** An aggregate relationship */
  details_aggregate: Armovedetails_Aggregate;
  discount_amount: Scalars['numeric']['output'];
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  disputed: Scalars['Boolean']['output'];
  due_amount: Scalars['numeric']['output'];
  /** An array relationship */
  eventsByEventId: Array<Arevents>;
  /** An aggregate relationship */
  eventsByEventId_aggregate: Arevents_Aggregate;
  /** An array relationship */
  eventsByMove: Array<Arevents>;
  /** An aggregate relationship */
  eventsByMove_aggregate: Arevents_Aggregate;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  invoice: Arinvoices;
  invoice_id: Scalars['bigint']['output'];
  /** An object relationship */
  move?: Maybe<Moves>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  notes: Scalars['String']['output'];
  paid_amount: Scalars['numeric']['output'];
  /** An array relationship */
  payments: Array<Arpaymentdetails>;
  /** An array relationship */
  paymentsByInvoice: Array<Arpayments>;
  /** An aggregate relationship */
  paymentsByInvoice_aggregate: Arpayments_Aggregate;
  /** An aggregate relationship */
  payments_aggregate: Arpaymentdetails_Aggregate;
  /** An array relationship */
  revisions: Array<Armoveshistory>;
  /** An aggregate relationship */
  revisions_aggregate: Armoveshistory_Aggregate;
  source_event_id?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "armoves" */
export type ArmovesDetailsArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesDetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesEventsByEventIdArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesEventsByEventId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesEventsByMoveArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesEventsByMove_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesPaymentsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesPaymentsByInvoiceArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesPaymentsByInvoice_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesPayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesRevisionsArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


/** columns and relationships of "armoves" */
export type ArmovesRevisions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};

/** aggregated selection of "armoves" */
export type Armoves_Aggregate = {
  __typename?: 'armoves_aggregate';
  aggregate?: Maybe<Armoves_Aggregate_Fields>;
  nodes: Array<Armoves>;
};

export type Armoves_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Armoves_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Armoves_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Armoves_Aggregate_Bool_Exp_Count>;
};

export type Armoves_Aggregate_Bool_Exp_Bool_And = {
  arguments: Armoves_Select_Column_Armoves_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armoves_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Armoves_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Armoves_Select_Column_Armoves_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armoves_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Armoves_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Armoves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armoves_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "armoves" */
export type Armoves_Aggregate_Fields = {
  __typename?: 'armoves_aggregate_fields';
  avg?: Maybe<Armoves_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Armoves_Max_Fields>;
  min?: Maybe<Armoves_Min_Fields>;
  stddev?: Maybe<Armoves_Stddev_Fields>;
  stddev_pop?: Maybe<Armoves_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Armoves_Stddev_Samp_Fields>;
  sum?: Maybe<Armoves_Sum_Fields>;
  var_pop?: Maybe<Armoves_Var_Pop_Fields>;
  var_samp?: Maybe<Armoves_Var_Samp_Fields>;
  variance?: Maybe<Armoves_Variance_Fields>;
};


/** aggregate fields of "armoves" */
export type Armoves_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Armoves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "armoves" */
export type Armoves_Aggregate_Order_By = {
  avg?: InputMaybe<Armoves_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Armoves_Max_Order_By>;
  min?: InputMaybe<Armoves_Min_Order_By>;
  stddev?: InputMaybe<Armoves_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Armoves_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Armoves_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Armoves_Sum_Order_By>;
  var_pop?: InputMaybe<Armoves_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Armoves_Var_Samp_Order_By>;
  variance?: InputMaybe<Armoves_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "armoves" */
export type Armoves_Arr_Rel_Insert_Input = {
  data: Array<Armoves_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Armoves_On_Conflict>;
};

/** aggregate avg on columns */
export type Armoves_Avg_Fields = {
  __typename?: 'armoves_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "armoves" */
export type Armoves_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "armoves". All fields are combined with a logical 'AND'. */
export type Armoves_Bool_Exp = {
  _and?: InputMaybe<Array<Armoves_Bool_Exp>>;
  _not?: InputMaybe<Armoves_Bool_Exp>;
  _or?: InputMaybe<Array<Armoves_Bool_Exp>>;
  accounting_item_id?: InputMaybe<String_Comparison_Exp>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  arevent_id?: InputMaybe<String_Comparison_Exp>;
  author?: InputMaybe<String_Comparison_Exp>;
  billable_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  details?: InputMaybe<Armovedetails_Bool_Exp>;
  details_aggregate?: InputMaybe<Armovedetails_Aggregate_Bool_Exp>;
  discount_amount?: InputMaybe<Numeric_Comparison_Exp>;
  discount_reason?: InputMaybe<String_Comparison_Exp>;
  dispute_reason?: InputMaybe<String_Comparison_Exp>;
  disputed?: InputMaybe<Boolean_Comparison_Exp>;
  due_amount?: InputMaybe<Numeric_Comparison_Exp>;
  eventsByEventId?: InputMaybe<Arevents_Bool_Exp>;
  eventsByEventId_aggregate?: InputMaybe<Arevents_Aggregate_Bool_Exp>;
  eventsByMove?: InputMaybe<Arevents_Bool_Exp>;
  eventsByMove_aggregate?: InputMaybe<Arevents_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  invoice?: InputMaybe<Arinvoices_Bool_Exp>;
  invoice_id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  paid_amount?: InputMaybe<Numeric_Comparison_Exp>;
  payments?: InputMaybe<Arpaymentdetails_Bool_Exp>;
  paymentsByInvoice?: InputMaybe<Arpayments_Bool_Exp>;
  paymentsByInvoice_aggregate?: InputMaybe<Arpayments_Aggregate_Bool_Exp>;
  payments_aggregate?: InputMaybe<Arpaymentdetails_Aggregate_Bool_Exp>;
  revisions?: InputMaybe<Armoveshistory_Bool_Exp>;
  revisions_aggregate?: InputMaybe<Armoveshistory_Aggregate_Bool_Exp>;
  source_event_id?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "armoves" */
export enum Armoves_Constraint {
  /** unique or primary key constraint on columns "move_id" */
  ArmovesMoveIdKey = 'armoves_move_id_key',
  /** unique or primary key constraint on columns "id" */
  ArmovesPkey = 'armoves_pkey'
}

/** input type for incrementing numeric columns in table "armoves" */
export type Armoves_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "armoves" */
export type Armoves_Insert_Input = {
  accounting_item_id?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  billable_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  details?: InputMaybe<Armovedetails_Arr_Rel_Insert_Input>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  eventsByEventId?: InputMaybe<Arevents_Arr_Rel_Insert_Input>;
  eventsByMove?: InputMaybe<Arevents_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice?: InputMaybe<Arinvoices_Obj_Rel_Insert_Input>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  payments?: InputMaybe<Arpaymentdetails_Arr_Rel_Insert_Input>;
  paymentsByInvoice?: InputMaybe<Arpayments_Arr_Rel_Insert_Input>;
  revisions?: InputMaybe<Armoveshistory_Arr_Rel_Insert_Input>;
  source_event_id?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Armoves_Max_Fields = {
  __typename?: 'armoves_max_fields';
  accounting_item_id?: Maybe<Scalars['String']['output']>;
  active?: Maybe<Scalars['smallint']['output']>;
  arevent_id?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  billable_datetime?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  due_amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paid_amount?: Maybe<Scalars['numeric']['output']>;
  source_event_id?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "armoves" */
export type Armoves_Max_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  billable_datetime?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  source_event_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Armoves_Min_Fields = {
  __typename?: 'armoves_min_fields';
  accounting_item_id?: Maybe<Scalars['String']['output']>;
  active?: Maybe<Scalars['smallint']['output']>;
  arevent_id?: Maybe<Scalars['String']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  billable_datetime?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  due_amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paid_amount?: Maybe<Scalars['numeric']['output']>;
  source_event_id?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "armoves" */
export type Armoves_Min_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  billable_datetime?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  source_event_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "armoves" */
export type Armoves_Mutation_Response = {
  __typename?: 'armoves_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Armoves>;
};

/** input type for inserting object relation for remote table "armoves" */
export type Armoves_Obj_Rel_Insert_Input = {
  data: Armoves_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Armoves_On_Conflict>;
};

/** on_conflict condition type for table "armoves" */
export type Armoves_On_Conflict = {
  constraint: Armoves_Constraint;
  update_columns?: Array<Armoves_Update_Column>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};

/** Ordering options when selecting data from "armoves". */
export type Armoves_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  billable_datetime?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  details_aggregate?: InputMaybe<Armovedetails_Aggregate_Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  disputed?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  eventsByEventId_aggregate?: InputMaybe<Arevents_Aggregate_Order_By>;
  eventsByMove_aggregate?: InputMaybe<Arevents_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  invoice?: InputMaybe<Arinvoices_Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  paymentsByInvoice_aggregate?: InputMaybe<Arpayments_Aggregate_Order_By>;
  payments_aggregate?: InputMaybe<Arpaymentdetails_Aggregate_Order_By>;
  revisions_aggregate?: InputMaybe<Armoveshistory_Aggregate_Order_By>;
  source_event_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: armoves */
export type Armoves_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "armoves" */
export enum Armoves_Select_Column {
  /** column name */
  AccountingItemId = 'accounting_item_id',
  /** column name */
  Active = 'active',
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  Author = 'author',
  /** column name */
  BillableDatetime = 'billable_datetime',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DueAmount = 'due_amount',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PaidAmount = 'paid_amount',
  /** column name */
  SourceEventId = 'source_event_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** select "armoves_aggregate_bool_exp_bool_and_arguments_columns" columns of table "armoves" */
export enum Armoves_Select_Column_Armoves_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Disputed = 'disputed'
}

/** select "armoves_aggregate_bool_exp_bool_or_arguments_columns" columns of table "armoves" */
export enum Armoves_Select_Column_Armoves_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Disputed = 'disputed'
}

/** input type for updating data in table "armoves" */
export type Armoves_Set_Input = {
  accounting_item_id?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  billable_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  source_event_id?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Armoves_Stddev_Fields = {
  __typename?: 'armoves_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "armoves" */
export type Armoves_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Armoves_Stddev_Pop_Fields = {
  __typename?: 'armoves_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "armoves" */
export type Armoves_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Armoves_Stddev_Samp_Fields = {
  __typename?: 'armoves_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "armoves" */
export type Armoves_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "armoves" */
export type Armoves_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Armoves_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Armoves_Stream_Cursor_Value_Input = {
  accounting_item_id?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  billable_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  source_event_id?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** Armoves do not only represent only moves- they are a record of an product we charge to a customer. Along with "move" type armoves there are also "fee" (e.g. credit card processing fee); "prepaid" (prepaid move packages);   "one-time" and scheduled charge that happens once per customer, such as an onboarding fee) and "products" generic type for other services charged to customers such as appraisal or white labeling services */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Armoves_Sum_Fields = {
  __typename?: 'armoves_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  due_amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  paid_amount?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "armoves" */
export type Armoves_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** update columns of table "armoves" */
export enum Armoves_Update_Column {
  /** column name */
  AccountingItemId = 'accounting_item_id',
  /** column name */
  Active = 'active',
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  Author = 'author',
  /** column name */
  BillableDatetime = 'billable_datetime',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DueAmount = 'due_amount',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PaidAmount = 'paid_amount',
  /** column name */
  SourceEventId = 'source_event_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Armoves_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Armoves_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Armoves_Set_Input>;
  /** filter the rows which have to be updated */
  where: Armoves_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Armoves_Var_Pop_Fields = {
  __typename?: 'armoves_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "armoves" */
export type Armoves_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Armoves_Var_Samp_Fields = {
  __typename?: 'armoves_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "armoves" */
export type Armoves_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Armoves_Variance_Fields = {
  __typename?: 'armoves_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "armoves" */
export type Armoves_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
};

/** columns and relationships of "armoveshistory" */
export type Armoveshistory = {
  __typename?: 'armoveshistory';
  accounting_item_id?: Maybe<Scalars['numeric']['output']>;
  arevent_id: Scalars['String']['output'];
  /** An object relationship */
  armove?: Maybe<Armoves>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  author: Scalars['String']['output'];
  billable_datetime: Scalars['timestamptz']['output'];
  createdat: Scalars['timestamptz']['output'];
  /** An array relationship */
  details: Array<Armovedetailshistory>;
  /** An aggregate relationship */
  details_aggregate: Armovedetailshistory_Aggregate;
  discount_amount: Scalars['numeric']['output'];
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  disputed: Scalars['Boolean']['output'];
  due_amount: Scalars['numeric']['output'];
  id: Scalars['bigint']['output'];
  invoice_id: Scalars['bigint']['output'];
  /** An object relationship */
  move: Moves;
  move_id: Scalars['bigint']['output'];
  notes: Scalars['String']['output'];
  paid_amount: Scalars['numeric']['output'];
  revision: Scalars['smallint']['output'];
  status: Scalars['String']['output'];
  type: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
};


/** columns and relationships of "armoveshistory" */
export type ArmoveshistoryDetailsArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


/** columns and relationships of "armoveshistory" */
export type ArmoveshistoryDetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};

/** aggregated selection of "armoveshistory" */
export type Armoveshistory_Aggregate = {
  __typename?: 'armoveshistory_aggregate';
  aggregate?: Maybe<Armoveshistory_Aggregate_Fields>;
  nodes: Array<Armoveshistory>;
};

export type Armoveshistory_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Armoveshistory_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Armoveshistory_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Armoveshistory_Aggregate_Bool_Exp_Count>;
};

export type Armoveshistory_Aggregate_Bool_Exp_Bool_And = {
  arguments: Armoveshistory_Select_Column_Armoveshistory_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armoveshistory_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Armoveshistory_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Armoveshistory_Select_Column_Armoveshistory_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armoveshistory_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Armoveshistory_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Armoveshistory_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "armoveshistory" */
export type Armoveshistory_Aggregate_Fields = {
  __typename?: 'armoveshistory_aggregate_fields';
  avg?: Maybe<Armoveshistory_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Armoveshistory_Max_Fields>;
  min?: Maybe<Armoveshistory_Min_Fields>;
  stddev?: Maybe<Armoveshistory_Stddev_Fields>;
  stddev_pop?: Maybe<Armoveshistory_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Armoveshistory_Stddev_Samp_Fields>;
  sum?: Maybe<Armoveshistory_Sum_Fields>;
  var_pop?: Maybe<Armoveshistory_Var_Pop_Fields>;
  var_samp?: Maybe<Armoveshistory_Var_Samp_Fields>;
  variance?: Maybe<Armoveshistory_Variance_Fields>;
};


/** aggregate fields of "armoveshistory" */
export type Armoveshistory_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "armoveshistory" */
export type Armoveshistory_Aggregate_Order_By = {
  avg?: InputMaybe<Armoveshistory_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Armoveshistory_Max_Order_By>;
  min?: InputMaybe<Armoveshistory_Min_Order_By>;
  stddev?: InputMaybe<Armoveshistory_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Armoveshistory_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Armoveshistory_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Armoveshistory_Sum_Order_By>;
  var_pop?: InputMaybe<Armoveshistory_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Armoveshistory_Var_Samp_Order_By>;
  variance?: InputMaybe<Armoveshistory_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "armoveshistory" */
export type Armoveshistory_Arr_Rel_Insert_Input = {
  data: Array<Armoveshistory_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Armoveshistory_On_Conflict>;
};

/** aggregate avg on columns */
export type Armoveshistory_Avg_Fields = {
  __typename?: 'armoveshistory_avg_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "armoveshistory" */
export type Armoveshistory_Avg_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "armoveshistory". All fields are combined with a logical 'AND'. */
export type Armoveshistory_Bool_Exp = {
  _and?: InputMaybe<Array<Armoveshistory_Bool_Exp>>;
  _not?: InputMaybe<Armoveshistory_Bool_Exp>;
  _or?: InputMaybe<Array<Armoveshistory_Bool_Exp>>;
  accounting_item_id?: InputMaybe<Numeric_Comparison_Exp>;
  arevent_id?: InputMaybe<String_Comparison_Exp>;
  armove?: InputMaybe<Armoves_Bool_Exp>;
  armove_id?: InputMaybe<Bigint_Comparison_Exp>;
  author?: InputMaybe<String_Comparison_Exp>;
  billable_datetime?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  details?: InputMaybe<Armovedetailshistory_Bool_Exp>;
  details_aggregate?: InputMaybe<Armovedetailshistory_Aggregate_Bool_Exp>;
  discount_amount?: InputMaybe<Numeric_Comparison_Exp>;
  discount_reason?: InputMaybe<String_Comparison_Exp>;
  dispute_reason?: InputMaybe<String_Comparison_Exp>;
  disputed?: InputMaybe<Boolean_Comparison_Exp>;
  due_amount?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  invoice_id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  paid_amount?: InputMaybe<Numeric_Comparison_Exp>;
  revision?: InputMaybe<Smallint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "armoveshistory" */
export enum Armoveshistory_Constraint {
  /** unique or primary key constraint on columns "revision", "armove_id" */
  ArmoveshistoryArmoveIdRevisionKey = 'armoveshistory_armove_id_revision_key',
  /** unique or primary key constraint on columns "id" */
  ArmoveshistoryPkey = 'armoveshistory_pkey'
}

/** input type for incrementing numeric columns in table "armoveshistory" */
export type Armoveshistory_Inc_Input = {
  accounting_item_id?: InputMaybe<Scalars['numeric']['input']>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  revision?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "armoveshistory" */
export type Armoveshistory_Insert_Input = {
  accounting_item_id?: InputMaybe<Scalars['numeric']['input']>;
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  armove?: InputMaybe<Armoves_Obj_Rel_Insert_Input>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  billable_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  details?: InputMaybe<Armovedetailshistory_Arr_Rel_Insert_Input>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  revision?: InputMaybe<Scalars['smallint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Armoveshistory_Max_Fields = {
  __typename?: 'armoveshistory_max_fields';
  accounting_item_id?: Maybe<Scalars['numeric']['output']>;
  arevent_id?: Maybe<Scalars['String']['output']>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  billable_datetime?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  due_amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paid_amount?: Maybe<Scalars['numeric']['output']>;
  revision?: Maybe<Scalars['smallint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "armoveshistory" */
export type Armoveshistory_Max_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  billable_datetime?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Armoveshistory_Min_Fields = {
  __typename?: 'armoveshistory_min_fields';
  accounting_item_id?: Maybe<Scalars['numeric']['output']>;
  arevent_id?: Maybe<Scalars['String']['output']>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  author?: Maybe<Scalars['String']['output']>;
  billable_datetime?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  due_amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paid_amount?: Maybe<Scalars['numeric']['output']>;
  revision?: Maybe<Scalars['smallint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "armoveshistory" */
export type Armoveshistory_Min_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  billable_datetime?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "armoveshistory" */
export type Armoveshistory_Mutation_Response = {
  __typename?: 'armoveshistory_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Armoveshistory>;
};

/** input type for inserting object relation for remote table "armoveshistory" */
export type Armoveshistory_Obj_Rel_Insert_Input = {
  data: Armoveshistory_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Armoveshistory_On_Conflict>;
};

/** on_conflict condition type for table "armoveshistory" */
export type Armoveshistory_On_Conflict = {
  constraint: Armoveshistory_Constraint;
  update_columns?: Array<Armoveshistory_Update_Column>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};

/** Ordering options when selecting data from "armoveshistory". */
export type Armoveshistory_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  arevent_id?: InputMaybe<Order_By>;
  armove?: InputMaybe<Armoves_Order_By>;
  armove_id?: InputMaybe<Order_By>;
  author?: InputMaybe<Order_By>;
  billable_datetime?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  details_aggregate?: InputMaybe<Armovedetailshistory_Aggregate_Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  disputed?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: armoveshistory */
export type Armoveshistory_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "armoveshistory" */
export enum Armoveshistory_Select_Column {
  /** column name */
  AccountingItemId = 'accounting_item_id',
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  ArmoveId = 'armove_id',
  /** column name */
  Author = 'author',
  /** column name */
  BillableDatetime = 'billable_datetime',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DueAmount = 'due_amount',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PaidAmount = 'paid_amount',
  /** column name */
  Revision = 'revision',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** select "armoveshistory_aggregate_bool_exp_bool_and_arguments_columns" columns of table "armoveshistory" */
export enum Armoveshistory_Select_Column_Armoveshistory_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Disputed = 'disputed'
}

/** select "armoveshistory_aggregate_bool_exp_bool_or_arguments_columns" columns of table "armoveshistory" */
export enum Armoveshistory_Select_Column_Armoveshistory_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Disputed = 'disputed'
}

/** input type for updating data in table "armoveshistory" */
export type Armoveshistory_Set_Input = {
  accounting_item_id?: InputMaybe<Scalars['numeric']['input']>;
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  billable_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  revision?: InputMaybe<Scalars['smallint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Armoveshistory_Stddev_Fields = {
  __typename?: 'armoveshistory_stddev_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "armoveshistory" */
export type Armoveshistory_Stddev_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Armoveshistory_Stddev_Pop_Fields = {
  __typename?: 'armoveshistory_stddev_pop_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "armoveshistory" */
export type Armoveshistory_Stddev_Pop_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Armoveshistory_Stddev_Samp_Fields = {
  __typename?: 'armoveshistory_stddev_samp_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "armoveshistory" */
export type Armoveshistory_Stddev_Samp_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "armoveshistory" */
export type Armoveshistory_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Armoveshistory_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Armoveshistory_Stream_Cursor_Value_Input = {
  accounting_item_id?: InputMaybe<Scalars['numeric']['input']>;
  arevent_id?: InputMaybe<Scalars['String']['input']>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  billable_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  due_amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paid_amount?: InputMaybe<Scalars['numeric']['input']>;
  revision?: InputMaybe<Scalars['smallint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Armoveshistory_Sum_Fields = {
  __typename?: 'armoveshistory_sum_fields';
  accounting_item_id?: Maybe<Scalars['numeric']['output']>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  due_amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  paid_amount?: Maybe<Scalars['numeric']['output']>;
  revision?: Maybe<Scalars['smallint']['output']>;
};

/** order by sum() on columns of table "armoveshistory" */
export type Armoveshistory_Sum_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** update columns of table "armoveshistory" */
export enum Armoveshistory_Update_Column {
  /** column name */
  AccountingItemId = 'accounting_item_id',
  /** column name */
  AreventId = 'arevent_id',
  /** column name */
  ArmoveId = 'armove_id',
  /** column name */
  Author = 'author',
  /** column name */
  BillableDatetime = 'billable_datetime',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DueAmount = 'due_amount',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PaidAmount = 'paid_amount',
  /** column name */
  Revision = 'revision',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Armoveshistory_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Armoveshistory_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Armoveshistory_Set_Input>;
  /** filter the rows which have to be updated */
  where: Armoveshistory_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Armoveshistory_Var_Pop_Fields = {
  __typename?: 'armoveshistory_var_pop_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "armoveshistory" */
export type Armoveshistory_Var_Pop_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Armoveshistory_Var_Samp_Fields = {
  __typename?: 'armoveshistory_var_samp_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "armoveshistory" */
export type Armoveshistory_Var_Samp_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Armoveshistory_Variance_Fields = {
  __typename?: 'armoveshistory_variance_fields';
  accounting_item_id?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  due_amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  paid_amount?: Maybe<Scalars['Float']['output']>;
  revision?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "armoveshistory" */
export type Armoveshistory_Variance_Order_By = {
  accounting_item_id?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  due_amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  paid_amount?: InputMaybe<Order_By>;
  revision?: InputMaybe<Order_By>;
};

/** columns and relationships of "arpaymentdetails" */
export type Arpaymentdetails = {
  __typename?: 'arpaymentdetails';
  amount: Scalars['numeric']['output'];
  /** An object relationship */
  armove?: Maybe<Armoves>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  createdat: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** An object relationship */
  parent: Arpayments;
  payment_id: Scalars['bigint']['output'];
  type: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
};

/** aggregated selection of "arpaymentdetails" */
export type Arpaymentdetails_Aggregate = {
  __typename?: 'arpaymentdetails_aggregate';
  aggregate?: Maybe<Arpaymentdetails_Aggregate_Fields>;
  nodes: Array<Arpaymentdetails>;
};

export type Arpaymentdetails_Aggregate_Bool_Exp = {
  count?: InputMaybe<Arpaymentdetails_Aggregate_Bool_Exp_Count>;
};

export type Arpaymentdetails_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arpaymentdetails_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "arpaymentdetails" */
export type Arpaymentdetails_Aggregate_Fields = {
  __typename?: 'arpaymentdetails_aggregate_fields';
  avg?: Maybe<Arpaymentdetails_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arpaymentdetails_Max_Fields>;
  min?: Maybe<Arpaymentdetails_Min_Fields>;
  stddev?: Maybe<Arpaymentdetails_Stddev_Fields>;
  stddev_pop?: Maybe<Arpaymentdetails_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arpaymentdetails_Stddev_Samp_Fields>;
  sum?: Maybe<Arpaymentdetails_Sum_Fields>;
  var_pop?: Maybe<Arpaymentdetails_Var_Pop_Fields>;
  var_samp?: Maybe<Arpaymentdetails_Var_Samp_Fields>;
  variance?: Maybe<Arpaymentdetails_Variance_Fields>;
};


/** aggregate fields of "arpaymentdetails" */
export type Arpaymentdetails_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "arpaymentdetails" */
export type Arpaymentdetails_Aggregate_Order_By = {
  avg?: InputMaybe<Arpaymentdetails_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Arpaymentdetails_Max_Order_By>;
  min?: InputMaybe<Arpaymentdetails_Min_Order_By>;
  stddev?: InputMaybe<Arpaymentdetails_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Arpaymentdetails_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Arpaymentdetails_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Arpaymentdetails_Sum_Order_By>;
  var_pop?: InputMaybe<Arpaymentdetails_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Arpaymentdetails_Var_Samp_Order_By>;
  variance?: InputMaybe<Arpaymentdetails_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "arpaymentdetails" */
export type Arpaymentdetails_Arr_Rel_Insert_Input = {
  data: Array<Arpaymentdetails_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Arpaymentdetails_On_Conflict>;
};

/** aggregate avg on columns */
export type Arpaymentdetails_Avg_Fields = {
  __typename?: 'arpaymentdetails_avg_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Avg_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "arpaymentdetails". All fields are combined with a logical 'AND'. */
export type Arpaymentdetails_Bool_Exp = {
  _and?: InputMaybe<Array<Arpaymentdetails_Bool_Exp>>;
  _not?: InputMaybe<Arpaymentdetails_Bool_Exp>;
  _or?: InputMaybe<Array<Arpaymentdetails_Bool_Exp>>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  armove?: InputMaybe<Armoves_Bool_Exp>;
  armove_id?: InputMaybe<Bigint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  parent?: InputMaybe<Arpayments_Bool_Exp>;
  payment_id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arpaymentdetails" */
export enum Arpaymentdetails_Constraint {
  /** unique or primary key constraint on columns "id" */
  ArpaymentdetailsPkey = 'arpaymentdetails_pkey'
}

/** input type for incrementing numeric columns in table "arpaymentdetails" */
export type Arpaymentdetails_Inc_Input = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  payment_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "arpaymentdetails" */
export type Arpaymentdetails_Insert_Input = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  armove?: InputMaybe<Armoves_Obj_Rel_Insert_Input>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  parent?: InputMaybe<Arpayments_Obj_Rel_Insert_Input>;
  payment_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arpaymentdetails_Max_Fields = {
  __typename?: 'arpaymentdetails_max_fields';
  amount?: Maybe<Scalars['numeric']['output']>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  payment_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Max_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Arpaymentdetails_Min_Fields = {
  __typename?: 'arpaymentdetails_min_fields';
  amount?: Maybe<Scalars['numeric']['output']>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  payment_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Min_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "arpaymentdetails" */
export type Arpaymentdetails_Mutation_Response = {
  __typename?: 'arpaymentdetails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arpaymentdetails>;
};

/** on_conflict condition type for table "arpaymentdetails" */
export type Arpaymentdetails_On_Conflict = {
  constraint: Arpaymentdetails_Constraint;
  update_columns?: Array<Arpaymentdetails_Update_Column>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};

/** Ordering options when selecting data from "arpaymentdetails". */
export type Arpaymentdetails_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove?: InputMaybe<Armoves_Order_By>;
  armove_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parent?: InputMaybe<Arpayments_Order_By>;
  payment_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arpaymentdetails */
export type Arpaymentdetails_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "arpaymentdetails" */
export enum Arpaymentdetails_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ArmoveId = 'armove_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Id = 'id',
  /** column name */
  PaymentId = 'payment_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "arpaymentdetails" */
export type Arpaymentdetails_Set_Input = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  payment_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arpaymentdetails_Stddev_Fields = {
  __typename?: 'arpaymentdetails_stddev_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Stddev_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Arpaymentdetails_Stddev_Pop_Fields = {
  __typename?: 'arpaymentdetails_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Stddev_Pop_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Arpaymentdetails_Stddev_Samp_Fields = {
  __typename?: 'arpaymentdetails_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Stddev_Samp_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "arpaymentdetails" */
export type Arpaymentdetails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arpaymentdetails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arpaymentdetails_Stream_Cursor_Value_Input = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  armove_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  payment_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arpaymentdetails_Sum_Fields = {
  __typename?: 'arpaymentdetails_sum_fields';
  amount?: Maybe<Scalars['numeric']['output']>;
  armove_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  payment_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Sum_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** update columns of table "arpaymentdetails" */
export enum Arpaymentdetails_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ArmoveId = 'armove_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Id = 'id',
  /** column name */
  PaymentId = 'payment_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Arpaymentdetails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arpaymentdetails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arpaymentdetails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arpaymentdetails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arpaymentdetails_Var_Pop_Fields = {
  __typename?: 'arpaymentdetails_var_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Var_Pop_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Arpaymentdetails_Var_Samp_Fields = {
  __typename?: 'arpaymentdetails_var_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Var_Samp_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Arpaymentdetails_Variance_Fields = {
  __typename?: 'arpaymentdetails_variance_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  armove_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  payment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "arpaymentdetails" */
export type Arpaymentdetails_Variance_Order_By = {
  amount?: InputMaybe<Order_By>;
  armove_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payment_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "arpaymentmethods" */
export type Arpaymentmethods = {
  __typename?: 'arpaymentmethods';
  account_number: Scalars['bigint']['output'];
  account_type?: Maybe<Scalars['String']['output']>;
  active: Scalars['Boolean']['output'];
  card_type?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer: Customers;
  customer_id: Scalars['bigint']['output'];
  expiration?: Maybe<Scalars['smallint']['output']>;
  gateway_token: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  name: Scalars['String']['output'];
  primary: Scalars['Boolean']['output'];
  routing_number?: Maybe<Scalars['bigint']['output']>;
  source: Scalars['String']['output'];
  type: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "arpaymentmethods" */
export type Arpaymentmethods_Aggregate = {
  __typename?: 'arpaymentmethods_aggregate';
  aggregate?: Maybe<Arpaymentmethods_Aggregate_Fields>;
  nodes: Array<Arpaymentmethods>;
};

export type Arpaymentmethods_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Arpaymentmethods_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Arpaymentmethods_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Arpaymentmethods_Aggregate_Bool_Exp_Count>;
};

export type Arpaymentmethods_Aggregate_Bool_Exp_Bool_And = {
  arguments: Arpaymentmethods_Select_Column_Arpaymentmethods_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arpaymentmethods_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Arpaymentmethods_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Arpaymentmethods_Select_Column_Arpaymentmethods_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arpaymentmethods_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Arpaymentmethods_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arpaymentmethods_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "arpaymentmethods" */
export type Arpaymentmethods_Aggregate_Fields = {
  __typename?: 'arpaymentmethods_aggregate_fields';
  avg?: Maybe<Arpaymentmethods_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arpaymentmethods_Max_Fields>;
  min?: Maybe<Arpaymentmethods_Min_Fields>;
  stddev?: Maybe<Arpaymentmethods_Stddev_Fields>;
  stddev_pop?: Maybe<Arpaymentmethods_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arpaymentmethods_Stddev_Samp_Fields>;
  sum?: Maybe<Arpaymentmethods_Sum_Fields>;
  var_pop?: Maybe<Arpaymentmethods_Var_Pop_Fields>;
  var_samp?: Maybe<Arpaymentmethods_Var_Samp_Fields>;
  variance?: Maybe<Arpaymentmethods_Variance_Fields>;
};


/** aggregate fields of "arpaymentmethods" */
export type Arpaymentmethods_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "arpaymentmethods" */
export type Arpaymentmethods_Aggregate_Order_By = {
  avg?: InputMaybe<Arpaymentmethods_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Arpaymentmethods_Max_Order_By>;
  min?: InputMaybe<Arpaymentmethods_Min_Order_By>;
  stddev?: InputMaybe<Arpaymentmethods_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Arpaymentmethods_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Arpaymentmethods_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Arpaymentmethods_Sum_Order_By>;
  var_pop?: InputMaybe<Arpaymentmethods_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Arpaymentmethods_Var_Samp_Order_By>;
  variance?: InputMaybe<Arpaymentmethods_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "arpaymentmethods" */
export type Arpaymentmethods_Arr_Rel_Insert_Input = {
  data: Array<Arpaymentmethods_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Arpaymentmethods_On_Conflict>;
};

/** aggregate avg on columns */
export type Arpaymentmethods_Avg_Fields = {
  __typename?: 'arpaymentmethods_avg_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Avg_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "arpaymentmethods". All fields are combined with a logical 'AND'. */
export type Arpaymentmethods_Bool_Exp = {
  _and?: InputMaybe<Array<Arpaymentmethods_Bool_Exp>>;
  _not?: InputMaybe<Arpaymentmethods_Bool_Exp>;
  _or?: InputMaybe<Array<Arpaymentmethods_Bool_Exp>>;
  account_number?: InputMaybe<Bigint_Comparison_Exp>;
  account_type?: InputMaybe<String_Comparison_Exp>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  card_type?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  expiration?: InputMaybe<Smallint_Comparison_Exp>;
  gateway_token?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  primary?: InputMaybe<Boolean_Comparison_Exp>;
  routing_number?: InputMaybe<Bigint_Comparison_Exp>;
  source?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arpaymentmethods" */
export enum Arpaymentmethods_Constraint {
  /** unique or primary key constraint on columns "id" */
  ArpaymentmethodsPkey = 'arpaymentmethods_pkey'
}

/** input type for incrementing numeric columns in table "arpaymentmethods" */
export type Arpaymentmethods_Inc_Input = {
  account_number?: InputMaybe<Scalars['bigint']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  routing_number?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "arpaymentmethods" */
export type Arpaymentmethods_Insert_Input = {
  account_number?: InputMaybe<Scalars['bigint']['input']>;
  account_type?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_type?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration?: InputMaybe<Scalars['smallint']['input']>;
  gateway_token?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  routing_number?: InputMaybe<Scalars['bigint']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arpaymentmethods_Max_Fields = {
  __typename?: 'arpaymentmethods_max_fields';
  account_number?: Maybe<Scalars['bigint']['output']>;
  account_type?: Maybe<Scalars['String']['output']>;
  card_type?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  expiration?: Maybe<Scalars['smallint']['output']>;
  gateway_token?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  routing_number?: Maybe<Scalars['bigint']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Max_Order_By = {
  account_number?: InputMaybe<Order_By>;
  account_type?: InputMaybe<Order_By>;
  card_type?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  gateway_token?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
  source?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Arpaymentmethods_Min_Fields = {
  __typename?: 'arpaymentmethods_min_fields';
  account_number?: Maybe<Scalars['bigint']['output']>;
  account_type?: Maybe<Scalars['String']['output']>;
  card_type?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  expiration?: Maybe<Scalars['smallint']['output']>;
  gateway_token?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  routing_number?: Maybe<Scalars['bigint']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Min_Order_By = {
  account_number?: InputMaybe<Order_By>;
  account_type?: InputMaybe<Order_By>;
  card_type?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  gateway_token?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
  source?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "arpaymentmethods" */
export type Arpaymentmethods_Mutation_Response = {
  __typename?: 'arpaymentmethods_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arpaymentmethods>;
};

/** input type for inserting object relation for remote table "arpaymentmethods" */
export type Arpaymentmethods_Obj_Rel_Insert_Input = {
  data: Arpaymentmethods_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Arpaymentmethods_On_Conflict>;
};

/** on_conflict condition type for table "arpaymentmethods" */
export type Arpaymentmethods_On_Conflict = {
  constraint: Arpaymentmethods_Constraint;
  update_columns?: Array<Arpaymentmethods_Update_Column>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};

/** Ordering options when selecting data from "arpaymentmethods". */
export type Arpaymentmethods_Order_By = {
  account_number?: InputMaybe<Order_By>;
  account_type?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  card_type?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  gateway_token?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  primary?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
  source?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arpaymentmethods */
export type Arpaymentmethods_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "arpaymentmethods" */
export enum Arpaymentmethods_Select_Column {
  /** column name */
  AccountNumber = 'account_number',
  /** column name */
  AccountType = 'account_type',
  /** column name */
  Active = 'active',
  /** column name */
  CardType = 'card_type',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Expiration = 'expiration',
  /** column name */
  GatewayToken = 'gateway_token',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Primary = 'primary',
  /** column name */
  RoutingNumber = 'routing_number',
  /** column name */
  Source = 'source',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** select "arpaymentmethods_aggregate_bool_exp_bool_and_arguments_columns" columns of table "arpaymentmethods" */
export enum Arpaymentmethods_Select_Column_Arpaymentmethods_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active',
  /** column name */
  Primary = 'primary'
}

/** select "arpaymentmethods_aggregate_bool_exp_bool_or_arguments_columns" columns of table "arpaymentmethods" */
export enum Arpaymentmethods_Select_Column_Arpaymentmethods_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active',
  /** column name */
  Primary = 'primary'
}

/** input type for updating data in table "arpaymentmethods" */
export type Arpaymentmethods_Set_Input = {
  account_number?: InputMaybe<Scalars['bigint']['input']>;
  account_type?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_type?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration?: InputMaybe<Scalars['smallint']['input']>;
  gateway_token?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  routing_number?: InputMaybe<Scalars['bigint']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arpaymentmethods_Stddev_Fields = {
  __typename?: 'arpaymentmethods_stddev_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Stddev_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Arpaymentmethods_Stddev_Pop_Fields = {
  __typename?: 'arpaymentmethods_stddev_pop_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Stddev_Pop_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Arpaymentmethods_Stddev_Samp_Fields = {
  __typename?: 'arpaymentmethods_stddev_samp_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Stddev_Samp_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "arpaymentmethods" */
export type Arpaymentmethods_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arpaymentmethods_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arpaymentmethods_Stream_Cursor_Value_Input = {
  account_number?: InputMaybe<Scalars['bigint']['input']>;
  account_type?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_type?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration?: InputMaybe<Scalars['smallint']['input']>;
  gateway_token?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  routing_number?: InputMaybe<Scalars['bigint']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arpaymentmethods_Sum_Fields = {
  __typename?: 'arpaymentmethods_sum_fields';
  account_number?: Maybe<Scalars['bigint']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  expiration?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  routing_number?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Sum_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** update columns of table "arpaymentmethods" */
export enum Arpaymentmethods_Update_Column {
  /** column name */
  AccountNumber = 'account_number',
  /** column name */
  AccountType = 'account_type',
  /** column name */
  Active = 'active',
  /** column name */
  CardType = 'card_type',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Expiration = 'expiration',
  /** column name */
  GatewayToken = 'gateway_token',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Primary = 'primary',
  /** column name */
  RoutingNumber = 'routing_number',
  /** column name */
  Source = 'source',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Arpaymentmethods_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arpaymentmethods_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arpaymentmethods_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arpaymentmethods_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arpaymentmethods_Var_Pop_Fields = {
  __typename?: 'arpaymentmethods_var_pop_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Var_Pop_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Arpaymentmethods_Var_Samp_Fields = {
  __typename?: 'arpaymentmethods_var_samp_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Var_Samp_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Arpaymentmethods_Variance_Fields = {
  __typename?: 'arpaymentmethods_variance_fields';
  account_number?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  expiration?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  routing_number?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "arpaymentmethods" */
export type Arpaymentmethods_Variance_Order_By = {
  account_number?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  routing_number?: InputMaybe<Order_By>;
};

/** columns and relationships of "arpayments" */
export type Arpayments = {
  __typename?: 'arpayments';
  accounting_id?: Maybe<Scalars['String']['output']>;
  amount: Scalars['numeric']['output'];
  /** An object relationship */
  arinvoice?: Maybe<Arinvoices>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  details: Array<Arpaymentdetails>;
  /** An aggregate relationship */
  details_aggregate: Arpaymentdetails_Aggregate;
  failure_reason?: Maybe<Scalars['String']['output']>;
  gateway_transaction_id?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  method: Arpaymentmethods;
  paymentmethod_id: Scalars['bigint']['output'];
  status: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "arpayments" */
export type ArpaymentsDetailsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


/** columns and relationships of "arpayments" */
export type ArpaymentsDetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};

/** aggregated selection of "arpayments" */
export type Arpayments_Aggregate = {
  __typename?: 'arpayments_aggregate';
  aggregate?: Maybe<Arpayments_Aggregate_Fields>;
  nodes: Array<Arpayments>;
};

export type Arpayments_Aggregate_Bool_Exp = {
  count?: InputMaybe<Arpayments_Aggregate_Bool_Exp_Count>;
};

export type Arpayments_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Arpayments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Arpayments_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "arpayments" */
export type Arpayments_Aggregate_Fields = {
  __typename?: 'arpayments_aggregate_fields';
  avg?: Maybe<Arpayments_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arpayments_Max_Fields>;
  min?: Maybe<Arpayments_Min_Fields>;
  stddev?: Maybe<Arpayments_Stddev_Fields>;
  stddev_pop?: Maybe<Arpayments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arpayments_Stddev_Samp_Fields>;
  sum?: Maybe<Arpayments_Sum_Fields>;
  var_pop?: Maybe<Arpayments_Var_Pop_Fields>;
  var_samp?: Maybe<Arpayments_Var_Samp_Fields>;
  variance?: Maybe<Arpayments_Variance_Fields>;
};


/** aggregate fields of "arpayments" */
export type Arpayments_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arpayments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "arpayments" */
export type Arpayments_Aggregate_Order_By = {
  avg?: InputMaybe<Arpayments_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Arpayments_Max_Order_By>;
  min?: InputMaybe<Arpayments_Min_Order_By>;
  stddev?: InputMaybe<Arpayments_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Arpayments_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Arpayments_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Arpayments_Sum_Order_By>;
  var_pop?: InputMaybe<Arpayments_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Arpayments_Var_Samp_Order_By>;
  variance?: InputMaybe<Arpayments_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "arpayments" */
export type Arpayments_Arr_Rel_Insert_Input = {
  data: Array<Arpayments_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Arpayments_On_Conflict>;
};

/** aggregate avg on columns */
export type Arpayments_Avg_Fields = {
  __typename?: 'arpayments_avg_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "arpayments" */
export type Arpayments_Avg_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "arpayments". All fields are combined with a logical 'AND'. */
export type Arpayments_Bool_Exp = {
  _and?: InputMaybe<Array<Arpayments_Bool_Exp>>;
  _not?: InputMaybe<Arpayments_Bool_Exp>;
  _or?: InputMaybe<Array<Arpayments_Bool_Exp>>;
  accounting_id?: InputMaybe<String_Comparison_Exp>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  arinvoice?: InputMaybe<Arinvoices_Bool_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  details?: InputMaybe<Arpaymentdetails_Bool_Exp>;
  details_aggregate?: InputMaybe<Arpaymentdetails_Aggregate_Bool_Exp>;
  failure_reason?: InputMaybe<String_Comparison_Exp>;
  gateway_transaction_id?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  invoice_id?: InputMaybe<Bigint_Comparison_Exp>;
  method?: InputMaybe<Arpaymentmethods_Bool_Exp>;
  paymentmethod_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arpayments" */
export enum Arpayments_Constraint {
  /** unique or primary key constraint on columns "id" */
  ArpaymentsPkey = 'arpayments_pkey'
}

/** input type for incrementing numeric columns in table "arpayments" */
export type Arpayments_Inc_Input = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  paymentmethod_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "arpayments" */
export type Arpayments_Insert_Input = {
  accounting_id?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['numeric']['input']>;
  arinvoice?: InputMaybe<Arinvoices_Obj_Rel_Insert_Input>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  details?: InputMaybe<Arpaymentdetails_Arr_Rel_Insert_Input>;
  failure_reason?: InputMaybe<Scalars['String']['input']>;
  gateway_transaction_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  method?: InputMaybe<Arpaymentmethods_Obj_Rel_Insert_Input>;
  paymentmethod_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arpayments_Max_Fields = {
  __typename?: 'arpayments_max_fields';
  accounting_id?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  failure_reason?: Maybe<Scalars['String']['output']>;
  gateway_transaction_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  paymentmethod_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "arpayments" */
export type Arpayments_Max_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  amount?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  failure_reason?: InputMaybe<Order_By>;
  gateway_transaction_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Arpayments_Min_Fields = {
  __typename?: 'arpayments_min_fields';
  accounting_id?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  failure_reason?: Maybe<Scalars['String']['output']>;
  gateway_transaction_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  paymentmethod_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "arpayments" */
export type Arpayments_Min_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  amount?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  failure_reason?: InputMaybe<Order_By>;
  gateway_transaction_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "arpayments" */
export type Arpayments_Mutation_Response = {
  __typename?: 'arpayments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arpayments>;
};

/** input type for inserting object relation for remote table "arpayments" */
export type Arpayments_Obj_Rel_Insert_Input = {
  data: Arpayments_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Arpayments_On_Conflict>;
};

/** on_conflict condition type for table "arpayments" */
export type Arpayments_On_Conflict = {
  constraint: Arpayments_Constraint;
  update_columns?: Array<Arpayments_Update_Column>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};

/** Ordering options when selecting data from "arpayments". */
export type Arpayments_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  amount?: InputMaybe<Order_By>;
  arinvoice?: InputMaybe<Arinvoices_Order_By>;
  createdat?: InputMaybe<Order_By>;
  details_aggregate?: InputMaybe<Arpaymentdetails_Aggregate_Order_By>;
  failure_reason?: InputMaybe<Order_By>;
  gateway_transaction_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  method?: InputMaybe<Arpaymentmethods_Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arpayments */
export type Arpayments_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "arpayments" */
export enum Arpayments_Select_Column {
  /** column name */
  AccountingId = 'accounting_id',
  /** column name */
  Amount = 'amount',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  FailureReason = 'failure_reason',
  /** column name */
  GatewayTransactionId = 'gateway_transaction_id',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  PaymentmethodId = 'paymentmethod_id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "arpayments" */
export type Arpayments_Set_Input = {
  accounting_id?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  failure_reason?: InputMaybe<Scalars['String']['input']>;
  gateway_transaction_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  paymentmethod_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arpayments_Stddev_Fields = {
  __typename?: 'arpayments_stddev_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "arpayments" */
export type Arpayments_Stddev_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Arpayments_Stddev_Pop_Fields = {
  __typename?: 'arpayments_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "arpayments" */
export type Arpayments_Stddev_Pop_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Arpayments_Stddev_Samp_Fields = {
  __typename?: 'arpayments_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "arpayments" */
export type Arpayments_Stddev_Samp_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "arpayments" */
export type Arpayments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arpayments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arpayments_Stream_Cursor_Value_Input = {
  accounting_id?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  failure_reason?: InputMaybe<Scalars['String']['input']>;
  gateway_transaction_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoice_id?: InputMaybe<Scalars['bigint']['input']>;
  paymentmethod_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arpayments_Sum_Fields = {
  __typename?: 'arpayments_sum_fields';
  amount?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  invoice_id?: Maybe<Scalars['bigint']['output']>;
  paymentmethod_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "arpayments" */
export type Arpayments_Sum_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** update columns of table "arpayments" */
export enum Arpayments_Update_Column {
  /** column name */
  AccountingId = 'accounting_id',
  /** column name */
  Amount = 'amount',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  FailureReason = 'failure_reason',
  /** column name */
  GatewayTransactionId = 'gateway_transaction_id',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  PaymentmethodId = 'paymentmethod_id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

export type Arpayments_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arpayments_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arpayments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arpayments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arpayments_Var_Pop_Fields = {
  __typename?: 'arpayments_var_pop_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "arpayments" */
export type Arpayments_Var_Pop_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Arpayments_Var_Samp_Fields = {
  __typename?: 'arpayments_var_samp_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "arpayments" */
export type Arpayments_Var_Samp_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Arpayments_Variance_Fields = {
  __typename?: 'arpayments_variance_fields';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  invoice_id?: Maybe<Scalars['Float']['output']>;
  paymentmethod_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "arpayments" */
export type Arpayments_Variance_Order_By = {
  amount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invoice_id?: InputMaybe<Order_By>;
  paymentmethod_id?: InputMaybe<Order_By>;
};

/** Contains move level overrides for customer pricing. This table is used for pricing moves through bidding or other alternative methods to the raterule system. If an active override is associated with a move, its transport price will be the "amount" stored in the arpriceoverride instead of being calculated from a raterule. Additional move costs such as accessorials will only be applied to the move if their code is in the "allowed_charges" array property in the "config" column. */
export type Arpriceoverrides = {
  __typename?: 'arpriceoverrides';
  /** Active if true. Record soft delete implementation. */
  active: Scalars['Boolean']['output'];
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: Maybe<Scalars['jsonb']['output']>;
  /** The timestamp with timezone of when the record was created. */
  created_at: Scalars['timestamptz']['output'];
  /** The user email of who created the record. */
  created_by?: Maybe<Scalars['String']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  move?: Maybe<Moves>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** The timestamp with timezone of when the record was last modified. */
  updated_at: Scalars['timestamptz']['output'];
  /** The user email of who last modified the record. */
  updated_by?: Maybe<Scalars['String']['output']>;
};


/** Contains move level overrides for customer pricing. This table is used for pricing moves through bidding or other alternative methods to the raterule system. If an active override is associated with a move, its transport price will be the "amount" stored in the arpriceoverride instead of being calculated from a raterule. Additional move costs such as accessorials will only be applied to the move if their code is in the "allowed_charges" array property in the "config" column. */
export type ArpriceoverridesConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "arpriceoverrides" */
export type Arpriceoverrides_Aggregate = {
  __typename?: 'arpriceoverrides_aggregate';
  aggregate?: Maybe<Arpriceoverrides_Aggregate_Fields>;
  nodes: Array<Arpriceoverrides>;
};

/** aggregate fields of "arpriceoverrides" */
export type Arpriceoverrides_Aggregate_Fields = {
  __typename?: 'arpriceoverrides_aggregate_fields';
  avg?: Maybe<Arpriceoverrides_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arpriceoverrides_Max_Fields>;
  min?: Maybe<Arpriceoverrides_Min_Fields>;
  stddev?: Maybe<Arpriceoverrides_Stddev_Fields>;
  stddev_pop?: Maybe<Arpriceoverrides_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arpriceoverrides_Stddev_Samp_Fields>;
  sum?: Maybe<Arpriceoverrides_Sum_Fields>;
  var_pop?: Maybe<Arpriceoverrides_Var_Pop_Fields>;
  var_samp?: Maybe<Arpriceoverrides_Var_Samp_Fields>;
  variance?: Maybe<Arpriceoverrides_Variance_Fields>;
};


/** aggregate fields of "arpriceoverrides" */
export type Arpriceoverrides_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arpriceoverrides_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Arpriceoverrides_Append_Input = {
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Arpriceoverrides_Avg_Fields = {
  __typename?: 'arpriceoverrides_avg_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "arpriceoverrides". All fields are combined with a logical 'AND'. */
export type Arpriceoverrides_Bool_Exp = {
  _and?: InputMaybe<Array<Arpriceoverrides_Bool_Exp>>;
  _not?: InputMaybe<Arpriceoverrides_Bool_Exp>;
  _or?: InputMaybe<Array<Arpriceoverrides_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "arpriceoverrides" */
export enum Arpriceoverrides_Constraint {
  /** unique or primary key constraint on columns "move_id" */
  ArpriceoverridesMoveIdKey = 'arpriceoverrides_move_id_key',
  /** unique or primary key constraint on columns "id" */
  ArpriceoverridesPkey = 'arpriceoverrides_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Arpriceoverrides_Delete_At_Path_Input = {
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Arpriceoverrides_Delete_Elem_Input = {
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Arpriceoverrides_Delete_Key_Input = {
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "arpriceoverrides" */
export type Arpriceoverrides_Inc_Input = {
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "arpriceoverrides" */
export type Arpriceoverrides_Insert_Input = {
  /** Active if true. Record soft delete implementation. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The timestamp with timezone of when the record was created. */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user email of who created the record. */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The timestamp with timezone of when the record was last modified. */
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user email of who last modified the record. */
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Arpriceoverrides_Max_Fields = {
  __typename?: 'arpriceoverrides_max_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** The timestamp with timezone of when the record was created. */
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** The user email of who created the record. */
  created_by?: Maybe<Scalars['String']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** The timestamp with timezone of when the record was last modified. */
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** The user email of who last modified the record. */
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Arpriceoverrides_Min_Fields = {
  __typename?: 'arpriceoverrides_min_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** The timestamp with timezone of when the record was created. */
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** The user email of who created the record. */
  created_by?: Maybe<Scalars['String']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** The timestamp with timezone of when the record was last modified. */
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** The user email of who last modified the record. */
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "arpriceoverrides" */
export type Arpriceoverrides_Mutation_Response = {
  __typename?: 'arpriceoverrides_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arpriceoverrides>;
};

/** input type for inserting object relation for remote table "arpriceoverrides" */
export type Arpriceoverrides_Obj_Rel_Insert_Input = {
  data: Arpriceoverrides_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Arpriceoverrides_On_Conflict>;
};

/** on_conflict condition type for table "arpriceoverrides" */
export type Arpriceoverrides_On_Conflict = {
  constraint: Arpriceoverrides_Constraint;
  update_columns?: Array<Arpriceoverrides_Update_Column>;
  where?: InputMaybe<Arpriceoverrides_Bool_Exp>;
};

/** Ordering options when selecting data from "arpriceoverrides". */
export type Arpriceoverrides_Order_By = {
  active?: InputMaybe<Order_By>;
  amount?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arpriceoverrides */
export type Arpriceoverrides_Pk_Columns_Input = {
  /** PK autoinc column unique for each override added to a move. */
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Arpriceoverrides_Prepend_Input = {
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "arpriceoverrides" */
export enum Arpriceoverrides_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Amount = 'amount',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "arpriceoverrides" */
export type Arpriceoverrides_Set_Input = {
  /** Active if true. Record soft delete implementation. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The timestamp with timezone of when the record was created. */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user email of who created the record. */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The timestamp with timezone of when the record was last modified. */
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user email of who last modified the record. */
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Arpriceoverrides_Stddev_Fields = {
  __typename?: 'arpriceoverrides_stddev_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Arpriceoverrides_Stddev_Pop_Fields = {
  __typename?: 'arpriceoverrides_stddev_pop_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Arpriceoverrides_Stddev_Samp_Fields = {
  __typename?: 'arpriceoverrides_stddev_samp_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "arpriceoverrides" */
export type Arpriceoverrides_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arpriceoverrides_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arpriceoverrides_Stream_Cursor_Value_Input = {
  /** Active if true. Record soft delete implementation. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** An optional config object allowing us to expand upon.  Initial properties and their meaning:AllowedCharges - If the override amount is intended to apply to the entirety of the AR charge, then this property would be null, undefined, or an empty array. However, if there are some allowed charges that are expected to be allowed to be tacked on and added to the final AR amount, then the codes representing those should be listed in this array. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The timestamp with timezone of when the record was created. */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user email of who created the record. */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The timestamp with timezone of when the record was last modified. */
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The user email of who last modified the record. */
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Arpriceoverrides_Sum_Fields = {
  __typename?: 'arpriceoverrides_sum_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['bigint']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "arpriceoverrides" */
export enum Arpriceoverrides_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Amount = 'amount',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Arpriceoverrides_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Arpriceoverrides_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Arpriceoverrides_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Arpriceoverrides_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Arpriceoverrides_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arpriceoverrides_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Arpriceoverrides_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arpriceoverrides_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arpriceoverrides_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arpriceoverrides_Var_Pop_Fields = {
  __typename?: 'arpriceoverrides_var_pop_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Arpriceoverrides_Var_Samp_Fields = {
  __typename?: 'arpriceoverrides_var_samp_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Arpriceoverrides_Variance_Fields = {
  __typename?: 'arpriceoverrides_variance_fields';
  /** The override dollar amount. This would be the bid price an admin would indicate in the add override modal on the move details screen in admin. */
  amount?: Maybe<Scalars['Float']['output']>;
  /** PK autoinc column unique for each override added to a move. */
  id?: Maybe<Scalars['Float']['output']>;
  /** FK (moves) id of the move the override applies to. */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "authkeys" */
export type Authkeys = {
  __typename?: 'authkeys';
  createdat: Scalars['timestamptz']['output'];
  expireat?: Maybe<Scalars['timestamp']['output']>;
  id: Scalars['bigint']['output'];
  type: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  value: Scalars['String']['output'];
};

/** aggregated selection of "authkeys" */
export type Authkeys_Aggregate = {
  __typename?: 'authkeys_aggregate';
  aggregate?: Maybe<Authkeys_Aggregate_Fields>;
  nodes: Array<Authkeys>;
};

/** aggregate fields of "authkeys" */
export type Authkeys_Aggregate_Fields = {
  __typename?: 'authkeys_aggregate_fields';
  avg?: Maybe<Authkeys_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Authkeys_Max_Fields>;
  min?: Maybe<Authkeys_Min_Fields>;
  stddev?: Maybe<Authkeys_Stddev_Fields>;
  stddev_pop?: Maybe<Authkeys_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Authkeys_Stddev_Samp_Fields>;
  sum?: Maybe<Authkeys_Sum_Fields>;
  var_pop?: Maybe<Authkeys_Var_Pop_Fields>;
  var_samp?: Maybe<Authkeys_Var_Samp_Fields>;
  variance?: Maybe<Authkeys_Variance_Fields>;
};


/** aggregate fields of "authkeys" */
export type Authkeys_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Authkeys_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Authkeys_Avg_Fields = {
  __typename?: 'authkeys_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "authkeys". All fields are combined with a logical 'AND'. */
export type Authkeys_Bool_Exp = {
  _and?: InputMaybe<Array<Authkeys_Bool_Exp>>;
  _not?: InputMaybe<Authkeys_Bool_Exp>;
  _or?: InputMaybe<Array<Authkeys_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  expireat?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "authkeys" */
export enum Authkeys_Constraint {
  /** unique or primary key constraint on columns "id" */
  AuthkeysPkey = 'authkeys_pkey',
  /** unique or primary key constraint on columns "type" */
  AuthkeysTypeKey = 'authkeys_type_key',
  /** unique or primary key constraint on columns "value" */
  AuthkeysValueKey = 'authkeys_value_key'
}

/** input type for incrementing numeric columns in table "authkeys" */
export type Authkeys_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "authkeys" */
export type Authkeys_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  expireat?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Authkeys_Max_Fields = {
  __typename?: 'authkeys_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  expireat?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Authkeys_Min_Fields = {
  __typename?: 'authkeys_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  expireat?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "authkeys" */
export type Authkeys_Mutation_Response = {
  __typename?: 'authkeys_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Authkeys>;
};

/** on_conflict condition type for table "authkeys" */
export type Authkeys_On_Conflict = {
  constraint: Authkeys_Constraint;
  update_columns?: Array<Authkeys_Update_Column>;
  where?: InputMaybe<Authkeys_Bool_Exp>;
};

/** Ordering options when selecting data from "authkeys". */
export type Authkeys_Order_By = {
  createdat?: InputMaybe<Order_By>;
  expireat?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: authkeys */
export type Authkeys_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "authkeys" */
export enum Authkeys_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Expireat = 'expireat',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "authkeys" */
export type Authkeys_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  expireat?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Authkeys_Stddev_Fields = {
  __typename?: 'authkeys_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Authkeys_Stddev_Pop_Fields = {
  __typename?: 'authkeys_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Authkeys_Stddev_Samp_Fields = {
  __typename?: 'authkeys_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "authkeys" */
export type Authkeys_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Authkeys_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Authkeys_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  expireat?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Authkeys_Sum_Fields = {
  __typename?: 'authkeys_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "authkeys" */
export enum Authkeys_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Expireat = 'expireat',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Value = 'value'
}

export type Authkeys_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Authkeys_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Authkeys_Set_Input>;
  /** filter the rows which have to be updated */
  where: Authkeys_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Authkeys_Var_Pop_Fields = {
  __typename?: 'authkeys_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Authkeys_Var_Samp_Fields = {
  __typename?: 'authkeys_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Authkeys_Variance_Fields = {
  __typename?: 'authkeys_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** A table to hold credit card authorizations coming from driver issued credit cards for fuel and other operational expenses. Pre-authorizations will be written to this table then updated once the card is used. In order for an authorization to be approved, this record must exist as well as a related accessorial record in a pending status. */
export type Authorizations = {
  __typename?: 'authorizations';
  /** An array relationship */
  accessorials: Array<Accessorials>;
  /** An aggregate relationship */
  accessorials_aggregate: Accessorials_Aggregate;
  approved_at?: Maybe<Scalars['timestamptz']['output']>;
  auth_attempts: Scalars['smallint']['output'];
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  last4?: Maybe<Scalars['String']['output']>;
  last_declined_at?: Maybe<Scalars['timestamptz']['output']>;
  last_declined_reason?: Maybe<Scalars['String']['output']>;
  max_charge: Scalars['numeric']['output'];
  merchant_city?: Maybe<Scalars['String']['output']>;
  merchant_name?: Maybe<Scalars['String']['output']>;
  merchant_postalcode?: Maybe<Scalars['String']['output']>;
  merchant_state?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  valid_from?: Maybe<Scalars['timestamptz']['output']>;
  valid_to?: Maybe<Scalars['timestamptz']['output']>;
  vendor_auth_id?: Maybe<Scalars['String']['output']>;
};


/** A table to hold credit card authorizations coming from driver issued credit cards for fuel and other operational expenses. Pre-authorizations will be written to this table then updated once the card is used. In order for an authorization to be approved, this record must exist as well as a related accessorial record in a pending status. */
export type AuthorizationsAccessorialsArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


/** A table to hold credit card authorizations coming from driver issued credit cards for fuel and other operational expenses. Pre-authorizations will be written to this table then updated once the card is used. In order for an authorization to be approved, this record must exist as well as a related accessorial record in a pending status. */
export type AuthorizationsAccessorials_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};

/** aggregated selection of "authorizations" */
export type Authorizations_Aggregate = {
  __typename?: 'authorizations_aggregate';
  aggregate?: Maybe<Authorizations_Aggregate_Fields>;
  nodes: Array<Authorizations>;
};

/** aggregate fields of "authorizations" */
export type Authorizations_Aggregate_Fields = {
  __typename?: 'authorizations_aggregate_fields';
  avg?: Maybe<Authorizations_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Authorizations_Max_Fields>;
  min?: Maybe<Authorizations_Min_Fields>;
  stddev?: Maybe<Authorizations_Stddev_Fields>;
  stddev_pop?: Maybe<Authorizations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Authorizations_Stddev_Samp_Fields>;
  sum?: Maybe<Authorizations_Sum_Fields>;
  var_pop?: Maybe<Authorizations_Var_Pop_Fields>;
  var_samp?: Maybe<Authorizations_Var_Samp_Fields>;
  variance?: Maybe<Authorizations_Variance_Fields>;
};


/** aggregate fields of "authorizations" */
export type Authorizations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Authorizations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Authorizations_Avg_Fields = {
  __typename?: 'authorizations_avg_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "authorizations". All fields are combined with a logical 'AND'. */
export type Authorizations_Bool_Exp = {
  _and?: InputMaybe<Array<Authorizations_Bool_Exp>>;
  _not?: InputMaybe<Authorizations_Bool_Exp>;
  _or?: InputMaybe<Array<Authorizations_Bool_Exp>>;
  accessorials?: InputMaybe<Accessorials_Bool_Exp>;
  accessorials_aggregate?: InputMaybe<Accessorials_Aggregate_Bool_Exp>;
  approved_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  auth_attempts?: InputMaybe<Smallint_Comparison_Exp>;
  card_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_name?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  last4?: InputMaybe<String_Comparison_Exp>;
  last_declined_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  last_declined_reason?: InputMaybe<String_Comparison_Exp>;
  max_charge?: InputMaybe<Numeric_Comparison_Exp>;
  merchant_city?: InputMaybe<String_Comparison_Exp>;
  merchant_name?: InputMaybe<String_Comparison_Exp>;
  merchant_postalcode?: InputMaybe<String_Comparison_Exp>;
  merchant_state?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  valid_from?: InputMaybe<Timestamptz_Comparison_Exp>;
  valid_to?: InputMaybe<Timestamptz_Comparison_Exp>;
  vendor_auth_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "authorizations" */
export enum Authorizations_Constraint {
  /** unique or primary key constraint on columns "id" */
  AuthorizationsPkey = 'authorizations_pkey'
}

/** input type for incrementing numeric columns in table "authorizations" */
export type Authorizations_Inc_Input = {
  auth_attempts?: InputMaybe<Scalars['smallint']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  max_charge?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "authorizations" */
export type Authorizations_Insert_Input = {
  accessorials?: InputMaybe<Accessorials_Arr_Rel_Insert_Input>;
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  auth_attempts?: InputMaybe<Scalars['smallint']['input']>;
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last4?: InputMaybe<Scalars['String']['input']>;
  last_declined_at?: InputMaybe<Scalars['timestamptz']['input']>;
  last_declined_reason?: InputMaybe<Scalars['String']['input']>;
  max_charge?: InputMaybe<Scalars['numeric']['input']>;
  merchant_city?: InputMaybe<Scalars['String']['input']>;
  merchant_name?: InputMaybe<Scalars['String']['input']>;
  merchant_postalcode?: InputMaybe<Scalars['String']['input']>;
  merchant_state?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  valid_from?: InputMaybe<Scalars['timestamptz']['input']>;
  valid_to?: InputMaybe<Scalars['timestamptz']['input']>;
  vendor_auth_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Authorizations_Max_Fields = {
  __typename?: 'authorizations_max_fields';
  approved_at?: Maybe<Scalars['timestamptz']['output']>;
  auth_attempts?: Maybe<Scalars['smallint']['output']>;
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last4?: Maybe<Scalars['String']['output']>;
  last_declined_at?: Maybe<Scalars['timestamptz']['output']>;
  last_declined_reason?: Maybe<Scalars['String']['output']>;
  max_charge?: Maybe<Scalars['numeric']['output']>;
  merchant_city?: Maybe<Scalars['String']['output']>;
  merchant_name?: Maybe<Scalars['String']['output']>;
  merchant_postalcode?: Maybe<Scalars['String']['output']>;
  merchant_state?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  valid_from?: Maybe<Scalars['timestamptz']['output']>;
  valid_to?: Maybe<Scalars['timestamptz']['output']>;
  vendor_auth_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Authorizations_Min_Fields = {
  __typename?: 'authorizations_min_fields';
  approved_at?: Maybe<Scalars['timestamptz']['output']>;
  auth_attempts?: Maybe<Scalars['smallint']['output']>;
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last4?: Maybe<Scalars['String']['output']>;
  last_declined_at?: Maybe<Scalars['timestamptz']['output']>;
  last_declined_reason?: Maybe<Scalars['String']['output']>;
  max_charge?: Maybe<Scalars['numeric']['output']>;
  merchant_city?: Maybe<Scalars['String']['output']>;
  merchant_name?: Maybe<Scalars['String']['output']>;
  merchant_postalcode?: Maybe<Scalars['String']['output']>;
  merchant_state?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  valid_from?: Maybe<Scalars['timestamptz']['output']>;
  valid_to?: Maybe<Scalars['timestamptz']['output']>;
  vendor_auth_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "authorizations" */
export type Authorizations_Mutation_Response = {
  __typename?: 'authorizations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Authorizations>;
};

/** input type for inserting object relation for remote table "authorizations" */
export type Authorizations_Obj_Rel_Insert_Input = {
  data: Authorizations_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Authorizations_On_Conflict>;
};

/** on_conflict condition type for table "authorizations" */
export type Authorizations_On_Conflict = {
  constraint: Authorizations_Constraint;
  update_columns?: Array<Authorizations_Update_Column>;
  where?: InputMaybe<Authorizations_Bool_Exp>;
};

/** Ordering options when selecting data from "authorizations". */
export type Authorizations_Order_By = {
  accessorials_aggregate?: InputMaybe<Accessorials_Aggregate_Order_By>;
  approved_at?: InputMaybe<Order_By>;
  auth_attempts?: InputMaybe<Order_By>;
  card_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last4?: InputMaybe<Order_By>;
  last_declined_at?: InputMaybe<Order_By>;
  last_declined_reason?: InputMaybe<Order_By>;
  max_charge?: InputMaybe<Order_By>;
  merchant_city?: InputMaybe<Order_By>;
  merchant_name?: InputMaybe<Order_By>;
  merchant_postalcode?: InputMaybe<Order_By>;
  merchant_state?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  valid_from?: InputMaybe<Order_By>;
  valid_to?: InputMaybe<Order_By>;
  vendor_auth_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: authorizations */
export type Authorizations_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "authorizations" */
export enum Authorizations_Select_Column {
  /** column name */
  ApprovedAt = 'approved_at',
  /** column name */
  AuthAttempts = 'auth_attempts',
  /** column name */
  CardId = 'card_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  Id = 'id',
  /** column name */
  Last4 = 'last4',
  /** column name */
  LastDeclinedAt = 'last_declined_at',
  /** column name */
  LastDeclinedReason = 'last_declined_reason',
  /** column name */
  MaxCharge = 'max_charge',
  /** column name */
  MerchantCity = 'merchant_city',
  /** column name */
  MerchantName = 'merchant_name',
  /** column name */
  MerchantPostalcode = 'merchant_postalcode',
  /** column name */
  MerchantState = 'merchant_state',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ValidFrom = 'valid_from',
  /** column name */
  ValidTo = 'valid_to',
  /** column name */
  VendorAuthId = 'vendor_auth_id'
}

/** input type for updating data in table "authorizations" */
export type Authorizations_Set_Input = {
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  auth_attempts?: InputMaybe<Scalars['smallint']['input']>;
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last4?: InputMaybe<Scalars['String']['input']>;
  last_declined_at?: InputMaybe<Scalars['timestamptz']['input']>;
  last_declined_reason?: InputMaybe<Scalars['String']['input']>;
  max_charge?: InputMaybe<Scalars['numeric']['input']>;
  merchant_city?: InputMaybe<Scalars['String']['input']>;
  merchant_name?: InputMaybe<Scalars['String']['input']>;
  merchant_postalcode?: InputMaybe<Scalars['String']['input']>;
  merchant_state?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  valid_from?: InputMaybe<Scalars['timestamptz']['input']>;
  valid_to?: InputMaybe<Scalars['timestamptz']['input']>;
  vendor_auth_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Authorizations_Stddev_Fields = {
  __typename?: 'authorizations_stddev_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Authorizations_Stddev_Pop_Fields = {
  __typename?: 'authorizations_stddev_pop_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Authorizations_Stddev_Samp_Fields = {
  __typename?: 'authorizations_stddev_samp_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "authorizations" */
export type Authorizations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Authorizations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Authorizations_Stream_Cursor_Value_Input = {
  approved_at?: InputMaybe<Scalars['timestamptz']['input']>;
  auth_attempts?: InputMaybe<Scalars['smallint']['input']>;
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last4?: InputMaybe<Scalars['String']['input']>;
  last_declined_at?: InputMaybe<Scalars['timestamptz']['input']>;
  last_declined_reason?: InputMaybe<Scalars['String']['input']>;
  max_charge?: InputMaybe<Scalars['numeric']['input']>;
  merchant_city?: InputMaybe<Scalars['String']['input']>;
  merchant_name?: InputMaybe<Scalars['String']['input']>;
  merchant_postalcode?: InputMaybe<Scalars['String']['input']>;
  merchant_state?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  valid_from?: InputMaybe<Scalars['timestamptz']['input']>;
  valid_to?: InputMaybe<Scalars['timestamptz']['input']>;
  vendor_auth_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Authorizations_Sum_Fields = {
  __typename?: 'authorizations_sum_fields';
  auth_attempts?: Maybe<Scalars['smallint']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  max_charge?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "authorizations" */
export enum Authorizations_Update_Column {
  /** column name */
  ApprovedAt = 'approved_at',
  /** column name */
  AuthAttempts = 'auth_attempts',
  /** column name */
  CardId = 'card_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  Id = 'id',
  /** column name */
  Last4 = 'last4',
  /** column name */
  LastDeclinedAt = 'last_declined_at',
  /** column name */
  LastDeclinedReason = 'last_declined_reason',
  /** column name */
  MaxCharge = 'max_charge',
  /** column name */
  MerchantCity = 'merchant_city',
  /** column name */
  MerchantName = 'merchant_name',
  /** column name */
  MerchantPostalcode = 'merchant_postalcode',
  /** column name */
  MerchantState = 'merchant_state',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ValidFrom = 'valid_from',
  /** column name */
  ValidTo = 'valid_to',
  /** column name */
  VendorAuthId = 'vendor_auth_id'
}

export type Authorizations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Authorizations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Authorizations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Authorizations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Authorizations_Var_Pop_Fields = {
  __typename?: 'authorizations_var_pop_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Authorizations_Var_Samp_Fields = {
  __typename?: 'authorizations_var_samp_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Authorizations_Variance_Fields = {
  __typename?: 'authorizations_variance_fields';
  auth_attempts?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  max_charge?: Maybe<Scalars['Float']['output']>;
};

/** Table for jobs that can potentially take too long for a lambda function to run. This table has an input (request) and output (response) that triggers a hasura background event and runs long transactions. A subscription to this table on the "output" field is recommended to get the response from the background function. */
export type Batch_Jobs = {
  __typename?: 'batch_jobs';
  /** Subscription listeners should target this value to find other related batch jobs from the same insert pool. */
  batch_id: Scalars['uuid']['output'];
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Key that helps in determining if another job of that same type can be inserted. This key is not unique, but only one of these should be allowed to be inserted within the delay_ms window. This is based on the batch_jobs_unique_delay_key index, which only allows you to insert another record with the same key as long as the status is NOT in "pending" or "delaying". */
  delay_key?: Maybe<Scalars['String']['output']>;
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['bigint']['output'];
  /** The request to the batch job. */
  input?: Maybe<Scalars['jsonb']['output']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: Maybe<Scalars['jsonb']['output']>;
  /** The response from the batch job. */
  output?: Maybe<Scalars['jsonb']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['bigint']['output']>;
  status: Scalars['String']['output'];
  /** String to determine which batch job should run. Refer to these in the switch statement of handleBatchJob netlify function. */
  trigger_type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};


/** Table for jobs that can potentially take too long for a lambda function to run. This table has an input (request) and output (response) that triggers a hasura background event and runs long transactions. A subscription to this table on the "output" field is recommended to get the response from the background function. */
export type Batch_JobsInputArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Table for jobs that can potentially take too long for a lambda function to run. This table has an input (request) and output (response) that triggers a hasura background event and runs long transactions. A subscription to this table on the "output" field is recommended to get the response from the background function. */
export type Batch_JobsOrchestrator_ConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Table for jobs that can potentially take too long for a lambda function to run. This table has an input (request) and output (response) that triggers a hasura background event and runs long transactions. A subscription to this table on the "output" field is recommended to get the response from the background function. */
export type Batch_JobsOutputArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "batch_jobs" */
export type Batch_Jobs_Aggregate = {
  __typename?: 'batch_jobs_aggregate';
  aggregate?: Maybe<Batch_Jobs_Aggregate_Fields>;
  nodes: Array<Batch_Jobs>;
};

/** aggregate fields of "batch_jobs" */
export type Batch_Jobs_Aggregate_Fields = {
  __typename?: 'batch_jobs_aggregate_fields';
  avg?: Maybe<Batch_Jobs_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Batch_Jobs_Max_Fields>;
  min?: Maybe<Batch_Jobs_Min_Fields>;
  stddev?: Maybe<Batch_Jobs_Stddev_Fields>;
  stddev_pop?: Maybe<Batch_Jobs_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Batch_Jobs_Stddev_Samp_Fields>;
  sum?: Maybe<Batch_Jobs_Sum_Fields>;
  var_pop?: Maybe<Batch_Jobs_Var_Pop_Fields>;
  var_samp?: Maybe<Batch_Jobs_Var_Samp_Fields>;
  variance?: Maybe<Batch_Jobs_Variance_Fields>;
};


/** aggregate fields of "batch_jobs" */
export type Batch_Jobs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Batch_Jobs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Batch_Jobs_Append_Input = {
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Batch_Jobs_Avg_Fields = {
  __typename?: 'batch_jobs_avg_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "batch_jobs". All fields are combined with a logical 'AND'. */
export type Batch_Jobs_Bool_Exp = {
  _and?: InputMaybe<Array<Batch_Jobs_Bool_Exp>>;
  _not?: InputMaybe<Batch_Jobs_Bool_Exp>;
  _or?: InputMaybe<Array<Batch_Jobs_Bool_Exp>>;
  batch_id?: InputMaybe<Uuid_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  delay_key?: InputMaybe<String_Comparison_Exp>;
  delay_ms?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  input?: InputMaybe<Jsonb_Comparison_Exp>;
  orchestrator_config?: InputMaybe<Jsonb_Comparison_Exp>;
  output?: InputMaybe<Jsonb_Comparison_Exp>;
  sequence?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  trigger_type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "batch_jobs" */
export enum Batch_Jobs_Constraint {
  /** unique or primary key constraint on columns "id" */
  BatchJobsPkey = 'batch_jobs_pkey',
  /** unique or primary key constraint on columns "delay_key" */
  BatchJobsUniqueDelayKey = 'batch_jobs_unique_delay_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Batch_Jobs_Delete_At_Path_Input = {
  /** The request to the batch job. */
  input?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The response from the batch job. */
  output?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Batch_Jobs_Delete_Elem_Input = {
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['Int']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['Int']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Batch_Jobs_Delete_Key_Input = {
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['String']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['String']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "batch_jobs" */
export type Batch_Jobs_Inc_Input = {
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "batch_jobs" */
export type Batch_Jobs_Insert_Input = {
  /** Subscription listeners should target this value to find other related batch jobs from the same insert pool. */
  batch_id?: InputMaybe<Scalars['uuid']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Key that helps in determining if another job of that same type can be inserted. This key is not unique, but only one of these should be allowed to be inserted within the delay_ms window. This is based on the batch_jobs_unique_delay_key index, which only allows you to insert another record with the same key as long as the status is NOT in "pending" or "delaying". */
  delay_key?: InputMaybe<Scalars['String']['input']>;
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['jsonb']['input']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** String to determine which batch job should run. Refer to these in the switch statement of handleBatchJob netlify function. */
  trigger_type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Batch_Jobs_Max_Fields = {
  __typename?: 'batch_jobs_max_fields';
  /** Subscription listeners should target this value to find other related batch jobs from the same insert pool. */
  batch_id?: Maybe<Scalars['uuid']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Key that helps in determining if another job of that same type can be inserted. This key is not unique, but only one of these should be allowed to be inserted within the delay_ms window. This is based on the batch_jobs_unique_delay_key index, which only allows you to insert another record with the same key as long as the status is NOT in "pending" or "delaying". */
  delay_key?: Maybe<Scalars['String']['output']>;
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  /** String to determine which batch job should run. Refer to these in the switch statement of handleBatchJob netlify function. */
  trigger_type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Batch_Jobs_Min_Fields = {
  __typename?: 'batch_jobs_min_fields';
  /** Subscription listeners should target this value to find other related batch jobs from the same insert pool. */
  batch_id?: Maybe<Scalars['uuid']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Key that helps in determining if another job of that same type can be inserted. This key is not unique, but only one of these should be allowed to be inserted within the delay_ms window. This is based on the batch_jobs_unique_delay_key index, which only allows you to insert another record with the same key as long as the status is NOT in "pending" or "delaying". */
  delay_key?: Maybe<Scalars['String']['output']>;
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  /** String to determine which batch job should run. Refer to these in the switch statement of handleBatchJob netlify function. */
  trigger_type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "batch_jobs" */
export type Batch_Jobs_Mutation_Response = {
  __typename?: 'batch_jobs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Batch_Jobs>;
};

/** on_conflict condition type for table "batch_jobs" */
export type Batch_Jobs_On_Conflict = {
  constraint: Batch_Jobs_Constraint;
  update_columns?: Array<Batch_Jobs_Update_Column>;
  where?: InputMaybe<Batch_Jobs_Bool_Exp>;
};

/** Ordering options when selecting data from "batch_jobs". */
export type Batch_Jobs_Order_By = {
  batch_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  delay_key?: InputMaybe<Order_By>;
  delay_ms?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input?: InputMaybe<Order_By>;
  orchestrator_config?: InputMaybe<Order_By>;
  output?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  trigger_type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: batch_jobs */
export type Batch_Jobs_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Batch_Jobs_Prepend_Input = {
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "batch_jobs" */
export enum Batch_Jobs_Select_Column {
  /** column name */
  BatchId = 'batch_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DelayKey = 'delay_key',
  /** column name */
  DelayMs = 'delay_ms',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  OrchestratorConfig = 'orchestrator_config',
  /** column name */
  Output = 'output',
  /** column name */
  Sequence = 'sequence',
  /** column name */
  Status = 'status',
  /** column name */
  TriggerType = 'trigger_type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "batch_jobs" */
export type Batch_Jobs_Set_Input = {
  /** Subscription listeners should target this value to find other related batch jobs from the same insert pool. */
  batch_id?: InputMaybe<Scalars['uuid']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Key that helps in determining if another job of that same type can be inserted. This key is not unique, but only one of these should be allowed to be inserted within the delay_ms window. This is based on the batch_jobs_unique_delay_key index, which only allows you to insert another record with the same key as long as the status is NOT in "pending" or "delaying". */
  delay_key?: InputMaybe<Scalars['String']['input']>;
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['jsonb']['input']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** String to determine which batch job should run. Refer to these in the switch statement of handleBatchJob netlify function. */
  trigger_type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Batch_Jobs_Stddev_Fields = {
  __typename?: 'batch_jobs_stddev_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Batch_Jobs_Stddev_Pop_Fields = {
  __typename?: 'batch_jobs_stddev_pop_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Batch_Jobs_Stddev_Samp_Fields = {
  __typename?: 'batch_jobs_stddev_samp_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "batch_jobs" */
export type Batch_Jobs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Batch_Jobs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Batch_Jobs_Stream_Cursor_Value_Input = {
  /** Subscription listeners should target this value to find other related batch jobs from the same insert pool. */
  batch_id?: InputMaybe<Scalars['uuid']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Key that helps in determining if another job of that same type can be inserted. This key is not unique, but only one of these should be allowed to be inserted within the delay_ms window. This is based on the batch_jobs_unique_delay_key index, which only allows you to insert another record with the same key as long as the status is NOT in "pending" or "delaying". */
  delay_key?: InputMaybe<Scalars['String']['input']>;
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The request to the batch job. */
  input?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for rideshare orchestrator jobs */
  orchestrator_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** The response from the batch job. */
  output?: InputMaybe<Scalars['jsonb']['input']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  /** String to determine which batch job should run. Refer to these in the switch statement of handleBatchJob netlify function. */
  trigger_type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Batch_Jobs_Sum_Fields = {
  __typename?: 'batch_jobs_sum_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "batch_jobs" */
export enum Batch_Jobs_Update_Column {
  /** column name */
  BatchId = 'batch_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DelayKey = 'delay_key',
  /** column name */
  DelayMs = 'delay_ms',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  OrchestratorConfig = 'orchestrator_config',
  /** column name */
  Output = 'output',
  /** column name */
  Sequence = 'sequence',
  /** column name */
  Status = 'status',
  /** column name */
  TriggerType = 'trigger_type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Batch_Jobs_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Batch_Jobs_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Batch_Jobs_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Batch_Jobs_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Batch_Jobs_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Batch_Jobs_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Batch_Jobs_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Batch_Jobs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Batch_Jobs_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Batch_Jobs_Var_Pop_Fields = {
  __typename?: 'batch_jobs_var_pop_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Batch_Jobs_Var_Samp_Fields = {
  __typename?: 'batch_jobs_var_samp_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Batch_Jobs_Variance_Fields = {
  __typename?: 'batch_jobs_variance_fields';
  /** Delay (in milliseconds) before another batch job of the same delay_key in "pending" or "delaying" status can be inserted. */
  delay_ms?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The numerical index of the batch job, used for tracking a list of multiple batch jobs with the same batch_id. */
  sequence?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'. */
export type Bpchar_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bpchar']['input']>;
  _gt?: InputMaybe<Scalars['bpchar']['input']>;
  _gte?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['bpchar']['input']>;
  _in?: InputMaybe<Array<Scalars['bpchar']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['bpchar']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['bpchar']['input']>;
  _lt?: InputMaybe<Scalars['bpchar']['input']>;
  _lte?: InputMaybe<Scalars['bpchar']['input']>;
  _neq?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['bpchar']['input']>;
  _nin?: InputMaybe<Array<Scalars['bpchar']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['bpchar']['input']>;
};

/** A grouping mechanism for one or more scenarios to be offered together to a driver through the offer system. A bundle is transient representing a collection of scenarios needing a driver to be assigned at a point in time. */
export type Bundles = {
  __typename?: 'bundles';
  /** An object relationship */
  assignedOffer?: Maybe<Offers>;
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the parent bundleset */
  bundle_set_id: Scalars['bigint']['output'];
  /** An object relationship */
  bundleset: Bundlesets;
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config: Scalars['jsonb']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  /** An array relationship */
  offers: Array<Offers>;
  /** An aggregate relationship */
  offers_aggregate: Offers_Aggregate;
  /** An array relationship */
  scenarios: Array<Bundletoscenarios>;
  /** An aggregate relationship */
  scenarios_aggregate: Bundletoscenarios_Aggregate;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** A grouping mechanism for one or more scenarios to be offered together to a driver through the offer system. A bundle is transient representing a collection of scenarios needing a driver to be assigned at a point in time. */
export type BundlesConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** A grouping mechanism for one or more scenarios to be offered together to a driver through the offer system. A bundle is transient representing a collection of scenarios needing a driver to be assigned at a point in time. */
export type BundlesOffersArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


/** A grouping mechanism for one or more scenarios to be offered together to a driver through the offer system. A bundle is transient representing a collection of scenarios needing a driver to be assigned at a point in time. */
export type BundlesOffers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


/** A grouping mechanism for one or more scenarios to be offered together to a driver through the offer system. A bundle is transient representing a collection of scenarios needing a driver to be assigned at a point in time. */
export type BundlesScenariosArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


/** A grouping mechanism for one or more scenarios to be offered together to a driver through the offer system. A bundle is transient representing a collection of scenarios needing a driver to be assigned at a point in time. */
export type BundlesScenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};

/** aggregated selection of "bundles" */
export type Bundles_Aggregate = {
  __typename?: 'bundles_aggregate';
  aggregate?: Maybe<Bundles_Aggregate_Fields>;
  nodes: Array<Bundles>;
};

export type Bundles_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bundles_Aggregate_Bool_Exp_Count>;
};

export type Bundles_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bundles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bundles_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bundles" */
export type Bundles_Aggregate_Fields = {
  __typename?: 'bundles_aggregate_fields';
  avg?: Maybe<Bundles_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Bundles_Max_Fields>;
  min?: Maybe<Bundles_Min_Fields>;
  stddev?: Maybe<Bundles_Stddev_Fields>;
  stddev_pop?: Maybe<Bundles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bundles_Stddev_Samp_Fields>;
  sum?: Maybe<Bundles_Sum_Fields>;
  var_pop?: Maybe<Bundles_Var_Pop_Fields>;
  var_samp?: Maybe<Bundles_Var_Samp_Fields>;
  variance?: Maybe<Bundles_Variance_Fields>;
};


/** aggregate fields of "bundles" */
export type Bundles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bundles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bundles" */
export type Bundles_Aggregate_Order_By = {
  avg?: InputMaybe<Bundles_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bundles_Max_Order_By>;
  min?: InputMaybe<Bundles_Min_Order_By>;
  stddev?: InputMaybe<Bundles_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Bundles_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Bundles_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Bundles_Sum_Order_By>;
  var_pop?: InputMaybe<Bundles_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Bundles_Var_Samp_Order_By>;
  variance?: InputMaybe<Bundles_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bundles_Append_Input = {
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "bundles" */
export type Bundles_Arr_Rel_Insert_Input = {
  data: Array<Bundles_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bundles_On_Conflict>;
};

/** aggregate avg on columns */
export type Bundles_Avg_Fields = {
  __typename?: 'bundles_avg_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "bundles" */
export type Bundles_Avg_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "bundles". All fields are combined with a logical 'AND'. */
export type Bundles_Bool_Exp = {
  _and?: InputMaybe<Array<Bundles_Bool_Exp>>;
  _not?: InputMaybe<Bundles_Bool_Exp>;
  _or?: InputMaybe<Array<Bundles_Bool_Exp>>;
  assignedOffer?: InputMaybe<Offers_Bool_Exp>;
  assigned_offer_id?: InputMaybe<Bigint_Comparison_Exp>;
  bundle_set_id?: InputMaybe<Bigint_Comparison_Exp>;
  bundleset?: InputMaybe<Bundlesets_Bool_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  offers?: InputMaybe<Offers_Bool_Exp>;
  offers_aggregate?: InputMaybe<Offers_Aggregate_Bool_Exp>;
  scenarios?: InputMaybe<Bundletoscenarios_Bool_Exp>;
  scenarios_aggregate?: InputMaybe<Bundletoscenarios_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "bundles" */
export enum Bundles_Constraint {
  /** unique or primary key constraint on columns "id" */
  BundlesPkey = 'bundles_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bundles_Delete_At_Path_Input = {
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bundles_Delete_Elem_Input = {
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bundles_Delete_Key_Input = {
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "bundles" */
export type Bundles_Inc_Input = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "bundles" */
export type Bundles_Insert_Input = {
  assignedOffer?: InputMaybe<Offers_Obj_Rel_Insert_Input>;
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Scalars['bigint']['input']>;
  bundleset?: InputMaybe<Bundlesets_Obj_Rel_Insert_Input>;
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  offers?: InputMaybe<Offers_Arr_Rel_Insert_Input>;
  scenarios?: InputMaybe<Bundletoscenarios_Arr_Rel_Insert_Input>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Bundles_Max_Fields = {
  __typename?: 'bundles_max_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "bundles" */
export type Bundles_Max_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bundles_Min_Fields = {
  __typename?: 'bundles_min_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "bundles" */
export type Bundles_Min_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bundles" */
export type Bundles_Mutation_Response = {
  __typename?: 'bundles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bundles>;
};

/** input type for inserting object relation for remote table "bundles" */
export type Bundles_Obj_Rel_Insert_Input = {
  data: Bundles_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bundles_On_Conflict>;
};

/** on_conflict condition type for table "bundles" */
export type Bundles_On_Conflict = {
  constraint: Bundles_Constraint;
  update_columns?: Array<Bundles_Update_Column>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};

/** Ordering options when selecting data from "bundles". */
export type Bundles_Order_By = {
  assignedOffer?: InputMaybe<Offers_Order_By>;
  assigned_offer_id?: InputMaybe<Order_By>;
  bundle_set_id?: InputMaybe<Order_By>;
  bundleset?: InputMaybe<Bundlesets_Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  offers_aggregate?: InputMaybe<Offers_Aggregate_Order_By>;
  scenarios_aggregate?: InputMaybe<Bundletoscenarios_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bundles */
export type Bundles_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bundles_Prepend_Input = {
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bundles" */
export enum Bundles_Select_Column {
  /** column name */
  AssignedOfferId = 'assigned_offer_id',
  /** column name */
  BundleSetId = 'bundle_set_id',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "bundles" */
export type Bundles_Set_Input = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Bundles_Stddev_Fields = {
  __typename?: 'bundles_stddev_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "bundles" */
export type Bundles_Stddev_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Bundles_Stddev_Pop_Fields = {
  __typename?: 'bundles_stddev_pop_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "bundles" */
export type Bundles_Stddev_Pop_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Bundles_Stddev_Samp_Fields = {
  __typename?: 'bundles_stddev_samp_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "bundles" */
export type Bundles_Stddev_Samp_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "bundles" */
export type Bundles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bundles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bundles_Stream_Cursor_Value_Input = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a dynamic JSON object which can be used to control how the bundle might be interpreted or executed by the driver or handled by the offer system. An example property: flexSequence boolean - a true value would indicate that the sequence of execution of the scenarios is flexible. They can work the scenarios in any order. A false value would indicate that the cardinality must be followed strictly by the driver. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - a bundle that has just been written to the database but is not yet populated with moves nor is it ready for any automated processing yet ready - the bundle has completed its bundling phase and is ready for dispatching. dispatching - the bundler is currently creating offers, assigning them to drivers, monitoring for responses, and ultimately finding a driver to accept the offer to work this bundle. At the start of that process, the bundler will set the status of the bundle to dispatching to clearly record its state in the bundle lifecycle. dispatched - once the dispatching process has completed and the driver has been assigned to the scenarios in the  bundle, then the bundle status will update to reflect that successful outcome. failed - if the offer system exhausted all offers and was unsuccessful at finding a driver to accept the bundle of scenarios then the status of the bundle is set to failed. This will require human intervention by a dispatcher to decide whether or not to break the bundle apart and try a new combination of scenarios to offer out to drivers, or to reach out to drivers manually over SMS or phone to attempt to get better acceptance. deprecated - This could be invoked by a dispatcher manually changing the drivers plan and thus it deprecates the scenarios and thus the bundle gets deprecated. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Bundles_Sum_Fields = {
  __typename?: 'bundles_sum_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "bundles" */
export type Bundles_Sum_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "bundles" */
export enum Bundles_Update_Column {
  /** column name */
  AssignedOfferId = 'assigned_offer_id',
  /** column name */
  BundleSetId = 'bundle_set_id',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Bundles_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bundles_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bundles_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bundles_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bundles_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bundles_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bundles_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bundles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bundles_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bundles_Var_Pop_Fields = {
  __typename?: 'bundles_var_pop_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "bundles" */
export type Bundles_Var_Pop_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Bundles_Var_Samp_Fields = {
  __typename?: 'bundles_var_samp_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "bundles" */
export type Bundles_Var_Samp_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Bundles_Variance_Fields = {
  __typename?: 'bundles_variance_fields';
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: Maybe<Scalars['Float']['output']>;
  /** id for the parent bundleset */
  bundle_set_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "bundles" */
export type Bundles_Variance_Order_By = {
  /** id for the offer that was finally accepted by a driver during the dispatching process. */
  assigned_offer_id?: InputMaybe<Order_By>;
  /** id for the parent bundleset */
  bundle_set_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** When a set of bundles needs to have coordinated execution such as with shared return rides, a bundle set is needed to convey that grouping/coordination. To keep the data modeling simpler however, weve decided to just always have a bundle_set event if there is only a single bundle as a child. This makes the expectations of the data fetching for the front end and back end simpler and more predictable. */
export type Bundlesets = {
  __typename?: 'bundlesets';
  /** An array relationship */
  bundles: Array<Bundles>;
  /** An aggregate relationship */
  bundles_aggregate: Bundles_Aggregate;
  config: Scalars['jsonb']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  /** a string of all lowercase alpha characters separated by dashes and never having spaces to indicate what type of set this is. Possible values are: single - a simple single bundle bundle set. This is what we will see on most of the sets created just for the purposes of keeping the data model clean. shuttle-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the shuttle vehicle. rideshare-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the 3rd party ride-share vehicle. */
  type: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** When a set of bundles needs to have coordinated execution such as with shared return rides, a bundle set is needed to convey that grouping/coordination. To keep the data modeling simpler however, weve decided to just always have a bundle_set event if there is only a single bundle as a child. This makes the expectations of the data fetching for the front end and back end simpler and more predictable. */
export type BundlesetsBundlesArgs = {
  distinct_on?: InputMaybe<Array<Bundles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundles_Order_By>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


/** When a set of bundles needs to have coordinated execution such as with shared return rides, a bundle set is needed to convey that grouping/coordination. To keep the data modeling simpler however, weve decided to just always have a bundle_set event if there is only a single bundle as a child. This makes the expectations of the data fetching for the front end and back end simpler and more predictable. */
export type BundlesetsBundles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundles_Order_By>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


/** When a set of bundles needs to have coordinated execution such as with shared return rides, a bundle set is needed to convey that grouping/coordination. To keep the data modeling simpler however, weve decided to just always have a bundle_set event if there is only a single bundle as a child. This makes the expectations of the data fetching for the front end and back end simpler and more predictable. */
export type BundlesetsConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "bundlesets" */
export type Bundlesets_Aggregate = {
  __typename?: 'bundlesets_aggregate';
  aggregate?: Maybe<Bundlesets_Aggregate_Fields>;
  nodes: Array<Bundlesets>;
};

/** aggregate fields of "bundlesets" */
export type Bundlesets_Aggregate_Fields = {
  __typename?: 'bundlesets_aggregate_fields';
  avg?: Maybe<Bundlesets_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Bundlesets_Max_Fields>;
  min?: Maybe<Bundlesets_Min_Fields>;
  stddev?: Maybe<Bundlesets_Stddev_Fields>;
  stddev_pop?: Maybe<Bundlesets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bundlesets_Stddev_Samp_Fields>;
  sum?: Maybe<Bundlesets_Sum_Fields>;
  var_pop?: Maybe<Bundlesets_Var_Pop_Fields>;
  var_samp?: Maybe<Bundlesets_Var_Samp_Fields>;
  variance?: Maybe<Bundlesets_Variance_Fields>;
};


/** aggregate fields of "bundlesets" */
export type Bundlesets_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bundlesets_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Bundlesets_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Bundlesets_Avg_Fields = {
  __typename?: 'bundlesets_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "bundlesets". All fields are combined with a logical 'AND'. */
export type Bundlesets_Bool_Exp = {
  _and?: InputMaybe<Array<Bundlesets_Bool_Exp>>;
  _not?: InputMaybe<Bundlesets_Bool_Exp>;
  _or?: InputMaybe<Array<Bundlesets_Bool_Exp>>;
  bundles?: InputMaybe<Bundles_Bool_Exp>;
  bundles_aggregate?: InputMaybe<Bundles_Aggregate_Bool_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "bundlesets" */
export enum Bundlesets_Constraint {
  /** unique or primary key constraint on columns "id" */
  BundlesetsPkey = 'bundlesets_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Bundlesets_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Bundlesets_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Bundlesets_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "bundlesets" */
export type Bundlesets_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "bundlesets" */
export type Bundlesets_Insert_Input = {
  bundles?: InputMaybe<Bundles_Arr_Rel_Insert_Input>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a string of all lowercase alpha characters separated by dashes and never having spaces to indicate what type of set this is. Possible values are: single - a simple single bundle bundle set. This is what we will see on most of the sets created just for the purposes of keeping the data model clean. shuttle-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the shuttle vehicle. rideshare-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the 3rd party ride-share vehicle. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Bundlesets_Max_Fields = {
  __typename?: 'bundlesets_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** a string of all lowercase alpha characters separated by dashes and never having spaces to indicate what type of set this is. Possible values are: single - a simple single bundle bundle set. This is what we will see on most of the sets created just for the purposes of keeping the data model clean. shuttle-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the shuttle vehicle. rideshare-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the 3rd party ride-share vehicle. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Bundlesets_Min_Fields = {
  __typename?: 'bundlesets_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** a string of all lowercase alpha characters separated by dashes and never having spaces to indicate what type of set this is. Possible values are: single - a simple single bundle bundle set. This is what we will see on most of the sets created just for the purposes of keeping the data model clean. shuttle-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the shuttle vehicle. rideshare-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the 3rd party ride-share vehicle. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "bundlesets" */
export type Bundlesets_Mutation_Response = {
  __typename?: 'bundlesets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bundlesets>;
};

/** input type for inserting object relation for remote table "bundlesets" */
export type Bundlesets_Obj_Rel_Insert_Input = {
  data: Bundlesets_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Bundlesets_On_Conflict>;
};

/** on_conflict condition type for table "bundlesets" */
export type Bundlesets_On_Conflict = {
  constraint: Bundlesets_Constraint;
  update_columns?: Array<Bundlesets_Update_Column>;
  where?: InputMaybe<Bundlesets_Bool_Exp>;
};

/** Ordering options when selecting data from "bundlesets". */
export type Bundlesets_Order_By = {
  bundles_aggregate?: InputMaybe<Bundles_Aggregate_Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bundlesets */
export type Bundlesets_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Bundlesets_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "bundlesets" */
export enum Bundlesets_Select_Column {
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "bundlesets" */
export type Bundlesets_Set_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a string of all lowercase alpha characters separated by dashes and never having spaces to indicate what type of set this is. Possible values are: single - a simple single bundle bundle set. This is what we will see on most of the sets created just for the purposes of keeping the data model clean. shuttle-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the shuttle vehicle. rideshare-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the 3rd party ride-share vehicle. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Bundlesets_Stddev_Fields = {
  __typename?: 'bundlesets_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Bundlesets_Stddev_Pop_Fields = {
  __typename?: 'bundlesets_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Bundlesets_Stddev_Samp_Fields = {
  __typename?: 'bundlesets_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "bundlesets" */
export type Bundlesets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bundlesets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bundlesets_Stream_Cursor_Value_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a string of all lowercase alpha characters separated by dashes and never having spaces to indicate what type of set this is. Possible values are: single - a simple single bundle bundle set. This is what we will see on most of the sets created just for the purposes of keeping the data model clean. shuttle-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the shuttle vehicle. rideshare-group - a coordinated set of bundles where each driver must arrive and depart at the same time to ensure they can share a ride back in the 3rd party ride-share vehicle. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Bundlesets_Sum_Fields = {
  __typename?: 'bundlesets_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "bundlesets" */
export enum Bundlesets_Update_Column {
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Bundlesets_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Bundlesets_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Bundlesets_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Bundlesets_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Bundlesets_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bundlesets_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Bundlesets_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bundlesets_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bundlesets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bundlesets_Var_Pop_Fields = {
  __typename?: 'bundlesets_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Bundlesets_Var_Samp_Fields = {
  __typename?: 'bundlesets_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Bundlesets_Variance_Fields = {
  __typename?: 'bundlesets_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Contains the relationship between bundles and scenarios as well as some extra information. Cardinality for one. This is a many to many link table to facilitate keeping track of the prior bundles. */
export type Bundletoscenarios = {
  __typename?: 'bundletoscenarios';
  /** An object relationship */
  bundle: Bundles;
  /** id for the related bundle record */
  bundle_id: Scalars['bigint']['output'];
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality: Scalars['smallint']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** an auto-incrementing id for the record */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  scenario: Scenarios;
  /** id for the related scenario record */
  scenario_id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "bundletoscenarios" */
export type Bundletoscenarios_Aggregate = {
  __typename?: 'bundletoscenarios_aggregate';
  aggregate?: Maybe<Bundletoscenarios_Aggregate_Fields>;
  nodes: Array<Bundletoscenarios>;
};

export type Bundletoscenarios_Aggregate_Bool_Exp = {
  count?: InputMaybe<Bundletoscenarios_Aggregate_Bool_Exp_Count>;
};

export type Bundletoscenarios_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Bundletoscenarios_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "bundletoscenarios" */
export type Bundletoscenarios_Aggregate_Fields = {
  __typename?: 'bundletoscenarios_aggregate_fields';
  avg?: Maybe<Bundletoscenarios_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Bundletoscenarios_Max_Fields>;
  min?: Maybe<Bundletoscenarios_Min_Fields>;
  stddev?: Maybe<Bundletoscenarios_Stddev_Fields>;
  stddev_pop?: Maybe<Bundletoscenarios_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bundletoscenarios_Stddev_Samp_Fields>;
  sum?: Maybe<Bundletoscenarios_Sum_Fields>;
  var_pop?: Maybe<Bundletoscenarios_Var_Pop_Fields>;
  var_samp?: Maybe<Bundletoscenarios_Var_Samp_Fields>;
  variance?: Maybe<Bundletoscenarios_Variance_Fields>;
};


/** aggregate fields of "bundletoscenarios" */
export type Bundletoscenarios_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "bundletoscenarios" */
export type Bundletoscenarios_Aggregate_Order_By = {
  avg?: InputMaybe<Bundletoscenarios_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Bundletoscenarios_Max_Order_By>;
  min?: InputMaybe<Bundletoscenarios_Min_Order_By>;
  stddev?: InputMaybe<Bundletoscenarios_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Bundletoscenarios_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Bundletoscenarios_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Bundletoscenarios_Sum_Order_By>;
  var_pop?: InputMaybe<Bundletoscenarios_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Bundletoscenarios_Var_Samp_Order_By>;
  variance?: InputMaybe<Bundletoscenarios_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "bundletoscenarios" */
export type Bundletoscenarios_Arr_Rel_Insert_Input = {
  data: Array<Bundletoscenarios_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Bundletoscenarios_On_Conflict>;
};

/** aggregate avg on columns */
export type Bundletoscenarios_Avg_Fields = {
  __typename?: 'bundletoscenarios_avg_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Avg_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "bundletoscenarios". All fields are combined with a logical 'AND'. */
export type Bundletoscenarios_Bool_Exp = {
  _and?: InputMaybe<Array<Bundletoscenarios_Bool_Exp>>;
  _not?: InputMaybe<Bundletoscenarios_Bool_Exp>;
  _or?: InputMaybe<Array<Bundletoscenarios_Bool_Exp>>;
  bundle?: InputMaybe<Bundles_Bool_Exp>;
  bundle_id?: InputMaybe<Bigint_Comparison_Exp>;
  cardinality?: InputMaybe<Smallint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  scenario?: InputMaybe<Scenarios_Bool_Exp>;
  scenario_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "bundletoscenarios" */
export enum Bundletoscenarios_Constraint {
  /** unique or primary key constraint on columns "id" */
  BundletoscenariosPkey = 'bundletoscenarios_pkey'
}

/** input type for incrementing numeric columns in table "bundletoscenarios" */
export type Bundletoscenarios_Inc_Input = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "bundletoscenarios" */
export type Bundletoscenarios_Insert_Input = {
  bundle?: InputMaybe<Bundles_Obj_Rel_Insert_Input>;
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  scenario?: InputMaybe<Scenarios_Obj_Rel_Insert_Input>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Bundletoscenarios_Max_Fields = {
  __typename?: 'bundletoscenarios_max_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['bigint']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Max_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Bundletoscenarios_Min_Fields = {
  __typename?: 'bundletoscenarios_min_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['bigint']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Min_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "bundletoscenarios" */
export type Bundletoscenarios_Mutation_Response = {
  __typename?: 'bundletoscenarios_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Bundletoscenarios>;
};

/** on_conflict condition type for table "bundletoscenarios" */
export type Bundletoscenarios_On_Conflict = {
  constraint: Bundletoscenarios_Constraint;
  update_columns?: Array<Bundletoscenarios_Update_Column>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};

/** Ordering options when selecting data from "bundletoscenarios". */
export type Bundletoscenarios_Order_By = {
  bundle?: InputMaybe<Bundles_Order_By>;
  bundle_id?: InputMaybe<Order_By>;
  cardinality?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Scenarios_Order_By>;
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: bundletoscenarios */
export type Bundletoscenarios_Pk_Columns_Input = {
  /** an auto-incrementing id for the record */
  id: Scalars['bigint']['input'];
};

/** select columns of table "bundletoscenarios" */
export enum Bundletoscenarios_Select_Column {
  /** column name */
  BundleId = 'bundle_id',
  /** column name */
  Cardinality = 'cardinality',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  ScenarioId = 'scenario_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "bundletoscenarios" */
export type Bundletoscenarios_Set_Input = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Bundletoscenarios_Stddev_Fields = {
  __typename?: 'bundletoscenarios_stddev_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Stddev_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Bundletoscenarios_Stddev_Pop_Fields = {
  __typename?: 'bundletoscenarios_stddev_pop_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Stddev_Pop_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Bundletoscenarios_Stddev_Samp_Fields = {
  __typename?: 'bundletoscenarios_stddev_samp_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Stddev_Samp_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "bundletoscenarios" */
export type Bundletoscenarios_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Bundletoscenarios_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Bundletoscenarios_Stream_Cursor_Value_Input = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Bundletoscenarios_Sum_Fields = {
  __typename?: 'bundletoscenarios_sum_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['bigint']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['smallint']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Sum_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** update columns of table "bundletoscenarios" */
export enum Bundletoscenarios_Update_Column {
  /** column name */
  BundleId = 'bundle_id',
  /** column name */
  Cardinality = 'cardinality',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  ScenarioId = 'scenario_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Bundletoscenarios_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Bundletoscenarios_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Bundletoscenarios_Set_Input>;
  /** filter the rows which have to be updated */
  where: Bundletoscenarios_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Bundletoscenarios_Var_Pop_Fields = {
  __typename?: 'bundletoscenarios_var_pop_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Var_Pop_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Bundletoscenarios_Var_Samp_Fields = {
  __typename?: 'bundletoscenarios_var_samp_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Var_Samp_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Bundletoscenarios_Variance_Fields = {
  __typename?: 'bundletoscenarios_variance_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "bundletoscenarios" */
export type Bundletoscenarios_Variance_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** starting with 0 and counting up by 1 to indicate the sequential order the scenarios should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  scenario_id?: InputMaybe<Order_By>;
};

/** Location hours of operations */
export type Businesshours = {
  __typename?: 'businesshours';
  /** Closing time in UTC timestamp with no date */
  closed_time?: Maybe<Scalars['time']['output']>;
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['String']['output'];
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Int']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Int']['output']>;
  id: Scalars['bigint']['output'];
  /** Indicates if the location is open or closed this day */
  is_open: Scalars['Boolean']['output'];
  /** An object relationship */
  location?: Maybe<Locations>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Int']['output']>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name: Scalars['String']['output'];
  /** Opening time in UTC timestamp with no date */
  open_time?: Maybe<Scalars['time']['output']>;
  /** Record type (holiday, one-off, business-hours) */
  type: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by: Scalars['String']['output'];
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Int']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "businesshours" */
export type Businesshours_Aggregate = {
  __typename?: 'businesshours_aggregate';
  aggregate?: Maybe<Businesshours_Aggregate_Fields>;
  nodes: Array<Businesshours>;
};

export type Businesshours_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Businesshours_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Businesshours_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Businesshours_Aggregate_Bool_Exp_Count>;
};

export type Businesshours_Aggregate_Bool_Exp_Bool_And = {
  arguments: Businesshours_Select_Column_Businesshours_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Businesshours_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Businesshours_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Businesshours_Select_Column_Businesshours_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Businesshours_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Businesshours_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Businesshours_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Businesshours_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "businesshours" */
export type Businesshours_Aggregate_Fields = {
  __typename?: 'businesshours_aggregate_fields';
  avg?: Maybe<Businesshours_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Businesshours_Max_Fields>;
  min?: Maybe<Businesshours_Min_Fields>;
  stddev?: Maybe<Businesshours_Stddev_Fields>;
  stddev_pop?: Maybe<Businesshours_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Businesshours_Stddev_Samp_Fields>;
  sum?: Maybe<Businesshours_Sum_Fields>;
  var_pop?: Maybe<Businesshours_Var_Pop_Fields>;
  var_samp?: Maybe<Businesshours_Var_Samp_Fields>;
  variance?: Maybe<Businesshours_Variance_Fields>;
};


/** aggregate fields of "businesshours" */
export type Businesshours_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Businesshours_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "businesshours" */
export type Businesshours_Aggregate_Order_By = {
  avg?: InputMaybe<Businesshours_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Businesshours_Max_Order_By>;
  min?: InputMaybe<Businesshours_Min_Order_By>;
  stddev?: InputMaybe<Businesshours_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Businesshours_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Businesshours_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Businesshours_Sum_Order_By>;
  var_pop?: InputMaybe<Businesshours_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Businesshours_Var_Samp_Order_By>;
  variance?: InputMaybe<Businesshours_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "businesshours" */
export type Businesshours_Arr_Rel_Insert_Input = {
  data: Array<Businesshours_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Businesshours_On_Conflict>;
};

/** aggregate avg on columns */
export type Businesshours_Avg_Fields = {
  __typename?: 'businesshours_avg_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "businesshours" */
export type Businesshours_Avg_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "businesshours". All fields are combined with a logical 'AND'. */
export type Businesshours_Bool_Exp = {
  _and?: InputMaybe<Array<Businesshours_Bool_Exp>>;
  _not?: InputMaybe<Businesshours_Bool_Exp>;
  _or?: InputMaybe<Array<Businesshours_Bool_Exp>>;
  closed_time?: InputMaybe<Time_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  day?: InputMaybe<Int_Comparison_Exp>;
  day_of_week?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  is_open?: InputMaybe<Boolean_Comparison_Exp>;
  location?: InputMaybe<Locations_Bool_Exp>;
  location_id?: InputMaybe<Bigint_Comparison_Exp>;
  month?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  open_time?: InputMaybe<Time_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  week_of_month?: InputMaybe<Int_Comparison_Exp>;
  year?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "businesshours" */
export enum Businesshours_Constraint {
  /** unique or primary key constraint on columns "id" */
  BusinesshoursPkey = 'businesshours_pkey'
}

/** input type for incrementing numeric columns in table "businesshours" */
export type Businesshours_Inc_Input = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Unique id of location */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Scalars['Int']['input']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Scalars['Int']['input']>;
  /** Year (2025) */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "businesshours" */
export type Businesshours_Insert_Input = {
  /** Closing time in UTC timestamp with no date */
  closed_time?: InputMaybe<Scalars['time']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Indicates if the location is open or closed this day */
  is_open?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  /** Unique id of location */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Opening time in UTC timestamp with no date */
  open_time?: InputMaybe<Scalars['time']['input']>;
  /** Record type (holiday, one-off, business-hours) */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Scalars['Int']['input']>;
  /** Year (2025) */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Businesshours_Max_Fields = {
  __typename?: 'businesshours_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Int']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Int']['output']>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: Maybe<Scalars['String']['output']>;
  /** Record type (holiday, one-off, business-hours) */
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Int']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "businesshours" */
export type Businesshours_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: InputMaybe<Order_By>;
  /** Record type (holiday, one-off, business-hours) */
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Businesshours_Min_Fields = {
  __typename?: 'businesshours_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Int']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Int']['output']>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: Maybe<Scalars['String']['output']>;
  /** Record type (holiday, one-off, business-hours) */
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Int']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "businesshours" */
export type Businesshours_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: InputMaybe<Order_By>;
  /** Record type (holiday, one-off, business-hours) */
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "businesshours" */
export type Businesshours_Mutation_Response = {
  __typename?: 'businesshours_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Businesshours>;
};

/** on_conflict condition type for table "businesshours" */
export type Businesshours_On_Conflict = {
  constraint: Businesshours_Constraint;
  update_columns?: Array<Businesshours_Update_Column>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};

/** Ordering options when selecting data from "businesshours". */
export type Businesshours_Order_By = {
  closed_time?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  is_open?: InputMaybe<Order_By>;
  location?: InputMaybe<Locations_Order_By>;
  location_id?: InputMaybe<Order_By>;
  month?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  open_time?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  week_of_month?: InputMaybe<Order_By>;
  year?: InputMaybe<Order_By>;
};

/** primary key columns input for table: businesshours */
export type Businesshours_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "businesshours" */
export enum Businesshours_Select_Column {
  /** column name */
  ClosedTime = 'closed_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Day = 'day',
  /** column name */
  DayOfWeek = 'day_of_week',
  /** column name */
  Id = 'id',
  /** column name */
  IsOpen = 'is_open',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Month = 'month',
  /** column name */
  Name = 'name',
  /** column name */
  OpenTime = 'open_time',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  WeekOfMonth = 'week_of_month',
  /** column name */
  Year = 'year'
}

/** select "businesshours_aggregate_bool_exp_bool_and_arguments_columns" columns of table "businesshours" */
export enum Businesshours_Select_Column_Businesshours_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsOpen = 'is_open'
}

/** select "businesshours_aggregate_bool_exp_bool_or_arguments_columns" columns of table "businesshours" */
export enum Businesshours_Select_Column_Businesshours_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsOpen = 'is_open'
}

/** input type for updating data in table "businesshours" */
export type Businesshours_Set_Input = {
  /** Closing time in UTC timestamp with no date */
  closed_time?: InputMaybe<Scalars['time']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Indicates if the location is open or closed this day */
  is_open?: InputMaybe<Scalars['Boolean']['input']>;
  /** Unique id of location */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Opening time in UTC timestamp with no date */
  open_time?: InputMaybe<Scalars['time']['input']>;
  /** Record type (holiday, one-off, business-hours) */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Scalars['Int']['input']>;
  /** Year (2025) */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Businesshours_Stddev_Fields = {
  __typename?: 'businesshours_stddev_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "businesshours" */
export type Businesshours_Stddev_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Businesshours_Stddev_Pop_Fields = {
  __typename?: 'businesshours_stddev_pop_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "businesshours" */
export type Businesshours_Stddev_Pop_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Businesshours_Stddev_Samp_Fields = {
  __typename?: 'businesshours_stddev_samp_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "businesshours" */
export type Businesshours_Stddev_Samp_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "businesshours" */
export type Businesshours_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Businesshours_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Businesshours_Stream_Cursor_Value_Input = {
  /** Closing time in UTC timestamp with no date */
  closed_time?: InputMaybe<Scalars['time']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Indicates if the location is open or closed this day */
  is_open?: InputMaybe<Scalars['Boolean']['input']>;
  /** Unique id of location */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the record ("Christmas", "Business Hours - Monday", etc) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Opening time in UTC timestamp with no date */
  open_time?: InputMaybe<Scalars['time']['input']>;
  /** Record type (holiday, one-off, business-hours) */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Scalars['Int']['input']>;
  /** Year (2025) */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Businesshours_Sum_Fields = {
  __typename?: 'businesshours_sum_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Int']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Int']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Int']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "businesshours" */
export type Businesshours_Sum_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** update columns of table "businesshours" */
export enum Businesshours_Update_Column {
  /** column name */
  ClosedTime = 'closed_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Day = 'day',
  /** column name */
  DayOfWeek = 'day_of_week',
  /** column name */
  Id = 'id',
  /** column name */
  IsOpen = 'is_open',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Month = 'month',
  /** column name */
  Name = 'name',
  /** column name */
  OpenTime = 'open_time',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  WeekOfMonth = 'week_of_month',
  /** column name */
  Year = 'year'
}

export type Businesshours_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Businesshours_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Businesshours_Set_Input>;
  /** filter the rows which have to be updated */
  where: Businesshours_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Businesshours_Var_Pop_Fields = {
  __typename?: 'businesshours_var_pop_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "businesshours" */
export type Businesshours_Var_Pop_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Businesshours_Var_Samp_Fields = {
  __typename?: 'businesshours_var_samp_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "businesshours" */
export type Businesshours_Var_Samp_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Businesshours_Variance_Fields = {
  __typename?: 'businesshours_variance_fields';
  /** Day of the month (25 for Christmas) */
  day?: Maybe<Scalars['Float']['output']>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of location */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Month of the year (12 for December) */
  month?: Maybe<Scalars['Float']['output']>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: Maybe<Scalars['Float']['output']>;
  /** Year (2025) */
  year?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "businesshours" */
export type Businesshours_Variance_Order_By = {
  /** Day of the month (25 for Christmas) */
  day?: InputMaybe<Order_By>;
  /** Day of the week (0 = Sunday ..... 6 = Saturday) */
  day_of_week?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Unique id of location */
  location_id?: InputMaybe<Order_By>;
  /** Month of the year (12 for December) */
  month?: InputMaybe<Order_By>;
  /** Week of the month (0 = first week of month ...... 4 = last week of month) */
  week_of_month?: InputMaybe<Order_By>;
  /** Year (2025) */
  year?: InputMaybe<Order_By>;
};

/** columns and relationships of "businessrules" */
export type Businessrules = {
  __typename?: 'businessrules';
  active: Scalars['Boolean']['output'];
  createdat: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  jsonb: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  ruletype: Businessruletypes;
  type: Scalars['Int']['output'];
  updatedat: Scalars['timestamptz']['output'];
};


/** columns and relationships of "businessrules" */
export type BusinessrulesJsonbArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "businessrules" */
export type Businessrules_Aggregate = {
  __typename?: 'businessrules_aggregate';
  aggregate?: Maybe<Businessrules_Aggregate_Fields>;
  nodes: Array<Businessrules>;
};

export type Businessrules_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Businessrules_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Businessrules_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Businessrules_Aggregate_Bool_Exp_Count>;
};

export type Businessrules_Aggregate_Bool_Exp_Bool_And = {
  arguments: Businessrules_Select_Column_Businessrules_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Businessrules_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Businessrules_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Businessrules_Select_Column_Businessrules_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Businessrules_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Businessrules_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Businessrules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Businessrules_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "businessrules" */
export type Businessrules_Aggregate_Fields = {
  __typename?: 'businessrules_aggregate_fields';
  avg?: Maybe<Businessrules_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Businessrules_Max_Fields>;
  min?: Maybe<Businessrules_Min_Fields>;
  stddev?: Maybe<Businessrules_Stddev_Fields>;
  stddev_pop?: Maybe<Businessrules_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Businessrules_Stddev_Samp_Fields>;
  sum?: Maybe<Businessrules_Sum_Fields>;
  var_pop?: Maybe<Businessrules_Var_Pop_Fields>;
  var_samp?: Maybe<Businessrules_Var_Samp_Fields>;
  variance?: Maybe<Businessrules_Variance_Fields>;
};


/** aggregate fields of "businessrules" */
export type Businessrules_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Businessrules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "businessrules" */
export type Businessrules_Aggregate_Order_By = {
  avg?: InputMaybe<Businessrules_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Businessrules_Max_Order_By>;
  min?: InputMaybe<Businessrules_Min_Order_By>;
  stddev?: InputMaybe<Businessrules_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Businessrules_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Businessrules_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Businessrules_Sum_Order_By>;
  var_pop?: InputMaybe<Businessrules_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Businessrules_Var_Samp_Order_By>;
  variance?: InputMaybe<Businessrules_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Businessrules_Append_Input = {
  jsonb?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "businessrules" */
export type Businessrules_Arr_Rel_Insert_Input = {
  data: Array<Businessrules_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Businessrules_On_Conflict>;
};

/** aggregate avg on columns */
export type Businessrules_Avg_Fields = {
  __typename?: 'businessrules_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "businessrules" */
export type Businessrules_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "businessrules". All fields are combined with a logical 'AND'. */
export type Businessrules_Bool_Exp = {
  _and?: InputMaybe<Array<Businessrules_Bool_Exp>>;
  _not?: InputMaybe<Businessrules_Bool_Exp>;
  _or?: InputMaybe<Array<Businessrules_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  jsonb?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ruletype?: InputMaybe<Businessruletypes_Bool_Exp>;
  type?: InputMaybe<Int_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "businessrules" */
export enum Businessrules_Constraint {
  /** unique or primary key constraint on columns "id" */
  BusinessrulesPkey = 'businessrules_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Businessrules_Delete_At_Path_Input = {
  jsonb?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Businessrules_Delete_Elem_Input = {
  jsonb?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Businessrules_Delete_Key_Input = {
  jsonb?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "businessrules" */
export type Businessrules_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "businessrules" */
export type Businessrules_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  jsonb?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ruletype?: InputMaybe<Businessruletypes_Obj_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['Int']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Businessrules_Max_Fields = {
  __typename?: 'businessrules_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['Int']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "businessrules" */
export type Businessrules_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Businessrules_Min_Fields = {
  __typename?: 'businessrules_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['Int']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "businessrules" */
export type Businessrules_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "businessrules" */
export type Businessrules_Mutation_Response = {
  __typename?: 'businessrules_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Businessrules>;
};

/** input type for inserting object relation for remote table "businessrules" */
export type Businessrules_Obj_Rel_Insert_Input = {
  data: Businessrules_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Businessrules_On_Conflict>;
};

/** on_conflict condition type for table "businessrules" */
export type Businessrules_On_Conflict = {
  constraint: Businessrules_Constraint;
  update_columns?: Array<Businessrules_Update_Column>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};

/** Ordering options when selecting data from "businessrules". */
export type Businessrules_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  jsonb?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ruletype?: InputMaybe<Businessruletypes_Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: businessrules */
export type Businessrules_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Businessrules_Prepend_Input = {
  jsonb?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "businessrules" */
export enum Businessrules_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Jsonb = 'jsonb',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** select "businessrules_aggregate_bool_exp_bool_and_arguments_columns" columns of table "businessrules" */
export enum Businessrules_Select_Column_Businessrules_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** select "businessrules_aggregate_bool_exp_bool_or_arguments_columns" columns of table "businessrules" */
export enum Businessrules_Select_Column_Businessrules_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** input type for updating data in table "businessrules" */
export type Businessrules_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  jsonb?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['Int']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Businessrules_Stddev_Fields = {
  __typename?: 'businessrules_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "businessrules" */
export type Businessrules_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Businessrules_Stddev_Pop_Fields = {
  __typename?: 'businessrules_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "businessrules" */
export type Businessrules_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Businessrules_Stddev_Samp_Fields = {
  __typename?: 'businessrules_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "businessrules" */
export type Businessrules_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "businessrules" */
export type Businessrules_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Businessrules_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Businessrules_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  jsonb?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['Int']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Businessrules_Sum_Fields = {
  __typename?: 'businessrules_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "businessrules" */
export type Businessrules_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** update columns of table "businessrules" */
export enum Businessrules_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Jsonb = 'jsonb',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Businessrules_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Businessrules_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Businessrules_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Businessrules_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Businessrules_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Businessrules_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Businessrules_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Businessrules_Set_Input>;
  /** filter the rows which have to be updated */
  where: Businessrules_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Businessrules_Var_Pop_Fields = {
  __typename?: 'businessrules_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "businessrules" */
export type Businessrules_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Businessrules_Var_Samp_Fields = {
  __typename?: 'businessrules_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "businessrules" */
export type Businessrules_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Businessrules_Variance_Fields = {
  __typename?: 'businessrules_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  type?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "businessrules" */
export type Businessrules_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** columns and relationships of "businessruletypes" */
export type Businessruletypes = {
  __typename?: 'businessruletypes';
  active: Scalars['Boolean']['output'];
  /** An array relationship */
  businessrules: Array<Businessrules>;
  /** An aggregate relationship */
  businessrules_aggregate: Businessrules_Aggregate;
  createdat: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
};


/** columns and relationships of "businessruletypes" */
export type BusinessruletypesBusinessrulesArgs = {
  distinct_on?: InputMaybe<Array<Businessrules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessrules_Order_By>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};


/** columns and relationships of "businessruletypes" */
export type BusinessruletypesBusinessrules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businessrules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessrules_Order_By>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};

/** aggregated selection of "businessruletypes" */
export type Businessruletypes_Aggregate = {
  __typename?: 'businessruletypes_aggregate';
  aggregate?: Maybe<Businessruletypes_Aggregate_Fields>;
  nodes: Array<Businessruletypes>;
};

/** aggregate fields of "businessruletypes" */
export type Businessruletypes_Aggregate_Fields = {
  __typename?: 'businessruletypes_aggregate_fields';
  avg?: Maybe<Businessruletypes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Businessruletypes_Max_Fields>;
  min?: Maybe<Businessruletypes_Min_Fields>;
  stddev?: Maybe<Businessruletypes_Stddev_Fields>;
  stddev_pop?: Maybe<Businessruletypes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Businessruletypes_Stddev_Samp_Fields>;
  sum?: Maybe<Businessruletypes_Sum_Fields>;
  var_pop?: Maybe<Businessruletypes_Var_Pop_Fields>;
  var_samp?: Maybe<Businessruletypes_Var_Samp_Fields>;
  variance?: Maybe<Businessruletypes_Variance_Fields>;
};


/** aggregate fields of "businessruletypes" */
export type Businessruletypes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Businessruletypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Businessruletypes_Avg_Fields = {
  __typename?: 'businessruletypes_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "businessruletypes". All fields are combined with a logical 'AND'. */
export type Businessruletypes_Bool_Exp = {
  _and?: InputMaybe<Array<Businessruletypes_Bool_Exp>>;
  _not?: InputMaybe<Businessruletypes_Bool_Exp>;
  _or?: InputMaybe<Array<Businessruletypes_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  businessrules?: InputMaybe<Businessrules_Bool_Exp>;
  businessrules_aggregate?: InputMaybe<Businessrules_Aggregate_Bool_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "businessruletypes" */
export enum Businessruletypes_Constraint {
  /** unique or primary key constraint on columns "id" */
  BusinessruletypesPkey = 'businessruletypes_pkey'
}

/** input type for incrementing numeric columns in table "businessruletypes" */
export type Businessruletypes_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "businessruletypes" */
export type Businessruletypes_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  businessrules?: InputMaybe<Businessrules_Arr_Rel_Insert_Input>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Businessruletypes_Max_Fields = {
  __typename?: 'businessruletypes_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Businessruletypes_Min_Fields = {
  __typename?: 'businessruletypes_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "businessruletypes" */
export type Businessruletypes_Mutation_Response = {
  __typename?: 'businessruletypes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Businessruletypes>;
};

/** input type for inserting object relation for remote table "businessruletypes" */
export type Businessruletypes_Obj_Rel_Insert_Input = {
  data: Businessruletypes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Businessruletypes_On_Conflict>;
};

/** on_conflict condition type for table "businessruletypes" */
export type Businessruletypes_On_Conflict = {
  constraint: Businessruletypes_Constraint;
  update_columns?: Array<Businessruletypes_Update_Column>;
  where?: InputMaybe<Businessruletypes_Bool_Exp>;
};

/** Ordering options when selecting data from "businessruletypes". */
export type Businessruletypes_Order_By = {
  active?: InputMaybe<Order_By>;
  businessrules_aggregate?: InputMaybe<Businessrules_Aggregate_Order_By>;
  createdat?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: businessruletypes */
export type Businessruletypes_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "businessruletypes" */
export enum Businessruletypes_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "businessruletypes" */
export type Businessruletypes_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Businessruletypes_Stddev_Fields = {
  __typename?: 'businessruletypes_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Businessruletypes_Stddev_Pop_Fields = {
  __typename?: 'businessruletypes_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Businessruletypes_Stddev_Samp_Fields = {
  __typename?: 'businessruletypes_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "businessruletypes" */
export type Businessruletypes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Businessruletypes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Businessruletypes_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Businessruletypes_Sum_Fields = {
  __typename?: 'businessruletypes_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "businessruletypes" */
export enum Businessruletypes_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Updatedat = 'updatedat'
}

export type Businessruletypes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Businessruletypes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Businessruletypes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Businessruletypes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Businessruletypes_Var_Pop_Fields = {
  __typename?: 'businessruletypes_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Businessruletypes_Var_Samp_Fields = {
  __typename?: 'businessruletypes_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Businessruletypes_Variance_Fields = {
  __typename?: 'businessruletypes_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type Certifications = {
  __typename?: 'certifications';
  /** An array relationship */
  certifications_customerstocertifications: Array<Customerstocertifications>;
  /** An aggregate relationship */
  certifications_customerstocertifications_aggregate: Customerstocertifications_Aggregate;
  /** An array relationship */
  certifications_driverstocertifications: Array<Driverstocertifications>;
  /** An aggregate relationship */
  certifications_driverstocertifications_aggregate: Driverstocertifications_Aggregate;
  /** An array relationship */
  certifications_locationstocertifications: Array<Locationstocertifications>;
  /** An aggregate relationship */
  certifications_locationstocertifications_aggregate: Locationstocertifications_Aggregate;
  /** An array relationship */
  certifications_organizationstocertifications: Array<Organizationstocertifications>;
  /** An aggregate relationship */
  certifications_organizationstocertifications_aggregate: Organizationstocertifications_Aggregate;
  /** An array relationship */
  certifications_scenariotypestocertifications: Array<Scenariotypestocertifications>;
  /** An aggregate relationship */
  certifications_scenariotypestocertifications_aggregate: Scenariotypestocertifications_Aggregate;
  /** An array relationship */
  certifications_usecasetocertifications: Array<Usecasetocertifications>;
  /** An aggregate relationship */
  certifications_usecasetocertifications_aggregate: Usecasetocertifications_Aggregate;
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** a short-form description to provide context as to why it is different from others. Tooltips or card views would show this as non-bold text under the bolded name. */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** optional full text notes field here supporting markdown syntax like we do in locations table. Enable this to be real time searched on the table index view of certification so people have a better chance of not creating duplicate certs. */
  notes?: Maybe<Scalars['String']['output']>;
  /** true if the author must upload some documents when granting this certification. */
  requires_documents: Scalars['Boolean']['output'];
  /** true if the certification must have effective and expiration dates provided when issued */
  requires_expiration: Scalars['Boolean']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_CustomerstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customerstocertifications_Order_By>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_Customerstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customerstocertifications_Order_By>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_DriverstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_Driverstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_LocationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_Locationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_OrganizationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_Organizationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_ScenariotypestocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_Scenariotypestocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_UsecasetocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


/** A master list of all certifications (regulatory or training based) to be created and maintained by operations. */
export type CertificationsCertifications_Usecasetocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};

/** aggregated selection of "certifications" */
export type Certifications_Aggregate = {
  __typename?: 'certifications_aggregate';
  aggregate?: Maybe<Certifications_Aggregate_Fields>;
  nodes: Array<Certifications>;
};

/** aggregate fields of "certifications" */
export type Certifications_Aggregate_Fields = {
  __typename?: 'certifications_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Certifications_Max_Fields>;
  min?: Maybe<Certifications_Min_Fields>;
};


/** aggregate fields of "certifications" */
export type Certifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Certifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "certifications". All fields are combined with a logical 'AND'. */
export type Certifications_Bool_Exp = {
  _and?: InputMaybe<Array<Certifications_Bool_Exp>>;
  _not?: InputMaybe<Certifications_Bool_Exp>;
  _or?: InputMaybe<Array<Certifications_Bool_Exp>>;
  certifications_customerstocertifications?: InputMaybe<Customerstocertifications_Bool_Exp>;
  certifications_customerstocertifications_aggregate?: InputMaybe<Customerstocertifications_Aggregate_Bool_Exp>;
  certifications_driverstocertifications?: InputMaybe<Driverstocertifications_Bool_Exp>;
  certifications_driverstocertifications_aggregate?: InputMaybe<Driverstocertifications_Aggregate_Bool_Exp>;
  certifications_locationstocertifications?: InputMaybe<Locationstocertifications_Bool_Exp>;
  certifications_locationstocertifications_aggregate?: InputMaybe<Locationstocertifications_Aggregate_Bool_Exp>;
  certifications_organizationstocertifications?: InputMaybe<Organizationstocertifications_Bool_Exp>;
  certifications_organizationstocertifications_aggregate?: InputMaybe<Organizationstocertifications_Aggregate_Bool_Exp>;
  certifications_scenariotypestocertifications?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
  certifications_scenariotypestocertifications_aggregate?: InputMaybe<Scenariotypestocertifications_Aggregate_Bool_Exp>;
  certifications_usecasetocertifications?: InputMaybe<Usecasetocertifications_Bool_Exp>;
  certifications_usecasetocertifications_aggregate?: InputMaybe<Usecasetocertifications_Aggregate_Bool_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  key?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  requires_documents?: InputMaybe<Boolean_Comparison_Exp>;
  requires_expiration?: InputMaybe<Boolean_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "certifications" */
export enum Certifications_Constraint {
  /** unique or primary key constraint on columns "key" */
  CertificationsPkey = 'certifications_pkey'
}

/** input type for inserting data into table "certifications" */
export type Certifications_Insert_Input = {
  certifications_customerstocertifications?: InputMaybe<Customerstocertifications_Arr_Rel_Insert_Input>;
  certifications_driverstocertifications?: InputMaybe<Driverstocertifications_Arr_Rel_Insert_Input>;
  certifications_locationstocertifications?: InputMaybe<Locationstocertifications_Arr_Rel_Insert_Input>;
  certifications_organizationstocertifications?: InputMaybe<Organizationstocertifications_Arr_Rel_Insert_Input>;
  certifications_scenariotypestocertifications?: InputMaybe<Scenariotypestocertifications_Arr_Rel_Insert_Input>;
  certifications_usecasetocertifications?: InputMaybe<Usecasetocertifications_Arr_Rel_Insert_Input>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a short-form description to provide context as to why it is different from others. Tooltips or card views would show this as non-bold text under the bolded name. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** optional full text notes field here supporting markdown syntax like we do in locations table. Enable this to be real time searched on the table index view of certification so people have a better chance of not creating duplicate certs. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** true if the author must upload some documents when granting this certification. */
  requires_documents?: InputMaybe<Scalars['Boolean']['input']>;
  /** true if the certification must have effective and expiration dates provided when issued */
  requires_expiration?: InputMaybe<Scalars['Boolean']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Certifications_Max_Fields = {
  __typename?: 'certifications_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** a short-form description to provide context as to why it is different from others. Tooltips or card views would show this as non-bold text under the bolded name. */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** optional full text notes field here supporting markdown syntax like we do in locations table. Enable this to be real time searched on the table index view of certification so people have a better chance of not creating duplicate certs. */
  notes?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Certifications_Min_Fields = {
  __typename?: 'certifications_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** a short-form description to provide context as to why it is different from others. Tooltips or card views would show this as non-bold text under the bolded name. */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** optional full text notes field here supporting markdown syntax like we do in locations table. Enable this to be real time searched on the table index view of certification so people have a better chance of not creating duplicate certs. */
  notes?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "certifications" */
export type Certifications_Mutation_Response = {
  __typename?: 'certifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Certifications>;
};

/** input type for inserting object relation for remote table "certifications" */
export type Certifications_Obj_Rel_Insert_Input = {
  data: Certifications_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Certifications_On_Conflict>;
};

/** on_conflict condition type for table "certifications" */
export type Certifications_On_Conflict = {
  constraint: Certifications_Constraint;
  update_columns?: Array<Certifications_Update_Column>;
  where?: InputMaybe<Certifications_Bool_Exp>;
};

/** Ordering options when selecting data from "certifications". */
export type Certifications_Order_By = {
  certifications_customerstocertifications_aggregate?: InputMaybe<Customerstocertifications_Aggregate_Order_By>;
  certifications_driverstocertifications_aggregate?: InputMaybe<Driverstocertifications_Aggregate_Order_By>;
  certifications_locationstocertifications_aggregate?: InputMaybe<Locationstocertifications_Aggregate_Order_By>;
  certifications_organizationstocertifications_aggregate?: InputMaybe<Organizationstocertifications_Aggregate_Order_By>;
  certifications_scenariotypestocertifications_aggregate?: InputMaybe<Scenariotypestocertifications_Aggregate_Order_By>;
  certifications_usecasetocertifications_aggregate?: InputMaybe<Usecasetocertifications_Aggregate_Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  key?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  requires_documents?: InputMaybe<Order_By>;
  requires_expiration?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: certifications */
export type Certifications_Pk_Columns_Input = {
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['input'];
};

/** select columns of table "certifications" */
export enum Certifications_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  RequiresDocuments = 'requires_documents',
  /** column name */
  RequiresExpiration = 'requires_expiration',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "certifications" */
export type Certifications_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a short-form description to provide context as to why it is different from others. Tooltips or card views would show this as non-bold text under the bolded name. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** optional full text notes field here supporting markdown syntax like we do in locations table. Enable this to be real time searched on the table index view of certification so people have a better chance of not creating duplicate certs. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** true if the author must upload some documents when granting this certification. */
  requires_documents?: InputMaybe<Scalars['Boolean']['input']>;
  /** true if the certification must have effective and expiration dates provided when issued */
  requires_expiration?: InputMaybe<Scalars['Boolean']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "certifications" */
export type Certifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Certifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Certifications_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a short-form description to provide context as to why it is different from others. Tooltips or card views would show this as non-bold text under the bolded name. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** optional full text notes field here supporting markdown syntax like we do in locations table. Enable this to be real time searched on the table index view of certification so people have a better chance of not creating duplicate certs. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** true if the author must upload some documents when granting this certification. */
  requires_documents?: InputMaybe<Scalars['Boolean']['input']>;
  /** true if the certification must have effective and expiration dates provided when issued */
  requires_expiration?: InputMaybe<Scalars['Boolean']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "certifications" */
export enum Certifications_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  RequiresDocuments = 'requires_documents',
  /** column name */
  RequiresExpiration = 'requires_expiration',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Certifications_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Certifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Certifications_Bool_Exp;
};

/** Master list of all vehicles that have been used as chase vehicles */
export type Chasevehicles = {
  __typename?: 'chasevehicles';
  capacity?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  make: Scalars['String']['output'];
  model: Scalars['String']['output'];
  vin: Scalars['String']['output'];
};

/** aggregated selection of "chasevehicles" */
export type Chasevehicles_Aggregate = {
  __typename?: 'chasevehicles_aggregate';
  aggregate?: Maybe<Chasevehicles_Aggregate_Fields>;
  nodes: Array<Chasevehicles>;
};

/** aggregate fields of "chasevehicles" */
export type Chasevehicles_Aggregate_Fields = {
  __typename?: 'chasevehicles_aggregate_fields';
  avg?: Maybe<Chasevehicles_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Chasevehicles_Max_Fields>;
  min?: Maybe<Chasevehicles_Min_Fields>;
  stddev?: Maybe<Chasevehicles_Stddev_Fields>;
  stddev_pop?: Maybe<Chasevehicles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Chasevehicles_Stddev_Samp_Fields>;
  sum?: Maybe<Chasevehicles_Sum_Fields>;
  var_pop?: Maybe<Chasevehicles_Var_Pop_Fields>;
  var_samp?: Maybe<Chasevehicles_Var_Samp_Fields>;
  variance?: Maybe<Chasevehicles_Variance_Fields>;
};


/** aggregate fields of "chasevehicles" */
export type Chasevehicles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Chasevehicles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Chasevehicles_Avg_Fields = {
  __typename?: 'chasevehicles_avg_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "chasevehicles". All fields are combined with a logical 'AND'. */
export type Chasevehicles_Bool_Exp = {
  _and?: InputMaybe<Array<Chasevehicles_Bool_Exp>>;
  _not?: InputMaybe<Chasevehicles_Bool_Exp>;
  _or?: InputMaybe<Array<Chasevehicles_Bool_Exp>>;
  capacity?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  make?: InputMaybe<String_Comparison_Exp>;
  model?: InputMaybe<String_Comparison_Exp>;
  vin?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chasevehicles" */
export enum Chasevehicles_Constraint {
  /** unique or primary key constraint on columns "id" */
  ChasevehiclesPkey = 'chasevehicles_pkey',
  /** unique or primary key constraint on columns "vin" */
  ChasevehiclesVinKey = 'chasevehicles_vin_key'
}

/** input type for incrementing numeric columns in table "chasevehicles" */
export type Chasevehicles_Inc_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "chasevehicles" */
export type Chasevehicles_Insert_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  make?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Chasevehicles_Max_Fields = {
  __typename?: 'chasevehicles_max_fields';
  capacity?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  make?: Maybe<Scalars['String']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Chasevehicles_Min_Fields = {
  __typename?: 'chasevehicles_min_fields';
  capacity?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  make?: Maybe<Scalars['String']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "chasevehicles" */
export type Chasevehicles_Mutation_Response = {
  __typename?: 'chasevehicles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Chasevehicles>;
};

/** input type for inserting object relation for remote table "chasevehicles" */
export type Chasevehicles_Obj_Rel_Insert_Input = {
  data: Chasevehicles_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Chasevehicles_On_Conflict>;
};

/** on_conflict condition type for table "chasevehicles" */
export type Chasevehicles_On_Conflict = {
  constraint: Chasevehicles_Constraint;
  update_columns?: Array<Chasevehicles_Update_Column>;
  where?: InputMaybe<Chasevehicles_Bool_Exp>;
};

/** Ordering options when selecting data from "chasevehicles". */
export type Chasevehicles_Order_By = {
  capacity?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  make?: InputMaybe<Order_By>;
  model?: InputMaybe<Order_By>;
  vin?: InputMaybe<Order_By>;
};

/** primary key columns input for table: chasevehicles */
export type Chasevehicles_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "chasevehicles" */
export enum Chasevehicles_Select_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  Id = 'id',
  /** column name */
  Make = 'make',
  /** column name */
  Model = 'model',
  /** column name */
  Vin = 'vin'
}

/** input type for updating data in table "chasevehicles" */
export type Chasevehicles_Set_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  make?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Chasevehicles_Stddev_Fields = {
  __typename?: 'chasevehicles_stddev_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Chasevehicles_Stddev_Pop_Fields = {
  __typename?: 'chasevehicles_stddev_pop_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Chasevehicles_Stddev_Samp_Fields = {
  __typename?: 'chasevehicles_stddev_samp_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "chasevehicles" */
export type Chasevehicles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Chasevehicles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Chasevehicles_Stream_Cursor_Value_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  make?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Chasevehicles_Sum_Fields = {
  __typename?: 'chasevehicles_sum_fields';
  capacity?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "chasevehicles" */
export enum Chasevehicles_Update_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  Id = 'id',
  /** column name */
  Make = 'make',
  /** column name */
  Model = 'model',
  /** column name */
  Vin = 'vin'
}

export type Chasevehicles_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Chasevehicles_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Chasevehicles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Chasevehicles_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Chasevehicles_Var_Pop_Fields = {
  __typename?: 'chasevehicles_var_pop_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Chasevehicles_Var_Samp_Fields = {
  __typename?: 'chasevehicles_var_samp_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Chasevehicles_Variance_Fields = {
  __typename?: 'chasevehicles_variance_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "chasevehiclesassigned" */
export type Chasevehiclesassigned = {
  __typename?: 'chasevehiclesassigned';
  capacity: Scalars['bigint']['output'];
  chase_vehicle_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  chasevehicle?: Maybe<Chasevehicles>;
  config?: Maybe<Scalars['jsonb']['output']>;
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  first_move_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  last_driver_id?: Maybe<Scalars['bigint']['output']>;
  last_location_id?: Maybe<Scalars['bigint']['output']>;
  last_move_id?: Maybe<Scalars['bigint']['output']>;
  make?: Maybe<Scalars['String']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  organization?: Maybe<Organizations>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  plan_date?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id: Scalars['bigint']['output'];
  /** Either received or returned */
  status: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "chasevehiclesassigned" */
export type ChasevehiclesassignedConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "chasevehiclesassigned" */
export type Chasevehiclesassigned_Aggregate = {
  __typename?: 'chasevehiclesassigned_aggregate';
  aggregate?: Maybe<Chasevehiclesassigned_Aggregate_Fields>;
  nodes: Array<Chasevehiclesassigned>;
};

/** aggregate fields of "chasevehiclesassigned" */
export type Chasevehiclesassigned_Aggregate_Fields = {
  __typename?: 'chasevehiclesassigned_aggregate_fields';
  avg?: Maybe<Chasevehiclesassigned_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Chasevehiclesassigned_Max_Fields>;
  min?: Maybe<Chasevehiclesassigned_Min_Fields>;
  stddev?: Maybe<Chasevehiclesassigned_Stddev_Fields>;
  stddev_pop?: Maybe<Chasevehiclesassigned_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Chasevehiclesassigned_Stddev_Samp_Fields>;
  sum?: Maybe<Chasevehiclesassigned_Sum_Fields>;
  var_pop?: Maybe<Chasevehiclesassigned_Var_Pop_Fields>;
  var_samp?: Maybe<Chasevehiclesassigned_Var_Samp_Fields>;
  variance?: Maybe<Chasevehiclesassigned_Variance_Fields>;
};


/** aggregate fields of "chasevehiclesassigned" */
export type Chasevehiclesassigned_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Chasevehiclesassigned_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chasevehiclesassigned_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Chasevehiclesassigned_Avg_Fields = {
  __typename?: 'chasevehiclesassigned_avg_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "chasevehiclesassigned". All fields are combined with a logical 'AND'. */
export type Chasevehiclesassigned_Bool_Exp = {
  _and?: InputMaybe<Array<Chasevehiclesassigned_Bool_Exp>>;
  _not?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
  _or?: InputMaybe<Array<Chasevehiclesassigned_Bool_Exp>>;
  capacity?: InputMaybe<Bigint_Comparison_Exp>;
  chase_vehicle_id?: InputMaybe<Bigint_Comparison_Exp>;
  chasevehicle?: InputMaybe<Chasevehicles_Bool_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  first_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  last_driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  last_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  last_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  make?: InputMaybe<String_Comparison_Exp>;
  model?: InputMaybe<String_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  plan_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  vin?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chasevehiclesassigned" */
export enum Chasevehiclesassigned_Constraint {
  /** unique or primary key constraint on columns "id" */
  ChasevehiclesassignedPkey = 'chasevehiclesassigned_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chasevehiclesassigned_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chasevehiclesassigned_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chasevehiclesassigned_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "chasevehiclesassigned" */
export type Chasevehiclesassigned_Inc_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  chase_vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  first_move_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_driver_id?: InputMaybe<Scalars['bigint']['input']>;
  last_location_id?: InputMaybe<Scalars['bigint']['input']>;
  last_move_id?: InputMaybe<Scalars['bigint']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "chasevehiclesassigned" */
export type Chasevehiclesassigned_Insert_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  chase_vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  chasevehicle?: InputMaybe<Chasevehicles_Obj_Rel_Insert_Input>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  first_move_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_driver_id?: InputMaybe<Scalars['bigint']['input']>;
  last_location_id?: InputMaybe<Scalars['bigint']['input']>;
  last_move_id?: InputMaybe<Scalars['bigint']['input']>;
  make?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  plan_date?: InputMaybe<Scalars['timestamptz']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Either received or returned */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Chasevehiclesassigned_Max_Fields = {
  __typename?: 'chasevehiclesassigned_max_fields';
  capacity?: Maybe<Scalars['bigint']['output']>;
  chase_vehicle_id?: Maybe<Scalars['bigint']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  first_move_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_driver_id?: Maybe<Scalars['bigint']['output']>;
  last_location_id?: Maybe<Scalars['bigint']['output']>;
  last_move_id?: Maybe<Scalars['bigint']['output']>;
  make?: Maybe<Scalars['String']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  plan_date?: Maybe<Scalars['timestamptz']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Either received or returned */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Chasevehiclesassigned_Min_Fields = {
  __typename?: 'chasevehiclesassigned_min_fields';
  capacity?: Maybe<Scalars['bigint']['output']>;
  chase_vehicle_id?: Maybe<Scalars['bigint']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  first_move_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_driver_id?: Maybe<Scalars['bigint']['output']>;
  last_location_id?: Maybe<Scalars['bigint']['output']>;
  last_move_id?: Maybe<Scalars['bigint']['output']>;
  make?: Maybe<Scalars['String']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  plan_date?: Maybe<Scalars['timestamptz']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Either received or returned */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  vin?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "chasevehiclesassigned" */
export type Chasevehiclesassigned_Mutation_Response = {
  __typename?: 'chasevehiclesassigned_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Chasevehiclesassigned>;
};

/** on_conflict condition type for table "chasevehiclesassigned" */
export type Chasevehiclesassigned_On_Conflict = {
  constraint: Chasevehiclesassigned_Constraint;
  update_columns?: Array<Chasevehiclesassigned_Update_Column>;
  where?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
};

/** Ordering options when selecting data from "chasevehiclesassigned". */
export type Chasevehiclesassigned_Order_By = {
  capacity?: InputMaybe<Order_By>;
  chase_vehicle_id?: InputMaybe<Order_By>;
  chasevehicle?: InputMaybe<Chasevehicles_Order_By>;
  config?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  first_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_driver_id?: InputMaybe<Order_By>;
  last_location_id?: InputMaybe<Order_By>;
  last_move_id?: InputMaybe<Order_By>;
  make?: InputMaybe<Order_By>;
  model?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  plan_date?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  vin?: InputMaybe<Order_By>;
};

/** primary key columns input for table: chasevehiclesassigned */
export type Chasevehiclesassigned_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chasevehiclesassigned_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "chasevehiclesassigned" */
export enum Chasevehiclesassigned_Select_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChaseVehicleId = 'chase_vehicle_id',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  FirstMoveId = 'first_move_id',
  /** column name */
  Id = 'id',
  /** column name */
  LastDriverId = 'last_driver_id',
  /** column name */
  LastLocationId = 'last_location_id',
  /** column name */
  LastMoveId = 'last_move_id',
  /** column name */
  Make = 'make',
  /** column name */
  Model = 'model',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PlanDate = 'plan_date',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  Vin = 'vin'
}

/** input type for updating data in table "chasevehiclesassigned" */
export type Chasevehiclesassigned_Set_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  chase_vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  first_move_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_driver_id?: InputMaybe<Scalars['bigint']['input']>;
  last_location_id?: InputMaybe<Scalars['bigint']['input']>;
  last_move_id?: InputMaybe<Scalars['bigint']['input']>;
  make?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  plan_date?: InputMaybe<Scalars['timestamptz']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Either received or returned */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Chasevehiclesassigned_Stddev_Fields = {
  __typename?: 'chasevehiclesassigned_stddev_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Chasevehiclesassigned_Stddev_Pop_Fields = {
  __typename?: 'chasevehiclesassigned_stddev_pop_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Chasevehiclesassigned_Stddev_Samp_Fields = {
  __typename?: 'chasevehiclesassigned_stddev_samp_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "chasevehiclesassigned" */
export type Chasevehiclesassigned_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Chasevehiclesassigned_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Chasevehiclesassigned_Stream_Cursor_Value_Input = {
  capacity?: InputMaybe<Scalars['bigint']['input']>;
  chase_vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  first_move_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_driver_id?: InputMaybe<Scalars['bigint']['input']>;
  last_location_id?: InputMaybe<Scalars['bigint']['input']>;
  last_move_id?: InputMaybe<Scalars['bigint']['input']>;
  make?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  plan_date?: InputMaybe<Scalars['timestamptz']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Either received or returned */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  vin?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Chasevehiclesassigned_Sum_Fields = {
  __typename?: 'chasevehiclesassigned_sum_fields';
  capacity?: Maybe<Scalars['bigint']['output']>;
  chase_vehicle_id?: Maybe<Scalars['bigint']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  first_move_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_driver_id?: Maybe<Scalars['bigint']['output']>;
  last_location_id?: Maybe<Scalars['bigint']['output']>;
  last_move_id?: Maybe<Scalars['bigint']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "chasevehiclesassigned" */
export enum Chasevehiclesassigned_Update_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChaseVehicleId = 'chase_vehicle_id',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  FirstMoveId = 'first_move_id',
  /** column name */
  Id = 'id',
  /** column name */
  LastDriverId = 'last_driver_id',
  /** column name */
  LastLocationId = 'last_location_id',
  /** column name */
  LastMoveId = 'last_move_id',
  /** column name */
  Make = 'make',
  /** column name */
  Model = 'model',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PlanDate = 'plan_date',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  Vin = 'vin'
}

export type Chasevehiclesassigned_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Chasevehiclesassigned_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Chasevehiclesassigned_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Chasevehiclesassigned_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Chasevehiclesassigned_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Chasevehiclesassigned_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Chasevehiclesassigned_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Chasevehiclesassigned_Set_Input>;
  /** filter the rows which have to be updated */
  where: Chasevehiclesassigned_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Chasevehiclesassigned_Var_Pop_Fields = {
  __typename?: 'chasevehiclesassigned_var_pop_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Chasevehiclesassigned_Var_Samp_Fields = {
  __typename?: 'chasevehiclesassigned_var_samp_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Chasevehiclesassigned_Variance_Fields = {
  __typename?: 'chasevehiclesassigned_variance_fields';
  capacity?: Maybe<Scalars['Float']['output']>;
  chase_vehicle_id?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  first_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  last_driver_id?: Maybe<Scalars['Float']['output']>;
  last_location_id?: Maybe<Scalars['Float']['output']>;
  last_move_id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "consumer_numbers" */
export type Consumer_Numbers = {
  __typename?: 'consumer_numbers';
  alt_formats?: Maybe<Scalars['String']['output']>;
  createdat: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  is_mobile: Scalars['Boolean']['output'];
  number: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "consumer_numbers" */
export type Consumer_Numbers_Aggregate = {
  __typename?: 'consumer_numbers_aggregate';
  aggregate?: Maybe<Consumer_Numbers_Aggregate_Fields>;
  nodes: Array<Consumer_Numbers>;
};

/** aggregate fields of "consumer_numbers" */
export type Consumer_Numbers_Aggregate_Fields = {
  __typename?: 'consumer_numbers_aggregate_fields';
  avg?: Maybe<Consumer_Numbers_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Consumer_Numbers_Max_Fields>;
  min?: Maybe<Consumer_Numbers_Min_Fields>;
  stddev?: Maybe<Consumer_Numbers_Stddev_Fields>;
  stddev_pop?: Maybe<Consumer_Numbers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Consumer_Numbers_Stddev_Samp_Fields>;
  sum?: Maybe<Consumer_Numbers_Sum_Fields>;
  var_pop?: Maybe<Consumer_Numbers_Var_Pop_Fields>;
  var_samp?: Maybe<Consumer_Numbers_Var_Samp_Fields>;
  variance?: Maybe<Consumer_Numbers_Variance_Fields>;
};


/** aggregate fields of "consumer_numbers" */
export type Consumer_Numbers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Consumer_Numbers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Consumer_Numbers_Avg_Fields = {
  __typename?: 'consumer_numbers_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "consumer_numbers". All fields are combined with a logical 'AND'. */
export type Consumer_Numbers_Bool_Exp = {
  _and?: InputMaybe<Array<Consumer_Numbers_Bool_Exp>>;
  _not?: InputMaybe<Consumer_Numbers_Bool_Exp>;
  _or?: InputMaybe<Array<Consumer_Numbers_Bool_Exp>>;
  alt_formats?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  is_mobile?: InputMaybe<Boolean_Comparison_Exp>;
  number?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "consumer_numbers" */
export enum Consumer_Numbers_Constraint {
  /** unique or primary key constraint on columns "number" */
  ConsumerNumbersNumberKey = 'consumer_numbers_number_key',
  /** unique or primary key constraint on columns "id" */
  ConsumerNumbersPkey = 'consumer_numbers_pkey'
}

/** input type for incrementing numeric columns in table "consumer_numbers" */
export type Consumer_Numbers_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "consumer_numbers" */
export type Consumer_Numbers_Insert_Input = {
  alt_formats?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  is_mobile?: InputMaybe<Scalars['Boolean']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Consumer_Numbers_Max_Fields = {
  __typename?: 'consumer_numbers_max_fields';
  alt_formats?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Consumer_Numbers_Min_Fields = {
  __typename?: 'consumer_numbers_min_fields';
  alt_formats?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "consumer_numbers" */
export type Consumer_Numbers_Mutation_Response = {
  __typename?: 'consumer_numbers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Consumer_Numbers>;
};

/** on_conflict condition type for table "consumer_numbers" */
export type Consumer_Numbers_On_Conflict = {
  constraint: Consumer_Numbers_Constraint;
  update_columns?: Array<Consumer_Numbers_Update_Column>;
  where?: InputMaybe<Consumer_Numbers_Bool_Exp>;
};

/** Ordering options when selecting data from "consumer_numbers". */
export type Consumer_Numbers_Order_By = {
  alt_formats?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  is_mobile?: InputMaybe<Order_By>;
  number?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: consumer_numbers */
export type Consumer_Numbers_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "consumer_numbers" */
export enum Consumer_Numbers_Select_Column {
  /** column name */
  AltFormats = 'alt_formats',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Id = 'id',
  /** column name */
  IsMobile = 'is_mobile',
  /** column name */
  Number = 'number',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "consumer_numbers" */
export type Consumer_Numbers_Set_Input = {
  alt_formats?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  is_mobile?: InputMaybe<Scalars['Boolean']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Consumer_Numbers_Stddev_Fields = {
  __typename?: 'consumer_numbers_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Consumer_Numbers_Stddev_Pop_Fields = {
  __typename?: 'consumer_numbers_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Consumer_Numbers_Stddev_Samp_Fields = {
  __typename?: 'consumer_numbers_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "consumer_numbers" */
export type Consumer_Numbers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Consumer_Numbers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Consumer_Numbers_Stream_Cursor_Value_Input = {
  alt_formats?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  is_mobile?: InputMaybe<Scalars['Boolean']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Consumer_Numbers_Sum_Fields = {
  __typename?: 'consumer_numbers_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "consumer_numbers" */
export enum Consumer_Numbers_Update_Column {
  /** column name */
  AltFormats = 'alt_formats',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Id = 'id',
  /** column name */
  IsMobile = 'is_mobile',
  /** column name */
  Number = 'number',
  /** column name */
  Updatedat = 'updatedat'
}

export type Consumer_Numbers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Consumer_Numbers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Consumer_Numbers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Consumer_Numbers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Consumer_Numbers_Var_Pop_Fields = {
  __typename?: 'consumer_numbers_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Consumer_Numbers_Var_Samp_Fields = {
  __typename?: 'consumer_numbers_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Consumer_Numbers_Variance_Fields = {
  __typename?: 'consumer_numbers_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Contains information about individual plans that should be coordinated. */
export type Coordinatedplans = {
  __typename?: 'coordinatedplans';
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config: Scalars['jsonb']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Display name to use in the UI to identify this coordinated plan. It can be for example the name of the shuttle driver for a shuttle group plan. */
  display_name: Scalars['String']['output'];
  /** delivery_time of the last move in this coordinated plan. As the coordinated plan changes this should be updated */
  end_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique id of the coordinated plan */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  scenarios: Array<Coordinatedplantoscenarios>;
  /** An aggregate relationship */
  scenarios_aggregate: Coordinatedplantoscenarios_Aggregate;
  /** pickup time of the first move in this coordinated plan. As the coordinated plan changes, this should be updated. */
  start_time: Scalars['timestamptz']['output'];
  /** Coordinated plan type. Values: shuttle for a shuttle group plan. ridegroup for a shared rideshare group plan. */
  type: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** Contains information about individual plans that should be coordinated. */
export type CoordinatedplansConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Contains information about individual plans that should be coordinated. */
export type CoordinatedplansScenariosArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


/** Contains information about individual plans that should be coordinated. */
export type CoordinatedplansScenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};

/** aggregated selection of "coordinatedplans" */
export type Coordinatedplans_Aggregate = {
  __typename?: 'coordinatedplans_aggregate';
  aggregate?: Maybe<Coordinatedplans_Aggregate_Fields>;
  nodes: Array<Coordinatedplans>;
};

/** aggregate fields of "coordinatedplans" */
export type Coordinatedplans_Aggregate_Fields = {
  __typename?: 'coordinatedplans_aggregate_fields';
  avg?: Maybe<Coordinatedplans_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Coordinatedplans_Max_Fields>;
  min?: Maybe<Coordinatedplans_Min_Fields>;
  stddev?: Maybe<Coordinatedplans_Stddev_Fields>;
  stddev_pop?: Maybe<Coordinatedplans_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Coordinatedplans_Stddev_Samp_Fields>;
  sum?: Maybe<Coordinatedplans_Sum_Fields>;
  var_pop?: Maybe<Coordinatedplans_Var_Pop_Fields>;
  var_samp?: Maybe<Coordinatedplans_Var_Samp_Fields>;
  variance?: Maybe<Coordinatedplans_Variance_Fields>;
};


/** aggregate fields of "coordinatedplans" */
export type Coordinatedplans_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Coordinatedplans_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Coordinatedplans_Append_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Coordinatedplans_Avg_Fields = {
  __typename?: 'coordinatedplans_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "coordinatedplans". All fields are combined with a logical 'AND'. */
export type Coordinatedplans_Bool_Exp = {
  _and?: InputMaybe<Array<Coordinatedplans_Bool_Exp>>;
  _not?: InputMaybe<Coordinatedplans_Bool_Exp>;
  _or?: InputMaybe<Array<Coordinatedplans_Bool_Exp>>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  display_name?: InputMaybe<String_Comparison_Exp>;
  end_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  scenarios?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
  scenarios_aggregate?: InputMaybe<Coordinatedplantoscenarios_Aggregate_Bool_Exp>;
  start_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "coordinatedplans" */
export enum Coordinatedplans_Constraint {
  /** unique or primary key constraint on columns "id" */
  CoordinatedplansPkey = 'coordinatedplans_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Coordinatedplans_Delete_At_Path_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Coordinatedplans_Delete_Elem_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Coordinatedplans_Delete_Key_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "coordinatedplans" */
export type Coordinatedplans_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Unique id of the coordinated plan */
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "coordinatedplans" */
export type Coordinatedplans_Insert_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Display name to use in the UI to identify this coordinated plan. It can be for example the name of the shuttle driver for a shuttle group plan. */
  display_name?: InputMaybe<Scalars['String']['input']>;
  /** delivery_time of the last move in this coordinated plan. As the coordinated plan changes this should be updated */
  end_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique id of the coordinated plan */
  id?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  scenarios?: InputMaybe<Coordinatedplantoscenarios_Arr_Rel_Insert_Input>;
  /** pickup time of the first move in this coordinated plan. As the coordinated plan changes, this should be updated. */
  start_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Coordinated plan type. Values: shuttle for a shuttle group plan. ridegroup for a shared rideshare group plan. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Coordinatedplans_Max_Fields = {
  __typename?: 'coordinatedplans_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Display name to use in the UI to identify this coordinated plan. It can be for example the name of the shuttle driver for a shuttle group plan. */
  display_name?: Maybe<Scalars['String']['output']>;
  /** delivery_time of the last move in this coordinated plan. As the coordinated plan changes this should be updated */
  end_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** pickup time of the first move in this coordinated plan. As the coordinated plan changes, this should be updated. */
  start_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Coordinated plan type. Values: shuttle for a shuttle group plan. ridegroup for a shared rideshare group plan. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Coordinatedplans_Min_Fields = {
  __typename?: 'coordinatedplans_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Display name to use in the UI to identify this coordinated plan. It can be for example the name of the shuttle driver for a shuttle group plan. */
  display_name?: Maybe<Scalars['String']['output']>;
  /** delivery_time of the last move in this coordinated plan. As the coordinated plan changes this should be updated */
  end_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** pickup time of the first move in this coordinated plan. As the coordinated plan changes, this should be updated. */
  start_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Coordinated plan type. Values: shuttle for a shuttle group plan. ridegroup for a shared rideshare group plan. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "coordinatedplans" */
export type Coordinatedplans_Mutation_Response = {
  __typename?: 'coordinatedplans_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Coordinatedplans>;
};

/** input type for inserting object relation for remote table "coordinatedplans" */
export type Coordinatedplans_Obj_Rel_Insert_Input = {
  data: Coordinatedplans_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Coordinatedplans_On_Conflict>;
};

/** on_conflict condition type for table "coordinatedplans" */
export type Coordinatedplans_On_Conflict = {
  constraint: Coordinatedplans_Constraint;
  update_columns?: Array<Coordinatedplans_Update_Column>;
  where?: InputMaybe<Coordinatedplans_Bool_Exp>;
};

/** Ordering options when selecting data from "coordinatedplans". */
export type Coordinatedplans_Order_By = {
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  display_name?: InputMaybe<Order_By>;
  end_time?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  scenarios_aggregate?: InputMaybe<Coordinatedplantoscenarios_Aggregate_Order_By>;
  start_time?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: coordinatedplans */
export type Coordinatedplans_Pk_Columns_Input = {
  /** Unique id of the coordinated plan */
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Coordinatedplans_Prepend_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "coordinatedplans" */
export enum Coordinatedplans_Select_Column {
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  StartTime = 'start_time',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "coordinatedplans" */
export type Coordinatedplans_Set_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Display name to use in the UI to identify this coordinated plan. It can be for example the name of the shuttle driver for a shuttle group plan. */
  display_name?: InputMaybe<Scalars['String']['input']>;
  /** delivery_time of the last move in this coordinated plan. As the coordinated plan changes this should be updated */
  end_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique id of the coordinated plan */
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** pickup time of the first move in this coordinated plan. As the coordinated plan changes, this should be updated. */
  start_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Coordinated plan type. Values: shuttle for a shuttle group plan. ridegroup for a shared rideshare group plan. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Coordinatedplans_Stddev_Fields = {
  __typename?: 'coordinatedplans_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Coordinatedplans_Stddev_Pop_Fields = {
  __typename?: 'coordinatedplans_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Coordinatedplans_Stddev_Samp_Fields = {
  __typename?: 'coordinatedplans_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "coordinatedplans" */
export type Coordinatedplans_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Coordinatedplans_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Coordinatedplans_Stream_Cursor_Value_Input = {
  /** Contains configuration for a coordinated plan. Could contain rules of execution or other items */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Display name to use in the UI to identify this coordinated plan. It can be for example the name of the shuttle driver for a shuttle group plan. */
  display_name?: InputMaybe<Scalars['String']['input']>;
  /** delivery_time of the last move in this coordinated plan. As the coordinated plan changes this should be updated */
  end_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique id of the coordinated plan */
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** pickup time of the first move in this coordinated plan. As the coordinated plan changes, this should be updated. */
  start_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Coordinated plan type. Values: shuttle for a shuttle group plan. ridegroup for a shared rideshare group plan. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Coordinatedplans_Sum_Fields = {
  __typename?: 'coordinatedplans_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "coordinatedplans" */
export enum Coordinatedplans_Update_Column {
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  StartTime = 'start_time',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Coordinatedplans_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Coordinatedplans_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Coordinatedplans_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Coordinatedplans_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Coordinatedplans_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Coordinatedplans_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Coordinatedplans_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Coordinatedplans_Set_Input>;
  /** filter the rows which have to be updated */
  where: Coordinatedplans_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Coordinatedplans_Var_Pop_Fields = {
  __typename?: 'coordinatedplans_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Coordinatedplans_Var_Samp_Fields = {
  __typename?: 'coordinatedplans_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Coordinatedplans_Variance_Fields = {
  __typename?: 'coordinatedplans_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Unique id of the coordinated plan */
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Contains the scenarios in a coordinated plan. Only the active scenarios are included. */
export type Coordinatedplantoscenarios = {
  __typename?: 'coordinatedplantoscenarios';
  /** An object relationship */
  coordinatedplan: Coordinatedplans;
  /** Id of the coordinated plan */
  coordinatedplan_id: Scalars['bigint']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  scenario: Scenarios;
  /** id of the scenario */
  scenario_id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Aggregate = {
  __typename?: 'coordinatedplantoscenarios_aggregate';
  aggregate?: Maybe<Coordinatedplantoscenarios_Aggregate_Fields>;
  nodes: Array<Coordinatedplantoscenarios>;
};

export type Coordinatedplantoscenarios_Aggregate_Bool_Exp = {
  count?: InputMaybe<Coordinatedplantoscenarios_Aggregate_Bool_Exp_Count>;
};

export type Coordinatedplantoscenarios_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Aggregate_Fields = {
  __typename?: 'coordinatedplantoscenarios_aggregate_fields';
  avg?: Maybe<Coordinatedplantoscenarios_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Coordinatedplantoscenarios_Max_Fields>;
  min?: Maybe<Coordinatedplantoscenarios_Min_Fields>;
  stddev?: Maybe<Coordinatedplantoscenarios_Stddev_Fields>;
  stddev_pop?: Maybe<Coordinatedplantoscenarios_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Coordinatedplantoscenarios_Stddev_Samp_Fields>;
  sum?: Maybe<Coordinatedplantoscenarios_Sum_Fields>;
  var_pop?: Maybe<Coordinatedplantoscenarios_Var_Pop_Fields>;
  var_samp?: Maybe<Coordinatedplantoscenarios_Var_Samp_Fields>;
  variance?: Maybe<Coordinatedplantoscenarios_Variance_Fields>;
};


/** aggregate fields of "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Aggregate_Order_By = {
  avg?: InputMaybe<Coordinatedplantoscenarios_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Coordinatedplantoscenarios_Max_Order_By>;
  min?: InputMaybe<Coordinatedplantoscenarios_Min_Order_By>;
  stddev?: InputMaybe<Coordinatedplantoscenarios_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Coordinatedplantoscenarios_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Coordinatedplantoscenarios_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Coordinatedplantoscenarios_Sum_Order_By>;
  var_pop?: InputMaybe<Coordinatedplantoscenarios_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Coordinatedplantoscenarios_Var_Samp_Order_By>;
  variance?: InputMaybe<Coordinatedplantoscenarios_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Arr_Rel_Insert_Input = {
  data: Array<Coordinatedplantoscenarios_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Coordinatedplantoscenarios_On_Conflict>;
};

/** aggregate avg on columns */
export type Coordinatedplantoscenarios_Avg_Fields = {
  __typename?: 'coordinatedplantoscenarios_avg_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Avg_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "coordinatedplantoscenarios". All fields are combined with a logical 'AND'. */
export type Coordinatedplantoscenarios_Bool_Exp = {
  _and?: InputMaybe<Array<Coordinatedplantoscenarios_Bool_Exp>>;
  _not?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
  _or?: InputMaybe<Array<Coordinatedplantoscenarios_Bool_Exp>>;
  coordinatedplan?: InputMaybe<Coordinatedplans_Bool_Exp>;
  coordinatedplan_id?: InputMaybe<Bigint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  scenario?: InputMaybe<Scenarios_Bool_Exp>;
  scenario_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "coordinatedplantoscenarios" */
export enum Coordinatedplantoscenarios_Constraint {
  /** unique or primary key constraint on columns "coordinatedplan_id", "scenario_id" */
  CoordinatedplantoscenariosPkey = 'coordinatedplantoscenarios_pkey'
}

/** input type for incrementing numeric columns in table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Inc_Input = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Insert_Input = {
  coordinatedplan?: InputMaybe<Coordinatedplans_Obj_Rel_Insert_Input>;
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  scenario?: InputMaybe<Scenarios_Obj_Rel_Insert_Input>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Coordinatedplantoscenarios_Max_Fields = {
  __typename?: 'coordinatedplantoscenarios_max_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Max_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Coordinatedplantoscenarios_Min_Fields = {
  __typename?: 'coordinatedplantoscenarios_min_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Min_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Mutation_Response = {
  __typename?: 'coordinatedplantoscenarios_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Coordinatedplantoscenarios>;
};

/** on_conflict condition type for table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_On_Conflict = {
  constraint: Coordinatedplantoscenarios_Constraint;
  update_columns?: Array<Coordinatedplantoscenarios_Update_Column>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};

/** Ordering options when selecting data from "coordinatedplantoscenarios". */
export type Coordinatedplantoscenarios_Order_By = {
  coordinatedplan?: InputMaybe<Coordinatedplans_Order_By>;
  coordinatedplan_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Scenarios_Order_By>;
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: coordinatedplantoscenarios */
export type Coordinatedplantoscenarios_Pk_Columns_Input = {
  /** Id of the coordinated plan */
  coordinatedplan_id: Scalars['bigint']['input'];
  /** id of the scenario */
  scenario_id: Scalars['bigint']['input'];
};

/** select columns of table "coordinatedplantoscenarios" */
export enum Coordinatedplantoscenarios_Select_Column {
  /** column name */
  CoordinatedplanId = 'coordinatedplan_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  ScenarioId = 'scenario_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Set_Input = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Coordinatedplantoscenarios_Stddev_Fields = {
  __typename?: 'coordinatedplantoscenarios_stddev_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Stddev_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Coordinatedplantoscenarios_Stddev_Pop_Fields = {
  __typename?: 'coordinatedplantoscenarios_stddev_pop_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Stddev_Pop_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Coordinatedplantoscenarios_Stddev_Samp_Fields = {
  __typename?: 'coordinatedplantoscenarios_stddev_samp_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Stddev_Samp_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Coordinatedplantoscenarios_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Coordinatedplantoscenarios_Stream_Cursor_Value_Input = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Coordinatedplantoscenarios_Sum_Fields = {
  __typename?: 'coordinatedplantoscenarios_sum_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['bigint']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Sum_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** update columns of table "coordinatedplantoscenarios" */
export enum Coordinatedplantoscenarios_Update_Column {
  /** column name */
  CoordinatedplanId = 'coordinatedplan_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  ScenarioId = 'scenario_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Coordinatedplantoscenarios_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Coordinatedplantoscenarios_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Coordinatedplantoscenarios_Set_Input>;
  /** filter the rows which have to be updated */
  where: Coordinatedplantoscenarios_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Coordinatedplantoscenarios_Var_Pop_Fields = {
  __typename?: 'coordinatedplantoscenarios_var_pop_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Var_Pop_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Coordinatedplantoscenarios_Var_Samp_Fields = {
  __typename?: 'coordinatedplantoscenarios_var_samp_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Var_Samp_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Coordinatedplantoscenarios_Variance_Fields = {
  __typename?: 'coordinatedplantoscenarios_variance_fields';
  /** Id of the coordinated plan */
  coordinatedplan_id?: Maybe<Scalars['Float']['output']>;
  /** id of the scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "coordinatedplantoscenarios" */
export type Coordinatedplantoscenarios_Variance_Order_By = {
  /** Id of the coordinated plan */
  coordinatedplan_id?: InputMaybe<Order_By>;
  /** id of the scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "customers" */
export type Customers = {
  __typename?: 'customers';
  accounting_id?: Maybe<Scalars['String']['output']>;
  active: Scalars['smallint']['output'];
  address?: Maybe<Scalars['String']['output']>;
  auto_pay: Scalars['Boolean']['output'];
  billing_frequency: Scalars['String']['output'];
  branded: Scalars['Boolean']['output'];
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: Maybe<Scalars['String']['output']>;
  config?: Maybe<Scalars['jsonb']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  /** An array relationship */
  favoritelanes: Array<Favoritelanes>;
  /** An aggregate relationship */
  favoritelanes_aggregate: Favoritelanes_Aggregate;
  /** An array relationship */
  favoritelocations: Array<Favoritelocations>;
  /** An aggregate relationship */
  favoritelocations_aggregate: Favoritelocations_Aggregate;
  /** An array relationship */
  hangtags: Array<Hangtags>;
  /** An aggregate relationship */
  hangtags_aggregate: Hangtags_Aggregate;
  id: Scalars['bigint']['output'];
  /** An array relationship */
  invoices: Array<Arinvoices>;
  /** An aggregate relationship */
  invoices_aggregate: Arinvoices_Aggregate;
  /** An array relationship */
  lanes: Array<Lanes>;
  /** An aggregate relationship */
  lanes_aggregate: Lanes_Aggregate;
  /** An object relationship */
  location?: Maybe<Locations>;
  /** An object relationship */
  locationByAddress?: Maybe<Locations>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  locations: Array<Locations>;
  /** An aggregate relationship */
  locations_aggregate: Locations_Aggregate;
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  name?: Maybe<Scalars['String']['output']>;
  notify_billing?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  organization?: Maybe<Organizations>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  payerMoves: Array<Moves>;
  /** An aggregate relationship */
  payerMoves_aggregate: Moves_Aggregate;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms: Scalars['numeric']['output'];
  /** An array relationship */
  paymentmethods: Array<Arpaymentmethods>;
  /** An aggregate relationship */
  paymentmethods_aggregate: Arpaymentmethods_Aggregate;
  phone?: Maybe<Scalars['String']['output']>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  raterulegroups: Array<Raterulegroups>;
  /** An aggregate relationship */
  raterulegroups_aggregate: Raterulegroups_Aggregate;
  /** An array relationship */
  raterules: Array<Raterules>;
  /** An aggregate relationship */
  raterules_aggregate: Raterules_Aggregate;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  subscriptions: Array<Subscriptions>;
  /** An aggregate relationship */
  subscriptions_aggregate: Subscriptions_Aggregate;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier: Scalars['String']['output'];
  /** An array relationship */
  trips: Array<Trips>;
  /** An aggregate relationship */
  trips_aggregate: Trips_Aggregate;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  workflowsets: Array<Workflowsets>;
  /** An aggregate relationship */
  workflowsets_aggregate: Workflowsets_Aggregate;
};


/** columns and relationships of "customers" */
export type CustomersConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "customers" */
export type CustomersEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersFavoritelanesArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersFavoritelanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersFavoritelocationsArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersFavoritelocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersHangtagsArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersHangtags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersInvoicesArgs = {
  distinct_on?: InputMaybe<Array<Arinvoices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arinvoices_Order_By>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersInvoices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arinvoices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arinvoices_Order_By>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersLanesArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersLanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersLocationsArgs = {
  distinct_on?: InputMaybe<Array<Locations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locations_Order_By>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersLocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locations_Order_By>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersPayerMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersPayerMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersPaymentmethodsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentmethods_Order_By>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersPaymentmethods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentmethods_Order_By>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersRaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersRaterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersRaterulesArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersRaterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Subscriptions_Order_By>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersSubscriptions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Subscriptions_Order_By>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersTripsArgs = {
  distinct_on?: InputMaybe<Array<Trips_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Trips_Order_By>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersTrips_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trips_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Trips_Order_By>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersWorkflowsetsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** columns and relationships of "customers" */
export type CustomersWorkflowsets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};

/** aggregated selection of "customers" */
export type Customers_Aggregate = {
  __typename?: 'customers_aggregate';
  aggregate?: Maybe<Customers_Aggregate_Fields>;
  nodes: Array<Customers>;
};

export type Customers_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Customers_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Customers_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Customers_Aggregate_Bool_Exp_Count>;
};

export type Customers_Aggregate_Bool_Exp_Bool_And = {
  arguments: Customers_Select_Column_Customers_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Customers_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Customers_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Customers_Select_Column_Customers_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Customers_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Customers_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Customers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Customers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "customers" */
export type Customers_Aggregate_Fields = {
  __typename?: 'customers_aggregate_fields';
  avg?: Maybe<Customers_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Customers_Max_Fields>;
  min?: Maybe<Customers_Min_Fields>;
  stddev?: Maybe<Customers_Stddev_Fields>;
  stddev_pop?: Maybe<Customers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Customers_Stddev_Samp_Fields>;
  sum?: Maybe<Customers_Sum_Fields>;
  var_pop?: Maybe<Customers_Var_Pop_Fields>;
  var_samp?: Maybe<Customers_Var_Samp_Fields>;
  variance?: Maybe<Customers_Variance_Fields>;
};


/** aggregate fields of "customers" */
export type Customers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Customers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "customers" */
export type Customers_Aggregate_Order_By = {
  avg?: InputMaybe<Customers_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Customers_Max_Order_By>;
  min?: InputMaybe<Customers_Min_Order_By>;
  stddev?: InputMaybe<Customers_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Customers_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Customers_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Customers_Sum_Order_By>;
  var_pop?: InputMaybe<Customers_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Customers_Var_Samp_Order_By>;
  variance?: InputMaybe<Customers_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Customers_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "customers" */
export type Customers_Arr_Rel_Insert_Input = {
  data: Array<Customers_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Customers_On_Conflict>;
};

/** aggregate avg on columns */
export type Customers_Avg_Fields = {
  __typename?: 'customers_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "customers" */
export type Customers_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "customers". All fields are combined with a logical 'AND'. */
export type Customers_Bool_Exp = {
  _and?: InputMaybe<Array<Customers_Bool_Exp>>;
  _not?: InputMaybe<Customers_Bool_Exp>;
  _or?: InputMaybe<Array<Customers_Bool_Exp>>;
  accounting_id?: InputMaybe<String_Comparison_Exp>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  address?: InputMaybe<String_Comparison_Exp>;
  auto_pay?: InputMaybe<Boolean_Comparison_Exp>;
  billing_frequency?: InputMaybe<String_Comparison_Exp>;
  branded?: InputMaybe<Boolean_Comparison_Exp>;
  category?: InputMaybe<String_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_template_name?: InputMaybe<String_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  eventlogs?: InputMaybe<Eventlogs_Bool_Exp>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Bool_Exp>;
  favoritelanes?: InputMaybe<Favoritelanes_Bool_Exp>;
  favoritelanes_aggregate?: InputMaybe<Favoritelanes_Aggregate_Bool_Exp>;
  favoritelocations?: InputMaybe<Favoritelocations_Bool_Exp>;
  favoritelocations_aggregate?: InputMaybe<Favoritelocations_Aggregate_Bool_Exp>;
  hangtags?: InputMaybe<Hangtags_Bool_Exp>;
  hangtags_aggregate?: InputMaybe<Hangtags_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  invoices?: InputMaybe<Arinvoices_Bool_Exp>;
  invoices_aggregate?: InputMaybe<Arinvoices_Aggregate_Bool_Exp>;
  lanes?: InputMaybe<Lanes_Bool_Exp>;
  lanes_aggregate?: InputMaybe<Lanes_Aggregate_Bool_Exp>;
  location?: InputMaybe<Locations_Bool_Exp>;
  locationByAddress?: InputMaybe<Locations_Bool_Exp>;
  location_id?: InputMaybe<Bigint_Comparison_Exp>;
  locations?: InputMaybe<Locations_Bool_Exp>;
  locations_aggregate?: InputMaybe<Locations_Aggregate_Bool_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notify_billing?: InputMaybe<Boolean_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  payerMoves?: InputMaybe<Moves_Bool_Exp>;
  payerMoves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  payment_terms?: InputMaybe<Numeric_Comparison_Exp>;
  paymentmethods?: InputMaybe<Arpaymentmethods_Bool_Exp>;
  paymentmethods_aggregate?: InputMaybe<Arpaymentmethods_Aggregate_Bool_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  pickup_template_name?: InputMaybe<String_Comparison_Exp>;
  raterulegroups?: InputMaybe<Raterulegroups_Bool_Exp>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Bool_Exp>;
  raterules?: InputMaybe<Raterules_Bool_Exp>;
  raterules_aggregate?: InputMaybe<Raterules_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  subscriptions?: InputMaybe<Subscriptions_Bool_Exp>;
  subscriptions_aggregate?: InputMaybe<Subscriptions_Aggregate_Bool_Exp>;
  tier?: InputMaybe<String_Comparison_Exp>;
  trips?: InputMaybe<Trips_Bool_Exp>;
  trips_aggregate?: InputMaybe<Trips_Aggregate_Bool_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  workflowsets?: InputMaybe<Workflowsets_Bool_Exp>;
  workflowsets_aggregate?: InputMaybe<Workflowsets_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "customers" */
export enum Customers_Constraint {
  /** unique or primary key constraint on columns "accounting_id" */
  CustomersAccountingIdKey = 'customers_accounting_id_key',
  /** unique or primary key constraint on columns "id" */
  Idx_21595Primary = 'idx_21595_primary'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Customers_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Customers_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Customers_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "customers" */
export type Customers_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "customers" */
export type Customers_Insert_Input = {
  accounting_id?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  auto_pay?: InputMaybe<Scalars['Boolean']['input']>;
  billing_frequency?: InputMaybe<Scalars['String']['input']>;
  branded?: InputMaybe<Scalars['Boolean']['input']>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  eventlogs?: InputMaybe<Eventlogs_Arr_Rel_Insert_Input>;
  favoritelanes?: InputMaybe<Favoritelanes_Arr_Rel_Insert_Input>;
  favoritelocations?: InputMaybe<Favoritelocations_Arr_Rel_Insert_Input>;
  hangtags?: InputMaybe<Hangtags_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  invoices?: InputMaybe<Arinvoices_Arr_Rel_Insert_Input>;
  lanes?: InputMaybe<Lanes_Arr_Rel_Insert_Input>;
  location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  locationByAddress?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  locations?: InputMaybe<Locations_Arr_Rel_Insert_Input>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  notify_billing?: InputMaybe<Scalars['Boolean']['input']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  payerMoves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Scalars['numeric']['input']>;
  paymentmethods?: InputMaybe<Arpaymentmethods_Arr_Rel_Insert_Input>;
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: InputMaybe<Scalars['String']['input']>;
  raterulegroups?: InputMaybe<Raterulegroups_Arr_Rel_Insert_Input>;
  raterules?: InputMaybe<Raterules_Arr_Rel_Insert_Input>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: InputMaybe<Scalars['String']['input']>;
  subscriptions?: InputMaybe<Subscriptions_Arr_Rel_Insert_Input>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: InputMaybe<Scalars['String']['input']>;
  trips?: InputMaybe<Trips_Arr_Rel_Insert_Input>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  workflowsets?: InputMaybe<Workflowsets_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Customers_Max_Fields = {
  __typename?: 'customers_max_fields';
  accounting_id?: Maybe<Scalars['String']['output']>;
  active?: Maybe<Scalars['smallint']['output']>;
  address?: Maybe<Scalars['String']['output']>;
  billing_frequency?: Maybe<Scalars['String']['output']>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['numeric']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: Maybe<Scalars['String']['output']>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: Maybe<Scalars['String']['output']>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "customers" */
export type Customers_Max_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  address?: InputMaybe<Order_By>;
  billing_frequency?: InputMaybe<Order_By>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: InputMaybe<Order_By>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: InputMaybe<Order_By>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Customers_Min_Fields = {
  __typename?: 'customers_min_fields';
  accounting_id?: Maybe<Scalars['String']['output']>;
  active?: Maybe<Scalars['smallint']['output']>;
  address?: Maybe<Scalars['String']['output']>;
  billing_frequency?: Maybe<Scalars['String']['output']>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['numeric']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: Maybe<Scalars['String']['output']>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: Maybe<Scalars['String']['output']>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "customers" */
export type Customers_Min_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  address?: InputMaybe<Order_By>;
  billing_frequency?: InputMaybe<Order_By>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: InputMaybe<Order_By>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: InputMaybe<Order_By>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "customers" */
export type Customers_Mutation_Response = {
  __typename?: 'customers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Customers>;
};

/** input type for inserting object relation for remote table "customers" */
export type Customers_Obj_Rel_Insert_Input = {
  data: Customers_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Customers_On_Conflict>;
};

/** on_conflict condition type for table "customers" */
export type Customers_On_Conflict = {
  constraint: Customers_Constraint;
  update_columns?: Array<Customers_Update_Column>;
  where?: InputMaybe<Customers_Bool_Exp>;
};

/** Ordering options when selecting data from "customers". */
export type Customers_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  address?: InputMaybe<Order_By>;
  auto_pay?: InputMaybe<Order_By>;
  billing_frequency?: InputMaybe<Order_By>;
  branded?: InputMaybe<Order_By>;
  category?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  delivery_template_name?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Order_By>;
  favoritelanes_aggregate?: InputMaybe<Favoritelanes_Aggregate_Order_By>;
  favoritelocations_aggregate?: InputMaybe<Favoritelocations_Aggregate_Order_By>;
  hangtags_aggregate?: InputMaybe<Hangtags_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  invoices_aggregate?: InputMaybe<Arinvoices_Aggregate_Order_By>;
  lanes_aggregate?: InputMaybe<Lanes_Aggregate_Order_By>;
  location?: InputMaybe<Locations_Order_By>;
  locationByAddress?: InputMaybe<Locations_Order_By>;
  location_id?: InputMaybe<Order_By>;
  locations_aggregate?: InputMaybe<Locations_Aggregate_Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  notify_billing?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  payerMoves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  payment_terms?: InputMaybe<Order_By>;
  paymentmethods_aggregate?: InputMaybe<Arpaymentmethods_Aggregate_Order_By>;
  phone?: InputMaybe<Order_By>;
  pickup_template_name?: InputMaybe<Order_By>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Order_By>;
  raterules_aggregate?: InputMaybe<Raterules_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  subscriptions_aggregate?: InputMaybe<Subscriptions_Aggregate_Order_By>;
  tier?: InputMaybe<Order_By>;
  trips_aggregate?: InputMaybe<Trips_Aggregate_Order_By>;
  updatedat?: InputMaybe<Order_By>;
  workflowsets_aggregate?: InputMaybe<Workflowsets_Aggregate_Order_By>;
};

/** primary key columns input for table: customers */
export type Customers_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Customers_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "customers" */
export enum Customers_Select_Column {
  /** column name */
  AccountingId = 'accounting_id',
  /** column name */
  Active = 'active',
  /** column name */
  Address = 'address',
  /** column name */
  AutoPay = 'auto_pay',
  /** column name */
  BillingFrequency = 'billing_frequency',
  /** column name */
  Branded = 'branded',
  /** column name */
  Category = 'category',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DeliveryTemplateName = 'delivery_template_name',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Name = 'name',
  /** column name */
  NotifyBilling = 'notify_billing',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PaymentTerms = 'payment_terms',
  /** column name */
  Phone = 'phone',
  /** column name */
  PickupTemplateName = 'pickup_template_name',
  /** column name */
  Status = 'status',
  /** column name */
  Tier = 'tier',
  /** column name */
  Updatedat = 'updatedat'
}

/** select "customers_aggregate_bool_exp_bool_and_arguments_columns" columns of table "customers" */
export enum Customers_Select_Column_Customers_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  AutoPay = 'auto_pay',
  /** column name */
  Branded = 'branded',
  /** column name */
  NotifyBilling = 'notify_billing'
}

/** select "customers_aggregate_bool_exp_bool_or_arguments_columns" columns of table "customers" */
export enum Customers_Select_Column_Customers_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  AutoPay = 'auto_pay',
  /** column name */
  Branded = 'branded',
  /** column name */
  NotifyBilling = 'notify_billing'
}

/** input type for updating data in table "customers" */
export type Customers_Set_Input = {
  accounting_id?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  auto_pay?: InputMaybe<Scalars['Boolean']['input']>;
  billing_frequency?: InputMaybe<Scalars['String']['input']>;
  branded?: InputMaybe<Scalars['Boolean']['input']>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notify_billing?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Scalars['numeric']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Customers_Stddev_Fields = {
  __typename?: 'customers_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "customers" */
export type Customers_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Customers_Stddev_Pop_Fields = {
  __typename?: 'customers_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "customers" */
export type Customers_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Customers_Stddev_Samp_Fields = {
  __typename?: 'customers_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "customers" */
export type Customers_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "customers" */
export type Customers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Customers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Customers_Stream_Cursor_Value_Input = {
  accounting_id?: InputMaybe<Scalars['String']['input']>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  auto_pay?: InputMaybe<Scalars['Boolean']['input']>;
  billing_frequency?: InputMaybe<Scalars['String']['input']>;
  branded?: InputMaybe<Scalars['Boolean']['input']>;
  /** Customers can be categorized as either "operational" or "concierge" (or "house" for house account) */
  category?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Default Tookan template name for deliveries (<customer_id>_d_<template_name>) */
  delivery_template_name?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notify_billing?: InputMaybe<Scalars['Boolean']['input']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Scalars['numeric']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Default Tookan template name for pickups (<customer_id>_p_<template_name>) */
  pickup_template_name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the customer. Used to determine what stage of the customer life-cycle this particular customer is in. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Level of service provided to customer. Can be "standard", "lite", or "hybrid". Standard customers receive labor management services, while lite customers use a SaaS version of HopDrive and manage their own driver pool. Hybrid customers can use either service on a move-by-move basis. */
  tier?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Customers_Sum_Fields = {
  __typename?: 'customers_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "customers" */
export type Customers_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** update columns of table "customers" */
export enum Customers_Update_Column {
  /** column name */
  AccountingId = 'accounting_id',
  /** column name */
  Active = 'active',
  /** column name */
  Address = 'address',
  /** column name */
  AutoPay = 'auto_pay',
  /** column name */
  BillingFrequency = 'billing_frequency',
  /** column name */
  Branded = 'branded',
  /** column name */
  Category = 'category',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DeliveryTemplateName = 'delivery_template_name',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Name = 'name',
  /** column name */
  NotifyBilling = 'notify_billing',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PaymentTerms = 'payment_terms',
  /** column name */
  Phone = 'phone',
  /** column name */
  PickupTemplateName = 'pickup_template_name',
  /** column name */
  Status = 'status',
  /** column name */
  Tier = 'tier',
  /** column name */
  Updatedat = 'updatedat'
}

export type Customers_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Customers_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Customers_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Customers_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Customers_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Customers_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Customers_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Customers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Customers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Customers_Var_Pop_Fields = {
  __typename?: 'customers_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "customers" */
export type Customers_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Customers_Var_Samp_Fields = {
  __typename?: 'customers_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "customers" */
export type Customers_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Customers_Variance_Fields = {
  __typename?: 'customers_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Location ID of the customer's store. */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "customers" */
export type Customers_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Location ID of the customer's store. */
  location_id?: InputMaybe<Order_By>;
  /** Optional overarching grouping of customers to a parent company or entity. Controls the allowed customer ids that get set on the custom claims of any admin-dealer roles. */
  organization_id?: InputMaybe<Order_By>;
  /** Number of days after the invoice end date that customer is expected to pay the invoice */
  payment_terms?: InputMaybe<Order_By>;
};

/** Many to Many relationships. This could be used if an org has a specific requirement for a certification but only at one of their rooftop customers. */
export type Customerstocertifications = {
  __typename?: 'customerstocertifications';
  /** An object relationship */
  certification: Certifications;
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  customer: Customers;
  customer_id: Scalars['bigint']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "customerstocertifications" */
export type Customerstocertifications_Aggregate = {
  __typename?: 'customerstocertifications_aggregate';
  aggregate?: Maybe<Customerstocertifications_Aggregate_Fields>;
  nodes: Array<Customerstocertifications>;
};

export type Customerstocertifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Customerstocertifications_Aggregate_Bool_Exp_Count>;
};

export type Customerstocertifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Customerstocertifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "customerstocertifications" */
export type Customerstocertifications_Aggregate_Fields = {
  __typename?: 'customerstocertifications_aggregate_fields';
  avg?: Maybe<Customerstocertifications_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Customerstocertifications_Max_Fields>;
  min?: Maybe<Customerstocertifications_Min_Fields>;
  stddev?: Maybe<Customerstocertifications_Stddev_Fields>;
  stddev_pop?: Maybe<Customerstocertifications_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Customerstocertifications_Stddev_Samp_Fields>;
  sum?: Maybe<Customerstocertifications_Sum_Fields>;
  var_pop?: Maybe<Customerstocertifications_Var_Pop_Fields>;
  var_samp?: Maybe<Customerstocertifications_Var_Samp_Fields>;
  variance?: Maybe<Customerstocertifications_Variance_Fields>;
};


/** aggregate fields of "customerstocertifications" */
export type Customerstocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "customerstocertifications" */
export type Customerstocertifications_Aggregate_Order_By = {
  avg?: InputMaybe<Customerstocertifications_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Customerstocertifications_Max_Order_By>;
  min?: InputMaybe<Customerstocertifications_Min_Order_By>;
  stddev?: InputMaybe<Customerstocertifications_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Customerstocertifications_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Customerstocertifications_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Customerstocertifications_Sum_Order_By>;
  var_pop?: InputMaybe<Customerstocertifications_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Customerstocertifications_Var_Samp_Order_By>;
  variance?: InputMaybe<Customerstocertifications_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "customerstocertifications" */
export type Customerstocertifications_Arr_Rel_Insert_Input = {
  data: Array<Customerstocertifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Customerstocertifications_On_Conflict>;
};

/** aggregate avg on columns */
export type Customerstocertifications_Avg_Fields = {
  __typename?: 'customerstocertifications_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "customerstocertifications" */
export type Customerstocertifications_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "customerstocertifications". All fields are combined with a logical 'AND'. */
export type Customerstocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Customerstocertifications_Bool_Exp>>;
  _not?: InputMaybe<Customerstocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Customerstocertifications_Bool_Exp>>;
  certification?: InputMaybe<Certifications_Bool_Exp>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "customerstocertifications" */
export enum Customerstocertifications_Constraint {
  /** unique or primary key constraint on columns "certification_key", "customer_id" */
  CustomerstocertificationsPkey = 'customerstocertifications_pkey'
}

/** input type for incrementing numeric columns in table "customerstocertifications" */
export type Customerstocertifications_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "customerstocertifications" */
export type Customerstocertifications_Insert_Input = {
  certification?: InputMaybe<Certifications_Obj_Rel_Insert_Input>;
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Customerstocertifications_Max_Fields = {
  __typename?: 'customerstocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "customerstocertifications" */
export type Customerstocertifications_Max_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Customerstocertifications_Min_Fields = {
  __typename?: 'customerstocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "customerstocertifications" */
export type Customerstocertifications_Min_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "customerstocertifications" */
export type Customerstocertifications_Mutation_Response = {
  __typename?: 'customerstocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Customerstocertifications>;
};

/** on_conflict condition type for table "customerstocertifications" */
export type Customerstocertifications_On_Conflict = {
  constraint: Customerstocertifications_Constraint;
  update_columns?: Array<Customerstocertifications_Update_Column>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "customerstocertifications". */
export type Customerstocertifications_Order_By = {
  certification?: InputMaybe<Certifications_Order_By>;
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: customerstocertifications */
export type Customerstocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  customer_id: Scalars['bigint']['input'];
};

/** select columns of table "customerstocertifications" */
export enum Customerstocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "customerstocertifications" */
export type Customerstocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Customerstocertifications_Stddev_Fields = {
  __typename?: 'customerstocertifications_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "customerstocertifications" */
export type Customerstocertifications_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Customerstocertifications_Stddev_Pop_Fields = {
  __typename?: 'customerstocertifications_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "customerstocertifications" */
export type Customerstocertifications_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Customerstocertifications_Stddev_Samp_Fields = {
  __typename?: 'customerstocertifications_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "customerstocertifications" */
export type Customerstocertifications_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "customerstocertifications" */
export type Customerstocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Customerstocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Customerstocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Customerstocertifications_Sum_Fields = {
  __typename?: 'customerstocertifications_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "customerstocertifications" */
export type Customerstocertifications_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** update columns of table "customerstocertifications" */
export enum Customerstocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

export type Customerstocertifications_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Customerstocertifications_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Customerstocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Customerstocertifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Customerstocertifications_Var_Pop_Fields = {
  __typename?: 'customerstocertifications_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "customerstocertifications" */
export type Customerstocertifications_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Customerstocertifications_Var_Samp_Fields = {
  __typename?: 'customerstocertifications_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "customerstocertifications" */
export type Customerstocertifications_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Customerstocertifications_Variance_Fields = {
  __typename?: 'customerstocertifications_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "customerstocertifications" */
export type Customerstocertifications_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['date']['input']>;
  _gt?: InputMaybe<Scalars['date']['input']>;
  _gte?: InputMaybe<Scalars['date']['input']>;
  _in?: InputMaybe<Array<Scalars['date']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['date']['input']>;
  _lte?: InputMaybe<Scalars['date']['input']>;
  _neq?: InputMaybe<Scalars['date']['input']>;
  _nin?: InputMaybe<Array<Scalars['date']['input']>>;
};

/** columns and relationships of "dealer_viewable_admin_info" */
export type Dealer_Viewable_Admin_Info = {
  __typename?: 'dealer_viewable_admin_info';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  display_name?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "dealer_viewable_admin_info" */
export type Dealer_Viewable_Admin_Info_Aggregate = {
  __typename?: 'dealer_viewable_admin_info_aggregate';
  aggregate?: Maybe<Dealer_Viewable_Admin_Info_Aggregate_Fields>;
  nodes: Array<Dealer_Viewable_Admin_Info>;
};

/** aggregate fields of "dealer_viewable_admin_info" */
export type Dealer_Viewable_Admin_Info_Aggregate_Fields = {
  __typename?: 'dealer_viewable_admin_info_aggregate_fields';
  avg?: Maybe<Dealer_Viewable_Admin_Info_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Dealer_Viewable_Admin_Info_Max_Fields>;
  min?: Maybe<Dealer_Viewable_Admin_Info_Min_Fields>;
  stddev?: Maybe<Dealer_Viewable_Admin_Info_Stddev_Fields>;
  stddev_pop?: Maybe<Dealer_Viewable_Admin_Info_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dealer_Viewable_Admin_Info_Stddev_Samp_Fields>;
  sum?: Maybe<Dealer_Viewable_Admin_Info_Sum_Fields>;
  var_pop?: Maybe<Dealer_Viewable_Admin_Info_Var_Pop_Fields>;
  var_samp?: Maybe<Dealer_Viewable_Admin_Info_Var_Samp_Fields>;
  variance?: Maybe<Dealer_Viewable_Admin_Info_Variance_Fields>;
};


/** aggregate fields of "dealer_viewable_admin_info" */
export type Dealer_Viewable_Admin_Info_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Dealer_Viewable_Admin_Info_Avg_Fields = {
  __typename?: 'dealer_viewable_admin_info_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "dealer_viewable_admin_info". All fields are combined with a logical 'AND'. */
export type Dealer_Viewable_Admin_Info_Bool_Exp = {
  _and?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Bool_Exp>>;
  _not?: InputMaybe<Dealer_Viewable_Admin_Info_Bool_Exp>;
  _or?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Bool_Exp>>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  display_name?: InputMaybe<String_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dealer_Viewable_Admin_Info_Max_Fields = {
  __typename?: 'dealer_viewable_admin_info_max_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  display_name?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Dealer_Viewable_Admin_Info_Min_Fields = {
  __typename?: 'dealer_viewable_admin_info_min_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  display_name?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "dealer_viewable_admin_info". */
export type Dealer_Viewable_Admin_Info_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  display_name?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "dealer_viewable_admin_info" */
export enum Dealer_Viewable_Admin_Info_Select_Column {
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  Email = 'email',
  /** column name */
  Phone = 'phone',
  /** column name */
  UserId = 'user_id'
}

/** aggregate stddev on columns */
export type Dealer_Viewable_Admin_Info_Stddev_Fields = {
  __typename?: 'dealer_viewable_admin_info_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Dealer_Viewable_Admin_Info_Stddev_Pop_Fields = {
  __typename?: 'dealer_viewable_admin_info_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Dealer_Viewable_Admin_Info_Stddev_Samp_Fields = {
  __typename?: 'dealer_viewable_admin_info_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "dealer_viewable_admin_info" */
export type Dealer_Viewable_Admin_Info_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dealer_Viewable_Admin_Info_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dealer_Viewable_Admin_Info_Stream_Cursor_Value_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  display_name?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Dealer_Viewable_Admin_Info_Sum_Fields = {
  __typename?: 'dealer_viewable_admin_info_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Dealer_Viewable_Admin_Info_Var_Pop_Fields = {
  __typename?: 'dealer_viewable_admin_info_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Dealer_Viewable_Admin_Info_Var_Samp_Fields = {
  __typename?: 'dealer_viewable_admin_info_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Dealer_Viewable_Admin_Info_Variance_Fields = {
  __typename?: 'dealer_viewable_admin_info_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "dealer_viewable_driver_info" */
export type Dealer_Viewable_Driver_Info = {
  __typename?: 'dealer_viewable_driver_info';
  avatar_url?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  display_name?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "dealer_viewable_driver_info" */
export type Dealer_Viewable_Driver_Info_Aggregate = {
  __typename?: 'dealer_viewable_driver_info_aggregate';
  aggregate?: Maybe<Dealer_Viewable_Driver_Info_Aggregate_Fields>;
  nodes: Array<Dealer_Viewable_Driver_Info>;
};

/** aggregate fields of "dealer_viewable_driver_info" */
export type Dealer_Viewable_Driver_Info_Aggregate_Fields = {
  __typename?: 'dealer_viewable_driver_info_aggregate_fields';
  avg?: Maybe<Dealer_Viewable_Driver_Info_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Dealer_Viewable_Driver_Info_Max_Fields>;
  min?: Maybe<Dealer_Viewable_Driver_Info_Min_Fields>;
  stddev?: Maybe<Dealer_Viewable_Driver_Info_Stddev_Fields>;
  stddev_pop?: Maybe<Dealer_Viewable_Driver_Info_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dealer_Viewable_Driver_Info_Stddev_Samp_Fields>;
  sum?: Maybe<Dealer_Viewable_Driver_Info_Sum_Fields>;
  var_pop?: Maybe<Dealer_Viewable_Driver_Info_Var_Pop_Fields>;
  var_samp?: Maybe<Dealer_Viewable_Driver_Info_Var_Samp_Fields>;
  variance?: Maybe<Dealer_Viewable_Driver_Info_Variance_Fields>;
};


/** aggregate fields of "dealer_viewable_driver_info" */
export type Dealer_Viewable_Driver_Info_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Dealer_Viewable_Driver_Info_Avg_Fields = {
  __typename?: 'dealer_viewable_driver_info_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "dealer_viewable_driver_info". All fields are combined with a logical 'AND'. */
export type Dealer_Viewable_Driver_Info_Bool_Exp = {
  _and?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Bool_Exp>>;
  _not?: InputMaybe<Dealer_Viewable_Driver_Info_Bool_Exp>;
  _or?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Bool_Exp>>;
  avatar_url?: InputMaybe<String_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  display_name?: InputMaybe<String_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dealer_Viewable_Driver_Info_Max_Fields = {
  __typename?: 'dealer_viewable_driver_info_max_fields';
  avatar_url?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  display_name?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Dealer_Viewable_Driver_Info_Min_Fields = {
  __typename?: 'dealer_viewable_driver_info_min_fields';
  avatar_url?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  display_name?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "dealer_viewable_driver_info". */
export type Dealer_Viewable_Driver_Info_Order_By = {
  avatar_url?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  display_name?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
};

/** select columns of table "dealer_viewable_driver_info" */
export enum Dealer_Viewable_Driver_Info_Select_Column {
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  MoveId = 'move_id'
}

/** aggregate stddev on columns */
export type Dealer_Viewable_Driver_Info_Stddev_Fields = {
  __typename?: 'dealer_viewable_driver_info_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Dealer_Viewable_Driver_Info_Stddev_Pop_Fields = {
  __typename?: 'dealer_viewable_driver_info_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Dealer_Viewable_Driver_Info_Stddev_Samp_Fields = {
  __typename?: 'dealer_viewable_driver_info_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "dealer_viewable_driver_info" */
export type Dealer_Viewable_Driver_Info_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dealer_Viewable_Driver_Info_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dealer_Viewable_Driver_Info_Stream_Cursor_Value_Input = {
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  display_name?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Dealer_Viewable_Driver_Info_Sum_Fields = {
  __typename?: 'dealer_viewable_driver_info_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Dealer_Viewable_Driver_Info_Var_Pop_Fields = {
  __typename?: 'dealer_viewable_driver_info_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Dealer_Viewable_Driver_Info_Var_Samp_Fields = {
  __typename?: 'dealer_viewable_driver_info_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Dealer_Viewable_Driver_Info_Variance_Fields = {
  __typename?: 'dealer_viewable_driver_info_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Table used to collect documents related to other records from other tables. */
export type Documents = {
  __typename?: 'documents';
  /** An array relationship */
  accessorials: Array<Accessorials>;
  /** An aggregate relationship */
  accessorials_aggregate: Accessorials_Aggregate;
  /** An array relationship */
  armovedetails: Array<Armovedetails>;
  /** An aggregate relationship */
  armovedetails_aggregate: Armovedetails_Aggregate;
  /** An array relationship */
  armovedetailshistory: Array<Armovedetailshistory>;
  /** An aggregate relationship */
  armovedetailshistory_aggregate: Armovedetailshistory_Aggregate;
  /** When the document was first created */
  created_at: Scalars['timestamptz']['output'];
  /** Who created the document */
  created_by: Scalars['String']['output'];
  /** Primary key, sequence auto incremented */
  id: Scalars['Int']['output'];
  /** The document's mime type. Ie: application/pdf */
  mime_type: Scalars['String']['output'];
  /** When the document was last modified */
  modified_at: Scalars['timestamptz']['output'];
  /** Who modified the document */
  modified_by: Scalars['String']['output'];
  /** Human readable name of this document */
  name: Scalars['String']['output'];
  /** Used to connect a record from another table to this document */
  reference_id: Scalars['uuid']['output'];
  secure: Scalars['Boolean']['output'];
  source_table: Scalars['String']['output'];
  /** url to fetch the document */
  url: Scalars['String']['output'];
};


/** Table used to collect documents related to other records from other tables. */
export type DocumentsAccessorialsArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


/** Table used to collect documents related to other records from other tables. */
export type DocumentsAccessorials_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


/** Table used to collect documents related to other records from other tables. */
export type DocumentsArmovedetailsArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


/** Table used to collect documents related to other records from other tables. */
export type DocumentsArmovedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


/** Table used to collect documents related to other records from other tables. */
export type DocumentsArmovedetailshistoryArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


/** Table used to collect documents related to other records from other tables. */
export type DocumentsArmovedetailshistory_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};

/** aggregated selection of "documents" */
export type Documents_Aggregate = {
  __typename?: 'documents_aggregate';
  aggregate?: Maybe<Documents_Aggregate_Fields>;
  nodes: Array<Documents>;
};

export type Documents_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Documents_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Documents_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Documents_Aggregate_Bool_Exp_Count>;
};

export type Documents_Aggregate_Bool_Exp_Bool_And = {
  arguments: Documents_Select_Column_Documents_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Documents_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Documents_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Documents_Select_Column_Documents_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Documents_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Documents_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Documents_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Documents_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "documents" */
export type Documents_Aggregate_Fields = {
  __typename?: 'documents_aggregate_fields';
  avg?: Maybe<Documents_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Documents_Max_Fields>;
  min?: Maybe<Documents_Min_Fields>;
  stddev?: Maybe<Documents_Stddev_Fields>;
  stddev_pop?: Maybe<Documents_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Documents_Stddev_Samp_Fields>;
  sum?: Maybe<Documents_Sum_Fields>;
  var_pop?: Maybe<Documents_Var_Pop_Fields>;
  var_samp?: Maybe<Documents_Var_Samp_Fields>;
  variance?: Maybe<Documents_Variance_Fields>;
};


/** aggregate fields of "documents" */
export type Documents_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Documents_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "documents" */
export type Documents_Aggregate_Order_By = {
  avg?: InputMaybe<Documents_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Documents_Max_Order_By>;
  min?: InputMaybe<Documents_Min_Order_By>;
  stddev?: InputMaybe<Documents_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Documents_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Documents_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Documents_Sum_Order_By>;
  var_pop?: InputMaybe<Documents_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Documents_Var_Samp_Order_By>;
  variance?: InputMaybe<Documents_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "documents" */
export type Documents_Arr_Rel_Insert_Input = {
  data: Array<Documents_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Documents_On_Conflict>;
};

/** aggregate avg on columns */
export type Documents_Avg_Fields = {
  __typename?: 'documents_avg_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "documents" */
export type Documents_Avg_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "documents". All fields are combined with a logical 'AND'. */
export type Documents_Bool_Exp = {
  _and?: InputMaybe<Array<Documents_Bool_Exp>>;
  _not?: InputMaybe<Documents_Bool_Exp>;
  _or?: InputMaybe<Array<Documents_Bool_Exp>>;
  accessorials?: InputMaybe<Accessorials_Bool_Exp>;
  accessorials_aggregate?: InputMaybe<Accessorials_Aggregate_Bool_Exp>;
  armovedetails?: InputMaybe<Armovedetails_Bool_Exp>;
  armovedetails_aggregate?: InputMaybe<Armovedetails_Aggregate_Bool_Exp>;
  armovedetailshistory?: InputMaybe<Armovedetailshistory_Bool_Exp>;
  armovedetailshistory_aggregate?: InputMaybe<Armovedetailshistory_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  mime_type?: InputMaybe<String_Comparison_Exp>;
  modified_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  modified_by?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  reference_id?: InputMaybe<Uuid_Comparison_Exp>;
  secure?: InputMaybe<Boolean_Comparison_Exp>;
  source_table?: InputMaybe<String_Comparison_Exp>;
  url?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "documents" */
export enum Documents_Constraint {
  /** unique or primary key constraint on columns "id" */
  DocumentsPkey = 'documents_pkey'
}

/** input type for incrementing numeric columns in table "documents" */
export type Documents_Inc_Input = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "documents" */
export type Documents_Insert_Input = {
  accessorials?: InputMaybe<Accessorials_Arr_Rel_Insert_Input>;
  armovedetails?: InputMaybe<Armovedetails_Arr_Rel_Insert_Input>;
  armovedetailshistory?: InputMaybe<Armovedetailshistory_Arr_Rel_Insert_Input>;
  /** When the document was first created */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who created the document */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: InputMaybe<Scalars['String']['input']>;
  /** When the document was last modified */
  modified_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who modified the document */
  modified_by?: InputMaybe<Scalars['String']['input']>;
  /** Human readable name of this document */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Used to connect a record from another table to this document */
  reference_id?: InputMaybe<Scalars['uuid']['input']>;
  secure?: InputMaybe<Scalars['Boolean']['input']>;
  source_table?: InputMaybe<Scalars['String']['input']>;
  /** url to fetch the document */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Documents_Max_Fields = {
  __typename?: 'documents_max_fields';
  /** When the document was first created */
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Who created the document */
  created_by?: Maybe<Scalars['String']['output']>;
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Int']['output']>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: Maybe<Scalars['String']['output']>;
  /** When the document was last modified */
  modified_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Who modified the document */
  modified_by?: Maybe<Scalars['String']['output']>;
  /** Human readable name of this document */
  name?: Maybe<Scalars['String']['output']>;
  /** Used to connect a record from another table to this document */
  reference_id?: Maybe<Scalars['uuid']['output']>;
  source_table?: Maybe<Scalars['String']['output']>;
  /** url to fetch the document */
  url?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "documents" */
export type Documents_Max_Order_By = {
  /** When the document was first created */
  created_at?: InputMaybe<Order_By>;
  /** Who created the document */
  created_by?: InputMaybe<Order_By>;
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: InputMaybe<Order_By>;
  /** When the document was last modified */
  modified_at?: InputMaybe<Order_By>;
  /** Who modified the document */
  modified_by?: InputMaybe<Order_By>;
  /** Human readable name of this document */
  name?: InputMaybe<Order_By>;
  /** Used to connect a record from another table to this document */
  reference_id?: InputMaybe<Order_By>;
  source_table?: InputMaybe<Order_By>;
  /** url to fetch the document */
  url?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Documents_Min_Fields = {
  __typename?: 'documents_min_fields';
  /** When the document was first created */
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Who created the document */
  created_by?: Maybe<Scalars['String']['output']>;
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Int']['output']>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: Maybe<Scalars['String']['output']>;
  /** When the document was last modified */
  modified_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Who modified the document */
  modified_by?: Maybe<Scalars['String']['output']>;
  /** Human readable name of this document */
  name?: Maybe<Scalars['String']['output']>;
  /** Used to connect a record from another table to this document */
  reference_id?: Maybe<Scalars['uuid']['output']>;
  source_table?: Maybe<Scalars['String']['output']>;
  /** url to fetch the document */
  url?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "documents" */
export type Documents_Min_Order_By = {
  /** When the document was first created */
  created_at?: InputMaybe<Order_By>;
  /** Who created the document */
  created_by?: InputMaybe<Order_By>;
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: InputMaybe<Order_By>;
  /** When the document was last modified */
  modified_at?: InputMaybe<Order_By>;
  /** Who modified the document */
  modified_by?: InputMaybe<Order_By>;
  /** Human readable name of this document */
  name?: InputMaybe<Order_By>;
  /** Used to connect a record from another table to this document */
  reference_id?: InputMaybe<Order_By>;
  source_table?: InputMaybe<Order_By>;
  /** url to fetch the document */
  url?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "documents" */
export type Documents_Mutation_Response = {
  __typename?: 'documents_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Documents>;
};

/** input type for inserting object relation for remote table "documents" */
export type Documents_Obj_Rel_Insert_Input = {
  data: Documents_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Documents_On_Conflict>;
};

/** on_conflict condition type for table "documents" */
export type Documents_On_Conflict = {
  constraint: Documents_Constraint;
  update_columns?: Array<Documents_Update_Column>;
  where?: InputMaybe<Documents_Bool_Exp>;
};

/** Ordering options when selecting data from "documents". */
export type Documents_Order_By = {
  accessorials_aggregate?: InputMaybe<Accessorials_Aggregate_Order_By>;
  armovedetails_aggregate?: InputMaybe<Armovedetails_Aggregate_Order_By>;
  armovedetailshistory_aggregate?: InputMaybe<Armovedetailshistory_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  mime_type?: InputMaybe<Order_By>;
  modified_at?: InputMaybe<Order_By>;
  modified_by?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  reference_id?: InputMaybe<Order_By>;
  secure?: InputMaybe<Order_By>;
  source_table?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
};

/** primary key columns input for table: documents */
export type Documents_Pk_Columns_Input = {
  /** Primary key, sequence auto incremented */
  id: Scalars['Int']['input'];
};

/** select columns of table "documents" */
export enum Documents_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  MimeType = 'mime_type',
  /** column name */
  ModifiedAt = 'modified_at',
  /** column name */
  ModifiedBy = 'modified_by',
  /** column name */
  Name = 'name',
  /** column name */
  ReferenceId = 'reference_id',
  /** column name */
  Secure = 'secure',
  /** column name */
  SourceTable = 'source_table',
  /** column name */
  Url = 'url'
}

/** select "documents_aggregate_bool_exp_bool_and_arguments_columns" columns of table "documents" */
export enum Documents_Select_Column_Documents_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Secure = 'secure'
}

/** select "documents_aggregate_bool_exp_bool_or_arguments_columns" columns of table "documents" */
export enum Documents_Select_Column_Documents_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Secure = 'secure'
}

/** input type for updating data in table "documents" */
export type Documents_Set_Input = {
  /** When the document was first created */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who created the document */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: InputMaybe<Scalars['String']['input']>;
  /** When the document was last modified */
  modified_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who modified the document */
  modified_by?: InputMaybe<Scalars['String']['input']>;
  /** Human readable name of this document */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Used to connect a record from another table to this document */
  reference_id?: InputMaybe<Scalars['uuid']['input']>;
  secure?: InputMaybe<Scalars['Boolean']['input']>;
  source_table?: InputMaybe<Scalars['String']['input']>;
  /** url to fetch the document */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Documents_Stddev_Fields = {
  __typename?: 'documents_stddev_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "documents" */
export type Documents_Stddev_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Documents_Stddev_Pop_Fields = {
  __typename?: 'documents_stddev_pop_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "documents" */
export type Documents_Stddev_Pop_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Documents_Stddev_Samp_Fields = {
  __typename?: 'documents_stddev_samp_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "documents" */
export type Documents_Stddev_Samp_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "documents" */
export type Documents_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Documents_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Documents_Stream_Cursor_Value_Input = {
  /** When the document was first created */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who created the document */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** The document's mime type. Ie: application/pdf */
  mime_type?: InputMaybe<Scalars['String']['input']>;
  /** When the document was last modified */
  modified_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Who modified the document */
  modified_by?: InputMaybe<Scalars['String']['input']>;
  /** Human readable name of this document */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Used to connect a record from another table to this document */
  reference_id?: InputMaybe<Scalars['uuid']['input']>;
  secure?: InputMaybe<Scalars['Boolean']['input']>;
  source_table?: InputMaybe<Scalars['String']['input']>;
  /** url to fetch the document */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Documents_Sum_Fields = {
  __typename?: 'documents_sum_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "documents" */
export type Documents_Sum_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** update columns of table "documents" */
export enum Documents_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  MimeType = 'mime_type',
  /** column name */
  ModifiedAt = 'modified_at',
  /** column name */
  ModifiedBy = 'modified_by',
  /** column name */
  Name = 'name',
  /** column name */
  ReferenceId = 'reference_id',
  /** column name */
  Secure = 'secure',
  /** column name */
  SourceTable = 'source_table',
  /** column name */
  Url = 'url'
}

export type Documents_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Documents_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Documents_Set_Input>;
  /** filter the rows which have to be updated */
  where: Documents_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Documents_Var_Pop_Fields = {
  __typename?: 'documents_var_pop_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "documents" */
export type Documents_Var_Pop_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Documents_Var_Samp_Fields = {
  __typename?: 'documents_var_samp_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "documents" */
export type Documents_Var_Samp_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Documents_Variance_Fields = {
  __typename?: 'documents_variance_fields';
  /** Primary key, sequence auto incremented */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "documents" */
export type Documents_Variance_Order_By = {
  /** Primary key, sequence auto incremented */
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "driver_pay_by_move" */
export type Driver_Pay_By_Move = {
  __typename?: 'driver_pay_by_move';
  /** An object relationship */
  appliedPayRateGroup?: Maybe<Payrategroups>;
  /** An object relationship */
  appliedPayRateRule?: Maybe<Payraterules>;
  /** An object relationship */
  appliedRegion?: Maybe<Regions>;
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph_source?: Maybe<Scalars['String']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  drive_time?: Maybe<Scalars['String']['output']>;
  drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  final_source?: Maybe<Scalars['String']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_is_overriding_per_mile?: Maybe<Scalars['Boolean']['output']>;
  lane_is_overriding_per_minute?: Maybe<Scalars['Boolean']['output']>;
  lane_modifier_id?: Maybe<Scalars['Int']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  lookup_date?: Maybe<Scalars['timestamptz']['output']>;
  lookup_date_source?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_with_return?: Maybe<Scalars['String']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_without_return?: Maybe<Scalars['String']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['bigint']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  pay_rate_group?: Maybe<Scalars['String']['output']>;
  pay_rate_group_begin_date?: Maybe<Scalars['timestamptz']['output']>;
  pay_rate_group_end_date?: Maybe<Scalars['timestamptz']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_type?: Maybe<Scalars['String']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['numeric']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_distance_miles?: Maybe<Scalars['numeric']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  region?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  region_source?: Maybe<Scalars['String']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  total_time_with_return?: Maybe<Scalars['String']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['numeric']['output']>;
  total_time_without_return?: Maybe<Scalars['String']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "driver_pay_by_move" */
export type Driver_Pay_By_Move_Aggregate = {
  __typename?: 'driver_pay_by_move_aggregate';
  aggregate?: Maybe<Driver_Pay_By_Move_Aggregate_Fields>;
  nodes: Array<Driver_Pay_By_Move>;
};

/** aggregate fields of "driver_pay_by_move" */
export type Driver_Pay_By_Move_Aggregate_Fields = {
  __typename?: 'driver_pay_by_move_aggregate_fields';
  avg?: Maybe<Driver_Pay_By_Move_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driver_Pay_By_Move_Max_Fields>;
  min?: Maybe<Driver_Pay_By_Move_Min_Fields>;
  stddev?: Maybe<Driver_Pay_By_Move_Stddev_Fields>;
  stddev_pop?: Maybe<Driver_Pay_By_Move_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driver_Pay_By_Move_Stddev_Samp_Fields>;
  sum?: Maybe<Driver_Pay_By_Move_Sum_Fields>;
  var_pop?: Maybe<Driver_Pay_By_Move_Var_Pop_Fields>;
  var_samp?: Maybe<Driver_Pay_By_Move_Var_Samp_Fields>;
  variance?: Maybe<Driver_Pay_By_Move_Variance_Fields>;
};


/** aggregate fields of "driver_pay_by_move" */
export type Driver_Pay_By_Move_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driver_Pay_By_Move_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driver_Pay_By_Move_Avg_Fields = {
  __typename?: 'driver_pay_by_move_avg_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driver_pay_by_move". All fields are combined with a logical 'AND'. */
export type Driver_Pay_By_Move_Bool_Exp = {
  _and?: InputMaybe<Array<Driver_Pay_By_Move_Bool_Exp>>;
  _not?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
  _or?: InputMaybe<Array<Driver_Pay_By_Move_Bool_Exp>>;
  appliedPayRateGroup?: InputMaybe<Payrategroups_Bool_Exp>;
  appliedPayRateRule?: InputMaybe<Payraterules_Bool_Exp>;
  appliedRegion?: InputMaybe<Regions_Bool_Exp>;
  average_drive_speed_mph?: InputMaybe<Numeric_Comparison_Exp>;
  average_drive_speed_mph_source?: InputMaybe<String_Comparison_Exp>;
  distance_miles?: InputMaybe<Numeric_Comparison_Exp>;
  drive_time?: InputMaybe<String_Comparison_Exp>;
  drive_time_seconds?: InputMaybe<Numeric_Comparison_Exp>;
  final_delivery_time_pay?: InputMaybe<Numeric_Comparison_Exp>;
  final_driver_base_pay?: InputMaybe<Numeric_Comparison_Exp>;
  final_driver_drive_pay?: InputMaybe<Numeric_Comparison_Exp>;
  final_driver_return_pay?: InputMaybe<Numeric_Comparison_Exp>;
  final_source?: InputMaybe<String_Comparison_Exp>;
  lane_delivery_inspection_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  lane_is_overriding_per_mile?: InputMaybe<Boolean_Comparison_Exp>;
  lane_is_overriding_per_minute?: InputMaybe<Boolean_Comparison_Exp>;
  lane_modifier_id?: InputMaybe<Int_Comparison_Exp>;
  lane_override_per_mile_rate?: InputMaybe<Numeric_Comparison_Exp>;
  lane_override_per_minute_rate?: InputMaybe<Numeric_Comparison_Exp>;
  lane_pickup_inspection_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  lane_return_ride_wait_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  lookup_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  lookup_date_source?: InputMaybe<String_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  non_drive_time_with_return?: InputMaybe<String_Comparison_Exp>;
  non_drive_time_with_return_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  non_drive_time_without_return?: InputMaybe<String_Comparison_Exp>;
  non_drive_time_without_return_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  overridden_delivery_time_pay?: InputMaybe<Numeric_Comparison_Exp>;
  overridden_driver_base_pay?: InputMaybe<Numeric_Comparison_Exp>;
  overridden_driver_drive_pay?: InputMaybe<Numeric_Comparison_Exp>;
  overridden_driver_return_pay?: InputMaybe<Numeric_Comparison_Exp>;
  pay_rate_group?: InputMaybe<String_Comparison_Exp>;
  pay_rate_group_begin_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  pay_rate_group_end_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  pay_rate_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  pay_rate_group_type?: InputMaybe<String_Comparison_Exp>;
  pay_rate_rule_band_end?: InputMaybe<Numeric_Comparison_Exp>;
  pay_rate_rule_band_start?: InputMaybe<Numeric_Comparison_Exp>;
  pay_rate_rule_id?: InputMaybe<Bigint_Comparison_Exp>;
  pay_rate_rule_per_mile?: InputMaybe<Numeric_Comparison_Exp>;
  pay_rate_rule_per_minute?: InputMaybe<Numeric_Comparison_Exp>;
  pre_delivery_inspection_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  pre_distance_miles?: InputMaybe<Numeric_Comparison_Exp>;
  pre_drive_time_seconds?: InputMaybe<Numeric_Comparison_Exp>;
  pre_pickup_inspection_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  pre_return_ride_wait_seconds?: InputMaybe<Bigint_Comparison_Exp>;
  region?: InputMaybe<String_Comparison_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  region_source?: InputMaybe<String_Comparison_Exp>;
  system_delivery_time_pay?: InputMaybe<Numeric_Comparison_Exp>;
  system_driver_base_pay?: InputMaybe<Numeric_Comparison_Exp>;
  system_driver_drive_pay?: InputMaybe<Numeric_Comparison_Exp>;
  system_driver_return_pay?: InputMaybe<Numeric_Comparison_Exp>;
  total_time_with_return?: InputMaybe<String_Comparison_Exp>;
  total_time_with_return_seconds?: InputMaybe<Numeric_Comparison_Exp>;
  total_time_without_return?: InputMaybe<String_Comparison_Exp>;
  total_time_without_return_seconds?: InputMaybe<Numeric_Comparison_Exp>;
};

/** input type for inserting data into table "driver_pay_by_move" */
export type Driver_Pay_By_Move_Insert_Input = {
  appliedPayRateGroup?: InputMaybe<Payrategroups_Obj_Rel_Insert_Input>;
  appliedPayRateRule?: InputMaybe<Payraterules_Obj_Rel_Insert_Input>;
  appliedRegion?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  average_drive_speed_mph?: InputMaybe<Scalars['numeric']['input']>;
  average_drive_speed_mph_source?: InputMaybe<Scalars['String']['input']>;
  distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  drive_time?: InputMaybe<Scalars['String']['input']>;
  drive_time_seconds?: InputMaybe<Scalars['numeric']['input']>;
  final_delivery_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_source?: InputMaybe<Scalars['String']['input']>;
  lane_delivery_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  lane_is_overriding_per_mile?: InputMaybe<Scalars['Boolean']['input']>;
  lane_is_overriding_per_minute?: InputMaybe<Scalars['Boolean']['input']>;
  lane_modifier_id?: InputMaybe<Scalars['Int']['input']>;
  lane_override_per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  lane_override_per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  lane_pickup_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  lane_return_ride_wait_seconds?: InputMaybe<Scalars['bigint']['input']>;
  lookup_date?: InputMaybe<Scalars['timestamptz']['input']>;
  lookup_date_source?: InputMaybe<Scalars['String']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  non_drive_time_with_return?: InputMaybe<Scalars['String']['input']>;
  non_drive_time_with_return_seconds?: InputMaybe<Scalars['bigint']['input']>;
  non_drive_time_without_return?: InputMaybe<Scalars['String']['input']>;
  non_drive_time_without_return_seconds?: InputMaybe<Scalars['bigint']['input']>;
  overridden_delivery_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  overridden_driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  overridden_driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  overridden_driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_group?: InputMaybe<Scalars['String']['input']>;
  pay_rate_group_begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  pay_rate_group_end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_type?: InputMaybe<Scalars['String']['input']>;
  pay_rate_rule_band_end?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_rule_band_start?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_rule_id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_rule_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_rule_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  pre_delivery_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  pre_distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  pre_drive_time_seconds?: InputMaybe<Scalars['numeric']['input']>;
  pre_pickup_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  pre_return_ride_wait_seconds?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  region_source?: InputMaybe<Scalars['String']['input']>;
  system_delivery_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  system_driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  system_driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  system_driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  total_time_with_return?: InputMaybe<Scalars['String']['input']>;
  total_time_with_return_seconds?: InputMaybe<Scalars['numeric']['input']>;
  total_time_without_return?: InputMaybe<Scalars['String']['input']>;
  total_time_without_return_seconds?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate max on columns */
export type Driver_Pay_By_Move_Max_Fields = {
  __typename?: 'driver_pay_by_move_max_fields';
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph_source?: Maybe<Scalars['String']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  drive_time?: Maybe<Scalars['String']['output']>;
  drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  final_source?: Maybe<Scalars['String']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_modifier_id?: Maybe<Scalars['Int']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  lookup_date?: Maybe<Scalars['timestamptz']['output']>;
  lookup_date_source?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_with_return?: Maybe<Scalars['String']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_without_return?: Maybe<Scalars['String']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['bigint']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  pay_rate_group?: Maybe<Scalars['String']['output']>;
  pay_rate_group_begin_date?: Maybe<Scalars['timestamptz']['output']>;
  pay_rate_group_end_date?: Maybe<Scalars['timestamptz']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_type?: Maybe<Scalars['String']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['numeric']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_distance_miles?: Maybe<Scalars['numeric']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  region?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  region_source?: Maybe<Scalars['String']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  total_time_with_return?: Maybe<Scalars['String']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['numeric']['output']>;
  total_time_without_return?: Maybe<Scalars['String']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type Driver_Pay_By_Move_Min_Fields = {
  __typename?: 'driver_pay_by_move_min_fields';
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph_source?: Maybe<Scalars['String']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  drive_time?: Maybe<Scalars['String']['output']>;
  drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  final_source?: Maybe<Scalars['String']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_modifier_id?: Maybe<Scalars['Int']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  lookup_date?: Maybe<Scalars['timestamptz']['output']>;
  lookup_date_source?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_with_return?: Maybe<Scalars['String']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_without_return?: Maybe<Scalars['String']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['bigint']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  pay_rate_group?: Maybe<Scalars['String']['output']>;
  pay_rate_group_begin_date?: Maybe<Scalars['timestamptz']['output']>;
  pay_rate_group_end_date?: Maybe<Scalars['timestamptz']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_type?: Maybe<Scalars['String']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['numeric']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_distance_miles?: Maybe<Scalars['numeric']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  region?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  region_source?: Maybe<Scalars['String']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  total_time_with_return?: Maybe<Scalars['String']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['numeric']['output']>;
  total_time_without_return?: Maybe<Scalars['String']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['numeric']['output']>;
};

/** input type for inserting object relation for remote table "driver_pay_by_move" */
export type Driver_Pay_By_Move_Obj_Rel_Insert_Input = {
  data: Driver_Pay_By_Move_Insert_Input;
};

/** Ordering options when selecting data from "driver_pay_by_move". */
export type Driver_Pay_By_Move_Order_By = {
  appliedPayRateGroup?: InputMaybe<Payrategroups_Order_By>;
  appliedPayRateRule?: InputMaybe<Payraterules_Order_By>;
  appliedRegion?: InputMaybe<Regions_Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  average_drive_speed_mph_source?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  drive_time?: InputMaybe<Order_By>;
  drive_time_seconds?: InputMaybe<Order_By>;
  final_delivery_time_pay?: InputMaybe<Order_By>;
  final_driver_base_pay?: InputMaybe<Order_By>;
  final_driver_drive_pay?: InputMaybe<Order_By>;
  final_driver_return_pay?: InputMaybe<Order_By>;
  final_source?: InputMaybe<Order_By>;
  lane_delivery_inspection_seconds?: InputMaybe<Order_By>;
  lane_is_overriding_per_mile?: InputMaybe<Order_By>;
  lane_is_overriding_per_minute?: InputMaybe<Order_By>;
  lane_modifier_id?: InputMaybe<Order_By>;
  lane_override_per_mile_rate?: InputMaybe<Order_By>;
  lane_override_per_minute_rate?: InputMaybe<Order_By>;
  lane_pickup_inspection_seconds?: InputMaybe<Order_By>;
  lane_return_ride_wait_seconds?: InputMaybe<Order_By>;
  lookup_date?: InputMaybe<Order_By>;
  lookup_date_source?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  non_drive_time_with_return?: InputMaybe<Order_By>;
  non_drive_time_with_return_seconds?: InputMaybe<Order_By>;
  non_drive_time_without_return?: InputMaybe<Order_By>;
  non_drive_time_without_return_seconds?: InputMaybe<Order_By>;
  overridden_delivery_time_pay?: InputMaybe<Order_By>;
  overridden_driver_base_pay?: InputMaybe<Order_By>;
  overridden_driver_drive_pay?: InputMaybe<Order_By>;
  overridden_driver_return_pay?: InputMaybe<Order_By>;
  pay_rate_group?: InputMaybe<Order_By>;
  pay_rate_group_begin_date?: InputMaybe<Order_By>;
  pay_rate_group_end_date?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  pay_rate_group_type?: InputMaybe<Order_By>;
  pay_rate_rule_band_end?: InputMaybe<Order_By>;
  pay_rate_rule_band_start?: InputMaybe<Order_By>;
  pay_rate_rule_id?: InputMaybe<Order_By>;
  pay_rate_rule_per_mile?: InputMaybe<Order_By>;
  pay_rate_rule_per_minute?: InputMaybe<Order_By>;
  pre_delivery_inspection_seconds?: InputMaybe<Order_By>;
  pre_distance_miles?: InputMaybe<Order_By>;
  pre_drive_time_seconds?: InputMaybe<Order_By>;
  pre_pickup_inspection_seconds?: InputMaybe<Order_By>;
  pre_return_ride_wait_seconds?: InputMaybe<Order_By>;
  region?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  region_source?: InputMaybe<Order_By>;
  system_delivery_time_pay?: InputMaybe<Order_By>;
  system_driver_base_pay?: InputMaybe<Order_By>;
  system_driver_drive_pay?: InputMaybe<Order_By>;
  system_driver_return_pay?: InputMaybe<Order_By>;
  total_time_with_return?: InputMaybe<Order_By>;
  total_time_with_return_seconds?: InputMaybe<Order_By>;
  total_time_without_return?: InputMaybe<Order_By>;
  total_time_without_return_seconds?: InputMaybe<Order_By>;
};

/** select columns of table "driver_pay_by_move" */
export enum Driver_Pay_By_Move_Select_Column {
  /** column name */
  AverageDriveSpeedMph = 'average_drive_speed_mph',
  /** column name */
  AverageDriveSpeedMphSource = 'average_drive_speed_mph_source',
  /** column name */
  DistanceMiles = 'distance_miles',
  /** column name */
  DriveTime = 'drive_time',
  /** column name */
  DriveTimeSeconds = 'drive_time_seconds',
  /** column name */
  FinalDeliveryTimePay = 'final_delivery_time_pay',
  /** column name */
  FinalDriverBasePay = 'final_driver_base_pay',
  /** column name */
  FinalDriverDrivePay = 'final_driver_drive_pay',
  /** column name */
  FinalDriverReturnPay = 'final_driver_return_pay',
  /** column name */
  FinalSource = 'final_source',
  /** column name */
  LaneDeliveryInspectionSeconds = 'lane_delivery_inspection_seconds',
  /** column name */
  LaneIsOverridingPerMile = 'lane_is_overriding_per_mile',
  /** column name */
  LaneIsOverridingPerMinute = 'lane_is_overriding_per_minute',
  /** column name */
  LaneModifierId = 'lane_modifier_id',
  /** column name */
  LaneOverridePerMileRate = 'lane_override_per_mile_rate',
  /** column name */
  LaneOverridePerMinuteRate = 'lane_override_per_minute_rate',
  /** column name */
  LanePickupInspectionSeconds = 'lane_pickup_inspection_seconds',
  /** column name */
  LaneReturnRideWaitSeconds = 'lane_return_ride_wait_seconds',
  /** column name */
  LookupDate = 'lookup_date',
  /** column name */
  LookupDateSource = 'lookup_date_source',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  NonDriveTimeWithReturn = 'non_drive_time_with_return',
  /** column name */
  NonDriveTimeWithReturnSeconds = 'non_drive_time_with_return_seconds',
  /** column name */
  NonDriveTimeWithoutReturn = 'non_drive_time_without_return',
  /** column name */
  NonDriveTimeWithoutReturnSeconds = 'non_drive_time_without_return_seconds',
  /** column name */
  OverriddenDeliveryTimePay = 'overridden_delivery_time_pay',
  /** column name */
  OverriddenDriverBasePay = 'overridden_driver_base_pay',
  /** column name */
  OverriddenDriverDrivePay = 'overridden_driver_drive_pay',
  /** column name */
  OverriddenDriverReturnPay = 'overridden_driver_return_pay',
  /** column name */
  PayRateGroup = 'pay_rate_group',
  /** column name */
  PayRateGroupBeginDate = 'pay_rate_group_begin_date',
  /** column name */
  PayRateGroupEndDate = 'pay_rate_group_end_date',
  /** column name */
  PayRateGroupId = 'pay_rate_group_id',
  /** column name */
  PayRateGroupType = 'pay_rate_group_type',
  /** column name */
  PayRateRuleBandEnd = 'pay_rate_rule_band_end',
  /** column name */
  PayRateRuleBandStart = 'pay_rate_rule_band_start',
  /** column name */
  PayRateRuleId = 'pay_rate_rule_id',
  /** column name */
  PayRateRulePerMile = 'pay_rate_rule_per_mile',
  /** column name */
  PayRateRulePerMinute = 'pay_rate_rule_per_minute',
  /** column name */
  PreDeliveryInspectionSeconds = 'pre_delivery_inspection_seconds',
  /** column name */
  PreDistanceMiles = 'pre_distance_miles',
  /** column name */
  PreDriveTimeSeconds = 'pre_drive_time_seconds',
  /** column name */
  PrePickupInspectionSeconds = 'pre_pickup_inspection_seconds',
  /** column name */
  PreReturnRideWaitSeconds = 'pre_return_ride_wait_seconds',
  /** column name */
  Region = 'region',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  RegionSource = 'region_source',
  /** column name */
  SystemDeliveryTimePay = 'system_delivery_time_pay',
  /** column name */
  SystemDriverBasePay = 'system_driver_base_pay',
  /** column name */
  SystemDriverDrivePay = 'system_driver_drive_pay',
  /** column name */
  SystemDriverReturnPay = 'system_driver_return_pay',
  /** column name */
  TotalTimeWithReturn = 'total_time_with_return',
  /** column name */
  TotalTimeWithReturnSeconds = 'total_time_with_return_seconds',
  /** column name */
  TotalTimeWithoutReturn = 'total_time_without_return',
  /** column name */
  TotalTimeWithoutReturnSeconds = 'total_time_without_return_seconds'
}

/** aggregate stddev on columns */
export type Driver_Pay_By_Move_Stddev_Fields = {
  __typename?: 'driver_pay_by_move_stddev_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driver_Pay_By_Move_Stddev_Pop_Fields = {
  __typename?: 'driver_pay_by_move_stddev_pop_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driver_Pay_By_Move_Stddev_Samp_Fields = {
  __typename?: 'driver_pay_by_move_stddev_samp_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driver_pay_by_move" */
export type Driver_Pay_By_Move_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driver_Pay_By_Move_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driver_Pay_By_Move_Stream_Cursor_Value_Input = {
  average_drive_speed_mph?: InputMaybe<Scalars['numeric']['input']>;
  average_drive_speed_mph_source?: InputMaybe<Scalars['String']['input']>;
  distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  drive_time?: InputMaybe<Scalars['String']['input']>;
  drive_time_seconds?: InputMaybe<Scalars['numeric']['input']>;
  final_delivery_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  final_source?: InputMaybe<Scalars['String']['input']>;
  lane_delivery_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  lane_is_overriding_per_mile?: InputMaybe<Scalars['Boolean']['input']>;
  lane_is_overriding_per_minute?: InputMaybe<Scalars['Boolean']['input']>;
  lane_modifier_id?: InputMaybe<Scalars['Int']['input']>;
  lane_override_per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  lane_override_per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  lane_pickup_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  lane_return_ride_wait_seconds?: InputMaybe<Scalars['bigint']['input']>;
  lookup_date?: InputMaybe<Scalars['timestamptz']['input']>;
  lookup_date_source?: InputMaybe<Scalars['String']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  non_drive_time_with_return?: InputMaybe<Scalars['String']['input']>;
  non_drive_time_with_return_seconds?: InputMaybe<Scalars['bigint']['input']>;
  non_drive_time_without_return?: InputMaybe<Scalars['String']['input']>;
  non_drive_time_without_return_seconds?: InputMaybe<Scalars['bigint']['input']>;
  overridden_delivery_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  overridden_driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  overridden_driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  overridden_driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_group?: InputMaybe<Scalars['String']['input']>;
  pay_rate_group_begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  pay_rate_group_end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_type?: InputMaybe<Scalars['String']['input']>;
  pay_rate_rule_band_end?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_rule_band_start?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_rule_id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_rule_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  pay_rate_rule_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  pre_delivery_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  pre_distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  pre_drive_time_seconds?: InputMaybe<Scalars['numeric']['input']>;
  pre_pickup_inspection_seconds?: InputMaybe<Scalars['bigint']['input']>;
  pre_return_ride_wait_seconds?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  region_source?: InputMaybe<Scalars['String']['input']>;
  system_delivery_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  system_driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  system_driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  system_driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  total_time_with_return?: InputMaybe<Scalars['String']['input']>;
  total_time_with_return_seconds?: InputMaybe<Scalars['numeric']['input']>;
  total_time_without_return?: InputMaybe<Scalars['String']['input']>;
  total_time_without_return_seconds?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type Driver_Pay_By_Move_Sum_Fields = {
  __typename?: 'driver_pay_by_move_sum_fields';
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  final_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_modifier_id?: Maybe<Scalars['Int']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['bigint']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['bigint']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['numeric']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['numeric']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_distance_miles?: Maybe<Scalars['numeric']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['numeric']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['bigint']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  system_driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['numeric']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate var_pop on columns */
export type Driver_Pay_By_Move_Var_Pop_Fields = {
  __typename?: 'driver_pay_by_move_var_pop_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driver_Pay_By_Move_Var_Samp_Fields = {
  __typename?: 'driver_pay_by_move_var_samp_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driver_Pay_By_Move_Variance_Fields = {
  __typename?: 'driver_pay_by_move_variance_fields';
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  final_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  final_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  lane_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_modifier_id?: Maybe<Scalars['Float']['output']>;
  lane_override_per_mile_rate?: Maybe<Scalars['Float']['output']>;
  lane_override_per_minute_rate?: Maybe<Scalars['Float']['output']>;
  lane_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  lane_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  non_drive_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  non_drive_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
  overridden_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  overridden_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_end?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_band_start?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_id?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_mile?: Maybe<Scalars['Float']['output']>;
  pay_rate_rule_per_minute?: Maybe<Scalars['Float']['output']>;
  pre_delivery_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_distance_miles?: Maybe<Scalars['Float']['output']>;
  pre_drive_time_seconds?: Maybe<Scalars['Float']['output']>;
  pre_pickup_inspection_seconds?: Maybe<Scalars['Float']['output']>;
  pre_return_ride_wait_seconds?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  system_delivery_time_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_base_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  system_driver_return_pay?: Maybe<Scalars['Float']['output']>;
  total_time_with_return_seconds?: Maybe<Scalars['Float']['output']>;
  total_time_without_return_seconds?: Maybe<Scalars['Float']['output']>;
};

/** App configuration JSON for the driver app. Used to control settings globally, by region, or by driver. */
export type Driverappconfig = {
  __typename?: 'driverappconfig';
  active: Scalars['Boolean']['output'];
  config: Scalars['jsonb']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  region_id?: Maybe<Scalars['bigint']['output']>;
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** App configuration JSON for the driver app. Used to control settings globally, by region, or by driver. */
export type DriverappconfigConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "driverappconfig" */
export type Driverappconfig_Aggregate = {
  __typename?: 'driverappconfig_aggregate';
  aggregate?: Maybe<Driverappconfig_Aggregate_Fields>;
  nodes: Array<Driverappconfig>;
};

/** aggregate fields of "driverappconfig" */
export type Driverappconfig_Aggregate_Fields = {
  __typename?: 'driverappconfig_aggregate_fields';
  avg?: Maybe<Driverappconfig_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverappconfig_Max_Fields>;
  min?: Maybe<Driverappconfig_Min_Fields>;
  stddev?: Maybe<Driverappconfig_Stddev_Fields>;
  stddev_pop?: Maybe<Driverappconfig_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverappconfig_Stddev_Samp_Fields>;
  sum?: Maybe<Driverappconfig_Sum_Fields>;
  var_pop?: Maybe<Driverappconfig_Var_Pop_Fields>;
  var_samp?: Maybe<Driverappconfig_Var_Samp_Fields>;
  variance?: Maybe<Driverappconfig_Variance_Fields>;
};


/** aggregate fields of "driverappconfig" */
export type Driverappconfig_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverappconfig_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Driverappconfig_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Driverappconfig_Avg_Fields = {
  __typename?: 'driverappconfig_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driverappconfig". All fields are combined with a logical 'AND'. */
export type Driverappconfig_Bool_Exp = {
  _and?: InputMaybe<Array<Driverappconfig_Bool_Exp>>;
  _not?: InputMaybe<Driverappconfig_Bool_Exp>;
  _or?: InputMaybe<Array<Driverappconfig_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverappconfig" */
export enum Driverappconfig_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriverappconfigPkey = 'driverappconfig_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Driverappconfig_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Driverappconfig_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Driverappconfig_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "driverappconfig" */
export type Driverappconfig_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverappconfig" */
export type Driverappconfig_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driverappconfig_Max_Fields = {
  __typename?: 'driverappconfig_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Driverappconfig_Min_Fields = {
  __typename?: 'driverappconfig_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "driverappconfig" */
export type Driverappconfig_Mutation_Response = {
  __typename?: 'driverappconfig_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverappconfig>;
};

/** on_conflict condition type for table "driverappconfig" */
export type Driverappconfig_On_Conflict = {
  constraint: Driverappconfig_Constraint;
  update_columns?: Array<Driverappconfig_Update_Column>;
  where?: InputMaybe<Driverappconfig_Bool_Exp>;
};

/** Ordering options when selecting data from "driverappconfig". */
export type Driverappconfig_Order_By = {
  active?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverappconfig */
export type Driverappconfig_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Driverappconfig_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "driverappconfig" */
export enum Driverappconfig_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "driverappconfig" */
export type Driverappconfig_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Driverappconfig_Stddev_Fields = {
  __typename?: 'driverappconfig_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driverappconfig_Stddev_Pop_Fields = {
  __typename?: 'driverappconfig_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driverappconfig_Stddev_Samp_Fields = {
  __typename?: 'driverappconfig_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driverappconfig" */
export type Driverappconfig_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverappconfig_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverappconfig_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driverappconfig_Sum_Fields = {
  __typename?: 'driverappconfig_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "driverappconfig" */
export enum Driverappconfig_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Driverappconfig_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Driverappconfig_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Driverappconfig_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Driverappconfig_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Driverappconfig_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverappconfig_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Driverappconfig_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverappconfig_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverappconfig_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverappconfig_Var_Pop_Fields = {
  __typename?: 'driverappconfig_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driverappconfig_Var_Samp_Fields = {
  __typename?: 'driverappconfig_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driverappconfig_Variance_Fields = {
  __typename?: 'driverappconfig_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "driverblacklist" */
export type Driverblacklist = {
  __typename?: 'driverblacklist';
  createdat: Scalars['timestamp']['output'];
  createdby?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  driver: Drivers;
  driver_id: Scalars['bigint']['output'];
  id: Scalars['bigint']['output'];
  point: Scalars['geography']['output'];
  reason: Scalars['String']['output'];
  udpatedat: Scalars['timestamp']['output'];
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "driverblacklist" */
export type Driverblacklist_Aggregate = {
  __typename?: 'driverblacklist_aggregate';
  aggregate?: Maybe<Driverblacklist_Aggregate_Fields>;
  nodes: Array<Driverblacklist>;
};

/** aggregate fields of "driverblacklist" */
export type Driverblacklist_Aggregate_Fields = {
  __typename?: 'driverblacklist_aggregate_fields';
  avg?: Maybe<Driverblacklist_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverblacklist_Max_Fields>;
  min?: Maybe<Driverblacklist_Min_Fields>;
  stddev?: Maybe<Driverblacklist_Stddev_Fields>;
  stddev_pop?: Maybe<Driverblacklist_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverblacklist_Stddev_Samp_Fields>;
  sum?: Maybe<Driverblacklist_Sum_Fields>;
  var_pop?: Maybe<Driverblacklist_Var_Pop_Fields>;
  var_samp?: Maybe<Driverblacklist_Var_Samp_Fields>;
  variance?: Maybe<Driverblacklist_Variance_Fields>;
};


/** aggregate fields of "driverblacklist" */
export type Driverblacklist_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverblacklist_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driverblacklist_Avg_Fields = {
  __typename?: 'driverblacklist_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driverblacklist". All fields are combined with a logical 'AND'. */
export type Driverblacklist_Bool_Exp = {
  _and?: InputMaybe<Array<Driverblacklist_Bool_Exp>>;
  _not?: InputMaybe<Driverblacklist_Bool_Exp>;
  _or?: InputMaybe<Array<Driverblacklist_Bool_Exp>>;
  createdat?: InputMaybe<Timestamp_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  point?: InputMaybe<Geography_Comparison_Exp>;
  reason?: InputMaybe<String_Comparison_Exp>;
  udpatedat?: InputMaybe<Timestamp_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverblacklist" */
export enum Driverblacklist_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriverblacklistPkey = 'driverblacklist_pkey'
}

/** input type for incrementing numeric columns in table "driverblacklist" */
export type Driverblacklist_Inc_Input = {
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverblacklist" */
export type Driverblacklist_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamp']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  point?: InputMaybe<Scalars['geography']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  udpatedat?: InputMaybe<Scalars['timestamp']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driverblacklist_Max_Fields = {
  __typename?: 'driverblacklist_max_fields';
  createdat?: Maybe<Scalars['timestamp']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  udpatedat?: Maybe<Scalars['timestamp']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Driverblacklist_Min_Fields = {
  __typename?: 'driverblacklist_min_fields';
  createdat?: Maybe<Scalars['timestamp']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  udpatedat?: Maybe<Scalars['timestamp']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "driverblacklist" */
export type Driverblacklist_Mutation_Response = {
  __typename?: 'driverblacklist_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverblacklist>;
};

/** on_conflict condition type for table "driverblacklist" */
export type Driverblacklist_On_Conflict = {
  constraint: Driverblacklist_Constraint;
  update_columns?: Array<Driverblacklist_Update_Column>;
  where?: InputMaybe<Driverblacklist_Bool_Exp>;
};

/** Ordering options when selecting data from "driverblacklist". */
export type Driverblacklist_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  point?: InputMaybe<Order_By>;
  reason?: InputMaybe<Order_By>;
  udpatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverblacklist */
export type Driverblacklist_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driverblacklist" */
export enum Driverblacklist_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Id = 'id',
  /** column name */
  Point = 'point',
  /** column name */
  Reason = 'reason',
  /** column name */
  Udpatedat = 'udpatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "driverblacklist" */
export type Driverblacklist_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamp']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  point?: InputMaybe<Scalars['geography']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  udpatedat?: InputMaybe<Scalars['timestamp']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Driverblacklist_Stddev_Fields = {
  __typename?: 'driverblacklist_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driverblacklist_Stddev_Pop_Fields = {
  __typename?: 'driverblacklist_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driverblacklist_Stddev_Samp_Fields = {
  __typename?: 'driverblacklist_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driverblacklist" */
export type Driverblacklist_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverblacklist_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverblacklist_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamp']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  point?: InputMaybe<Scalars['geography']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  udpatedat?: InputMaybe<Scalars['timestamp']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driverblacklist_Sum_Fields = {
  __typename?: 'driverblacklist_sum_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "driverblacklist" */
export enum Driverblacklist_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Id = 'id',
  /** column name */
  Point = 'point',
  /** column name */
  Reason = 'reason',
  /** column name */
  Udpatedat = 'udpatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Driverblacklist_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverblacklist_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverblacklist_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverblacklist_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverblacklist_Var_Pop_Fields = {
  __typename?: 'driverblacklist_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driverblacklist_Var_Samp_Fields = {
  __typename?: 'driverblacklist_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driverblacklist_Variance_Fields = {
  __typename?: 'driverblacklist_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** This table stores the drivers Personally Identifiable Information (PII). */
export type Driverdetails = {
  __typename?: 'driverdetails';
  /** Address city (home address). */
  address_city?: Maybe<Scalars['String']['output']>;
  /** Street address of driver (home address). */
  address_one?: Maybe<Scalars['String']['output']>;
  /** Address state (home address). */
  address_state?: Maybe<Scalars['String']['output']>;
  /** Additional street address information (home address). */
  address_two?: Maybe<Scalars['String']['output']>;
  /** Address ZIP code (home address). */
  address_zip?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** Birth date of the driver (YYYY-MM-DD). */
  date_of_birth?: Maybe<Scalars['String']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id: Scalars['bigint']['output'];
  /** The first emergency contact's name. */
  emergency_name_one?: Maybe<Scalars['String']['output']>;
  /** The second emergency contact's name. */
  emergency_name_two?: Maybe<Scalars['String']['output']>;
  /** The first emergency contact's phone number. */
  emergency_phone_one?: Maybe<Scalars['String']['output']>;
  /** The second emergency contact's phone number. */
  emergency_phone_two?: Maybe<Scalars['String']['output']>;
  /** Relation of the first emergency contact to the driver. */
  emergency_relationship_one?: Maybe<Scalars['String']['output']>;
  /** Relation of the second emergency contact to the driver. */
  emergency_relationship_two?: Maybe<Scalars['String']['output']>;
  /** Employer Identification Number with business entity. */
  employer_identifier?: Maybe<Scalars['String']['output']>;
  employer_name?: Maybe<Scalars['String']['output']>;
  /** Legal first name of driver. */
  first_name?: Maybe<Scalars['String']['output']>;
  /** What the driver identifies as. */
  gender?: Maybe<Scalars['String']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['numeric']['output']>;
  /** Identifier that represents what the policy includes. */
  insurance_policy_id?: Maybe<Scalars['String']['output']>;
  /** Company/Insurance Agency name. */
  insurance_provider?: Maybe<Scalars['String']['output']>;
  /** Determines if they have a rideshare rider on their insurance policy. */
  insurance_rideshare_rider?: Maybe<Scalars['Boolean']['output']>;
  /** Legal last name of driver. */
  last_name?: Maybe<Scalars['String']['output']>;
  /** Drivers license number. */
  license_number?: Maybe<Scalars['String']['output']>;
  /** A picture of the drivers license (stored in a secure photo bucket). */
  license_photo_url?: Maybe<Scalars['String']['output']>;
  /** Drivers license state. */
  license_state?: Maybe<Scalars['String']['output']>;
  /** Mailing address city (use home address instead if this is blank). */
  mail_address_city?: Maybe<Scalars['String']['output']>;
  /** Mailing street address of driver (use home address instead if this is blank). */
  mail_address_one?: Maybe<Scalars['String']['output']>;
  /** Mailing address state (use home address instead if this is blank). */
  mail_address_state?: Maybe<Scalars['String']['output']>;
  /** Mailing additional street address information (use home address instead if this is blank). */
  mail_address_two?: Maybe<Scalars['String']['output']>;
  /** Mailing address ZIP code (use home address instead if this is blank). */
  mail_address_zip?: Maybe<Scalars['String']['output']>;
  /** Legal middle name (or middle initial) of driver. */
  middle_name?: Maybe<Scalars['String']['output']>;
  /** Phone number to send to the IRS (not necessarily their cell phone). */
  primary_phone?: Maybe<Scalars['String']['output']>;
  /** Social Security Number for the individual. */
  social_security?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** Veteran information storage. */
  veteran?: Maybe<Scalars['jsonb']['output']>;
};


/** This table stores the drivers Personally Identifiable Information (PII). */
export type DriverdetailsVeteranArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "driverdetails" */
export type Driverdetails_Aggregate = {
  __typename?: 'driverdetails_aggregate';
  aggregate?: Maybe<Driverdetails_Aggregate_Fields>;
  nodes: Array<Driverdetails>;
};

/** aggregate fields of "driverdetails" */
export type Driverdetails_Aggregate_Fields = {
  __typename?: 'driverdetails_aggregate_fields';
  avg?: Maybe<Driverdetails_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverdetails_Max_Fields>;
  min?: Maybe<Driverdetails_Min_Fields>;
  stddev?: Maybe<Driverdetails_Stddev_Fields>;
  stddev_pop?: Maybe<Driverdetails_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverdetails_Stddev_Samp_Fields>;
  sum?: Maybe<Driverdetails_Sum_Fields>;
  var_pop?: Maybe<Driverdetails_Var_Pop_Fields>;
  var_samp?: Maybe<Driverdetails_Var_Samp_Fields>;
  variance?: Maybe<Driverdetails_Variance_Fields>;
};


/** aggregate fields of "driverdetails" */
export type Driverdetails_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverdetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Driverdetails_Append_Input = {
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Driverdetails_Avg_Fields = {
  __typename?: 'driverdetails_avg_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driverdetails". All fields are combined with a logical 'AND'. */
export type Driverdetails_Bool_Exp = {
  _and?: InputMaybe<Array<Driverdetails_Bool_Exp>>;
  _not?: InputMaybe<Driverdetails_Bool_Exp>;
  _or?: InputMaybe<Array<Driverdetails_Bool_Exp>>;
  address_city?: InputMaybe<String_Comparison_Exp>;
  address_one?: InputMaybe<String_Comparison_Exp>;
  address_state?: InputMaybe<String_Comparison_Exp>;
  address_two?: InputMaybe<String_Comparison_Exp>;
  address_zip?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  date_of_birth?: InputMaybe<String_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  emergency_name_one?: InputMaybe<String_Comparison_Exp>;
  emergency_name_two?: InputMaybe<String_Comparison_Exp>;
  emergency_phone_one?: InputMaybe<String_Comparison_Exp>;
  emergency_phone_two?: InputMaybe<String_Comparison_Exp>;
  emergency_relationship_one?: InputMaybe<String_Comparison_Exp>;
  emergency_relationship_two?: InputMaybe<String_Comparison_Exp>;
  employer_identifier?: InputMaybe<String_Comparison_Exp>;
  employer_name?: InputMaybe<String_Comparison_Exp>;
  first_name?: InputMaybe<String_Comparison_Exp>;
  gender?: InputMaybe<String_Comparison_Exp>;
  insurance_coverage_amount?: InputMaybe<Numeric_Comparison_Exp>;
  insurance_policy_id?: InputMaybe<String_Comparison_Exp>;
  insurance_provider?: InputMaybe<String_Comparison_Exp>;
  insurance_rideshare_rider?: InputMaybe<Boolean_Comparison_Exp>;
  last_name?: InputMaybe<String_Comparison_Exp>;
  license_number?: InputMaybe<String_Comparison_Exp>;
  license_photo_url?: InputMaybe<String_Comparison_Exp>;
  license_state?: InputMaybe<String_Comparison_Exp>;
  mail_address_city?: InputMaybe<String_Comparison_Exp>;
  mail_address_one?: InputMaybe<String_Comparison_Exp>;
  mail_address_state?: InputMaybe<String_Comparison_Exp>;
  mail_address_two?: InputMaybe<String_Comparison_Exp>;
  mail_address_zip?: InputMaybe<String_Comparison_Exp>;
  middle_name?: InputMaybe<String_Comparison_Exp>;
  primary_phone?: InputMaybe<String_Comparison_Exp>;
  social_security?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  veteran?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverdetails" */
export enum Driverdetails_Constraint {
  /** unique or primary key constraint on columns "driver_id" */
  DriverdetailsPkey = 'driverdetails_pkey',
  /** unique or primary key constraint on columns "social_security" */
  DriverdetailsSocialSecurityKey = 'driverdetails_social_security_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Driverdetails_Delete_At_Path_Input = {
  /** Veteran information storage. */
  veteran?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Driverdetails_Delete_Elem_Input = {
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Driverdetails_Delete_Key_Input = {
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "driverdetails" */
export type Driverdetails_Inc_Input = {
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "driverdetails" */
export type Driverdetails_Insert_Input = {
  /** Address city (home address). */
  address_city?: InputMaybe<Scalars['String']['input']>;
  /** Street address of driver (home address). */
  address_one?: InputMaybe<Scalars['String']['input']>;
  /** Address state (home address). */
  address_state?: InputMaybe<Scalars['String']['input']>;
  /** Additional street address information (home address). */
  address_two?: InputMaybe<Scalars['String']['input']>;
  /** Address ZIP code (home address). */
  address_zip?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Birth date of the driver (YYYY-MM-DD). */
  date_of_birth?: InputMaybe<Scalars['String']['input']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The first emergency contact's name. */
  emergency_name_one?: InputMaybe<Scalars['String']['input']>;
  /** The second emergency contact's name. */
  emergency_name_two?: InputMaybe<Scalars['String']['input']>;
  /** The first emergency contact's phone number. */
  emergency_phone_one?: InputMaybe<Scalars['String']['input']>;
  /** The second emergency contact's phone number. */
  emergency_phone_two?: InputMaybe<Scalars['String']['input']>;
  /** Relation of the first emergency contact to the driver. */
  emergency_relationship_one?: InputMaybe<Scalars['String']['input']>;
  /** Relation of the second emergency contact to the driver. */
  emergency_relationship_two?: InputMaybe<Scalars['String']['input']>;
  /** Employer Identification Number with business entity. */
  employer_identifier?: InputMaybe<Scalars['String']['input']>;
  employer_name?: InputMaybe<Scalars['String']['input']>;
  /** Legal first name of driver. */
  first_name?: InputMaybe<Scalars['String']['input']>;
  /** What the driver identifies as. */
  gender?: InputMaybe<Scalars['String']['input']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Identifier that represents what the policy includes. */
  insurance_policy_id?: InputMaybe<Scalars['String']['input']>;
  /** Company/Insurance Agency name. */
  insurance_provider?: InputMaybe<Scalars['String']['input']>;
  /** Determines if they have a rideshare rider on their insurance policy. */
  insurance_rideshare_rider?: InputMaybe<Scalars['Boolean']['input']>;
  /** Legal last name of driver. */
  last_name?: InputMaybe<Scalars['String']['input']>;
  /** Drivers license number. */
  license_number?: InputMaybe<Scalars['String']['input']>;
  /** A picture of the drivers license (stored in a secure photo bucket). */
  license_photo_url?: InputMaybe<Scalars['String']['input']>;
  /** Drivers license state. */
  license_state?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address city (use home address instead if this is blank). */
  mail_address_city?: InputMaybe<Scalars['String']['input']>;
  /** Mailing street address of driver (use home address instead if this is blank). */
  mail_address_one?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address state (use home address instead if this is blank). */
  mail_address_state?: InputMaybe<Scalars['String']['input']>;
  /** Mailing additional street address information (use home address instead if this is blank). */
  mail_address_two?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address ZIP code (use home address instead if this is blank). */
  mail_address_zip?: InputMaybe<Scalars['String']['input']>;
  /** Legal middle name (or middle initial) of driver. */
  middle_name?: InputMaybe<Scalars['String']['input']>;
  /** Phone number to send to the IRS (not necessarily their cell phone). */
  primary_phone?: InputMaybe<Scalars['String']['input']>;
  /** Social Security Number for the individual. */
  social_security?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type Driverdetails_Max_Fields = {
  __typename?: 'driverdetails_max_fields';
  /** Address city (home address). */
  address_city?: Maybe<Scalars['String']['output']>;
  /** Street address of driver (home address). */
  address_one?: Maybe<Scalars['String']['output']>;
  /** Address state (home address). */
  address_state?: Maybe<Scalars['String']['output']>;
  /** Additional street address information (home address). */
  address_two?: Maybe<Scalars['String']['output']>;
  /** Address ZIP code (home address). */
  address_zip?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Birth date of the driver (YYYY-MM-DD). */
  date_of_birth?: Maybe<Scalars['String']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** The first emergency contact's name. */
  emergency_name_one?: Maybe<Scalars['String']['output']>;
  /** The second emergency contact's name. */
  emergency_name_two?: Maybe<Scalars['String']['output']>;
  /** The first emergency contact's phone number. */
  emergency_phone_one?: Maybe<Scalars['String']['output']>;
  /** The second emergency contact's phone number. */
  emergency_phone_two?: Maybe<Scalars['String']['output']>;
  /** Relation of the first emergency contact to the driver. */
  emergency_relationship_one?: Maybe<Scalars['String']['output']>;
  /** Relation of the second emergency contact to the driver. */
  emergency_relationship_two?: Maybe<Scalars['String']['output']>;
  /** Employer Identification Number with business entity. */
  employer_identifier?: Maybe<Scalars['String']['output']>;
  employer_name?: Maybe<Scalars['String']['output']>;
  /** Legal first name of driver. */
  first_name?: Maybe<Scalars['String']['output']>;
  /** What the driver identifies as. */
  gender?: Maybe<Scalars['String']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['numeric']['output']>;
  /** Identifier that represents what the policy includes. */
  insurance_policy_id?: Maybe<Scalars['String']['output']>;
  /** Company/Insurance Agency name. */
  insurance_provider?: Maybe<Scalars['String']['output']>;
  /** Legal last name of driver. */
  last_name?: Maybe<Scalars['String']['output']>;
  /** Drivers license number. */
  license_number?: Maybe<Scalars['String']['output']>;
  /** A picture of the drivers license (stored in a secure photo bucket). */
  license_photo_url?: Maybe<Scalars['String']['output']>;
  /** Drivers license state. */
  license_state?: Maybe<Scalars['String']['output']>;
  /** Mailing address city (use home address instead if this is blank). */
  mail_address_city?: Maybe<Scalars['String']['output']>;
  /** Mailing street address of driver (use home address instead if this is blank). */
  mail_address_one?: Maybe<Scalars['String']['output']>;
  /** Mailing address state (use home address instead if this is blank). */
  mail_address_state?: Maybe<Scalars['String']['output']>;
  /** Mailing additional street address information (use home address instead if this is blank). */
  mail_address_two?: Maybe<Scalars['String']['output']>;
  /** Mailing address ZIP code (use home address instead if this is blank). */
  mail_address_zip?: Maybe<Scalars['String']['output']>;
  /** Legal middle name (or middle initial) of driver. */
  middle_name?: Maybe<Scalars['String']['output']>;
  /** Phone number to send to the IRS (not necessarily their cell phone). */
  primary_phone?: Maybe<Scalars['String']['output']>;
  /** Social Security Number for the individual. */
  social_security?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Driverdetails_Min_Fields = {
  __typename?: 'driverdetails_min_fields';
  /** Address city (home address). */
  address_city?: Maybe<Scalars['String']['output']>;
  /** Street address of driver (home address). */
  address_one?: Maybe<Scalars['String']['output']>;
  /** Address state (home address). */
  address_state?: Maybe<Scalars['String']['output']>;
  /** Additional street address information (home address). */
  address_two?: Maybe<Scalars['String']['output']>;
  /** Address ZIP code (home address). */
  address_zip?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Birth date of the driver (YYYY-MM-DD). */
  date_of_birth?: Maybe<Scalars['String']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** The first emergency contact's name. */
  emergency_name_one?: Maybe<Scalars['String']['output']>;
  /** The second emergency contact's name. */
  emergency_name_two?: Maybe<Scalars['String']['output']>;
  /** The first emergency contact's phone number. */
  emergency_phone_one?: Maybe<Scalars['String']['output']>;
  /** The second emergency contact's phone number. */
  emergency_phone_two?: Maybe<Scalars['String']['output']>;
  /** Relation of the first emergency contact to the driver. */
  emergency_relationship_one?: Maybe<Scalars['String']['output']>;
  /** Relation of the second emergency contact to the driver. */
  emergency_relationship_two?: Maybe<Scalars['String']['output']>;
  /** Employer Identification Number with business entity. */
  employer_identifier?: Maybe<Scalars['String']['output']>;
  employer_name?: Maybe<Scalars['String']['output']>;
  /** Legal first name of driver. */
  first_name?: Maybe<Scalars['String']['output']>;
  /** What the driver identifies as. */
  gender?: Maybe<Scalars['String']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['numeric']['output']>;
  /** Identifier that represents what the policy includes. */
  insurance_policy_id?: Maybe<Scalars['String']['output']>;
  /** Company/Insurance Agency name. */
  insurance_provider?: Maybe<Scalars['String']['output']>;
  /** Legal last name of driver. */
  last_name?: Maybe<Scalars['String']['output']>;
  /** Drivers license number. */
  license_number?: Maybe<Scalars['String']['output']>;
  /** A picture of the drivers license (stored in a secure photo bucket). */
  license_photo_url?: Maybe<Scalars['String']['output']>;
  /** Drivers license state. */
  license_state?: Maybe<Scalars['String']['output']>;
  /** Mailing address city (use home address instead if this is blank). */
  mail_address_city?: Maybe<Scalars['String']['output']>;
  /** Mailing street address of driver (use home address instead if this is blank). */
  mail_address_one?: Maybe<Scalars['String']['output']>;
  /** Mailing address state (use home address instead if this is blank). */
  mail_address_state?: Maybe<Scalars['String']['output']>;
  /** Mailing additional street address information (use home address instead if this is blank). */
  mail_address_two?: Maybe<Scalars['String']['output']>;
  /** Mailing address ZIP code (use home address instead if this is blank). */
  mail_address_zip?: Maybe<Scalars['String']['output']>;
  /** Legal middle name (or middle initial) of driver. */
  middle_name?: Maybe<Scalars['String']['output']>;
  /** Phone number to send to the IRS (not necessarily their cell phone). */
  primary_phone?: Maybe<Scalars['String']['output']>;
  /** Social Security Number for the individual. */
  social_security?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "driverdetails" */
export type Driverdetails_Mutation_Response = {
  __typename?: 'driverdetails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverdetails>;
};

/** input type for inserting object relation for remote table "driverdetails" */
export type Driverdetails_Obj_Rel_Insert_Input = {
  data: Driverdetails_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverdetails_On_Conflict>;
};

/** on_conflict condition type for table "driverdetails" */
export type Driverdetails_On_Conflict = {
  constraint: Driverdetails_Constraint;
  update_columns?: Array<Driverdetails_Update_Column>;
  where?: InputMaybe<Driverdetails_Bool_Exp>;
};

/** Ordering options when selecting data from "driverdetails". */
export type Driverdetails_Order_By = {
  address_city?: InputMaybe<Order_By>;
  address_one?: InputMaybe<Order_By>;
  address_state?: InputMaybe<Order_By>;
  address_two?: InputMaybe<Order_By>;
  address_zip?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  date_of_birth?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  emergency_name_one?: InputMaybe<Order_By>;
  emergency_name_two?: InputMaybe<Order_By>;
  emergency_phone_one?: InputMaybe<Order_By>;
  emergency_phone_two?: InputMaybe<Order_By>;
  emergency_relationship_one?: InputMaybe<Order_By>;
  emergency_relationship_two?: InputMaybe<Order_By>;
  employer_identifier?: InputMaybe<Order_By>;
  employer_name?: InputMaybe<Order_By>;
  first_name?: InputMaybe<Order_By>;
  gender?: InputMaybe<Order_By>;
  insurance_coverage_amount?: InputMaybe<Order_By>;
  insurance_policy_id?: InputMaybe<Order_By>;
  insurance_provider?: InputMaybe<Order_By>;
  insurance_rideshare_rider?: InputMaybe<Order_By>;
  last_name?: InputMaybe<Order_By>;
  license_number?: InputMaybe<Order_By>;
  license_photo_url?: InputMaybe<Order_By>;
  license_state?: InputMaybe<Order_By>;
  mail_address_city?: InputMaybe<Order_By>;
  mail_address_one?: InputMaybe<Order_By>;
  mail_address_state?: InputMaybe<Order_By>;
  mail_address_two?: InputMaybe<Order_By>;
  mail_address_zip?: InputMaybe<Order_By>;
  middle_name?: InputMaybe<Order_By>;
  primary_phone?: InputMaybe<Order_By>;
  social_security?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  veteran?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverdetails */
export type Driverdetails_Pk_Columns_Input = {
  /** Driver ID relating the driver record in our main database. */
  driver_id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Driverdetails_Prepend_Input = {
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "driverdetails" */
export enum Driverdetails_Select_Column {
  /** column name */
  AddressCity = 'address_city',
  /** column name */
  AddressOne = 'address_one',
  /** column name */
  AddressState = 'address_state',
  /** column name */
  AddressTwo = 'address_two',
  /** column name */
  AddressZip = 'address_zip',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DateOfBirth = 'date_of_birth',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EmergencyNameOne = 'emergency_name_one',
  /** column name */
  EmergencyNameTwo = 'emergency_name_two',
  /** column name */
  EmergencyPhoneOne = 'emergency_phone_one',
  /** column name */
  EmergencyPhoneTwo = 'emergency_phone_two',
  /** column name */
  EmergencyRelationshipOne = 'emergency_relationship_one',
  /** column name */
  EmergencyRelationshipTwo = 'emergency_relationship_two',
  /** column name */
  EmployerIdentifier = 'employer_identifier',
  /** column name */
  EmployerName = 'employer_name',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Gender = 'gender',
  /** column name */
  InsuranceCoverageAmount = 'insurance_coverage_amount',
  /** column name */
  InsurancePolicyId = 'insurance_policy_id',
  /** column name */
  InsuranceProvider = 'insurance_provider',
  /** column name */
  InsuranceRideshareRider = 'insurance_rideshare_rider',
  /** column name */
  LastName = 'last_name',
  /** column name */
  LicenseNumber = 'license_number',
  /** column name */
  LicensePhotoUrl = 'license_photo_url',
  /** column name */
  LicenseState = 'license_state',
  /** column name */
  MailAddressCity = 'mail_address_city',
  /** column name */
  MailAddressOne = 'mail_address_one',
  /** column name */
  MailAddressState = 'mail_address_state',
  /** column name */
  MailAddressTwo = 'mail_address_two',
  /** column name */
  MailAddressZip = 'mail_address_zip',
  /** column name */
  MiddleName = 'middle_name',
  /** column name */
  PrimaryPhone = 'primary_phone',
  /** column name */
  SocialSecurity = 'social_security',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Veteran = 'veteran'
}

/** input type for updating data in table "driverdetails" */
export type Driverdetails_Set_Input = {
  /** Address city (home address). */
  address_city?: InputMaybe<Scalars['String']['input']>;
  /** Street address of driver (home address). */
  address_one?: InputMaybe<Scalars['String']['input']>;
  /** Address state (home address). */
  address_state?: InputMaybe<Scalars['String']['input']>;
  /** Additional street address information (home address). */
  address_two?: InputMaybe<Scalars['String']['input']>;
  /** Address ZIP code (home address). */
  address_zip?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Birth date of the driver (YYYY-MM-DD). */
  date_of_birth?: InputMaybe<Scalars['String']['input']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The first emergency contact's name. */
  emergency_name_one?: InputMaybe<Scalars['String']['input']>;
  /** The second emergency contact's name. */
  emergency_name_two?: InputMaybe<Scalars['String']['input']>;
  /** The first emergency contact's phone number. */
  emergency_phone_one?: InputMaybe<Scalars['String']['input']>;
  /** The second emergency contact's phone number. */
  emergency_phone_two?: InputMaybe<Scalars['String']['input']>;
  /** Relation of the first emergency contact to the driver. */
  emergency_relationship_one?: InputMaybe<Scalars['String']['input']>;
  /** Relation of the second emergency contact to the driver. */
  emergency_relationship_two?: InputMaybe<Scalars['String']['input']>;
  /** Employer Identification Number with business entity. */
  employer_identifier?: InputMaybe<Scalars['String']['input']>;
  employer_name?: InputMaybe<Scalars['String']['input']>;
  /** Legal first name of driver. */
  first_name?: InputMaybe<Scalars['String']['input']>;
  /** What the driver identifies as. */
  gender?: InputMaybe<Scalars['String']['input']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Identifier that represents what the policy includes. */
  insurance_policy_id?: InputMaybe<Scalars['String']['input']>;
  /** Company/Insurance Agency name. */
  insurance_provider?: InputMaybe<Scalars['String']['input']>;
  /** Determines if they have a rideshare rider on their insurance policy. */
  insurance_rideshare_rider?: InputMaybe<Scalars['Boolean']['input']>;
  /** Legal last name of driver. */
  last_name?: InputMaybe<Scalars['String']['input']>;
  /** Drivers license number. */
  license_number?: InputMaybe<Scalars['String']['input']>;
  /** A picture of the drivers license (stored in a secure photo bucket). */
  license_photo_url?: InputMaybe<Scalars['String']['input']>;
  /** Drivers license state. */
  license_state?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address city (use home address instead if this is blank). */
  mail_address_city?: InputMaybe<Scalars['String']['input']>;
  /** Mailing street address of driver (use home address instead if this is blank). */
  mail_address_one?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address state (use home address instead if this is blank). */
  mail_address_state?: InputMaybe<Scalars['String']['input']>;
  /** Mailing additional street address information (use home address instead if this is blank). */
  mail_address_two?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address ZIP code (use home address instead if this is blank). */
  mail_address_zip?: InputMaybe<Scalars['String']['input']>;
  /** Legal middle name (or middle initial) of driver. */
  middle_name?: InputMaybe<Scalars['String']['input']>;
  /** Phone number to send to the IRS (not necessarily their cell phone). */
  primary_phone?: InputMaybe<Scalars['String']['input']>;
  /** Social Security Number for the individual. */
  social_security?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type Driverdetails_Stddev_Fields = {
  __typename?: 'driverdetails_stddev_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driverdetails_Stddev_Pop_Fields = {
  __typename?: 'driverdetails_stddev_pop_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driverdetails_Stddev_Samp_Fields = {
  __typename?: 'driverdetails_stddev_samp_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driverdetails" */
export type Driverdetails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverdetails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverdetails_Stream_Cursor_Value_Input = {
  /** Address city (home address). */
  address_city?: InputMaybe<Scalars['String']['input']>;
  /** Street address of driver (home address). */
  address_one?: InputMaybe<Scalars['String']['input']>;
  /** Address state (home address). */
  address_state?: InputMaybe<Scalars['String']['input']>;
  /** Additional street address information (home address). */
  address_two?: InputMaybe<Scalars['String']['input']>;
  /** Address ZIP code (home address). */
  address_zip?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Birth date of the driver (YYYY-MM-DD). */
  date_of_birth?: InputMaybe<Scalars['String']['input']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The first emergency contact's name. */
  emergency_name_one?: InputMaybe<Scalars['String']['input']>;
  /** The second emergency contact's name. */
  emergency_name_two?: InputMaybe<Scalars['String']['input']>;
  /** The first emergency contact's phone number. */
  emergency_phone_one?: InputMaybe<Scalars['String']['input']>;
  /** The second emergency contact's phone number. */
  emergency_phone_two?: InputMaybe<Scalars['String']['input']>;
  /** Relation of the first emergency contact to the driver. */
  emergency_relationship_one?: InputMaybe<Scalars['String']['input']>;
  /** Relation of the second emergency contact to the driver. */
  emergency_relationship_two?: InputMaybe<Scalars['String']['input']>;
  /** Employer Identification Number with business entity. */
  employer_identifier?: InputMaybe<Scalars['String']['input']>;
  employer_name?: InputMaybe<Scalars['String']['input']>;
  /** Legal first name of driver. */
  first_name?: InputMaybe<Scalars['String']['input']>;
  /** What the driver identifies as. */
  gender?: InputMaybe<Scalars['String']['input']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Identifier that represents what the policy includes. */
  insurance_policy_id?: InputMaybe<Scalars['String']['input']>;
  /** Company/Insurance Agency name. */
  insurance_provider?: InputMaybe<Scalars['String']['input']>;
  /** Determines if they have a rideshare rider on their insurance policy. */
  insurance_rideshare_rider?: InputMaybe<Scalars['Boolean']['input']>;
  /** Legal last name of driver. */
  last_name?: InputMaybe<Scalars['String']['input']>;
  /** Drivers license number. */
  license_number?: InputMaybe<Scalars['String']['input']>;
  /** A picture of the drivers license (stored in a secure photo bucket). */
  license_photo_url?: InputMaybe<Scalars['String']['input']>;
  /** Drivers license state. */
  license_state?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address city (use home address instead if this is blank). */
  mail_address_city?: InputMaybe<Scalars['String']['input']>;
  /** Mailing street address of driver (use home address instead if this is blank). */
  mail_address_one?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address state (use home address instead if this is blank). */
  mail_address_state?: InputMaybe<Scalars['String']['input']>;
  /** Mailing additional street address information (use home address instead if this is blank). */
  mail_address_two?: InputMaybe<Scalars['String']['input']>;
  /** Mailing address ZIP code (use home address instead if this is blank). */
  mail_address_zip?: InputMaybe<Scalars['String']['input']>;
  /** Legal middle name (or middle initial) of driver. */
  middle_name?: InputMaybe<Scalars['String']['input']>;
  /** Phone number to send to the IRS (not necessarily their cell phone). */
  primary_phone?: InputMaybe<Scalars['String']['input']>;
  /** Social Security Number for the individual. */
  social_security?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Veteran information storage. */
  veteran?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type Driverdetails_Sum_Fields = {
  __typename?: 'driverdetails_sum_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "driverdetails" */
export enum Driverdetails_Update_Column {
  /** column name */
  AddressCity = 'address_city',
  /** column name */
  AddressOne = 'address_one',
  /** column name */
  AddressState = 'address_state',
  /** column name */
  AddressTwo = 'address_two',
  /** column name */
  AddressZip = 'address_zip',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DateOfBirth = 'date_of_birth',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EmergencyNameOne = 'emergency_name_one',
  /** column name */
  EmergencyNameTwo = 'emergency_name_two',
  /** column name */
  EmergencyPhoneOne = 'emergency_phone_one',
  /** column name */
  EmergencyPhoneTwo = 'emergency_phone_two',
  /** column name */
  EmergencyRelationshipOne = 'emergency_relationship_one',
  /** column name */
  EmergencyRelationshipTwo = 'emergency_relationship_two',
  /** column name */
  EmployerIdentifier = 'employer_identifier',
  /** column name */
  EmployerName = 'employer_name',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Gender = 'gender',
  /** column name */
  InsuranceCoverageAmount = 'insurance_coverage_amount',
  /** column name */
  InsurancePolicyId = 'insurance_policy_id',
  /** column name */
  InsuranceProvider = 'insurance_provider',
  /** column name */
  InsuranceRideshareRider = 'insurance_rideshare_rider',
  /** column name */
  LastName = 'last_name',
  /** column name */
  LicenseNumber = 'license_number',
  /** column name */
  LicensePhotoUrl = 'license_photo_url',
  /** column name */
  LicenseState = 'license_state',
  /** column name */
  MailAddressCity = 'mail_address_city',
  /** column name */
  MailAddressOne = 'mail_address_one',
  /** column name */
  MailAddressState = 'mail_address_state',
  /** column name */
  MailAddressTwo = 'mail_address_two',
  /** column name */
  MailAddressZip = 'mail_address_zip',
  /** column name */
  MiddleName = 'middle_name',
  /** column name */
  PrimaryPhone = 'primary_phone',
  /** column name */
  SocialSecurity = 'social_security',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Veteran = 'veteran'
}

export type Driverdetails_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Driverdetails_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Driverdetails_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Driverdetails_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Driverdetails_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverdetails_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Driverdetails_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverdetails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverdetails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverdetails_Var_Pop_Fields = {
  __typename?: 'driverdetails_var_pop_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driverdetails_Var_Samp_Fields = {
  __typename?: 'driverdetails_var_samp_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driverdetails_Variance_Fields = {
  __typename?: 'driverdetails_variance_fields';
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Amount the insurance covers up to. */
  insurance_coverage_amount?: Maybe<Scalars['Float']['output']>;
};

/** Each entry is a piece of equipment we own. These records use the equipment table to tell us what they are. They can be deployed to drivers and tracked by region. */
export type Driverequipment = {
  __typename?: 'driverequipment';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  driver?: Maybe<Drivers>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  equipment?: Maybe<Equipment>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  region?: Maybe<Regions>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "driverequipment" */
export type Driverequipment_Aggregate = {
  __typename?: 'driverequipment_aggregate';
  aggregate?: Maybe<Driverequipment_Aggregate_Fields>;
  nodes: Array<Driverequipment>;
};

export type Driverequipment_Aggregate_Bool_Exp = {
  count?: InputMaybe<Driverequipment_Aggregate_Bool_Exp_Count>;
};

export type Driverequipment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driverequipment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driverequipment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driverequipment" */
export type Driverequipment_Aggregate_Fields = {
  __typename?: 'driverequipment_aggregate_fields';
  avg?: Maybe<Driverequipment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverequipment_Max_Fields>;
  min?: Maybe<Driverequipment_Min_Fields>;
  stddev?: Maybe<Driverequipment_Stddev_Fields>;
  stddev_pop?: Maybe<Driverequipment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverequipment_Stddev_Samp_Fields>;
  sum?: Maybe<Driverequipment_Sum_Fields>;
  var_pop?: Maybe<Driverequipment_Var_Pop_Fields>;
  var_samp?: Maybe<Driverequipment_Var_Samp_Fields>;
  variance?: Maybe<Driverequipment_Variance_Fields>;
};


/** aggregate fields of "driverequipment" */
export type Driverequipment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverequipment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driverequipment" */
export type Driverequipment_Aggregate_Order_By = {
  avg?: InputMaybe<Driverequipment_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driverequipment_Max_Order_By>;
  min?: InputMaybe<Driverequipment_Min_Order_By>;
  stddev?: InputMaybe<Driverequipment_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driverequipment_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driverequipment_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driverequipment_Sum_Order_By>;
  var_pop?: InputMaybe<Driverequipment_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driverequipment_Var_Samp_Order_By>;
  variance?: InputMaybe<Driverequipment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driverequipment" */
export type Driverequipment_Arr_Rel_Insert_Input = {
  data: Array<Driverequipment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverequipment_On_Conflict>;
};

/** aggregate avg on columns */
export type Driverequipment_Avg_Fields = {
  __typename?: 'driverequipment_avg_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driverequipment" */
export type Driverequipment_Avg_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driverequipment". All fields are combined with a logical 'AND'. */
export type Driverequipment_Bool_Exp = {
  _and?: InputMaybe<Array<Driverequipment_Bool_Exp>>;
  _not?: InputMaybe<Driverequipment_Bool_Exp>;
  _or?: InputMaybe<Array<Driverequipment_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  equipment?: InputMaybe<Equipment_Bool_Exp>;
  equipment_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverequipment" */
export enum Driverequipment_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriverequipmentPkey = 'driverequipment_pkey'
}

/** input type for incrementing numeric columns in table "driverequipment" */
export type Driverequipment_Inc_Input = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverequipment" */
export type Driverequipment_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  equipment?: InputMaybe<Equipment_Obj_Rel_Insert_Input>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Driverequipment_Max_Fields = {
  __typename?: 'driverequipment_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "driverequipment" */
export type Driverequipment_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driverequipment_Min_Fields = {
  __typename?: 'driverequipment_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "driverequipment" */
export type Driverequipment_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driverequipment" */
export type Driverequipment_Mutation_Response = {
  __typename?: 'driverequipment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverequipment>;
};

/** on_conflict condition type for table "driverequipment" */
export type Driverequipment_On_Conflict = {
  constraint: Driverequipment_Constraint;
  update_columns?: Array<Driverequipment_Update_Column>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};

/** Ordering options when selecting data from "driverequipment". */
export type Driverequipment_Order_By = {
  created_at?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  equipment?: InputMaybe<Equipment_Order_By>;
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverequipment */
export type Driverequipment_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driverequipment" */
export enum Driverequipment_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EquipmentId = 'equipment_id',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "driverequipment" */
export type Driverequipment_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Driverequipment_Stddev_Fields = {
  __typename?: 'driverequipment_stddev_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driverequipment" */
export type Driverequipment_Stddev_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driverequipment_Stddev_Pop_Fields = {
  __typename?: 'driverequipment_stddev_pop_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driverequipment" */
export type Driverequipment_Stddev_Pop_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driverequipment_Stddev_Samp_Fields = {
  __typename?: 'driverequipment_stddev_samp_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driverequipment" */
export type Driverequipment_Stddev_Samp_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driverequipment" */
export type Driverequipment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverequipment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverequipment_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Status of this particular item (inventory | deployed | lost | damaged | destroyed). */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Driverequipment_Sum_Fields = {
  __typename?: 'driverequipment_sum_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "driverequipment" */
export type Driverequipment_Sum_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** update columns of table "driverequipment" */
export enum Driverequipment_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EquipmentId = 'equipment_id',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Driverequipment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverequipment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverequipment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverequipment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverequipment_Var_Pop_Fields = {
  __typename?: 'driverequipment_var_pop_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driverequipment" */
export type Driverequipment_Var_Pop_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driverequipment_Var_Samp_Fields = {
  __typename?: 'driverequipment_var_samp_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driverequipment" */
export type Driverequipment_Var_Samp_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driverequipment_Variance_Fields = {
  __typename?: 'driverequipment_variance_fields';
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: Maybe<Scalars['Float']['output']>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driverequipment" */
export type Driverequipment_Variance_Order_By = {
  /** Relates to a driver record in our database (tells us which driver this item is assigned to). */
  driver_id?: InputMaybe<Order_By>;
  /** Relates to an equipment record in our database (tells us which item this actually is). */
  equipment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Relates to a region record in our database (lets us know where the item is located). */
  region_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "driverlocations" */
export type Driverlocations = {
  __typename?: 'driverlocations';
  accuracy?: Maybe<Scalars['float8']['output']>;
  activity_confidence?: Maybe<Scalars['Int']['output']>;
  activity_type?: Maybe<Scalars['String']['output']>;
  altitude?: Maybe<Scalars['float8']['output']>;
  altitude_accuracy?: Maybe<Scalars['float8']['output']>;
  battery_is_charging: Scalars['Boolean']['output'];
  battery_level?: Maybe<Scalars['float8']['output']>;
  driver_id: Scalars['bigint']['output'];
  event?: Maybe<Scalars['String']['output']>;
  heading?: Maybe<Scalars['float8']['output']>;
  id: Scalars['uuid']['output'];
  is_moving: Scalars['Boolean']['output'];
  location: Scalars['geography']['output'];
  mock: Scalars['Boolean']['output'];
  move_id?: Maybe<Scalars['bigint']['output']>;
  odometer?: Maybe<Scalars['float8']['output']>;
  speed?: Maybe<Scalars['float8']['output']>;
  time: Scalars['timestamptz']['output'];
};

/** aggregated selection of "driverlocations" */
export type Driverlocations_Aggregate = {
  __typename?: 'driverlocations_aggregate';
  aggregate?: Maybe<Driverlocations_Aggregate_Fields>;
  nodes: Array<Driverlocations>;
};

/** aggregate fields of "driverlocations" */
export type Driverlocations_Aggregate_Fields = {
  __typename?: 'driverlocations_aggregate_fields';
  avg?: Maybe<Driverlocations_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverlocations_Max_Fields>;
  min?: Maybe<Driverlocations_Min_Fields>;
  stddev?: Maybe<Driverlocations_Stddev_Fields>;
  stddev_pop?: Maybe<Driverlocations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverlocations_Stddev_Samp_Fields>;
  sum?: Maybe<Driverlocations_Sum_Fields>;
  var_pop?: Maybe<Driverlocations_Var_Pop_Fields>;
  var_samp?: Maybe<Driverlocations_Var_Samp_Fields>;
  variance?: Maybe<Driverlocations_Variance_Fields>;
};


/** aggregate fields of "driverlocations" */
export type Driverlocations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverlocations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driverlocations_Avg_Fields = {
  __typename?: 'driverlocations_avg_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driverlocations". All fields are combined with a logical 'AND'. */
export type Driverlocations_Bool_Exp = {
  _and?: InputMaybe<Array<Driverlocations_Bool_Exp>>;
  _not?: InputMaybe<Driverlocations_Bool_Exp>;
  _or?: InputMaybe<Array<Driverlocations_Bool_Exp>>;
  accuracy?: InputMaybe<Float8_Comparison_Exp>;
  activity_confidence?: InputMaybe<Int_Comparison_Exp>;
  activity_type?: InputMaybe<String_Comparison_Exp>;
  altitude?: InputMaybe<Float8_Comparison_Exp>;
  altitude_accuracy?: InputMaybe<Float8_Comparison_Exp>;
  battery_is_charging?: InputMaybe<Boolean_Comparison_Exp>;
  battery_level?: InputMaybe<Float8_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  event?: InputMaybe<String_Comparison_Exp>;
  heading?: InputMaybe<Float8_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  is_moving?: InputMaybe<Boolean_Comparison_Exp>;
  location?: InputMaybe<Geography_Comparison_Exp>;
  mock?: InputMaybe<Boolean_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  odometer?: InputMaybe<Float8_Comparison_Exp>;
  speed?: InputMaybe<Float8_Comparison_Exp>;
  time?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "driverlocations" */
export type Driverlocations_Inc_Input = {
  accuracy?: InputMaybe<Scalars['float8']['input']>;
  activity_confidence?: InputMaybe<Scalars['Int']['input']>;
  altitude?: InputMaybe<Scalars['float8']['input']>;
  altitude_accuracy?: InputMaybe<Scalars['float8']['input']>;
  battery_level?: InputMaybe<Scalars['float8']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  heading?: InputMaybe<Scalars['float8']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  odometer?: InputMaybe<Scalars['float8']['input']>;
  speed?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "driverlocations" */
export type Driverlocations_Insert_Input = {
  accuracy?: InputMaybe<Scalars['float8']['input']>;
  activity_confidence?: InputMaybe<Scalars['Int']['input']>;
  activity_type?: InputMaybe<Scalars['String']['input']>;
  altitude?: InputMaybe<Scalars['float8']['input']>;
  altitude_accuracy?: InputMaybe<Scalars['float8']['input']>;
  battery_is_charging?: InputMaybe<Scalars['Boolean']['input']>;
  battery_level?: InputMaybe<Scalars['float8']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  event?: InputMaybe<Scalars['String']['input']>;
  heading?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  is_moving?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  mock?: InputMaybe<Scalars['Boolean']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  odometer?: InputMaybe<Scalars['float8']['input']>;
  speed?: InputMaybe<Scalars['float8']['input']>;
  time?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Driverlocations_Max_Fields = {
  __typename?: 'driverlocations_max_fields';
  accuracy?: Maybe<Scalars['float8']['output']>;
  activity_confidence?: Maybe<Scalars['Int']['output']>;
  activity_type?: Maybe<Scalars['String']['output']>;
  altitude?: Maybe<Scalars['float8']['output']>;
  altitude_accuracy?: Maybe<Scalars['float8']['output']>;
  battery_level?: Maybe<Scalars['float8']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  event?: Maybe<Scalars['String']['output']>;
  heading?: Maybe<Scalars['float8']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  odometer?: Maybe<Scalars['float8']['output']>;
  speed?: Maybe<Scalars['float8']['output']>;
  time?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Driverlocations_Min_Fields = {
  __typename?: 'driverlocations_min_fields';
  accuracy?: Maybe<Scalars['float8']['output']>;
  activity_confidence?: Maybe<Scalars['Int']['output']>;
  activity_type?: Maybe<Scalars['String']['output']>;
  altitude?: Maybe<Scalars['float8']['output']>;
  altitude_accuracy?: Maybe<Scalars['float8']['output']>;
  battery_level?: Maybe<Scalars['float8']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  event?: Maybe<Scalars['String']['output']>;
  heading?: Maybe<Scalars['float8']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  odometer?: Maybe<Scalars['float8']['output']>;
  speed?: Maybe<Scalars['float8']['output']>;
  time?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "driverlocations" */
export type Driverlocations_Mutation_Response = {
  __typename?: 'driverlocations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverlocations>;
};

/** Ordering options when selecting data from "driverlocations". */
export type Driverlocations_Order_By = {
  accuracy?: InputMaybe<Order_By>;
  activity_confidence?: InputMaybe<Order_By>;
  activity_type?: InputMaybe<Order_By>;
  altitude?: InputMaybe<Order_By>;
  altitude_accuracy?: InputMaybe<Order_By>;
  battery_is_charging?: InputMaybe<Order_By>;
  battery_level?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  event?: InputMaybe<Order_By>;
  heading?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  is_moving?: InputMaybe<Order_By>;
  location?: InputMaybe<Order_By>;
  mock?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  odometer?: InputMaybe<Order_By>;
  speed?: InputMaybe<Order_By>;
  time?: InputMaybe<Order_By>;
};

/** select columns of table "driverlocations" */
export enum Driverlocations_Select_Column {
  /** column name */
  Accuracy = 'accuracy',
  /** column name */
  ActivityConfidence = 'activity_confidence',
  /** column name */
  ActivityType = 'activity_type',
  /** column name */
  Altitude = 'altitude',
  /** column name */
  AltitudeAccuracy = 'altitude_accuracy',
  /** column name */
  BatteryIsCharging = 'battery_is_charging',
  /** column name */
  BatteryLevel = 'battery_level',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Event = 'event',
  /** column name */
  Heading = 'heading',
  /** column name */
  Id = 'id',
  /** column name */
  IsMoving = 'is_moving',
  /** column name */
  Location = 'location',
  /** column name */
  Mock = 'mock',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Odometer = 'odometer',
  /** column name */
  Speed = 'speed',
  /** column name */
  Time = 'time'
}

/** input type for updating data in table "driverlocations" */
export type Driverlocations_Set_Input = {
  accuracy?: InputMaybe<Scalars['float8']['input']>;
  activity_confidence?: InputMaybe<Scalars['Int']['input']>;
  activity_type?: InputMaybe<Scalars['String']['input']>;
  altitude?: InputMaybe<Scalars['float8']['input']>;
  altitude_accuracy?: InputMaybe<Scalars['float8']['input']>;
  battery_is_charging?: InputMaybe<Scalars['Boolean']['input']>;
  battery_level?: InputMaybe<Scalars['float8']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  event?: InputMaybe<Scalars['String']['input']>;
  heading?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  is_moving?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  mock?: InputMaybe<Scalars['Boolean']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  odometer?: InputMaybe<Scalars['float8']['input']>;
  speed?: InputMaybe<Scalars['float8']['input']>;
  time?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Driverlocations_Stddev_Fields = {
  __typename?: 'driverlocations_stddev_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driverlocations_Stddev_Pop_Fields = {
  __typename?: 'driverlocations_stddev_pop_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driverlocations_Stddev_Samp_Fields = {
  __typename?: 'driverlocations_stddev_samp_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driverlocations" */
export type Driverlocations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverlocations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverlocations_Stream_Cursor_Value_Input = {
  accuracy?: InputMaybe<Scalars['float8']['input']>;
  activity_confidence?: InputMaybe<Scalars['Int']['input']>;
  activity_type?: InputMaybe<Scalars['String']['input']>;
  altitude?: InputMaybe<Scalars['float8']['input']>;
  altitude_accuracy?: InputMaybe<Scalars['float8']['input']>;
  battery_is_charging?: InputMaybe<Scalars['Boolean']['input']>;
  battery_level?: InputMaybe<Scalars['float8']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  event?: InputMaybe<Scalars['String']['input']>;
  heading?: InputMaybe<Scalars['float8']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  is_moving?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  mock?: InputMaybe<Scalars['Boolean']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  odometer?: InputMaybe<Scalars['float8']['input']>;
  speed?: InputMaybe<Scalars['float8']['input']>;
  time?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Driverlocations_Sum_Fields = {
  __typename?: 'driverlocations_sum_fields';
  accuracy?: Maybe<Scalars['float8']['output']>;
  activity_confidence?: Maybe<Scalars['Int']['output']>;
  altitude?: Maybe<Scalars['float8']['output']>;
  altitude_accuracy?: Maybe<Scalars['float8']['output']>;
  battery_level?: Maybe<Scalars['float8']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  heading?: Maybe<Scalars['float8']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  odometer?: Maybe<Scalars['float8']['output']>;
  speed?: Maybe<Scalars['float8']['output']>;
};

export type Driverlocations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverlocations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverlocations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverlocations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverlocations_Var_Pop_Fields = {
  __typename?: 'driverlocations_var_pop_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driverlocations_Var_Samp_Fields = {
  __typename?: 'driverlocations_var_samp_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driverlocations_Variance_Fields = {
  __typename?: 'driverlocations_variance_fields';
  accuracy?: Maybe<Scalars['Float']['output']>;
  activity_confidence?: Maybe<Scalars['Float']['output']>;
  altitude?: Maybe<Scalars['Float']['output']>;
  altitude_accuracy?: Maybe<Scalars['Float']['output']>;
  battery_level?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  heading?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  odometer?: Maybe<Scalars['Float']['output']>;
  speed?: Maybe<Scalars['Float']['output']>;
};

/** This table is an audit trail for everytime driver pay is triggered for a driver. Each relates to a driver and is a running amount until the next payout is created. */
export type Driverpayouts = {
  __typename?: 'driverpayouts';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount: Scalars['numeric']['output'];
  /** An array relationship */
  apcharges: Array<Apcharges>;
  /** An aggregate relationship */
  apcharges_aggregate: Apcharges_Aggregate;
  /** An array relationship */
  appayments: Array<Appayments>;
  /** An aggregate relationship */
  appayments_aggregate: Appayments_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  driver: Drivers;
  /** Driver ID relating the driver record in our main database. */
  driver_id: Scalars['bigint']['output'];
  id: Scalars['bigint']['output'];
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: Maybe<Scalars['String']['output']>;
  /** The status of the payout (new | processing | successful | failed). */
  status: Scalars['String']['output'];
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: Maybe<Scalars['String']['output']>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
};


/** This table is an audit trail for everytime driver pay is triggered for a driver. Each relates to a driver and is a running amount until the next payout is created. */
export type DriverpayoutsApchargesArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


/** This table is an audit trail for everytime driver pay is triggered for a driver. Each relates to a driver and is a running amount until the next payout is created. */
export type DriverpayoutsApcharges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


/** This table is an audit trail for everytime driver pay is triggered for a driver. Each relates to a driver and is a running amount until the next payout is created. */
export type DriverpayoutsAppaymentsArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


/** This table is an audit trail for everytime driver pay is triggered for a driver. Each relates to a driver and is a running amount until the next payout is created. */
export type DriverpayoutsAppayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};

/** aggregated selection of "driverpayouts" */
export type Driverpayouts_Aggregate = {
  __typename?: 'driverpayouts_aggregate';
  aggregate?: Maybe<Driverpayouts_Aggregate_Fields>;
  nodes: Array<Driverpayouts>;
};

export type Driverpayouts_Aggregate_Bool_Exp = {
  count?: InputMaybe<Driverpayouts_Aggregate_Bool_Exp_Count>;
};

export type Driverpayouts_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driverpayouts_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driverpayouts" */
export type Driverpayouts_Aggregate_Fields = {
  __typename?: 'driverpayouts_aggregate_fields';
  avg?: Maybe<Driverpayouts_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverpayouts_Max_Fields>;
  min?: Maybe<Driverpayouts_Min_Fields>;
  stddev?: Maybe<Driverpayouts_Stddev_Fields>;
  stddev_pop?: Maybe<Driverpayouts_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverpayouts_Stddev_Samp_Fields>;
  sum?: Maybe<Driverpayouts_Sum_Fields>;
  var_pop?: Maybe<Driverpayouts_Var_Pop_Fields>;
  var_samp?: Maybe<Driverpayouts_Var_Samp_Fields>;
  variance?: Maybe<Driverpayouts_Variance_Fields>;
};


/** aggregate fields of "driverpayouts" */
export type Driverpayouts_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driverpayouts" */
export type Driverpayouts_Aggregate_Order_By = {
  avg?: InputMaybe<Driverpayouts_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driverpayouts_Max_Order_By>;
  min?: InputMaybe<Driverpayouts_Min_Order_By>;
  stddev?: InputMaybe<Driverpayouts_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driverpayouts_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driverpayouts_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driverpayouts_Sum_Order_By>;
  var_pop?: InputMaybe<Driverpayouts_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driverpayouts_Var_Samp_Order_By>;
  variance?: InputMaybe<Driverpayouts_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driverpayouts" */
export type Driverpayouts_Arr_Rel_Insert_Input = {
  data: Array<Driverpayouts_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverpayouts_On_Conflict>;
};

/** aggregate avg on columns */
export type Driverpayouts_Avg_Fields = {
  __typename?: 'driverpayouts_avg_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driverpayouts" */
export type Driverpayouts_Avg_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driverpayouts". All fields are combined with a logical 'AND'. */
export type Driverpayouts_Bool_Exp = {
  _and?: InputMaybe<Array<Driverpayouts_Bool_Exp>>;
  _not?: InputMaybe<Driverpayouts_Bool_Exp>;
  _or?: InputMaybe<Array<Driverpayouts_Bool_Exp>>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  apcharges?: InputMaybe<Apcharges_Bool_Exp>;
  apcharges_aggregate?: InputMaybe<Apcharges_Aggregate_Bool_Exp>;
  appayments?: InputMaybe<Appayments_Bool_Exp>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  transfer_token?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverpayouts" */
export enum Driverpayouts_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriverpayoutsPkey = 'driverpayouts_pkey'
}

/** input type for incrementing numeric columns in table "driverpayouts" */
export type Driverpayouts_Inc_Input = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverpayouts" */
export type Driverpayouts_Insert_Input = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  apcharges?: InputMaybe<Apcharges_Arr_Rel_Insert_Input>;
  appayments?: InputMaybe<Appayments_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: InputMaybe<Scalars['String']['input']>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driverpayouts_Max_Fields = {
  __typename?: 'driverpayouts_max_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: Maybe<Scalars['String']['output']>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: Maybe<Scalars['String']['output']>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: Maybe<Scalars['String']['output']>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "driverpayouts" */
export type Driverpayouts_Max_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: InputMaybe<Order_By>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: InputMaybe<Order_By>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: InputMaybe<Order_By>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driverpayouts_Min_Fields = {
  __typename?: 'driverpayouts_min_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: Maybe<Scalars['String']['output']>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: Maybe<Scalars['String']['output']>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: Maybe<Scalars['String']['output']>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "driverpayouts" */
export type Driverpayouts_Min_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: InputMaybe<Order_By>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: InputMaybe<Order_By>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: InputMaybe<Order_By>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driverpayouts" */
export type Driverpayouts_Mutation_Response = {
  __typename?: 'driverpayouts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverpayouts>;
};

/** input type for inserting object relation for remote table "driverpayouts" */
export type Driverpayouts_Obj_Rel_Insert_Input = {
  data: Driverpayouts_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverpayouts_On_Conflict>;
};

/** on_conflict condition type for table "driverpayouts" */
export type Driverpayouts_On_Conflict = {
  constraint: Driverpayouts_Constraint;
  update_columns?: Array<Driverpayouts_Update_Column>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};

/** Ordering options when selecting data from "driverpayouts". */
export type Driverpayouts_Order_By = {
  amount?: InputMaybe<Order_By>;
  apcharges_aggregate?: InputMaybe<Apcharges_Aggregate_Order_By>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  transfer_token?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverpayouts */
export type Driverpayouts_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driverpayouts" */
export enum Driverpayouts_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  Status = 'status',
  /** column name */
  TransferToken = 'transfer_token',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "driverpayouts" */
export type Driverpayouts_Set_Input = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: InputMaybe<Scalars['String']['input']>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Driverpayouts_Stddev_Fields = {
  __typename?: 'driverpayouts_stddev_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driverpayouts" */
export type Driverpayouts_Stddev_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driverpayouts_Stddev_Pop_Fields = {
  __typename?: 'driverpayouts_stddev_pop_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driverpayouts" */
export type Driverpayouts_Stddev_Pop_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driverpayouts_Stddev_Samp_Fields = {
  __typename?: 'driverpayouts_stddev_samp_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driverpayouts" */
export type Driverpayouts_Stddev_Samp_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driverpayouts" */
export type Driverpayouts_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverpayouts_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverpayouts_Stream_Cursor_Value_Input = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** System notes specific to this payout (failure reason, etc.). Updated to "successful" or "failed" by 3rd party webhook. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** The status of the payout (new | processing | successful | failed). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** 3rd party banking token used to identify this specific transaction. */
  transfer_token?: InputMaybe<Scalars['String']['input']>;
  /** The type of payout. Used to determine who created the payout and when in the driver pay cycle this payout was created (weekly-standard | admin-early | driver-early). */
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driverpayouts_Sum_Fields = {
  __typename?: 'driverpayouts_sum_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['numeric']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "driverpayouts" */
export type Driverpayouts_Sum_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "driverpayouts" */
export enum Driverpayouts_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  Status = 'status',
  /** column name */
  TransferToken = 'transfer_token',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Driverpayouts_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverpayouts_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverpayouts_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverpayouts_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverpayouts_Var_Pop_Fields = {
  __typename?: 'driverpayouts_var_pop_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driverpayouts" */
export type Driverpayouts_Var_Pop_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driverpayouts_Var_Samp_Fields = {
  __typename?: 'driverpayouts_var_samp_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driverpayouts" */
export type Driverpayouts_Var_Samp_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driverpayouts_Variance_Fields = {
  __typename?: 'driverpayouts_variance_fields';
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driverpayouts" */
export type Driverpayouts_Variance_Order_By = {
  /** Amount to pay the driver (appayments added together since previous payout - This is the amount we are transferring to the driver when this record is created). */
  amount?: InputMaybe<Order_By>;
  /** Driver ID relating the driver record in our main database. */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "driverpays" */
export type Driverpays = {
  __typename?: 'driverpays';
  active: Scalars['smallint']['output'];
  average_driver_speed?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  region_code?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "driverpays" */
export type Driverpays_Aggregate = {
  __typename?: 'driverpays_aggregate';
  aggregate?: Maybe<Driverpays_Aggregate_Fields>;
  nodes: Array<Driverpays>;
};

/** aggregate fields of "driverpays" */
export type Driverpays_Aggregate_Fields = {
  __typename?: 'driverpays_aggregate_fields';
  avg?: Maybe<Driverpays_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverpays_Max_Fields>;
  min?: Maybe<Driverpays_Min_Fields>;
  stddev?: Maybe<Driverpays_Stddev_Fields>;
  stddev_pop?: Maybe<Driverpays_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverpays_Stddev_Samp_Fields>;
  sum?: Maybe<Driverpays_Sum_Fields>;
  var_pop?: Maybe<Driverpays_Var_Pop_Fields>;
  var_samp?: Maybe<Driverpays_Var_Samp_Fields>;
  variance?: Maybe<Driverpays_Variance_Fields>;
};


/** aggregate fields of "driverpays" */
export type Driverpays_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverpays_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driverpays_Avg_Fields = {
  __typename?: 'driverpays_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driverpays". All fields are combined with a logical 'AND'. */
export type Driverpays_Bool_Exp = {
  _and?: InputMaybe<Array<Driverpays_Bool_Exp>>;
  _not?: InputMaybe<Driverpays_Bool_Exp>;
  _or?: InputMaybe<Array<Driverpays_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  average_driver_speed?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  pay_per_kilometer?: InputMaybe<Numeric_Comparison_Exp>;
  pay_per_minute?: InputMaybe<Numeric_Comparison_Exp>;
  region_code?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverpays" */
export enum Driverpays_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25651Primary = 'idx_25651_primary'
}

/** input type for incrementing numeric columns in table "driverpays" */
export type Driverpays_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_driver_speed?: InputMaybe<Scalars['numeric']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "driverpays" */
export type Driverpays_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_driver_speed?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  region_code?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Driverpays_Max_Fields = {
  __typename?: 'driverpays_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  average_driver_speed?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  region_code?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Driverpays_Min_Fields = {
  __typename?: 'driverpays_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  average_driver_speed?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  region_code?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "driverpays" */
export type Driverpays_Mutation_Response = {
  __typename?: 'driverpays_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverpays>;
};

/** on_conflict condition type for table "driverpays" */
export type Driverpays_On_Conflict = {
  constraint: Driverpays_Constraint;
  update_columns?: Array<Driverpays_Update_Column>;
  where?: InputMaybe<Driverpays_Bool_Exp>;
};

/** Ordering options when selecting data from "driverpays". */
export type Driverpays_Order_By = {
  active?: InputMaybe<Order_By>;
  average_driver_speed?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_per_kilometer?: InputMaybe<Order_By>;
  pay_per_minute?: InputMaybe<Order_By>;
  region_code?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverpays */
export type Driverpays_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driverpays" */
export enum Driverpays_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AverageDriverSpeed = 'average_driver_speed',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  PayPerKilometer = 'pay_per_kilometer',
  /** column name */
  PayPerMinute = 'pay_per_minute',
  /** column name */
  RegionCode = 'region_code',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "driverpays" */
export type Driverpays_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_driver_speed?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  region_code?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Driverpays_Stddev_Fields = {
  __typename?: 'driverpays_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driverpays_Stddev_Pop_Fields = {
  __typename?: 'driverpays_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driverpays_Stddev_Samp_Fields = {
  __typename?: 'driverpays_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driverpays" */
export type Driverpays_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverpays_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverpays_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_driver_speed?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  region_code?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Driverpays_Sum_Fields = {
  __typename?: 'driverpays_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  average_driver_speed?: Maybe<Scalars['numeric']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  pay_per_minute?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "driverpays" */
export enum Driverpays_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AverageDriverSpeed = 'average_driver_speed',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  PayPerKilometer = 'pay_per_kilometer',
  /** column name */
  PayPerMinute = 'pay_per_minute',
  /** column name */
  RegionCode = 'region_code',
  /** column name */
  Updatedat = 'updatedat'
}

export type Driverpays_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverpays_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverpays_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverpays_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverpays_Var_Pop_Fields = {
  __typename?: 'driverpays_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driverpays_Var_Samp_Fields = {
  __typename?: 'driverpays_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driverpays_Variance_Fields = {
  __typename?: 'driverpays_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_driver_speed?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  pay_per_minute?: Maybe<Scalars['Float']['output']>;
};

/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type Drivers = {
  __typename?: 'drivers';
  /** An array relationship */
  apcharges: Array<Apcharges>;
  /** An aggregate relationship */
  apcharges_aggregate: Apcharges_Aggregate;
  /** When the app launches, is minimized, or force quit, that most recent app status will be reflected here. Possible values are (active, background, inactive) */
  app_status?: Maybe<Scalars['String']['output']>;
  /** Whenever the app_status changes, the timestamp of when that occurred will be reflected here. */
  app_status_updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  appayments: Array<Appayments>;
  /** An aggregate relationship */
  appayments_aggregate: Appayments_Aggregate;
  /** 3rd party bank account token used to directly associate a driver to a bank account. */
  bank_account_token?: Maybe<Scalars['String']['output']>;
  /** Status of the driver's background check */
  bg_check_status?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  certifications: Array<Driverstocertifications>;
  /** An aggregate relationship */
  certifications_aggregate: Driverstocertifications_Aggregate;
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: Maybe<Scalars['jsonb']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** Mobile device specifications */
  device_specs?: Maybe<Scalars['jsonb']['output']>;
  /** Mobile device token id for push notifications. Should be unique across Android and iOS. */
  device_token?: Maybe<Scalars['String']['output']>;
  /** The most recent version of the app the driver has used. */
  driver_app_version?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  driverdetail?: Maybe<Driverdetails>;
  /** An array relationship */
  driverpayouts: Array<Driverpayouts>;
  /** An aggregate relationship */
  driverpayouts_aggregate: Driverpayouts_Aggregate;
  /** An array relationship */
  equipment: Array<Driverequipment>;
  /** An aggregate relationship */
  equipment_aggregate: Driverequipment_Aggregate;
  gpslocations: Array<Driverlocations>;
  gpslocations_aggregate: Driverlocations_Aggregate;
  /** An object relationship */
  home_location?: Maybe<Locations>;
  home_location_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: Maybe<Scalars['jsonb']['output']>;
  /** Email of the last user to take an action in the recruitment pipeline */
  last_action_by?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  mailing_location?: Maybe<Locations>;
  mailing_location_id?: Maybe<Scalars['bigint']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  offers: Array<Offers>;
  /** An aggregate relationship */
  offers_aggregate: Offers_Aggregate;
  /** Drivers phone brand/type (android, iphone, etc.). */
  phone_type?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  plate?: Maybe<Plates>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['bigint']['output']>;
  /** Recruitment pipeline specific statuses, including new, ready, backlog, disqualified, contacting, interviewing, onboarding, training, rejected, and terminated */
  recruitment_status?: Maybe<Scalars['String']['output']>;
  /** Time at which the driver's recruitment status was last updated */
  recruitment_status_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Referral source for joining Hopdrive as a driver (LinkedIn, Google, Indeed, etc.) */
  referral_source?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  region?: Maybe<Regions>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['bigint']['output']>;
  starting_location?: Maybe<Scalars['geography']['output']>;
  /** Current driver status (new | interviewed | onboarding | training | offline | online | rejected | terminated). */
  status: Scalars['String']['output'];
  /** An object relationship */
  talent_coordinator?: Maybe<Users>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines the type of tax class the driver is in (1099, W-2, etc.). */
  tax_class: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user?: Maybe<Users>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['bigint']['output']>;
  /** Color of the drivers vehicle. */
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** License plate of the drivers vehicle. */
  vehicle_license_plate?: Maybe<Scalars['String']['output']>;
  /** State of the drivers license plate. */
  vehicle_license_plate_state?: Maybe<Scalars['String']['output']>;
  /** Make of the drivers vehicle. */
  vehicle_make?: Maybe<Scalars['String']['output']>;
  /** Model of the drivers vehicle. */
  vehicle_model?: Maybe<Scalars['String']['output']>;
  /** VIN of the drivers vehicle. */
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  /** Year of the drivers vehicle. */
  vehicle_year?: Maybe<Scalars['String']['output']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: Maybe<Scalars['jsonb']['output']>;
  /** 3rd party banking token used for transactions to this driver. */
  wallet_token?: Maybe<Scalars['String']['output']>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversApchargesArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversApcharges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversAppaymentsArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversAppayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversCertificationsArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversCertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversDevice_SpecsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversDriverpayoutsArgs = {
  distinct_on?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpayouts_Order_By>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversDriverpayouts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpayouts_Order_By>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversEquipmentArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversEquipment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversGpslocationsArgs = {
  distinct_on?: InputMaybe<Array<Driverlocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverlocations_Order_By>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversGpslocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverlocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverlocations_Order_By>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversIntake_InfoArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversOffersArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversOffers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


/** An extension of users with a driver role. Each record represents a driver for the company that will move cars and get paid for the gig. The driver id here will relate to many different places in the database including driver pay, plans, move assignment, users, and more. The ID originally came from Tookan and was imported then when Tookan went away, we started auto-incrementing from here instead. */
export type DriversVerificationArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "drivers" */
export type Drivers_Aggregate = {
  __typename?: 'drivers_aggregate';
  aggregate?: Maybe<Drivers_Aggregate_Fields>;
  nodes: Array<Drivers>;
};

/** aggregate fields of "drivers" */
export type Drivers_Aggregate_Fields = {
  __typename?: 'drivers_aggregate_fields';
  avg?: Maybe<Drivers_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Drivers_Max_Fields>;
  min?: Maybe<Drivers_Min_Fields>;
  stddev?: Maybe<Drivers_Stddev_Fields>;
  stddev_pop?: Maybe<Drivers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Drivers_Stddev_Samp_Fields>;
  sum?: Maybe<Drivers_Sum_Fields>;
  var_pop?: Maybe<Drivers_Var_Pop_Fields>;
  var_samp?: Maybe<Drivers_Var_Samp_Fields>;
  variance?: Maybe<Drivers_Variance_Fields>;
};


/** aggregate fields of "drivers" */
export type Drivers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Drivers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Drivers_Append_Input = {
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['jsonb']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['jsonb']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Drivers_Avg_Fields = {
  __typename?: 'drivers_avg_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "drivers". All fields are combined with a logical 'AND'. */
export type Drivers_Bool_Exp = {
  _and?: InputMaybe<Array<Drivers_Bool_Exp>>;
  _not?: InputMaybe<Drivers_Bool_Exp>;
  _or?: InputMaybe<Array<Drivers_Bool_Exp>>;
  apcharges?: InputMaybe<Apcharges_Bool_Exp>;
  apcharges_aggregate?: InputMaybe<Apcharges_Aggregate_Bool_Exp>;
  app_status?: InputMaybe<String_Comparison_Exp>;
  app_status_updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  appayments?: InputMaybe<Appayments_Bool_Exp>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Bool_Exp>;
  bank_account_token?: InputMaybe<String_Comparison_Exp>;
  bg_check_status?: InputMaybe<String_Comparison_Exp>;
  certifications?: InputMaybe<Driverstocertifications_Bool_Exp>;
  certifications_aggregate?: InputMaybe<Driverstocertifications_Aggregate_Bool_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  device_specs?: InputMaybe<Jsonb_Comparison_Exp>;
  device_token?: InputMaybe<String_Comparison_Exp>;
  driver_app_version?: InputMaybe<String_Comparison_Exp>;
  driverdetail?: InputMaybe<Driverdetails_Bool_Exp>;
  driverpayouts?: InputMaybe<Driverpayouts_Bool_Exp>;
  driverpayouts_aggregate?: InputMaybe<Driverpayouts_Aggregate_Bool_Exp>;
  equipment?: InputMaybe<Driverequipment_Bool_Exp>;
  equipment_aggregate?: InputMaybe<Driverequipment_Aggregate_Bool_Exp>;
  home_location?: InputMaybe<Locations_Bool_Exp>;
  home_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  intake_info?: InputMaybe<Jsonb_Comparison_Exp>;
  last_action_by?: InputMaybe<String_Comparison_Exp>;
  mailing_location?: InputMaybe<Locations_Bool_Exp>;
  mailing_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  max_drive_radius_mi?: InputMaybe<Bigint_Comparison_Exp>;
  offers?: InputMaybe<Offers_Bool_Exp>;
  offers_aggregate?: InputMaybe<Offers_Aggregate_Bool_Exp>;
  phone_type?: InputMaybe<String_Comparison_Exp>;
  plate?: InputMaybe<Plates_Bool_Exp>;
  plate_id?: InputMaybe<Bigint_Comparison_Exp>;
  recruitment_status?: InputMaybe<String_Comparison_Exp>;
  recruitment_status_updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  referral_source?: InputMaybe<String_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  starting_location?: InputMaybe<Geography_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  talent_coordinator?: InputMaybe<Users_Bool_Exp>;
  talent_coordinator_id?: InputMaybe<Bigint_Comparison_Exp>;
  tax_class?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
  vehicle_color?: InputMaybe<String_Comparison_Exp>;
  vehicle_license_plate?: InputMaybe<String_Comparison_Exp>;
  vehicle_license_plate_state?: InputMaybe<String_Comparison_Exp>;
  vehicle_make?: InputMaybe<String_Comparison_Exp>;
  vehicle_model?: InputMaybe<String_Comparison_Exp>;
  vehicle_vin?: InputMaybe<String_Comparison_Exp>;
  vehicle_year?: InputMaybe<String_Comparison_Exp>;
  verification?: InputMaybe<Jsonb_Comparison_Exp>;
  wallet_token?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "drivers" */
export enum Drivers_Constraint {
  /** unique or primary key constraint on columns "id" */
  DriversPkey = 'drivers_pkey',
  /** unique or primary key constraint on columns "user_id" */
  DriversUserIdKey = 'drivers_user_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Drivers_Delete_At_Path_Input = {
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Array<Scalars['String']['input']>>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Drivers_Delete_Elem_Input = {
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['Int']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['Int']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['Int']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Drivers_Delete_Key_Input = {
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['String']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['String']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['String']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "drivers" */
export type Drivers_Inc_Input = {
  home_location_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  mailing_location_id?: InputMaybe<Scalars['bigint']['input']>;
  max_drive_radius_mi?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "drivers" */
export type Drivers_Insert_Input = {
  apcharges?: InputMaybe<Apcharges_Arr_Rel_Insert_Input>;
  /** When the app launches, is minimized, or force quit, that most recent app status will be reflected here. Possible values are (active, background, inactive) */
  app_status?: InputMaybe<Scalars['String']['input']>;
  /** Whenever the app_status changes, the timestamp of when that occurred will be reflected here. */
  app_status_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  appayments?: InputMaybe<Appayments_Arr_Rel_Insert_Input>;
  /** 3rd party bank account token used to directly associate a driver to a bank account. */
  bank_account_token?: InputMaybe<Scalars['String']['input']>;
  /** Status of the driver's background check */
  bg_check_status?: InputMaybe<Scalars['String']['input']>;
  certifications?: InputMaybe<Driverstocertifications_Arr_Rel_Insert_Input>;
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['jsonb']['input']>;
  /** Mobile device token id for push notifications. Should be unique across Android and iOS. */
  device_token?: InputMaybe<Scalars['String']['input']>;
  /** The most recent version of the app the driver has used. */
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  driverdetail?: InputMaybe<Driverdetails_Obj_Rel_Insert_Input>;
  driverpayouts?: InputMaybe<Driverpayouts_Arr_Rel_Insert_Input>;
  equipment?: InputMaybe<Driverequipment_Arr_Rel_Insert_Input>;
  home_location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  home_location_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['jsonb']['input']>;
  /** Email of the last user to take an action in the recruitment pipeline */
  last_action_by?: InputMaybe<Scalars['String']['input']>;
  mailing_location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  mailing_location_id?: InputMaybe<Scalars['bigint']['input']>;
  max_drive_radius_mi?: InputMaybe<Scalars['bigint']['input']>;
  offers?: InputMaybe<Offers_Arr_Rel_Insert_Input>;
  /** Drivers phone brand/type (android, iphone, etc.). */
  phone_type?: InputMaybe<Scalars['String']['input']>;
  plate?: InputMaybe<Plates_Obj_Rel_Insert_Input>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Recruitment pipeline specific statuses, including new, ready, backlog, disqualified, contacting, interviewing, onboarding, training, rejected, and terminated */
  recruitment_status?: InputMaybe<Scalars['String']['input']>;
  /** Time at which the driver's recruitment status was last updated */
  recruitment_status_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referral source for joining Hopdrive as a driver (LinkedIn, Google, Indeed, etc.) */
  referral_source?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  starting_location?: InputMaybe<Scalars['geography']['input']>;
  /** Current driver status (new | interviewed | onboarding | training | offline | online | rejected | terminated). */
  status?: InputMaybe<Scalars['String']['input']>;
  talent_coordinator?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines the type of tax class the driver is in (1099, W-2, etc.). */
  tax_class?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Color of the drivers vehicle. */
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** License plate of the drivers vehicle. */
  vehicle_license_plate?: InputMaybe<Scalars['String']['input']>;
  /** State of the drivers license plate. */
  vehicle_license_plate_state?: InputMaybe<Scalars['String']['input']>;
  /** Make of the drivers vehicle. */
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  /** Model of the drivers vehicle. */
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  /** VIN of the drivers vehicle. */
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  /** Year of the drivers vehicle. */
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['jsonb']['input']>;
  /** 3rd party banking token used for transactions to this driver. */
  wallet_token?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Drivers_Max_Fields = {
  __typename?: 'drivers_max_fields';
  /** When the app launches, is minimized, or force quit, that most recent app status will be reflected here. Possible values are (active, background, inactive) */
  app_status?: Maybe<Scalars['String']['output']>;
  /** Whenever the app_status changes, the timestamp of when that occurred will be reflected here. */
  app_status_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** 3rd party bank account token used to directly associate a driver to a bank account. */
  bank_account_token?: Maybe<Scalars['String']['output']>;
  /** Status of the driver's background check */
  bg_check_status?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Mobile device token id for push notifications. Should be unique across Android and iOS. */
  device_token?: Maybe<Scalars['String']['output']>;
  /** The most recent version of the app the driver has used. */
  driver_app_version?: Maybe<Scalars['String']['output']>;
  home_location_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Email of the last user to take an action in the recruitment pipeline */
  last_action_by?: Maybe<Scalars['String']['output']>;
  mailing_location_id?: Maybe<Scalars['bigint']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['bigint']['output']>;
  /** Drivers phone brand/type (android, iphone, etc.). */
  phone_type?: Maybe<Scalars['String']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['bigint']['output']>;
  /** Recruitment pipeline specific statuses, including new, ready, backlog, disqualified, contacting, interviewing, onboarding, training, rejected, and terminated */
  recruitment_status?: Maybe<Scalars['String']['output']>;
  /** Time at which the driver's recruitment status was last updated */
  recruitment_status_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Referral source for joining Hopdrive as a driver (LinkedIn, Google, Indeed, etc.) */
  referral_source?: Maybe<Scalars['String']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Current driver status (new | interviewed | onboarding | training | offline | online | rejected | terminated). */
  status?: Maybe<Scalars['String']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines the type of tax class the driver is in (1099, W-2, etc.). */
  tax_class?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['bigint']['output']>;
  /** Color of the drivers vehicle. */
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** License plate of the drivers vehicle. */
  vehicle_license_plate?: Maybe<Scalars['String']['output']>;
  /** State of the drivers license plate. */
  vehicle_license_plate_state?: Maybe<Scalars['String']['output']>;
  /** Make of the drivers vehicle. */
  vehicle_make?: Maybe<Scalars['String']['output']>;
  /** Model of the drivers vehicle. */
  vehicle_model?: Maybe<Scalars['String']['output']>;
  /** VIN of the drivers vehicle. */
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  /** Year of the drivers vehicle. */
  vehicle_year?: Maybe<Scalars['String']['output']>;
  /** 3rd party banking token used for transactions to this driver. */
  wallet_token?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Drivers_Min_Fields = {
  __typename?: 'drivers_min_fields';
  /** When the app launches, is minimized, or force quit, that most recent app status will be reflected here. Possible values are (active, background, inactive) */
  app_status?: Maybe<Scalars['String']['output']>;
  /** Whenever the app_status changes, the timestamp of when that occurred will be reflected here. */
  app_status_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** 3rd party bank account token used to directly associate a driver to a bank account. */
  bank_account_token?: Maybe<Scalars['String']['output']>;
  /** Status of the driver's background check */
  bg_check_status?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Mobile device token id for push notifications. Should be unique across Android and iOS. */
  device_token?: Maybe<Scalars['String']['output']>;
  /** The most recent version of the app the driver has used. */
  driver_app_version?: Maybe<Scalars['String']['output']>;
  home_location_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Email of the last user to take an action in the recruitment pipeline */
  last_action_by?: Maybe<Scalars['String']['output']>;
  mailing_location_id?: Maybe<Scalars['bigint']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['bigint']['output']>;
  /** Drivers phone brand/type (android, iphone, etc.). */
  phone_type?: Maybe<Scalars['String']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['bigint']['output']>;
  /** Recruitment pipeline specific statuses, including new, ready, backlog, disqualified, contacting, interviewing, onboarding, training, rejected, and terminated */
  recruitment_status?: Maybe<Scalars['String']['output']>;
  /** Time at which the driver's recruitment status was last updated */
  recruitment_status_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Referral source for joining Hopdrive as a driver (LinkedIn, Google, Indeed, etc.) */
  referral_source?: Maybe<Scalars['String']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Current driver status (new | interviewed | onboarding | training | offline | online | rejected | terminated). */
  status?: Maybe<Scalars['String']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines the type of tax class the driver is in (1099, W-2, etc.). */
  tax_class?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['bigint']['output']>;
  /** Color of the drivers vehicle. */
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** License plate of the drivers vehicle. */
  vehicle_license_plate?: Maybe<Scalars['String']['output']>;
  /** State of the drivers license plate. */
  vehicle_license_plate_state?: Maybe<Scalars['String']['output']>;
  /** Make of the drivers vehicle. */
  vehicle_make?: Maybe<Scalars['String']['output']>;
  /** Model of the drivers vehicle. */
  vehicle_model?: Maybe<Scalars['String']['output']>;
  /** VIN of the drivers vehicle. */
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  /** Year of the drivers vehicle. */
  vehicle_year?: Maybe<Scalars['String']['output']>;
  /** 3rd party banking token used for transactions to this driver. */
  wallet_token?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "drivers" */
export type Drivers_Mutation_Response = {
  __typename?: 'drivers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Drivers>;
};

/** input type for inserting object relation for remote table "drivers" */
export type Drivers_Obj_Rel_Insert_Input = {
  data: Drivers_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Drivers_On_Conflict>;
};

/** on_conflict condition type for table "drivers" */
export type Drivers_On_Conflict = {
  constraint: Drivers_Constraint;
  update_columns?: Array<Drivers_Update_Column>;
  where?: InputMaybe<Drivers_Bool_Exp>;
};

/** Ordering options when selecting data from "drivers". */
export type Drivers_Order_By = {
  apcharges_aggregate?: InputMaybe<Apcharges_Aggregate_Order_By>;
  app_status?: InputMaybe<Order_By>;
  app_status_updated_at?: InputMaybe<Order_By>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Order_By>;
  bank_account_token?: InputMaybe<Order_By>;
  bg_check_status?: InputMaybe<Order_By>;
  certifications_aggregate?: InputMaybe<Driverstocertifications_Aggregate_Order_By>;
  config?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  device_specs?: InputMaybe<Order_By>;
  device_token?: InputMaybe<Order_By>;
  driver_app_version?: InputMaybe<Order_By>;
  driverdetail?: InputMaybe<Driverdetails_Order_By>;
  driverpayouts_aggregate?: InputMaybe<Driverpayouts_Aggregate_Order_By>;
  equipment_aggregate?: InputMaybe<Driverequipment_Aggregate_Order_By>;
  home_location?: InputMaybe<Locations_Order_By>;
  home_location_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  intake_info?: InputMaybe<Order_By>;
  last_action_by?: InputMaybe<Order_By>;
  mailing_location?: InputMaybe<Locations_Order_By>;
  mailing_location_id?: InputMaybe<Order_By>;
  max_drive_radius_mi?: InputMaybe<Order_By>;
  offers_aggregate?: InputMaybe<Offers_Aggregate_Order_By>;
  phone_type?: InputMaybe<Order_By>;
  plate?: InputMaybe<Plates_Order_By>;
  plate_id?: InputMaybe<Order_By>;
  recruitment_status?: InputMaybe<Order_By>;
  recruitment_status_updated_at?: InputMaybe<Order_By>;
  referral_source?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  starting_location?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  talent_coordinator?: InputMaybe<Users_Order_By>;
  talent_coordinator_id?: InputMaybe<Order_By>;
  tax_class?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  vehicle_license_plate?: InputMaybe<Order_By>;
  vehicle_license_plate_state?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  verification?: InputMaybe<Order_By>;
  wallet_token?: InputMaybe<Order_By>;
};

/** primary key columns input for table: drivers */
export type Drivers_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Drivers_Prepend_Input = {
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['jsonb']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['jsonb']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "drivers" */
export enum Drivers_Select_Column {
  /** column name */
  AppStatus = 'app_status',
  /** column name */
  AppStatusUpdatedAt = 'app_status_updated_at',
  /** column name */
  BankAccountToken = 'bank_account_token',
  /** column name */
  BgCheckStatus = 'bg_check_status',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeviceSpecs = 'device_specs',
  /** column name */
  DeviceToken = 'device_token',
  /** column name */
  DriverAppVersion = 'driver_app_version',
  /** column name */
  HomeLocationId = 'home_location_id',
  /** column name */
  Id = 'id',
  /** column name */
  IntakeInfo = 'intake_info',
  /** column name */
  LastActionBy = 'last_action_by',
  /** column name */
  MailingLocationId = 'mailing_location_id',
  /** column name */
  MaxDriveRadiusMi = 'max_drive_radius_mi',
  /** column name */
  PhoneType = 'phone_type',
  /** column name */
  PlateId = 'plate_id',
  /** column name */
  RecruitmentStatus = 'recruitment_status',
  /** column name */
  RecruitmentStatusUpdatedAt = 'recruitment_status_updated_at',
  /** column name */
  ReferralSource = 'referral_source',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  StartingLocation = 'starting_location',
  /** column name */
  Status = 'status',
  /** column name */
  TalentCoordinatorId = 'talent_coordinator_id',
  /** column name */
  TaxClass = 'tax_class',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleLicensePlate = 'vehicle_license_plate',
  /** column name */
  VehicleLicensePlateState = 'vehicle_license_plate_state',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  Verification = 'verification',
  /** column name */
  WalletToken = 'wallet_token'
}

/** input type for updating data in table "drivers" */
export type Drivers_Set_Input = {
  /** When the app launches, is minimized, or force quit, that most recent app status will be reflected here. Possible values are (active, background, inactive) */
  app_status?: InputMaybe<Scalars['String']['input']>;
  /** Whenever the app_status changes, the timestamp of when that occurred will be reflected here. */
  app_status_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** 3rd party bank account token used to directly associate a driver to a bank account. */
  bank_account_token?: InputMaybe<Scalars['String']['input']>;
  /** Status of the driver's background check */
  bg_check_status?: InputMaybe<Scalars['String']['input']>;
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['jsonb']['input']>;
  /** Mobile device token id for push notifications. Should be unique across Android and iOS. */
  device_token?: InputMaybe<Scalars['String']['input']>;
  /** The most recent version of the app the driver has used. */
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  home_location_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['jsonb']['input']>;
  /** Email of the last user to take an action in the recruitment pipeline */
  last_action_by?: InputMaybe<Scalars['String']['input']>;
  mailing_location_id?: InputMaybe<Scalars['bigint']['input']>;
  max_drive_radius_mi?: InputMaybe<Scalars['bigint']['input']>;
  /** Drivers phone brand/type (android, iphone, etc.). */
  phone_type?: InputMaybe<Scalars['String']['input']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Recruitment pipeline specific statuses, including new, ready, backlog, disqualified, contacting, interviewing, onboarding, training, rejected, and terminated */
  recruitment_status?: InputMaybe<Scalars['String']['input']>;
  /** Time at which the driver's recruitment status was last updated */
  recruitment_status_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referral source for joining Hopdrive as a driver (LinkedIn, Google, Indeed, etc.) */
  referral_source?: InputMaybe<Scalars['String']['input']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  starting_location?: InputMaybe<Scalars['geography']['input']>;
  /** Current driver status (new | interviewed | onboarding | training | offline | online | rejected | terminated). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines the type of tax class the driver is in (1099, W-2, etc.). */
  tax_class?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Color of the drivers vehicle. */
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** License plate of the drivers vehicle. */
  vehicle_license_plate?: InputMaybe<Scalars['String']['input']>;
  /** State of the drivers license plate. */
  vehicle_license_plate_state?: InputMaybe<Scalars['String']['input']>;
  /** Make of the drivers vehicle. */
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  /** Model of the drivers vehicle. */
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  /** VIN of the drivers vehicle. */
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  /** Year of the drivers vehicle. */
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['jsonb']['input']>;
  /** 3rd party banking token used for transactions to this driver. */
  wallet_token?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Drivers_Stddev_Fields = {
  __typename?: 'drivers_stddev_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Drivers_Stddev_Pop_Fields = {
  __typename?: 'drivers_stddev_pop_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Drivers_Stddev_Samp_Fields = {
  __typename?: 'drivers_stddev_samp_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "drivers" */
export type Drivers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Drivers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Drivers_Stream_Cursor_Value_Input = {
  /** When the app launches, is minimized, or force quit, that most recent app status will be reflected here. Possible values are (active, background, inactive) */
  app_status?: InputMaybe<Scalars['String']['input']>;
  /** Whenever the app_status changes, the timestamp of when that occurred will be reflected here. */
  app_status_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** 3rd party bank account token used to directly associate a driver to a bank account. */
  bank_account_token?: InputMaybe<Scalars['String']['input']>;
  /** Status of the driver's background check */
  bg_check_status?: InputMaybe<Scalars['String']['input']>;
  /** Stores dynamic values such as qualifications for our specific move types. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Mobile device specifications */
  device_specs?: InputMaybe<Scalars['jsonb']['input']>;
  /** Mobile device token id for push notifications. Should be unique across Android and iOS. */
  device_token?: InputMaybe<Scalars['String']['input']>;
  /** The most recent version of the app the driver has used. */
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  home_location_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** JSONb record of the driver's qualification and interest responses from their application form */
  intake_info?: InputMaybe<Scalars['jsonb']['input']>;
  /** Email of the last user to take an action in the recruitment pipeline */
  last_action_by?: InputMaybe<Scalars['String']['input']>;
  mailing_location_id?: InputMaybe<Scalars['bigint']['input']>;
  max_drive_radius_mi?: InputMaybe<Scalars['bigint']['input']>;
  /** Drivers phone brand/type (android, iphone, etc.). */
  phone_type?: InputMaybe<Scalars['String']['input']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Recruitment pipeline specific statuses, including new, ready, backlog, disqualified, contacting, interviewing, onboarding, training, rejected, and terminated */
  recruitment_status?: InputMaybe<Scalars['String']['input']>;
  /** Time at which the driver's recruitment status was last updated */
  recruitment_status_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Referral source for joining Hopdrive as a driver (LinkedIn, Google, Indeed, etc.) */
  referral_source?: InputMaybe<Scalars['String']['input']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  starting_location?: InputMaybe<Scalars['geography']['input']>;
  /** Current driver status (new | interviewed | onboarding | training | offline | online | rejected | terminated). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines the type of tax class the driver is in (1099, W-2, etc.). */
  tax_class?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Color of the drivers vehicle. */
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** License plate of the drivers vehicle. */
  vehicle_license_plate?: InputMaybe<Scalars['String']['input']>;
  /** State of the drivers license plate. */
  vehicle_license_plate_state?: InputMaybe<Scalars['String']['input']>;
  /** Make of the drivers vehicle. */
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  /** Model of the drivers vehicle. */
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  /** VIN of the drivers vehicle. */
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  /** Year of the drivers vehicle. */
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  /** Stores dynamic verification fields necessary to keep track of the drivers onboarding progress. */
  verification?: InputMaybe<Scalars['jsonb']['input']>;
  /** 3rd party banking token used for transactions to this driver. */
  wallet_token?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Drivers_Sum_Fields = {
  __typename?: 'drivers_sum_fields';
  home_location_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  mailing_location_id?: Maybe<Scalars['bigint']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['bigint']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['bigint']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['bigint']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "drivers" */
export enum Drivers_Update_Column {
  /** column name */
  AppStatus = 'app_status',
  /** column name */
  AppStatusUpdatedAt = 'app_status_updated_at',
  /** column name */
  BankAccountToken = 'bank_account_token',
  /** column name */
  BgCheckStatus = 'bg_check_status',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeviceSpecs = 'device_specs',
  /** column name */
  DeviceToken = 'device_token',
  /** column name */
  DriverAppVersion = 'driver_app_version',
  /** column name */
  HomeLocationId = 'home_location_id',
  /** column name */
  Id = 'id',
  /** column name */
  IntakeInfo = 'intake_info',
  /** column name */
  LastActionBy = 'last_action_by',
  /** column name */
  MailingLocationId = 'mailing_location_id',
  /** column name */
  MaxDriveRadiusMi = 'max_drive_radius_mi',
  /** column name */
  PhoneType = 'phone_type',
  /** column name */
  PlateId = 'plate_id',
  /** column name */
  RecruitmentStatus = 'recruitment_status',
  /** column name */
  RecruitmentStatusUpdatedAt = 'recruitment_status_updated_at',
  /** column name */
  ReferralSource = 'referral_source',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  StartingLocation = 'starting_location',
  /** column name */
  Status = 'status',
  /** column name */
  TalentCoordinatorId = 'talent_coordinator_id',
  /** column name */
  TaxClass = 'tax_class',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleLicensePlate = 'vehicle_license_plate',
  /** column name */
  VehicleLicensePlateState = 'vehicle_license_plate_state',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  Verification = 'verification',
  /** column name */
  WalletToken = 'wallet_token'
}

export type Drivers_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Drivers_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Drivers_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Drivers_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Drivers_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Drivers_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Drivers_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Drivers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Drivers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Drivers_Var_Pop_Fields = {
  __typename?: 'drivers_var_pop_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Drivers_Var_Samp_Fields = {
  __typename?: 'drivers_var_samp_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Drivers_Variance_Fields = {
  __typename?: 'drivers_variance_fields';
  home_location_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  mailing_location_id?: Maybe<Scalars['Float']['output']>;
  max_drive_radius_mi?: Maybe<Scalars['Float']['output']>;
  /** Relates to a transporter plate record object (from the plates table). */
  plate_id?: Maybe<Scalars['Float']['output']>;
  /** Relates a region record to the driver indicating which region the driver belongs in. */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** User ID of the talent coordinator assigned to the driver. Foreign key relationship to the users table. */
  talent_coordinator_id?: Maybe<Scalars['Float']['output']>;
  /** Once the driver is onboarded, a user record will be created to give them access to the app. This should be updated then with the generated PK ID column value from the users table. */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "driverscheduledetails" */
export type Driverscheduledetails = {
  __typename?: 'driverscheduledetails';
  block_end_time: Scalars['Int']['output'];
  block_start_time: Scalars['Int']['output'];
  createdat: Scalars['timestamptz']['output'];
  day: Scalars['Int']['output'];
  driver_schedule_id: Scalars['bigint']['output'];
  /** An object relationship */
  driverschedule: Driverschedules;
  id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
};

/** aggregated selection of "driverscheduledetails" */
export type Driverscheduledetails_Aggregate = {
  __typename?: 'driverscheduledetails_aggregate';
  aggregate?: Maybe<Driverscheduledetails_Aggregate_Fields>;
  nodes: Array<Driverscheduledetails>;
};

export type Driverscheduledetails_Aggregate_Bool_Exp = {
  count?: InputMaybe<Driverscheduledetails_Aggregate_Bool_Exp_Count>;
};

export type Driverscheduledetails_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driverscheduledetails_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driverscheduledetails" */
export type Driverscheduledetails_Aggregate_Fields = {
  __typename?: 'driverscheduledetails_aggregate_fields';
  avg?: Maybe<Driverscheduledetails_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverscheduledetails_Max_Fields>;
  min?: Maybe<Driverscheduledetails_Min_Fields>;
  stddev?: Maybe<Driverscheduledetails_Stddev_Fields>;
  stddev_pop?: Maybe<Driverscheduledetails_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverscheduledetails_Stddev_Samp_Fields>;
  sum?: Maybe<Driverscheduledetails_Sum_Fields>;
  var_pop?: Maybe<Driverscheduledetails_Var_Pop_Fields>;
  var_samp?: Maybe<Driverscheduledetails_Var_Samp_Fields>;
  variance?: Maybe<Driverscheduledetails_Variance_Fields>;
};


/** aggregate fields of "driverscheduledetails" */
export type Driverscheduledetails_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driverscheduledetails" */
export type Driverscheduledetails_Aggregate_Order_By = {
  avg?: InputMaybe<Driverscheduledetails_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driverscheduledetails_Max_Order_By>;
  min?: InputMaybe<Driverscheduledetails_Min_Order_By>;
  stddev?: InputMaybe<Driverscheduledetails_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driverscheduledetails_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driverscheduledetails_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driverscheduledetails_Sum_Order_By>;
  var_pop?: InputMaybe<Driverscheduledetails_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driverscheduledetails_Var_Samp_Order_By>;
  variance?: InputMaybe<Driverscheduledetails_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driverscheduledetails" */
export type Driverscheduledetails_Arr_Rel_Insert_Input = {
  data: Array<Driverscheduledetails_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverscheduledetails_On_Conflict>;
};

/** aggregate avg on columns */
export type Driverscheduledetails_Avg_Fields = {
  __typename?: 'driverscheduledetails_avg_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Avg_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driverscheduledetails". All fields are combined with a logical 'AND'. */
export type Driverscheduledetails_Bool_Exp = {
  _and?: InputMaybe<Array<Driverscheduledetails_Bool_Exp>>;
  _not?: InputMaybe<Driverscheduledetails_Bool_Exp>;
  _or?: InputMaybe<Array<Driverscheduledetails_Bool_Exp>>;
  block_end_time?: InputMaybe<Int_Comparison_Exp>;
  block_start_time?: InputMaybe<Int_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  day?: InputMaybe<Int_Comparison_Exp>;
  driver_schedule_id?: InputMaybe<Bigint_Comparison_Exp>;
  driverschedule?: InputMaybe<Driverschedules_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverscheduledetails" */
export enum Driverscheduledetails_Constraint {
  /** unique or primary key constraint on columns "day", "block_start_time", "driver_schedule_id" */
  DriverscheduledetailsDriverScheduleIdDayBlockStartTiKey = 'driverscheduledetails_driver_schedule_id_day_block_start_ti_key',
  /** unique or primary key constraint on columns "id" */
  DriverscheduledetailsPkey = 'driverscheduledetails_pkey'
}

/** input type for incrementing numeric columns in table "driverscheduledetails" */
export type Driverscheduledetails_Inc_Input = {
  block_end_time?: InputMaybe<Scalars['Int']['input']>;
  block_start_time?: InputMaybe<Scalars['Int']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  driver_schedule_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverscheduledetails" */
export type Driverscheduledetails_Insert_Input = {
  block_end_time?: InputMaybe<Scalars['Int']['input']>;
  block_start_time?: InputMaybe<Scalars['Int']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  driver_schedule_id?: InputMaybe<Scalars['bigint']['input']>;
  driverschedule?: InputMaybe<Driverschedules_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Driverscheduledetails_Max_Fields = {
  __typename?: 'driverscheduledetails_max_fields';
  block_end_time?: Maybe<Scalars['Int']['output']>;
  block_start_time?: Maybe<Scalars['Int']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  driver_schedule_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Max_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driverscheduledetails_Min_Fields = {
  __typename?: 'driverscheduledetails_min_fields';
  block_end_time?: Maybe<Scalars['Int']['output']>;
  block_start_time?: Maybe<Scalars['Int']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  driver_schedule_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Min_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driverscheduledetails" */
export type Driverscheduledetails_Mutation_Response = {
  __typename?: 'driverscheduledetails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverscheduledetails>;
};

/** on_conflict condition type for table "driverscheduledetails" */
export type Driverscheduledetails_On_Conflict = {
  constraint: Driverscheduledetails_Constraint;
  update_columns?: Array<Driverscheduledetails_Update_Column>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};

/** Ordering options when selecting data from "driverscheduledetails". */
export type Driverscheduledetails_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  driverschedule?: InputMaybe<Driverschedules_Order_By>;
  id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverscheduledetails */
export type Driverscheduledetails_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driverscheduledetails" */
export enum Driverscheduledetails_Select_Column {
  /** column name */
  BlockEndTime = 'block_end_time',
  /** column name */
  BlockStartTime = 'block_start_time',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Day = 'day',
  /** column name */
  DriverScheduleId = 'driver_schedule_id',
  /** column name */
  Id = 'id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "driverscheduledetails" */
export type Driverscheduledetails_Set_Input = {
  block_end_time?: InputMaybe<Scalars['Int']['input']>;
  block_start_time?: InputMaybe<Scalars['Int']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  driver_schedule_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Driverscheduledetails_Stddev_Fields = {
  __typename?: 'driverscheduledetails_stddev_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Stddev_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driverscheduledetails_Stddev_Pop_Fields = {
  __typename?: 'driverscheduledetails_stddev_pop_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Stddev_Pop_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driverscheduledetails_Stddev_Samp_Fields = {
  __typename?: 'driverscheduledetails_stddev_samp_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Stddev_Samp_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driverscheduledetails" */
export type Driverscheduledetails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverscheduledetails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverscheduledetails_Stream_Cursor_Value_Input = {
  block_end_time?: InputMaybe<Scalars['Int']['input']>;
  block_start_time?: InputMaybe<Scalars['Int']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  driver_schedule_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Driverscheduledetails_Sum_Fields = {
  __typename?: 'driverscheduledetails_sum_fields';
  block_end_time?: Maybe<Scalars['Int']['output']>;
  block_start_time?: Maybe<Scalars['Int']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  driver_schedule_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Sum_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "driverscheduledetails" */
export enum Driverscheduledetails_Update_Column {
  /** column name */
  BlockEndTime = 'block_end_time',
  /** column name */
  BlockStartTime = 'block_start_time',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Day = 'day',
  /** column name */
  DriverScheduleId = 'driver_schedule_id',
  /** column name */
  Id = 'id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Driverscheduledetails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverscheduledetails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverscheduledetails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverscheduledetails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverscheduledetails_Var_Pop_Fields = {
  __typename?: 'driverscheduledetails_var_pop_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Var_Pop_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driverscheduledetails_Var_Samp_Fields = {
  __typename?: 'driverscheduledetails_var_samp_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Var_Samp_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driverscheduledetails_Variance_Fields = {
  __typename?: 'driverscheduledetails_variance_fields';
  block_end_time?: Maybe<Scalars['Float']['output']>;
  block_start_time?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Float']['output']>;
  driver_schedule_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driverscheduledetails" */
export type Driverscheduledetails_Variance_Order_By = {
  block_end_time?: InputMaybe<Order_By>;
  block_start_time?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  driver_schedule_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "driverschedules" */
export type Driverschedules = {
  __typename?: 'driverschedules';
  createdat: Scalars['timestamptz']['output'];
  /** An array relationship */
  details: Array<Driverscheduledetails>;
  /** An aggregate relationship */
  details_aggregate: Driverscheduledetails_Aggregate;
  driver_id: Scalars['Int']['output'];
  expiration_date: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  type: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
};


/** columns and relationships of "driverschedules" */
export type DriverschedulesDetailsArgs = {
  distinct_on?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverscheduledetails_Order_By>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};


/** columns and relationships of "driverschedules" */
export type DriverschedulesDetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverscheduledetails_Order_By>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};

/** aggregated selection of "driverschedules" */
export type Driverschedules_Aggregate = {
  __typename?: 'driverschedules_aggregate';
  aggregate?: Maybe<Driverschedules_Aggregate_Fields>;
  nodes: Array<Driverschedules>;
};

/** aggregate fields of "driverschedules" */
export type Driverschedules_Aggregate_Fields = {
  __typename?: 'driverschedules_aggregate_fields';
  avg?: Maybe<Driverschedules_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverschedules_Max_Fields>;
  min?: Maybe<Driverschedules_Min_Fields>;
  stddev?: Maybe<Driverschedules_Stddev_Fields>;
  stddev_pop?: Maybe<Driverschedules_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverschedules_Stddev_Samp_Fields>;
  sum?: Maybe<Driverschedules_Sum_Fields>;
  var_pop?: Maybe<Driverschedules_Var_Pop_Fields>;
  var_samp?: Maybe<Driverschedules_Var_Samp_Fields>;
  variance?: Maybe<Driverschedules_Variance_Fields>;
};


/** aggregate fields of "driverschedules" */
export type Driverschedules_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverschedules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driverschedules_Avg_Fields = {
  __typename?: 'driverschedules_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driverschedules". All fields are combined with a logical 'AND'. */
export type Driverschedules_Bool_Exp = {
  _and?: InputMaybe<Array<Driverschedules_Bool_Exp>>;
  _not?: InputMaybe<Driverschedules_Bool_Exp>;
  _or?: InputMaybe<Array<Driverschedules_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  details?: InputMaybe<Driverscheduledetails_Bool_Exp>;
  details_aggregate?: InputMaybe<Driverscheduledetails_Aggregate_Bool_Exp>;
  driver_id?: InputMaybe<Int_Comparison_Exp>;
  expiration_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverschedules" */
export enum Driverschedules_Constraint {
  /** unique or primary key constraint on columns "type", "driver_id" */
  DriverschedulesDriverIdTypeKey = 'driverschedules_driver_id_type_key',
  /** unique or primary key constraint on columns "id" */
  DriverschedulesPkey = 'driverschedules_pkey'
}

/** input type for incrementing numeric columns in table "driverschedules" */
export type Driverschedules_Inc_Input = {
  driver_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverschedules" */
export type Driverschedules_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  details?: InputMaybe<Driverscheduledetails_Arr_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['Int']['input']>;
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Driverschedules_Max_Fields = {
  __typename?: 'driverschedules_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  driver_id?: Maybe<Scalars['Int']['output']>;
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Driverschedules_Min_Fields = {
  __typename?: 'driverschedules_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  driver_id?: Maybe<Scalars['Int']['output']>;
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "driverschedules" */
export type Driverschedules_Mutation_Response = {
  __typename?: 'driverschedules_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverschedules>;
};

/** input type for inserting object relation for remote table "driverschedules" */
export type Driverschedules_Obj_Rel_Insert_Input = {
  data: Driverschedules_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverschedules_On_Conflict>;
};

/** on_conflict condition type for table "driverschedules" */
export type Driverschedules_On_Conflict = {
  constraint: Driverschedules_Constraint;
  update_columns?: Array<Driverschedules_Update_Column>;
  where?: InputMaybe<Driverschedules_Bool_Exp>;
};

/** Ordering options when selecting data from "driverschedules". */
export type Driverschedules_Order_By = {
  createdat?: InputMaybe<Order_By>;
  details_aggregate?: InputMaybe<Driverscheduledetails_Aggregate_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  expiration_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverschedules */
export type Driverschedules_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "driverschedules" */
export enum Driverschedules_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "driverschedules" */
export type Driverschedules_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_id?: InputMaybe<Scalars['Int']['input']>;
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Driverschedules_Stddev_Fields = {
  __typename?: 'driverschedules_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driverschedules_Stddev_Pop_Fields = {
  __typename?: 'driverschedules_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driverschedules_Stddev_Samp_Fields = {
  __typename?: 'driverschedules_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driverschedules" */
export type Driverschedules_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverschedules_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverschedules_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_id?: InputMaybe<Scalars['Int']['input']>;
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Driverschedules_Sum_Fields = {
  __typename?: 'driverschedules_sum_fields';
  driver_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "driverschedules" */
export enum Driverschedules_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Driverschedules_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverschedules_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverschedules_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverschedules_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverschedules_Var_Pop_Fields = {
  __typename?: 'driverschedules_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driverschedules_Var_Samp_Fields = {
  __typename?: 'driverschedules_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driverschedules_Variance_Fields = {
  __typename?: 'driverschedules_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid = {
  __typename?: 'driversinridegroupbymoveid';
  driver_ids?: Maybe<Scalars['jsonb']['output']>;
  group_id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  ridegroup: Array<Ridegroups>;
  /** An aggregate relationship */
  ridegroup_aggregate: Ridegroups_Aggregate;
};


/** columns and relationships of "driversinridegroupbymoveid" */
export type DriversinridegroupbymoveidDriver_IdsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "driversinridegroupbymoveid" */
export type DriversinridegroupbymoveidRidegroupArgs = {
  distinct_on?: InputMaybe<Array<Ridegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridegroups_Order_By>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};


/** columns and relationships of "driversinridegroupbymoveid" */
export type DriversinridegroupbymoveidRidegroup_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridegroups_Order_By>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};

/** aggregated selection of "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid_Aggregate = {
  __typename?: 'driversinridegroupbymoveid_aggregate';
  aggregate?: Maybe<Driversinridegroupbymoveid_Aggregate_Fields>;
  nodes: Array<Driversinridegroupbymoveid>;
};

/** aggregate fields of "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid_Aggregate_Fields = {
  __typename?: 'driversinridegroupbymoveid_aggregate_fields';
  avg?: Maybe<Driversinridegroupbymoveid_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driversinridegroupbymoveid_Max_Fields>;
  min?: Maybe<Driversinridegroupbymoveid_Min_Fields>;
  stddev?: Maybe<Driversinridegroupbymoveid_Stddev_Fields>;
  stddev_pop?: Maybe<Driversinridegroupbymoveid_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driversinridegroupbymoveid_Stddev_Samp_Fields>;
  sum?: Maybe<Driversinridegroupbymoveid_Sum_Fields>;
  var_pop?: Maybe<Driversinridegroupbymoveid_Var_Pop_Fields>;
  var_samp?: Maybe<Driversinridegroupbymoveid_Var_Samp_Fields>;
  variance?: Maybe<Driversinridegroupbymoveid_Variance_Fields>;
};


/** aggregate fields of "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driversinridegroupbymoveid_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Driversinridegroupbymoveid_Avg_Fields = {
  __typename?: 'driversinridegroupbymoveid_avg_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "driversinridegroupbymoveid". All fields are combined with a logical 'AND'. */
export type Driversinridegroupbymoveid_Bool_Exp = {
  _and?: InputMaybe<Array<Driversinridegroupbymoveid_Bool_Exp>>;
  _not?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
  _or?: InputMaybe<Array<Driversinridegroupbymoveid_Bool_Exp>>;
  driver_ids?: InputMaybe<Jsonb_Comparison_Exp>;
  group_id?: InputMaybe<Uuid_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  ridegroup?: InputMaybe<Ridegroups_Bool_Exp>;
  ridegroup_aggregate?: InputMaybe<Ridegroups_Aggregate_Bool_Exp>;
};

/** input type for inserting data into table "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid_Insert_Input = {
  driver_ids?: InputMaybe<Scalars['jsonb']['input']>;
  group_id?: InputMaybe<Scalars['uuid']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  ridegroup?: InputMaybe<Ridegroups_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Driversinridegroupbymoveid_Max_Fields = {
  __typename?: 'driversinridegroupbymoveid_max_fields';
  group_id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Driversinridegroupbymoveid_Min_Fields = {
  __typename?: 'driversinridegroupbymoveid_min_fields';
  group_id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** input type for inserting object relation for remote table "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid_Obj_Rel_Insert_Input = {
  data: Driversinridegroupbymoveid_Insert_Input;
};

/** Ordering options when selecting data from "driversinridegroupbymoveid". */
export type Driversinridegroupbymoveid_Order_By = {
  driver_ids?: InputMaybe<Order_By>;
  group_id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  ridegroup_aggregate?: InputMaybe<Ridegroups_Aggregate_Order_By>;
};

/** select columns of table "driversinridegroupbymoveid" */
export enum Driversinridegroupbymoveid_Select_Column {
  /** column name */
  DriverIds = 'driver_ids',
  /** column name */
  GroupId = 'group_id',
  /** column name */
  MoveId = 'move_id'
}

/** aggregate stddev on columns */
export type Driversinridegroupbymoveid_Stddev_Fields = {
  __typename?: 'driversinridegroupbymoveid_stddev_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Driversinridegroupbymoveid_Stddev_Pop_Fields = {
  __typename?: 'driversinridegroupbymoveid_stddev_pop_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Driversinridegroupbymoveid_Stddev_Samp_Fields = {
  __typename?: 'driversinridegroupbymoveid_stddev_samp_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "driversinridegroupbymoveid" */
export type Driversinridegroupbymoveid_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driversinridegroupbymoveid_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driversinridegroupbymoveid_Stream_Cursor_Value_Input = {
  driver_ids?: InputMaybe<Scalars['jsonb']['input']>;
  group_id?: InputMaybe<Scalars['uuid']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Driversinridegroupbymoveid_Sum_Fields = {
  __typename?: 'driversinridegroupbymoveid_sum_fields';
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Driversinridegroupbymoveid_Var_Pop_Fields = {
  __typename?: 'driversinridegroupbymoveid_var_pop_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Driversinridegroupbymoveid_Var_Samp_Fields = {
  __typename?: 'driversinridegroupbymoveid_var_samp_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Driversinridegroupbymoveid_Variance_Fields = {
  __typename?: 'driversinridegroupbymoveid_variance_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Driver has a Many to Many to HopDrive Attributes to define their capabilities - This is as a driver progresses through various training modules, each completion certification they achieve for each module is recorded here as a certification that has a training module specified expiration date.  This will hold not only the link between driver ID and certification ID, but also introduce an expiration date for this earned certification instance. It will also have an optional document ID (which is a group ID for possible multiple documents under the same document ID) to reference an image and/or PDF or something like that. For instance a scan of their drivers license alongside the DOT cert doc scanned. */
export type Driverstocertifications = {
  __typename?: 'driverstocertifications';
  /** An object relationship */
  certification: Certifications;
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  driver: Drivers;
  driver_id: Scalars['bigint']['output'];
  /** the date when the certification for this driver goes into effect */
  effective_date: Scalars['timestamptz']['output'];
  /** the date when the certification for this driver will expire */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "driverstocertifications" */
export type Driverstocertifications_Aggregate = {
  __typename?: 'driverstocertifications_aggregate';
  aggregate?: Maybe<Driverstocertifications_Aggregate_Fields>;
  nodes: Array<Driverstocertifications>;
};

export type Driverstocertifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Driverstocertifications_Aggregate_Bool_Exp_Count>;
};

export type Driverstocertifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driverstocertifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driverstocertifications" */
export type Driverstocertifications_Aggregate_Fields = {
  __typename?: 'driverstocertifications_aggregate_fields';
  avg?: Maybe<Driverstocertifications_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverstocertifications_Max_Fields>;
  min?: Maybe<Driverstocertifications_Min_Fields>;
  stddev?: Maybe<Driverstocertifications_Stddev_Fields>;
  stddev_pop?: Maybe<Driverstocertifications_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverstocertifications_Stddev_Samp_Fields>;
  sum?: Maybe<Driverstocertifications_Sum_Fields>;
  var_pop?: Maybe<Driverstocertifications_Var_Pop_Fields>;
  var_samp?: Maybe<Driverstocertifications_Var_Samp_Fields>;
  variance?: Maybe<Driverstocertifications_Variance_Fields>;
};


/** aggregate fields of "driverstocertifications" */
export type Driverstocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driverstocertifications" */
export type Driverstocertifications_Aggregate_Order_By = {
  avg?: InputMaybe<Driverstocertifications_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driverstocertifications_Max_Order_By>;
  min?: InputMaybe<Driverstocertifications_Min_Order_By>;
  stddev?: InputMaybe<Driverstocertifications_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driverstocertifications_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driverstocertifications_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driverstocertifications_Sum_Order_By>;
  var_pop?: InputMaybe<Driverstocertifications_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driverstocertifications_Var_Samp_Order_By>;
  variance?: InputMaybe<Driverstocertifications_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driverstocertifications" */
export type Driverstocertifications_Arr_Rel_Insert_Input = {
  data: Array<Driverstocertifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverstocertifications_On_Conflict>;
};

/** aggregate avg on columns */
export type Driverstocertifications_Avg_Fields = {
  __typename?: 'driverstocertifications_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driverstocertifications" */
export type Driverstocertifications_Avg_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driverstocertifications". All fields are combined with a logical 'AND'. */
export type Driverstocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Driverstocertifications_Bool_Exp>>;
  _not?: InputMaybe<Driverstocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Driverstocertifications_Bool_Exp>>;
  certification?: InputMaybe<Certifications_Bool_Exp>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  document_reference_id?: InputMaybe<Uuid_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  effective_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiration_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverstocertifications" */
export enum Driverstocertifications_Constraint {
  /** unique or primary key constraint on columns "effective_date", "driver_id", "certification_key" */
  DriverstocertificationsPkey = 'driverstocertifications_pkey'
}

/** input type for incrementing numeric columns in table "driverstocertifications" */
export type Driverstocertifications_Inc_Input = {
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverstocertifications" */
export type Driverstocertifications_Insert_Input = {
  certification?: InputMaybe<Certifications_Obj_Rel_Insert_Input>;
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** the date when the certification for this driver will expire */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driverstocertifications_Max_Fields = {
  __typename?: 'driverstocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** the date when the certification for this driver will expire */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "driverstocertifications" */
export type Driverstocertifications_Max_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: InputMaybe<Order_By>;
  /** the date when the certification for this driver will expire */
  expiration_date?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driverstocertifications_Min_Fields = {
  __typename?: 'driverstocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** the date when the certification for this driver will expire */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "driverstocertifications" */
export type Driverstocertifications_Min_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: InputMaybe<Order_By>;
  /** the date when the certification for this driver will expire */
  expiration_date?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driverstocertifications" */
export type Driverstocertifications_Mutation_Response = {
  __typename?: 'driverstocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverstocertifications>;
};

/** on_conflict condition type for table "driverstocertifications" */
export type Driverstocertifications_On_Conflict = {
  constraint: Driverstocertifications_Constraint;
  update_columns?: Array<Driverstocertifications_Update_Column>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "driverstocertifications". */
export type Driverstocertifications_Order_By = {
  certification?: InputMaybe<Certifications_Order_By>;
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  document_reference_id?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  effective_date?: InputMaybe<Order_By>;
  expiration_date?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverstocertifications */
export type Driverstocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  driver_id: Scalars['bigint']['input'];
  /** the date when the certification for this driver goes into effect */
  effective_date: Scalars['timestamptz']['input'];
};

/** select columns of table "driverstocertifications" */
export enum Driverstocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "driverstocertifications" */
export type Driverstocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** the date when the certification for this driver will expire */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Driverstocertifications_Stddev_Fields = {
  __typename?: 'driverstocertifications_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driverstocertifications" */
export type Driverstocertifications_Stddev_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driverstocertifications_Stddev_Pop_Fields = {
  __typename?: 'driverstocertifications_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driverstocertifications" */
export type Driverstocertifications_Stddev_Pop_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driverstocertifications_Stddev_Samp_Fields = {
  __typename?: 'driverstocertifications_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driverstocertifications" */
export type Driverstocertifications_Stddev_Samp_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driverstocertifications" */
export type Driverstocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverstocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverstocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** eference to a document or set of documents in the documents table. For example if you are a DOT certified driver, then you might have one or more documents associated with the instance of this certification being issued. */
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** the date when the certification for this driver goes into effect */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** the date when the certification for this driver will expire */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driverstocertifications_Sum_Fields = {
  __typename?: 'driverstocertifications_sum_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "driverstocertifications" */
export type Driverstocertifications_Sum_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** update columns of table "driverstocertifications" */
export enum Driverstocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Driverstocertifications_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverstocertifications_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverstocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverstocertifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverstocertifications_Var_Pop_Fields = {
  __typename?: 'driverstocertifications_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driverstocertifications" */
export type Driverstocertifications_Var_Pop_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driverstocertifications_Var_Samp_Fields = {
  __typename?: 'driverstocertifications_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driverstocertifications" */
export type Driverstocertifications_Var_Samp_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driverstocertifications_Variance_Fields = {
  __typename?: 'driverstocertifications_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driverstocertifications" */
export type Driverstocertifications_Variance_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** Driver has a Many to Many relationship to UseCases to define use case exclusions - Record which use cases the driver is not interested in doing (this will be set by the driver in the app). Interests are assumed by having the qualification for it. This can be locked by ops to ensure this driver cannot opt back in. The UI in the driver app still shows it as opted out, but without the ability to change it like others. */
export type Driverstousecasesoptout = {
  __typename?: 'driverstousecasesoptout';
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  driver: Drivers;
  driver_id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  /** An object relationship */
  usecase: Usecases;
  usecase_key: Scalars['String']['output'];
};

/** aggregated selection of "driverstousecasesoptout" */
export type Driverstousecasesoptout_Aggregate = {
  __typename?: 'driverstousecasesoptout_aggregate';
  aggregate?: Maybe<Driverstousecasesoptout_Aggregate_Fields>;
  nodes: Array<Driverstousecasesoptout>;
};

export type Driverstousecasesoptout_Aggregate_Bool_Exp = {
  count?: InputMaybe<Driverstousecasesoptout_Aggregate_Bool_Exp_Count>;
};

export type Driverstousecasesoptout_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "driverstousecasesoptout" */
export type Driverstousecasesoptout_Aggregate_Fields = {
  __typename?: 'driverstousecasesoptout_aggregate_fields';
  avg?: Maybe<Driverstousecasesoptout_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Driverstousecasesoptout_Max_Fields>;
  min?: Maybe<Driverstousecasesoptout_Min_Fields>;
  stddev?: Maybe<Driverstousecasesoptout_Stddev_Fields>;
  stddev_pop?: Maybe<Driverstousecasesoptout_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Driverstousecasesoptout_Stddev_Samp_Fields>;
  sum?: Maybe<Driverstousecasesoptout_Sum_Fields>;
  var_pop?: Maybe<Driverstousecasesoptout_Var_Pop_Fields>;
  var_samp?: Maybe<Driverstousecasesoptout_Var_Samp_Fields>;
  variance?: Maybe<Driverstousecasesoptout_Variance_Fields>;
};


/** aggregate fields of "driverstousecasesoptout" */
export type Driverstousecasesoptout_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Aggregate_Order_By = {
  avg?: InputMaybe<Driverstousecasesoptout_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Driverstousecasesoptout_Max_Order_By>;
  min?: InputMaybe<Driverstousecasesoptout_Min_Order_By>;
  stddev?: InputMaybe<Driverstousecasesoptout_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Driverstousecasesoptout_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Driverstousecasesoptout_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Driverstousecasesoptout_Sum_Order_By>;
  var_pop?: InputMaybe<Driverstousecasesoptout_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Driverstousecasesoptout_Var_Samp_Order_By>;
  variance?: InputMaybe<Driverstousecasesoptout_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Arr_Rel_Insert_Input = {
  data: Array<Driverstousecasesoptout_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Driverstousecasesoptout_On_Conflict>;
};

/** aggregate avg on columns */
export type Driverstousecasesoptout_Avg_Fields = {
  __typename?: 'driverstousecasesoptout_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Avg_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "driverstousecasesoptout". All fields are combined with a logical 'AND'. */
export type Driverstousecasesoptout_Bool_Exp = {
  _and?: InputMaybe<Array<Driverstousecasesoptout_Bool_Exp>>;
  _not?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
  _or?: InputMaybe<Array<Driverstousecasesoptout_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  usecase?: InputMaybe<Usecases_Bool_Exp>;
  usecase_key?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "driverstousecasesoptout" */
export enum Driverstousecasesoptout_Constraint {
  /** unique or primary key constraint on columns "usecase_key", "driver_id" */
  DriverstousecasesoptoutPkey = 'driverstousecasesoptout_pkey'
}

/** input type for incrementing numeric columns in table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Inc_Input = {
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecase?: InputMaybe<Usecases_Obj_Rel_Insert_Input>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Driverstousecasesoptout_Max_Fields = {
  __typename?: 'driverstousecasesoptout_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  usecase_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecase_key?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Driverstousecasesoptout_Min_Fields = {
  __typename?: 'driverstousecasesoptout_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  usecase_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecase_key?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Mutation_Response = {
  __typename?: 'driverstousecasesoptout_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Driverstousecasesoptout>;
};

/** on_conflict condition type for table "driverstousecasesoptout" */
export type Driverstousecasesoptout_On_Conflict = {
  constraint: Driverstousecasesoptout_Constraint;
  update_columns?: Array<Driverstousecasesoptout_Update_Column>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};

/** Ordering options when selecting data from "driverstousecasesoptout". */
export type Driverstousecasesoptout_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecase?: InputMaybe<Usecases_Order_By>;
  usecase_key?: InputMaybe<Order_By>;
};

/** primary key columns input for table: driverstousecasesoptout */
export type Driverstousecasesoptout_Pk_Columns_Input = {
  driver_id: Scalars['bigint']['input'];
  usecase_key: Scalars['String']['input'];
};

/** select columns of table "driverstousecasesoptout" */
export enum Driverstousecasesoptout_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  UsecaseKey = 'usecase_key'
}

/** input type for updating data in table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Driverstousecasesoptout_Stddev_Fields = {
  __typename?: 'driverstousecasesoptout_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Stddev_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Driverstousecasesoptout_Stddev_Pop_Fields = {
  __typename?: 'driverstousecasesoptout_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Stddev_Pop_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Driverstousecasesoptout_Stddev_Samp_Fields = {
  __typename?: 'driverstousecasesoptout_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Stddev_Samp_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Driverstousecasesoptout_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Driverstousecasesoptout_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Driverstousecasesoptout_Sum_Fields = {
  __typename?: 'driverstousecasesoptout_sum_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Sum_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** update columns of table "driverstousecasesoptout" */
export enum Driverstousecasesoptout_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  UsecaseKey = 'usecase_key'
}

export type Driverstousecasesoptout_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Driverstousecasesoptout_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Driverstousecasesoptout_Set_Input>;
  /** filter the rows which have to be updated */
  where: Driverstousecasesoptout_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Driverstousecasesoptout_Var_Pop_Fields = {
  __typename?: 'driverstousecasesoptout_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Var_Pop_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Driverstousecasesoptout_Var_Samp_Fields = {
  __typename?: 'driverstousecasesoptout_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Var_Samp_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Driverstousecasesoptout_Variance_Fields = {
  __typename?: 'driverstousecasesoptout_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "driverstousecasesoptout" */
export type Driverstousecasesoptout_Variance_Order_By = {
  driver_id?: InputMaybe<Order_By>;
};

/** Instances of emails that were triggered by the database and sent to the recipient below */
export type Email_Events = {
  __typename?: 'email_events';
  created_at: Scalars['timestamptz']['output'];
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** The recipient's email address */
  recipient: Scalars['String']['output'];
  /** Response body from Mandrill */
  response: Scalars['String']['output'];
  /** Outcome of the attempt to send the email (eg, "sent", "queued", "failed").  Due to the way Mandrill currently returns its responses, the status will only be captured once */
  status: Scalars['String']['output'];
  /** The type of the email being sent (eg, "move update") */
  type: Scalars['String']['output'];
};

/** aggregated selection of "email_events" */
export type Email_Events_Aggregate = {
  __typename?: 'email_events_aggregate';
  aggregate?: Maybe<Email_Events_Aggregate_Fields>;
  nodes: Array<Email_Events>;
};

/** aggregate fields of "email_events" */
export type Email_Events_Aggregate_Fields = {
  __typename?: 'email_events_aggregate_fields';
  avg?: Maybe<Email_Events_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Email_Events_Max_Fields>;
  min?: Maybe<Email_Events_Min_Fields>;
  stddev?: Maybe<Email_Events_Stddev_Fields>;
  stddev_pop?: Maybe<Email_Events_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Email_Events_Stddev_Samp_Fields>;
  sum?: Maybe<Email_Events_Sum_Fields>;
  var_pop?: Maybe<Email_Events_Var_Pop_Fields>;
  var_samp?: Maybe<Email_Events_Var_Samp_Fields>;
  variance?: Maybe<Email_Events_Variance_Fields>;
};


/** aggregate fields of "email_events" */
export type Email_Events_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Email_Events_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Email_Events_Avg_Fields = {
  __typename?: 'email_events_avg_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "email_events". All fields are combined with a logical 'AND'. */
export type Email_Events_Bool_Exp = {
  _and?: InputMaybe<Array<Email_Events_Bool_Exp>>;
  _not?: InputMaybe<Email_Events_Bool_Exp>;
  _or?: InputMaybe<Array<Email_Events_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  recipient?: InputMaybe<String_Comparison_Exp>;
  response?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "email_events" */
export enum Email_Events_Constraint {
  /** unique or primary key constraint on columns "id" */
  EmailEventsPkey = 'email_events_pkey'
}

/** input type for incrementing numeric columns in table "email_events" */
export type Email_Events_Inc_Input = {
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "email_events" */
export type Email_Events_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The recipient's email address */
  recipient?: InputMaybe<Scalars['String']['input']>;
  /** Response body from Mandrill */
  response?: InputMaybe<Scalars['String']['input']>;
  /** Outcome of the attempt to send the email (eg, "sent", "queued", "failed").  Due to the way Mandrill currently returns its responses, the status will only be captured once */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The type of the email being sent (eg, "move update") */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Email_Events_Max_Fields = {
  __typename?: 'email_events_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** The recipient's email address */
  recipient?: Maybe<Scalars['String']['output']>;
  /** Response body from Mandrill */
  response?: Maybe<Scalars['String']['output']>;
  /** Outcome of the attempt to send the email (eg, "sent", "queued", "failed").  Due to the way Mandrill currently returns its responses, the status will only be captured once */
  status?: Maybe<Scalars['String']['output']>;
  /** The type of the email being sent (eg, "move update") */
  type?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Email_Events_Min_Fields = {
  __typename?: 'email_events_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** The recipient's email address */
  recipient?: Maybe<Scalars['String']['output']>;
  /** Response body from Mandrill */
  response?: Maybe<Scalars['String']['output']>;
  /** Outcome of the attempt to send the email (eg, "sent", "queued", "failed").  Due to the way Mandrill currently returns its responses, the status will only be captured once */
  status?: Maybe<Scalars['String']['output']>;
  /** The type of the email being sent (eg, "move update") */
  type?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "email_events" */
export type Email_Events_Mutation_Response = {
  __typename?: 'email_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Email_Events>;
};

/** on_conflict condition type for table "email_events" */
export type Email_Events_On_Conflict = {
  constraint: Email_Events_Constraint;
  update_columns?: Array<Email_Events_Update_Column>;
  where?: InputMaybe<Email_Events_Bool_Exp>;
};

/** Ordering options when selecting data from "email_events". */
export type Email_Events_Order_By = {
  created_at?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  recipient?: InputMaybe<Order_By>;
  response?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: email_events */
export type Email_Events_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "email_events" */
export enum Email_Events_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Recipient = 'recipient',
  /** column name */
  Response = 'response',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "email_events" */
export type Email_Events_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The recipient's email address */
  recipient?: InputMaybe<Scalars['String']['input']>;
  /** Response body from Mandrill */
  response?: InputMaybe<Scalars['String']['input']>;
  /** Outcome of the attempt to send the email (eg, "sent", "queued", "failed").  Due to the way Mandrill currently returns its responses, the status will only be captured once */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The type of the email being sent (eg, "move update") */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Email_Events_Stddev_Fields = {
  __typename?: 'email_events_stddev_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Email_Events_Stddev_Pop_Fields = {
  __typename?: 'email_events_stddev_pop_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Email_Events_Stddev_Samp_Fields = {
  __typename?: 'email_events_stddev_samp_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "email_events" */
export type Email_Events_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Email_Events_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Email_Events_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The recipient's email address */
  recipient?: InputMaybe<Scalars['String']['input']>;
  /** Response body from Mandrill */
  response?: InputMaybe<Scalars['String']['input']>;
  /** Outcome of the attempt to send the email (eg, "sent", "queued", "failed").  Due to the way Mandrill currently returns its responses, the status will only be captured once */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The type of the email being sent (eg, "move update") */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Email_Events_Sum_Fields = {
  __typename?: 'email_events_sum_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "email_events" */
export enum Email_Events_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Recipient = 'recipient',
  /** column name */
  Response = 'response',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type'
}

export type Email_Events_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Email_Events_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Email_Events_Set_Input>;
  /** filter the rows which have to be updated */
  where: Email_Events_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Email_Events_Var_Pop_Fields = {
  __typename?: 'email_events_var_pop_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Email_Events_Var_Samp_Fields = {
  __typename?: 'email_events_var_samp_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Email_Events_Variance_Fields = {
  __typename?: 'email_events_variance_fields';
  /** The id of the customer whom the email concerns, where applicable */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The id of the move that the email concerns, where applicable */
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** The masterlist for our equipment products. A driverequipment record can be related to this to say what the piece of equipment actually is. */
export type Equipment = {
  __typename?: 'equipment';
  /** Is the equipment active in our system (soft delete). */
  active: Scalars['Boolean']['output'];
  /** How much the company has to pay for this item. */
  cost: Scalars['numeric']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** Description of the item. */
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  driverequipment: Array<Driverequipment>;
  /** An aggregate relationship */
  driverequipment_aggregate: Driverequipment_Aggregate;
  id: Scalars['bigint']['output'];
  /** Name of the item. */
  name?: Maybe<Scalars['String']['output']>;
  /** Link to an image of the product. */
  photo_url?: Maybe<Scalars['String']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price: Scalars['numeric']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** The masterlist for our equipment products. A driverequipment record can be related to this to say what the piece of equipment actually is. */
export type EquipmentDriverequipmentArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


/** The masterlist for our equipment products. A driverequipment record can be related to this to say what the piece of equipment actually is. */
export type EquipmentDriverequipment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};

/** aggregated selection of "equipment" */
export type Equipment_Aggregate = {
  __typename?: 'equipment_aggregate';
  aggregate?: Maybe<Equipment_Aggregate_Fields>;
  nodes: Array<Equipment>;
};

/** aggregate fields of "equipment" */
export type Equipment_Aggregate_Fields = {
  __typename?: 'equipment_aggregate_fields';
  avg?: Maybe<Equipment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Equipment_Max_Fields>;
  min?: Maybe<Equipment_Min_Fields>;
  stddev?: Maybe<Equipment_Stddev_Fields>;
  stddev_pop?: Maybe<Equipment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Equipment_Stddev_Samp_Fields>;
  sum?: Maybe<Equipment_Sum_Fields>;
  var_pop?: Maybe<Equipment_Var_Pop_Fields>;
  var_samp?: Maybe<Equipment_Var_Samp_Fields>;
  variance?: Maybe<Equipment_Variance_Fields>;
};


/** aggregate fields of "equipment" */
export type Equipment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Equipment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Equipment_Avg_Fields = {
  __typename?: 'equipment_avg_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "equipment". All fields are combined with a logical 'AND'. */
export type Equipment_Bool_Exp = {
  _and?: InputMaybe<Array<Equipment_Bool_Exp>>;
  _not?: InputMaybe<Equipment_Bool_Exp>;
  _or?: InputMaybe<Array<Equipment_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  cost?: InputMaybe<Numeric_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  driverequipment?: InputMaybe<Driverequipment_Bool_Exp>;
  driverequipment_aggregate?: InputMaybe<Driverequipment_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  photo_url?: InputMaybe<String_Comparison_Exp>;
  price?: InputMaybe<Numeric_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "equipment" */
export enum Equipment_Constraint {
  /** unique or primary key constraint on columns "id" */
  EquipmentPkey = 'equipment_pkey'
}

/** input type for incrementing numeric columns in table "equipment" */
export type Equipment_Inc_Input = {
  /** How much the company has to pay for this item. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "equipment" */
export type Equipment_Insert_Input = {
  /** Is the equipment active in our system (soft delete). */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** How much the company has to pay for this item. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of the item. */
  description?: InputMaybe<Scalars['String']['input']>;
  driverequipment?: InputMaybe<Driverequipment_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Name of the item. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Link to an image of the product. */
  photo_url?: InputMaybe<Scalars['String']['input']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: InputMaybe<Scalars['numeric']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Equipment_Max_Fields = {
  __typename?: 'equipment_max_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of the item. */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Name of the item. */
  name?: Maybe<Scalars['String']['output']>;
  /** Link to an image of the product. */
  photo_url?: Maybe<Scalars['String']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['numeric']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Equipment_Min_Fields = {
  __typename?: 'equipment_min_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of the item. */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Name of the item. */
  name?: Maybe<Scalars['String']['output']>;
  /** Link to an image of the product. */
  photo_url?: Maybe<Scalars['String']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['numeric']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "equipment" */
export type Equipment_Mutation_Response = {
  __typename?: 'equipment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Equipment>;
};

/** input type for inserting object relation for remote table "equipment" */
export type Equipment_Obj_Rel_Insert_Input = {
  data: Equipment_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Equipment_On_Conflict>;
};

/** on_conflict condition type for table "equipment" */
export type Equipment_On_Conflict = {
  constraint: Equipment_Constraint;
  update_columns?: Array<Equipment_Update_Column>;
  where?: InputMaybe<Equipment_Bool_Exp>;
};

/** Ordering options when selecting data from "equipment". */
export type Equipment_Order_By = {
  active?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  driverequipment_aggregate?: InputMaybe<Driverequipment_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  photo_url?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: equipment */
export type Equipment_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "equipment" */
export enum Equipment_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PhotoUrl = 'photo_url',
  /** column name */
  Price = 'price',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "equipment" */
export type Equipment_Set_Input = {
  /** Is the equipment active in our system (soft delete). */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** How much the company has to pay for this item. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of the item. */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Name of the item. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Link to an image of the product. */
  photo_url?: InputMaybe<Scalars['String']['input']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: InputMaybe<Scalars['numeric']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Equipment_Stddev_Fields = {
  __typename?: 'equipment_stddev_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Equipment_Stddev_Pop_Fields = {
  __typename?: 'equipment_stddev_pop_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Equipment_Stddev_Samp_Fields = {
  __typename?: 'equipment_stddev_samp_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "equipment" */
export type Equipment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Equipment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Equipment_Stream_Cursor_Value_Input = {
  /** Is the equipment active in our system (soft delete). */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** How much the company has to pay for this item. */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of the item. */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Name of the item. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Link to an image of the product. */
  photo_url?: InputMaybe<Scalars['String']['input']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: InputMaybe<Scalars['numeric']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Equipment_Sum_Fields = {
  __typename?: 'equipment_sum_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "equipment" */
export enum Equipment_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PhotoUrl = 'photo_url',
  /** column name */
  Price = 'price',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Equipment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Equipment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Equipment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Equipment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Equipment_Var_Pop_Fields = {
  __typename?: 'equipment_var_pop_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Equipment_Var_Samp_Fields = {
  __typename?: 'equipment_var_samp_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Equipment_Variance_Fields = {
  __typename?: 'equipment_variance_fields';
  /** How much the company has to pay for this item. */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** The price that would be charged to someone purchasing the equipment from HopDrive. For instance, if a driver regularly loses their equipment and we no longer provide it to them for free, what would we charge that driver for the replacement item? It may be higher than our cost. */
  price?: Maybe<Scalars['Float']['output']>;
};

/** Each event module checked during an invocation */
export type Event_Executions = {
  __typename?: 'event_executions';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  detected: Scalars['Boolean']['output'];
  detection_duration_ms?: Maybe<Scalars['Int']['output']>;
  detection_error?: Maybe<Scalars['String']['output']>;
  detection_error_stack?: Maybe<Scalars['String']['output']>;
  event_module_path?: Maybe<Scalars['String']['output']>;
  event_name: Scalars['String']['output'];
  handler_duration_ms?: Maybe<Scalars['Int']['output']>;
  handler_error?: Maybe<Scalars['String']['output']>;
  handler_error_stack?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  /** An object relationship */
  invocation: Invocations;
  invocation_id: Scalars['uuid']['output'];
  /** An array relationship */
  job_executions: Array<Job_Executions>;
  /** An aggregate relationship */
  job_executions_aggregate: Job_Executions_Aggregate;
  jobs_count?: Maybe<Scalars['Int']['output']>;
  jobs_failed?: Maybe<Scalars['Int']['output']>;
  jobs_succeeded?: Maybe<Scalars['Int']['output']>;
  status: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** Each event module checked during an invocation */
export type Event_ExecutionsJob_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


/** Each event module checked during an invocation */
export type Event_ExecutionsJob_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};

/** aggregated selection of "event_executions" */
export type Event_Executions_Aggregate = {
  __typename?: 'event_executions_aggregate';
  aggregate?: Maybe<Event_Executions_Aggregate_Fields>;
  nodes: Array<Event_Executions>;
};

export type Event_Executions_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Event_Executions_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Event_Executions_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Event_Executions_Aggregate_Bool_Exp_Count>;
};

export type Event_Executions_Aggregate_Bool_Exp_Bool_And = {
  arguments: Event_Executions_Select_Column_Event_Executions_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Event_Executions_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Event_Executions_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Event_Executions_Select_Column_Event_Executions_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Event_Executions_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Event_Executions_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Event_Executions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Event_Executions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "event_executions" */
export type Event_Executions_Aggregate_Fields = {
  __typename?: 'event_executions_aggregate_fields';
  avg?: Maybe<Event_Executions_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Event_Executions_Max_Fields>;
  min?: Maybe<Event_Executions_Min_Fields>;
  stddev?: Maybe<Event_Executions_Stddev_Fields>;
  stddev_pop?: Maybe<Event_Executions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Event_Executions_Stddev_Samp_Fields>;
  sum?: Maybe<Event_Executions_Sum_Fields>;
  var_pop?: Maybe<Event_Executions_Var_Pop_Fields>;
  var_samp?: Maybe<Event_Executions_Var_Samp_Fields>;
  variance?: Maybe<Event_Executions_Variance_Fields>;
};


/** aggregate fields of "event_executions" */
export type Event_Executions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Event_Executions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "event_executions" */
export type Event_Executions_Aggregate_Order_By = {
  avg?: InputMaybe<Event_Executions_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Event_Executions_Max_Order_By>;
  min?: InputMaybe<Event_Executions_Min_Order_By>;
  stddev?: InputMaybe<Event_Executions_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Event_Executions_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Event_Executions_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Event_Executions_Sum_Order_By>;
  var_pop?: InputMaybe<Event_Executions_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Event_Executions_Var_Samp_Order_By>;
  variance?: InputMaybe<Event_Executions_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "event_executions" */
export type Event_Executions_Arr_Rel_Insert_Input = {
  data: Array<Event_Executions_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Event_Executions_On_Conflict>;
};

/** aggregate avg on columns */
export type Event_Executions_Avg_Fields = {
  __typename?: 'event_executions_avg_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "event_executions" */
export type Event_Executions_Avg_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "event_executions". All fields are combined with a logical 'AND'. */
export type Event_Executions_Bool_Exp = {
  _and?: InputMaybe<Array<Event_Executions_Bool_Exp>>;
  _not?: InputMaybe<Event_Executions_Bool_Exp>;
  _or?: InputMaybe<Array<Event_Executions_Bool_Exp>>;
  correlation_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  detected?: InputMaybe<Boolean_Comparison_Exp>;
  detection_duration_ms?: InputMaybe<Int_Comparison_Exp>;
  detection_error?: InputMaybe<String_Comparison_Exp>;
  detection_error_stack?: InputMaybe<String_Comparison_Exp>;
  event_module_path?: InputMaybe<String_Comparison_Exp>;
  event_name?: InputMaybe<String_Comparison_Exp>;
  handler_duration_ms?: InputMaybe<Int_Comparison_Exp>;
  handler_error?: InputMaybe<String_Comparison_Exp>;
  handler_error_stack?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  invocation?: InputMaybe<Invocations_Bool_Exp>;
  invocation_id?: InputMaybe<Uuid_Comparison_Exp>;
  job_executions?: InputMaybe<Job_Executions_Bool_Exp>;
  job_executions_aggregate?: InputMaybe<Job_Executions_Aggregate_Bool_Exp>;
  jobs_count?: InputMaybe<Int_Comparison_Exp>;
  jobs_failed?: InputMaybe<Int_Comparison_Exp>;
  jobs_succeeded?: InputMaybe<Int_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "event_executions" */
export enum Event_Executions_Constraint {
  /** unique or primary key constraint on columns "id" */
  EventExecutionsPkey = 'event_executions_pkey'
}

/** input type for incrementing numeric columns in table "event_executions" */
export type Event_Executions_Inc_Input = {
  detection_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  handler_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  jobs_count?: InputMaybe<Scalars['Int']['input']>;
  jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "event_executions" */
export type Event_Executions_Insert_Input = {
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  detected?: InputMaybe<Scalars['Boolean']['input']>;
  detection_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  detection_error?: InputMaybe<Scalars['String']['input']>;
  detection_error_stack?: InputMaybe<Scalars['String']['input']>;
  event_module_path?: InputMaybe<Scalars['String']['input']>;
  event_name?: InputMaybe<Scalars['String']['input']>;
  handler_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  handler_error?: InputMaybe<Scalars['String']['input']>;
  handler_error_stack?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invocation?: InputMaybe<Invocations_Obj_Rel_Insert_Input>;
  invocation_id?: InputMaybe<Scalars['uuid']['input']>;
  job_executions?: InputMaybe<Job_Executions_Arr_Rel_Insert_Input>;
  jobs_count?: InputMaybe<Scalars['Int']['input']>;
  jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Event_Executions_Max_Fields = {
  __typename?: 'event_executions_max_fields';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  detection_duration_ms?: Maybe<Scalars['Int']['output']>;
  detection_error?: Maybe<Scalars['String']['output']>;
  detection_error_stack?: Maybe<Scalars['String']['output']>;
  event_module_path?: Maybe<Scalars['String']['output']>;
  event_name?: Maybe<Scalars['String']['output']>;
  handler_duration_ms?: Maybe<Scalars['Int']['output']>;
  handler_error?: Maybe<Scalars['String']['output']>;
  handler_error_stack?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invocation_id?: Maybe<Scalars['uuid']['output']>;
  jobs_count?: Maybe<Scalars['Int']['output']>;
  jobs_failed?: Maybe<Scalars['Int']['output']>;
  jobs_succeeded?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "event_executions" */
export type Event_Executions_Max_Order_By = {
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  detection_duration_ms?: InputMaybe<Order_By>;
  detection_error?: InputMaybe<Order_By>;
  detection_error_stack?: InputMaybe<Order_By>;
  event_module_path?: InputMaybe<Order_By>;
  event_name?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  handler_error?: InputMaybe<Order_By>;
  handler_error_stack?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invocation_id?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Event_Executions_Min_Fields = {
  __typename?: 'event_executions_min_fields';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  detection_duration_ms?: Maybe<Scalars['Int']['output']>;
  detection_error?: Maybe<Scalars['String']['output']>;
  detection_error_stack?: Maybe<Scalars['String']['output']>;
  event_module_path?: Maybe<Scalars['String']['output']>;
  event_name?: Maybe<Scalars['String']['output']>;
  handler_duration_ms?: Maybe<Scalars['Int']['output']>;
  handler_error?: Maybe<Scalars['String']['output']>;
  handler_error_stack?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invocation_id?: Maybe<Scalars['uuid']['output']>;
  jobs_count?: Maybe<Scalars['Int']['output']>;
  jobs_failed?: Maybe<Scalars['Int']['output']>;
  jobs_succeeded?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "event_executions" */
export type Event_Executions_Min_Order_By = {
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  detection_duration_ms?: InputMaybe<Order_By>;
  detection_error?: InputMaybe<Order_By>;
  detection_error_stack?: InputMaybe<Order_By>;
  event_module_path?: InputMaybe<Order_By>;
  event_name?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  handler_error?: InputMaybe<Order_By>;
  handler_error_stack?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invocation_id?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "event_executions" */
export type Event_Executions_Mutation_Response = {
  __typename?: 'event_executions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Event_Executions>;
};

/** input type for inserting object relation for remote table "event_executions" */
export type Event_Executions_Obj_Rel_Insert_Input = {
  data: Event_Executions_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Event_Executions_On_Conflict>;
};

/** on_conflict condition type for table "event_executions" */
export type Event_Executions_On_Conflict = {
  constraint: Event_Executions_Constraint;
  update_columns?: Array<Event_Executions_Update_Column>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};

/** Ordering options when selecting data from "event_executions". */
export type Event_Executions_Order_By = {
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  detected?: InputMaybe<Order_By>;
  detection_duration_ms?: InputMaybe<Order_By>;
  detection_error?: InputMaybe<Order_By>;
  detection_error_stack?: InputMaybe<Order_By>;
  event_module_path?: InputMaybe<Order_By>;
  event_name?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  handler_error?: InputMaybe<Order_By>;
  handler_error_stack?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invocation?: InputMaybe<Invocations_Order_By>;
  invocation_id?: InputMaybe<Order_By>;
  job_executions_aggregate?: InputMaybe<Job_Executions_Aggregate_Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: event_executions */
export type Event_Executions_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "event_executions" */
export enum Event_Executions_Select_Column {
  /** column name */
  CorrelationId = 'correlation_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Detected = 'detected',
  /** column name */
  DetectionDurationMs = 'detection_duration_ms',
  /** column name */
  DetectionError = 'detection_error',
  /** column name */
  DetectionErrorStack = 'detection_error_stack',
  /** column name */
  EventModulePath = 'event_module_path',
  /** column name */
  EventName = 'event_name',
  /** column name */
  HandlerDurationMs = 'handler_duration_ms',
  /** column name */
  HandlerError = 'handler_error',
  /** column name */
  HandlerErrorStack = 'handler_error_stack',
  /** column name */
  Id = 'id',
  /** column name */
  InvocationId = 'invocation_id',
  /** column name */
  JobsCount = 'jobs_count',
  /** column name */
  JobsFailed = 'jobs_failed',
  /** column name */
  JobsSucceeded = 'jobs_succeeded',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "event_executions_aggregate_bool_exp_bool_and_arguments_columns" columns of table "event_executions" */
export enum Event_Executions_Select_Column_Event_Executions_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Detected = 'detected'
}

/** select "event_executions_aggregate_bool_exp_bool_or_arguments_columns" columns of table "event_executions" */
export enum Event_Executions_Select_Column_Event_Executions_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Detected = 'detected'
}

/** input type for updating data in table "event_executions" */
export type Event_Executions_Set_Input = {
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  detected?: InputMaybe<Scalars['Boolean']['input']>;
  detection_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  detection_error?: InputMaybe<Scalars['String']['input']>;
  detection_error_stack?: InputMaybe<Scalars['String']['input']>;
  event_module_path?: InputMaybe<Scalars['String']['input']>;
  event_name?: InputMaybe<Scalars['String']['input']>;
  handler_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  handler_error?: InputMaybe<Scalars['String']['input']>;
  handler_error_stack?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invocation_id?: InputMaybe<Scalars['uuid']['input']>;
  jobs_count?: InputMaybe<Scalars['Int']['input']>;
  jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Event_Executions_Stddev_Fields = {
  __typename?: 'event_executions_stddev_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "event_executions" */
export type Event_Executions_Stddev_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Event_Executions_Stddev_Pop_Fields = {
  __typename?: 'event_executions_stddev_pop_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "event_executions" */
export type Event_Executions_Stddev_Pop_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Event_Executions_Stddev_Samp_Fields = {
  __typename?: 'event_executions_stddev_samp_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "event_executions" */
export type Event_Executions_Stddev_Samp_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "event_executions" */
export type Event_Executions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Event_Executions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Event_Executions_Stream_Cursor_Value_Input = {
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  detected?: InputMaybe<Scalars['Boolean']['input']>;
  detection_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  detection_error?: InputMaybe<Scalars['String']['input']>;
  detection_error_stack?: InputMaybe<Scalars['String']['input']>;
  event_module_path?: InputMaybe<Scalars['String']['input']>;
  event_name?: InputMaybe<Scalars['String']['input']>;
  handler_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  handler_error?: InputMaybe<Scalars['String']['input']>;
  handler_error_stack?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invocation_id?: InputMaybe<Scalars['uuid']['input']>;
  jobs_count?: InputMaybe<Scalars['Int']['input']>;
  jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Event_Executions_Sum_Fields = {
  __typename?: 'event_executions_sum_fields';
  detection_duration_ms?: Maybe<Scalars['Int']['output']>;
  handler_duration_ms?: Maybe<Scalars['Int']['output']>;
  jobs_count?: Maybe<Scalars['Int']['output']>;
  jobs_failed?: Maybe<Scalars['Int']['output']>;
  jobs_succeeded?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "event_executions" */
export type Event_Executions_Sum_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** update columns of table "event_executions" */
export enum Event_Executions_Update_Column {
  /** column name */
  CorrelationId = 'correlation_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Detected = 'detected',
  /** column name */
  DetectionDurationMs = 'detection_duration_ms',
  /** column name */
  DetectionError = 'detection_error',
  /** column name */
  DetectionErrorStack = 'detection_error_stack',
  /** column name */
  EventModulePath = 'event_module_path',
  /** column name */
  EventName = 'event_name',
  /** column name */
  HandlerDurationMs = 'handler_duration_ms',
  /** column name */
  HandlerError = 'handler_error',
  /** column name */
  HandlerErrorStack = 'handler_error_stack',
  /** column name */
  Id = 'id',
  /** column name */
  InvocationId = 'invocation_id',
  /** column name */
  JobsCount = 'jobs_count',
  /** column name */
  JobsFailed = 'jobs_failed',
  /** column name */
  JobsSucceeded = 'jobs_succeeded',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Event_Executions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Event_Executions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Event_Executions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Event_Executions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Event_Executions_Var_Pop_Fields = {
  __typename?: 'event_executions_var_pop_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "event_executions" */
export type Event_Executions_Var_Pop_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Event_Executions_Var_Samp_Fields = {
  __typename?: 'event_executions_var_samp_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "event_executions" */
export type Event_Executions_Var_Samp_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Event_Executions_Variance_Fields = {
  __typename?: 'event_executions_variance_fields';
  detection_duration_ms?: Maybe<Scalars['Float']['output']>;
  handler_duration_ms?: Maybe<Scalars['Float']['output']>;
  jobs_count?: Maybe<Scalars['Float']['output']>;
  jobs_failed?: Maybe<Scalars['Float']['output']>;
  jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "event_executions" */
export type Event_Executions_Variance_Order_By = {
  detection_duration_ms?: InputMaybe<Order_By>;
  handler_duration_ms?: InputMaybe<Order_By>;
  jobs_count?: InputMaybe<Order_By>;
  jobs_failed?: InputMaybe<Order_By>;
  jobs_succeeded?: InputMaybe<Order_By>;
};

/** Logs of events which occur in our system. Allows auditing of actions which occur in our systems */
export type Eventlogs = {
  __typename?: 'eventlogs';
  /** An object relationship */
  actiontype: Actiontypes;
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id: Scalars['smallint']['output'];
  /** The time at which the event was logged in this table */
  created_at_utc: Scalars['timestamptz']['output'];
  /** An object relationship */
  customer?: Maybe<Customers>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** The time at which the event occurred */
  event_time_utc: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** An object relationship */
  lane?: Maybe<Lanes>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  location?: Maybe<Locations>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  move?: Maybe<Moves>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id: Scalars['smallint']['output'];
  /** An object relationship */
  roletype: Roletypes;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user: Scalars['String']['output'];
};


/** Logs of events which occur in our system. Allows auditing of actions which occur in our systems */
export type EventlogsMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "eventlogs" */
export type Eventlogs_Aggregate = {
  __typename?: 'eventlogs_aggregate';
  aggregate?: Maybe<Eventlogs_Aggregate_Fields>;
  nodes: Array<Eventlogs>;
};

export type Eventlogs_Aggregate_Bool_Exp = {
  count?: InputMaybe<Eventlogs_Aggregate_Bool_Exp_Count>;
};

export type Eventlogs_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Eventlogs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Eventlogs_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "eventlogs" */
export type Eventlogs_Aggregate_Fields = {
  __typename?: 'eventlogs_aggregate_fields';
  avg?: Maybe<Eventlogs_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Eventlogs_Max_Fields>;
  min?: Maybe<Eventlogs_Min_Fields>;
  stddev?: Maybe<Eventlogs_Stddev_Fields>;
  stddev_pop?: Maybe<Eventlogs_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Eventlogs_Stddev_Samp_Fields>;
  sum?: Maybe<Eventlogs_Sum_Fields>;
  var_pop?: Maybe<Eventlogs_Var_Pop_Fields>;
  var_samp?: Maybe<Eventlogs_Var_Samp_Fields>;
  variance?: Maybe<Eventlogs_Variance_Fields>;
};


/** aggregate fields of "eventlogs" */
export type Eventlogs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Eventlogs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "eventlogs" */
export type Eventlogs_Aggregate_Order_By = {
  avg?: InputMaybe<Eventlogs_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Eventlogs_Max_Order_By>;
  min?: InputMaybe<Eventlogs_Min_Order_By>;
  stddev?: InputMaybe<Eventlogs_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Eventlogs_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Eventlogs_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Eventlogs_Sum_Order_By>;
  var_pop?: InputMaybe<Eventlogs_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Eventlogs_Var_Samp_Order_By>;
  variance?: InputMaybe<Eventlogs_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Eventlogs_Append_Input = {
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "eventlogs" */
export type Eventlogs_Arr_Rel_Insert_Input = {
  data: Array<Eventlogs_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Eventlogs_On_Conflict>;
};

/** aggregate avg on columns */
export type Eventlogs_Avg_Fields = {
  __typename?: 'eventlogs_avg_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "eventlogs" */
export type Eventlogs_Avg_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "eventlogs". All fields are combined with a logical 'AND'. */
export type Eventlogs_Bool_Exp = {
  _and?: InputMaybe<Array<Eventlogs_Bool_Exp>>;
  _not?: InputMaybe<Eventlogs_Bool_Exp>;
  _or?: InputMaybe<Array<Eventlogs_Bool_Exp>>;
  actiontype?: InputMaybe<Actiontypes_Bool_Exp>;
  actiontype_id?: InputMaybe<Smallint_Comparison_Exp>;
  created_at_utc?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  event_time_utc?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  lane?: InputMaybe<Lanes_Bool_Exp>;
  lane_id?: InputMaybe<Bigint_Comparison_Exp>;
  location?: InputMaybe<Locations_Bool_Exp>;
  location_id?: InputMaybe<Bigint_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  role_id?: InputMaybe<Smallint_Comparison_Exp>;
  roletype?: InputMaybe<Roletypes_Bool_Exp>;
  user?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "eventlogs" */
export enum Eventlogs_Constraint {
  /** unique or primary key constraint on columns "id" */
  AuditsPkey = 'audits_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Eventlogs_Delete_At_Path_Input = {
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Eventlogs_Delete_Elem_Input = {
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Eventlogs_Delete_Key_Input = {
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "eventlogs" */
export type Eventlogs_Inc_Input = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "eventlogs" */
export type Eventlogs_Insert_Input = {
  actiontype?: InputMaybe<Actiontypes_Obj_Rel_Insert_Input>;
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** The time at which the event was logged in this table */
  created_at_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The time at which the event occurred */
  event_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane?: InputMaybe<Lanes_Obj_Rel_Insert_Input>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Scalars['smallint']['input']>;
  roletype?: InputMaybe<Roletypes_Obj_Rel_Insert_Input>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Eventlogs_Max_Fields = {
  __typename?: 'eventlogs_max_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['smallint']['output']>;
  /** The time at which the event was logged in this table */
  created_at_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** The time at which the event occurred */
  event_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['smallint']['output']>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "eventlogs" */
export type Eventlogs_Max_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** The time at which the event was logged in this table */
  created_at_utc?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  /** The time at which the event occurred */
  event_time_utc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Eventlogs_Min_Fields = {
  __typename?: 'eventlogs_min_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['smallint']['output']>;
  /** The time at which the event was logged in this table */
  created_at_utc?: Maybe<Scalars['timestamptz']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** The time at which the event occurred */
  event_time_utc?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['smallint']['output']>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "eventlogs" */
export type Eventlogs_Min_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** The time at which the event was logged in this table */
  created_at_utc?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  /** The time at which the event occurred */
  event_time_utc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "eventlogs" */
export type Eventlogs_Mutation_Response = {
  __typename?: 'eventlogs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Eventlogs>;
};

/** on_conflict condition type for table "eventlogs" */
export type Eventlogs_On_Conflict = {
  constraint: Eventlogs_Constraint;
  update_columns?: Array<Eventlogs_Update_Column>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};

/** Ordering options when selecting data from "eventlogs". */
export type Eventlogs_Order_By = {
  actiontype?: InputMaybe<Actiontypes_Order_By>;
  actiontype_id?: InputMaybe<Order_By>;
  created_at_utc?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  event_time_utc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane?: InputMaybe<Lanes_Order_By>;
  lane_id?: InputMaybe<Order_By>;
  location?: InputMaybe<Locations_Order_By>;
  location_id?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  roletype?: InputMaybe<Roletypes_Order_By>;
  user?: InputMaybe<Order_By>;
};

/** primary key columns input for table: eventlogs */
export type Eventlogs_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Eventlogs_Prepend_Input = {
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "eventlogs" */
export enum Eventlogs_Select_Column {
  /** column name */
  ActiontypeId = 'actiontype_id',
  /** column name */
  CreatedAtUtc = 'created_at_utc',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EventTimeUtc = 'event_time_utc',
  /** column name */
  Id = 'id',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  RoleId = 'role_id',
  /** column name */
  User = 'user'
}

/** input type for updating data in table "eventlogs" */
export type Eventlogs_Set_Input = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** The time at which the event was logged in this table */
  created_at_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The time at which the event occurred */
  event_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Scalars['smallint']['input']>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Eventlogs_Stddev_Fields = {
  __typename?: 'eventlogs_stddev_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "eventlogs" */
export type Eventlogs_Stddev_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Eventlogs_Stddev_Pop_Fields = {
  __typename?: 'eventlogs_stddev_pop_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "eventlogs" */
export type Eventlogs_Stddev_Pop_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Eventlogs_Stddev_Samp_Fields = {
  __typename?: 'eventlogs_stddev_samp_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "eventlogs" */
export type Eventlogs_Stddev_Samp_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "eventlogs" */
export type Eventlogs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Eventlogs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Eventlogs_Stream_Cursor_Value_Input = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** The time at which the event was logged in this table */
  created_at_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The time at which the event occurred */
  event_time_utc?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Catch-all for any metadata or additional info to be stored. Should be match the action type's metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Scalars['smallint']['input']>;
  /** Idetity of user (or system) which performed the action. We use email addresses to id human users */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Eventlogs_Sum_Fields = {
  __typename?: 'eventlogs_sum_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['smallint']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['bigint']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['smallint']['output']>;
};

/** order by sum() on columns of table "eventlogs" */
export type Eventlogs_Sum_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** update columns of table "eventlogs" */
export enum Eventlogs_Update_Column {
  /** column name */
  ActiontypeId = 'actiontype_id',
  /** column name */
  CreatedAtUtc = 'created_at_utc',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  EventTimeUtc = 'event_time_utc',
  /** column name */
  Id = 'id',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  RoleId = 'role_id',
  /** column name */
  User = 'user'
}

export type Eventlogs_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Eventlogs_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Eventlogs_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Eventlogs_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Eventlogs_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Eventlogs_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Eventlogs_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Eventlogs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Eventlogs_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Eventlogs_Var_Pop_Fields = {
  __typename?: 'eventlogs_var_pop_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "eventlogs" */
export type Eventlogs_Var_Pop_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Eventlogs_Var_Samp_Fields = {
  __typename?: 'eventlogs_var_samp_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "eventlogs" */
export type Eventlogs_Var_Samp_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Eventlogs_Variance_Fields = {
  __typename?: 'eventlogs_variance_fields';
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on lane table */
  lane_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations on locations table */
  location_id?: Maybe<Scalars['Float']['output']>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "eventlogs" */
export type Eventlogs_Variance_Order_By = {
  /** Code that represents the type of action being recorded (ex: creating a move).  The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Order_By>;
  /** Used when recording operations performed by a specific customer or when altering a customer record */
  customer_id?: InputMaybe<Order_By>;
  /** Used when recording driver actions or mutations to driver table or driver pay */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Used when recording mutations on lane table */
  lane_id?: InputMaybe<Order_By>;
  /** Used when recording mutations on locations table */
  location_id?: InputMaybe<Order_By>;
  /** Used when recording mutations to moves table, armoves table, etc. */
  move_id?: InputMaybe<Order_By>;
  /** Code representing the role of the user which performed the action. (Ex: Dealer, Dispatcher). The code corresponds with a row in the roletypes table which contains more information about the role, including name of role, description of role, and the role's permission */
  role_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "events" */
export type Events = {
  __typename?: 'events';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  eventid: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "events" */
export type Events_Aggregate = {
  __typename?: 'events_aggregate';
  aggregate?: Maybe<Events_Aggregate_Fields>;
  nodes: Array<Events>;
};

/** aggregate fields of "events" */
export type Events_Aggregate_Fields = {
  __typename?: 'events_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Events_Max_Fields>;
  min?: Maybe<Events_Min_Fields>;
};


/** aggregate fields of "events" */
export type Events_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Events_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
export type Events_Bool_Exp = {
  _and?: InputMaybe<Array<Events_Bool_Exp>>;
  _not?: InputMaybe<Events_Bool_Exp>;
  _or?: InputMaybe<Array<Events_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  eventid?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "events" */
export enum Events_Constraint {
  /** unique or primary key constraint on columns "eventid" */
  Idx_25656Primary = 'idx_25656_primary'
}

/** input type for inserting data into table "events" */
export type Events_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  eventid?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Events_Max_Fields = {
  __typename?: 'events_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  eventid?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Events_Min_Fields = {
  __typename?: 'events_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  eventid?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "events" */
export type Events_Mutation_Response = {
  __typename?: 'events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Events>;
};

/** on_conflict condition type for table "events" */
export type Events_On_Conflict = {
  constraint: Events_Constraint;
  update_columns?: Array<Events_Update_Column>;
  where?: InputMaybe<Events_Bool_Exp>;
};

/** Ordering options when selecting data from "events". */
export type Events_Order_By = {
  createdat?: InputMaybe<Order_By>;
  eventid?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: events */
export type Events_Pk_Columns_Input = {
  eventid: Scalars['String']['input'];
};

/** select columns of table "events" */
export enum Events_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Eventid = 'eventid',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "events" */
export type Events_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  eventid?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "events" */
export type Events_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Events_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Events_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  eventid?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "events" */
export enum Events_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Eventid = 'eventid',
  /** column name */
  Updatedat = 'updatedat'
}

export type Events_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Events_Set_Input>;
  /** filter the rows which have to be updated */
  where: Events_Bool_Exp;
};

/** columns and relationships of "faqs" */
export type Faqs = {
  __typename?: 'faqs';
  active: Scalars['Boolean']['output'];
  answer: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  /** Pops up on admin to review if new_flag is true. Doesn't display until active is true */
  new_flag: Scalars['Boolean']['output'];
  question: Scalars['String']['output'];
  /** 'null' (all users), 'dealer', 'driver', 'dispatcher' */
  user?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "faqs" */
export type Faqs_Aggregate = {
  __typename?: 'faqs_aggregate';
  aggregate?: Maybe<Faqs_Aggregate_Fields>;
  nodes: Array<Faqs>;
};

/** aggregate fields of "faqs" */
export type Faqs_Aggregate_Fields = {
  __typename?: 'faqs_aggregate_fields';
  avg?: Maybe<Faqs_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Faqs_Max_Fields>;
  min?: Maybe<Faqs_Min_Fields>;
  stddev?: Maybe<Faqs_Stddev_Fields>;
  stddev_pop?: Maybe<Faqs_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Faqs_Stddev_Samp_Fields>;
  sum?: Maybe<Faqs_Sum_Fields>;
  var_pop?: Maybe<Faqs_Var_Pop_Fields>;
  var_samp?: Maybe<Faqs_Var_Samp_Fields>;
  variance?: Maybe<Faqs_Variance_Fields>;
};


/** aggregate fields of "faqs" */
export type Faqs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faqs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Faqs_Avg_Fields = {
  __typename?: 'faqs_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "faqs". All fields are combined with a logical 'AND'. */
export type Faqs_Bool_Exp = {
  _and?: InputMaybe<Array<Faqs_Bool_Exp>>;
  _not?: InputMaybe<Faqs_Bool_Exp>;
  _or?: InputMaybe<Array<Faqs_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  answer?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  new_flag?: InputMaybe<Boolean_Comparison_Exp>;
  question?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faqs" */
export enum Faqs_Constraint {
  /** unique or primary key constraint on columns "id" */
  FaqsPkey = 'faqs_pkey'
}

/** input type for incrementing numeric columns in table "faqs" */
export type Faqs_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "faqs" */
export type Faqs_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Pops up on admin to review if new_flag is true. Doesn't display until active is true */
  new_flag?: InputMaybe<Scalars['Boolean']['input']>;
  question?: InputMaybe<Scalars['String']['input']>;
  /** 'null' (all users), 'dealer', 'driver', 'dispatcher' */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faqs_Max_Fields = {
  __typename?: 'faqs_max_fields';
  answer?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  question?: Maybe<Scalars['String']['output']>;
  /** 'null' (all users), 'dealer', 'driver', 'dispatcher' */
  user?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Faqs_Min_Fields = {
  __typename?: 'faqs_min_fields';
  answer?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  question?: Maybe<Scalars['String']['output']>;
  /** 'null' (all users), 'dealer', 'driver', 'dispatcher' */
  user?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "faqs" */
export type Faqs_Mutation_Response = {
  __typename?: 'faqs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faqs>;
};

/** on_conflict condition type for table "faqs" */
export type Faqs_On_Conflict = {
  constraint: Faqs_Constraint;
  update_columns?: Array<Faqs_Update_Column>;
  where?: InputMaybe<Faqs_Bool_Exp>;
};

/** Ordering options when selecting data from "faqs". */
export type Faqs_Order_By = {
  active?: InputMaybe<Order_By>;
  answer?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  new_flag?: InputMaybe<Order_By>;
  question?: InputMaybe<Order_By>;
  user?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faqs */
export type Faqs_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "faqs" */
export enum Faqs_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Answer = 'answer',
  /** column name */
  Id = 'id',
  /** column name */
  NewFlag = 'new_flag',
  /** column name */
  Question = 'question',
  /** column name */
  User = 'user'
}

/** input type for updating data in table "faqs" */
export type Faqs_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Pops up on admin to review if new_flag is true. Doesn't display until active is true */
  new_flag?: InputMaybe<Scalars['Boolean']['input']>;
  question?: InputMaybe<Scalars['String']['input']>;
  /** 'null' (all users), 'dealer', 'driver', 'dispatcher' */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Faqs_Stddev_Fields = {
  __typename?: 'faqs_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Faqs_Stddev_Pop_Fields = {
  __typename?: 'faqs_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Faqs_Stddev_Samp_Fields = {
  __typename?: 'faqs_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "faqs" */
export type Faqs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faqs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faqs_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Pops up on admin to review if new_flag is true. Doesn't display until active is true */
  new_flag?: InputMaybe<Scalars['Boolean']['input']>;
  question?: InputMaybe<Scalars['String']['input']>;
  /** 'null' (all users), 'dealer', 'driver', 'dispatcher' */
  user?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Faqs_Sum_Fields = {
  __typename?: 'faqs_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "faqs" */
export enum Faqs_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Answer = 'answer',
  /** column name */
  Id = 'id',
  /** column name */
  NewFlag = 'new_flag',
  /** column name */
  Question = 'question',
  /** column name */
  User = 'user'
}

export type Faqs_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Faqs_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faqs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faqs_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Faqs_Var_Pop_Fields = {
  __typename?: 'faqs_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Faqs_Var_Samp_Fields = {
  __typename?: 'faqs_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Faqs_Variance_Fields = {
  __typename?: 'faqs_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "favoritelanes" */
export type Favoritelanes = {
  __typename?: 'favoritelanes';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  lane?: Maybe<Lanes>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "favoritelanes" */
export type Favoritelanes_Aggregate = {
  __typename?: 'favoritelanes_aggregate';
  aggregate?: Maybe<Favoritelanes_Aggregate_Fields>;
  nodes: Array<Favoritelanes>;
};

export type Favoritelanes_Aggregate_Bool_Exp = {
  count?: InputMaybe<Favoritelanes_Aggregate_Bool_Exp_Count>;
};

export type Favoritelanes_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Favoritelanes_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "favoritelanes" */
export type Favoritelanes_Aggregate_Fields = {
  __typename?: 'favoritelanes_aggregate_fields';
  avg?: Maybe<Favoritelanes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Favoritelanes_Max_Fields>;
  min?: Maybe<Favoritelanes_Min_Fields>;
  stddev?: Maybe<Favoritelanes_Stddev_Fields>;
  stddev_pop?: Maybe<Favoritelanes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Favoritelanes_Stddev_Samp_Fields>;
  sum?: Maybe<Favoritelanes_Sum_Fields>;
  var_pop?: Maybe<Favoritelanes_Var_Pop_Fields>;
  var_samp?: Maybe<Favoritelanes_Var_Samp_Fields>;
  variance?: Maybe<Favoritelanes_Variance_Fields>;
};


/** aggregate fields of "favoritelanes" */
export type Favoritelanes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "favoritelanes" */
export type Favoritelanes_Aggregate_Order_By = {
  avg?: InputMaybe<Favoritelanes_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Favoritelanes_Max_Order_By>;
  min?: InputMaybe<Favoritelanes_Min_Order_By>;
  stddev?: InputMaybe<Favoritelanes_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Favoritelanes_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Favoritelanes_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Favoritelanes_Sum_Order_By>;
  var_pop?: InputMaybe<Favoritelanes_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Favoritelanes_Var_Samp_Order_By>;
  variance?: InputMaybe<Favoritelanes_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "favoritelanes" */
export type Favoritelanes_Arr_Rel_Insert_Input = {
  data: Array<Favoritelanes_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Favoritelanes_On_Conflict>;
};

/** aggregate avg on columns */
export type Favoritelanes_Avg_Fields = {
  __typename?: 'favoritelanes_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "favoritelanes" */
export type Favoritelanes_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "favoritelanes". All fields are combined with a logical 'AND'. */
export type Favoritelanes_Bool_Exp = {
  _and?: InputMaybe<Array<Favoritelanes_Bool_Exp>>;
  _not?: InputMaybe<Favoritelanes_Bool_Exp>;
  _or?: InputMaybe<Array<Favoritelanes_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  lane?: InputMaybe<Lanes_Bool_Exp>;
  lane_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "favoritelanes" */
export enum Favoritelanes_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25661Primary = 'idx_25661_primary'
}

/** input type for incrementing numeric columns in table "favoritelanes" */
export type Favoritelanes_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "favoritelanes" */
export type Favoritelanes_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane?: InputMaybe<Lanes_Obj_Rel_Insert_Input>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Favoritelanes_Max_Fields = {
  __typename?: 'favoritelanes_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "favoritelanes" */
export type Favoritelanes_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Favoritelanes_Min_Fields = {
  __typename?: 'favoritelanes_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "favoritelanes" */
export type Favoritelanes_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "favoritelanes" */
export type Favoritelanes_Mutation_Response = {
  __typename?: 'favoritelanes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Favoritelanes>;
};

/** on_conflict condition type for table "favoritelanes" */
export type Favoritelanes_On_Conflict = {
  constraint: Favoritelanes_Constraint;
  update_columns?: Array<Favoritelanes_Update_Column>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};

/** Ordering options when selecting data from "favoritelanes". */
export type Favoritelanes_Order_By = {
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane?: InputMaybe<Lanes_Order_By>;
  lane_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: favoritelanes */
export type Favoritelanes_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "favoritelanes" */
export enum Favoritelanes_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "favoritelanes" */
export type Favoritelanes_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Favoritelanes_Stddev_Fields = {
  __typename?: 'favoritelanes_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "favoritelanes" */
export type Favoritelanes_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Favoritelanes_Stddev_Pop_Fields = {
  __typename?: 'favoritelanes_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "favoritelanes" */
export type Favoritelanes_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Favoritelanes_Stddev_Samp_Fields = {
  __typename?: 'favoritelanes_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "favoritelanes" */
export type Favoritelanes_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "favoritelanes" */
export type Favoritelanes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Favoritelanes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Favoritelanes_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Favoritelanes_Sum_Fields = {
  __typename?: 'favoritelanes_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "favoritelanes" */
export type Favoritelanes_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** update columns of table "favoritelanes" */
export enum Favoritelanes_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Favoritelanes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Favoritelanes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Favoritelanes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Favoritelanes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Favoritelanes_Var_Pop_Fields = {
  __typename?: 'favoritelanes_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "favoritelanes" */
export type Favoritelanes_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Favoritelanes_Var_Samp_Fields = {
  __typename?: 'favoritelanes_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "favoritelanes" */
export type Favoritelanes_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Favoritelanes_Variance_Fields = {
  __typename?: 'favoritelanes_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "favoritelanes" */
export type Favoritelanes_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "favoritelocations" */
export type Favoritelocations = {
  __typename?: 'favoritelocations';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  location?: Maybe<Locations>;
  location_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "favoritelocations" */
export type Favoritelocations_Aggregate = {
  __typename?: 'favoritelocations_aggregate';
  aggregate?: Maybe<Favoritelocations_Aggregate_Fields>;
  nodes: Array<Favoritelocations>;
};

export type Favoritelocations_Aggregate_Bool_Exp = {
  count?: InputMaybe<Favoritelocations_Aggregate_Bool_Exp_Count>;
};

export type Favoritelocations_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Favoritelocations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "favoritelocations" */
export type Favoritelocations_Aggregate_Fields = {
  __typename?: 'favoritelocations_aggregate_fields';
  avg?: Maybe<Favoritelocations_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Favoritelocations_Max_Fields>;
  min?: Maybe<Favoritelocations_Min_Fields>;
  stddev?: Maybe<Favoritelocations_Stddev_Fields>;
  stddev_pop?: Maybe<Favoritelocations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Favoritelocations_Stddev_Samp_Fields>;
  sum?: Maybe<Favoritelocations_Sum_Fields>;
  var_pop?: Maybe<Favoritelocations_Var_Pop_Fields>;
  var_samp?: Maybe<Favoritelocations_Var_Samp_Fields>;
  variance?: Maybe<Favoritelocations_Variance_Fields>;
};


/** aggregate fields of "favoritelocations" */
export type Favoritelocations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "favoritelocations" */
export type Favoritelocations_Aggregate_Order_By = {
  avg?: InputMaybe<Favoritelocations_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Favoritelocations_Max_Order_By>;
  min?: InputMaybe<Favoritelocations_Min_Order_By>;
  stddev?: InputMaybe<Favoritelocations_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Favoritelocations_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Favoritelocations_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Favoritelocations_Sum_Order_By>;
  var_pop?: InputMaybe<Favoritelocations_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Favoritelocations_Var_Samp_Order_By>;
  variance?: InputMaybe<Favoritelocations_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "favoritelocations" */
export type Favoritelocations_Arr_Rel_Insert_Input = {
  data: Array<Favoritelocations_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Favoritelocations_On_Conflict>;
};

/** aggregate avg on columns */
export type Favoritelocations_Avg_Fields = {
  __typename?: 'favoritelocations_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "favoritelocations" */
export type Favoritelocations_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "favoritelocations". All fields are combined with a logical 'AND'. */
export type Favoritelocations_Bool_Exp = {
  _and?: InputMaybe<Array<Favoritelocations_Bool_Exp>>;
  _not?: InputMaybe<Favoritelocations_Bool_Exp>;
  _or?: InputMaybe<Array<Favoritelocations_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  location?: InputMaybe<Locations_Bool_Exp>;
  location_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "favoritelocations" */
export enum Favoritelocations_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25667Primary = 'idx_25667_primary'
}

/** input type for incrementing numeric columns in table "favoritelocations" */
export type Favoritelocations_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "favoritelocations" */
export type Favoritelocations_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Favoritelocations_Max_Fields = {
  __typename?: 'favoritelocations_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  location_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "favoritelocations" */
export type Favoritelocations_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Favoritelocations_Min_Fields = {
  __typename?: 'favoritelocations_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  location_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "favoritelocations" */
export type Favoritelocations_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "favoritelocations" */
export type Favoritelocations_Mutation_Response = {
  __typename?: 'favoritelocations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Favoritelocations>;
};

/** on_conflict condition type for table "favoritelocations" */
export type Favoritelocations_On_Conflict = {
  constraint: Favoritelocations_Constraint;
  update_columns?: Array<Favoritelocations_Update_Column>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};

/** Ordering options when selecting data from "favoritelocations". */
export type Favoritelocations_Order_By = {
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location?: InputMaybe<Locations_Order_By>;
  location_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: favoritelocations */
export type Favoritelocations_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "favoritelocations" */
export enum Favoritelocations_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "favoritelocations" */
export type Favoritelocations_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Favoritelocations_Stddev_Fields = {
  __typename?: 'favoritelocations_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "favoritelocations" */
export type Favoritelocations_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Favoritelocations_Stddev_Pop_Fields = {
  __typename?: 'favoritelocations_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "favoritelocations" */
export type Favoritelocations_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Favoritelocations_Stddev_Samp_Fields = {
  __typename?: 'favoritelocations_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "favoritelocations" */
export type Favoritelocations_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "favoritelocations" */
export type Favoritelocations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Favoritelocations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Favoritelocations_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Favoritelocations_Sum_Fields = {
  __typename?: 'favoritelocations_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  location_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "favoritelocations" */
export type Favoritelocations_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** update columns of table "favoritelocations" */
export enum Favoritelocations_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Favoritelocations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Favoritelocations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Favoritelocations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Favoritelocations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Favoritelocations_Var_Pop_Fields = {
  __typename?: 'favoritelocations_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "favoritelocations" */
export type Favoritelocations_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Favoritelocations_Var_Samp_Fields = {
  __typename?: 'favoritelocations_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "favoritelocations" */
export type Favoritelocations_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Favoritelocations_Variance_Fields = {
  __typename?: 'favoritelocations_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "favoritelocations" */
export type Favoritelocations_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
};

/** List of application features for determining user access */
export type Features = {
  __typename?: 'features';
  /** Application with which the feature is associated (admin, dealer, driver-portal, driver-app, concierge) */
  application: Scalars['String']['output'];
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Int']['output']>;
  /** Brief description of what the feature includes */
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** Display name used for UIs */
  label: Scalars['String']['output'];
  /** Name of the feature, used as a key to provide features in the UI */
  name: Scalars['String']['output'];
};

/** aggregated selection of "features" */
export type Features_Aggregate = {
  __typename?: 'features_aggregate';
  aggregate?: Maybe<Features_Aggregate_Fields>;
  nodes: Array<Features>;
};

/** aggregate fields of "features" */
export type Features_Aggregate_Fields = {
  __typename?: 'features_aggregate_fields';
  avg?: Maybe<Features_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Features_Max_Fields>;
  min?: Maybe<Features_Min_Fields>;
  stddev?: Maybe<Features_Stddev_Fields>;
  stddev_pop?: Maybe<Features_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Features_Stddev_Samp_Fields>;
  sum?: Maybe<Features_Sum_Fields>;
  var_pop?: Maybe<Features_Var_Pop_Fields>;
  var_samp?: Maybe<Features_Var_Samp_Fields>;
  variance?: Maybe<Features_Variance_Fields>;
};


/** aggregate fields of "features" */
export type Features_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Features_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Features_Avg_Fields = {
  __typename?: 'features_avg_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "features". All fields are combined with a logical 'AND'. */
export type Features_Bool_Exp = {
  _and?: InputMaybe<Array<Features_Bool_Exp>>;
  _not?: InputMaybe<Features_Bool_Exp>;
  _or?: InputMaybe<Array<Features_Bool_Exp>>;
  application?: InputMaybe<String_Comparison_Exp>;
  category_id?: InputMaybe<Int_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  label?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "features" */
export enum Features_Constraint {
  /** unique or primary key constraint on columns "name", "application" */
  FeaturesNameApplicationKey = 'features_name_application_key',
  /** unique or primary key constraint on columns "id" */
  FeaturesPkey = 'features_pkey'
}

/** input type for incrementing numeric columns in table "features" */
export type Features_Inc_Input = {
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "features" */
export type Features_Insert_Input = {
  /** Application with which the feature is associated (admin, dealer, driver-portal, driver-app, concierge) */
  application?: InputMaybe<Scalars['String']['input']>;
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: InputMaybe<Scalars['Int']['input']>;
  /** Brief description of what the feature includes */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Display name used for UIs */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Name of the feature, used as a key to provide features in the UI */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Features_Max_Fields = {
  __typename?: 'features_max_fields';
  /** Application with which the feature is associated (admin, dealer, driver-portal, driver-app, concierge) */
  application?: Maybe<Scalars['String']['output']>;
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Int']['output']>;
  /** Brief description of what the feature includes */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** Display name used for UIs */
  label?: Maybe<Scalars['String']['output']>;
  /** Name of the feature, used as a key to provide features in the UI */
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Features_Min_Fields = {
  __typename?: 'features_min_fields';
  /** Application with which the feature is associated (admin, dealer, driver-portal, driver-app, concierge) */
  application?: Maybe<Scalars['String']['output']>;
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Int']['output']>;
  /** Brief description of what the feature includes */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** Display name used for UIs */
  label?: Maybe<Scalars['String']['output']>;
  /** Name of the feature, used as a key to provide features in the UI */
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "features" */
export type Features_Mutation_Response = {
  __typename?: 'features_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Features>;
};

/** input type for inserting object relation for remote table "features" */
export type Features_Obj_Rel_Insert_Input = {
  data: Features_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Features_On_Conflict>;
};

/** on_conflict condition type for table "features" */
export type Features_On_Conflict = {
  constraint: Features_Constraint;
  update_columns?: Array<Features_Update_Column>;
  where?: InputMaybe<Features_Bool_Exp>;
};

/** Ordering options when selecting data from "features". */
export type Features_Order_By = {
  application?: InputMaybe<Order_By>;
  category_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: features */
export type Features_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "features" */
export enum Features_Select_Column {
  /** column name */
  Application = 'application',
  /** column name */
  CategoryId = 'category_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "features" */
export type Features_Set_Input = {
  /** Application with which the feature is associated (admin, dealer, driver-portal, driver-app, concierge) */
  application?: InputMaybe<Scalars['String']['input']>;
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: InputMaybe<Scalars['Int']['input']>;
  /** Brief description of what the feature includes */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Display name used for UIs */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Name of the feature, used as a key to provide features in the UI */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Features_Stddev_Fields = {
  __typename?: 'features_stddev_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Features_Stddev_Pop_Fields = {
  __typename?: 'features_stddev_pop_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Features_Stddev_Samp_Fields = {
  __typename?: 'features_stddev_samp_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "features" */
export type Features_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Features_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Features_Stream_Cursor_Value_Input = {
  /** Application with which the feature is associated (admin, dealer, driver-portal, driver-app, concierge) */
  application?: InputMaybe<Scalars['String']['input']>;
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: InputMaybe<Scalars['Int']['input']>;
  /** Brief description of what the feature includes */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Display name used for UIs */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Name of the feature, used as a key to provide features in the UI */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Features_Sum_Fields = {
  __typename?: 'features_sum_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "features" */
export enum Features_Update_Column {
  /** column name */
  Application = 'application',
  /** column name */
  CategoryId = 'category_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name'
}

export type Features_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Features_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Features_Set_Input>;
  /** filter the rows which have to be updated */
  where: Features_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Features_Var_Pop_Fields = {
  __typename?: 'features_var_pop_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Features_Var_Samp_Fields = {
  __typename?: 'features_var_samp_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Features_Variance_Fields = {
  __typename?: 'features_variance_fields';
  /** For display purposes. Id of another feature. If null the feature is considered a root feature, if it contains an id it will be grouped by that id in the UI. */
  category_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['float8']['input']>;
  _gt?: InputMaybe<Scalars['float8']['input']>;
  _gte?: InputMaybe<Scalars['float8']['input']>;
  _in?: InputMaybe<Array<Scalars['float8']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['float8']['input']>;
  _lte?: InputMaybe<Scalars['float8']['input']>;
  _neq?: InputMaybe<Scalars['float8']['input']>;
  _nin?: InputMaybe<Array<Scalars['float8']['input']>>;
};

/** Data from this table is sourced from the US Energy Information Administration API */
export type Fuelprices = {
  __typename?: 'fuelprices';
  cost: Scalars['numeric']['output'];
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['bpchar']['output'];
  effective_date: Scalars['timestamptz']['output'];
  eia_region_code: Scalars['bpchar']['output'];
  end_date: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  product: Scalars['bpchar']['output'];
  product_code: Scalars['bpchar']['output'];
  state_code: Scalars['bpchar']['output'];
  unit: Scalars['bpchar']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by: Scalars['bpchar']['output'];
};

/** aggregated selection of "fuelprices" */
export type Fuelprices_Aggregate = {
  __typename?: 'fuelprices_aggregate';
  aggregate?: Maybe<Fuelprices_Aggregate_Fields>;
  nodes: Array<Fuelprices>;
};

/** aggregate fields of "fuelprices" */
export type Fuelprices_Aggregate_Fields = {
  __typename?: 'fuelprices_aggregate_fields';
  avg?: Maybe<Fuelprices_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Fuelprices_Max_Fields>;
  min?: Maybe<Fuelprices_Min_Fields>;
  stddev?: Maybe<Fuelprices_Stddev_Fields>;
  stddev_pop?: Maybe<Fuelprices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Fuelprices_Stddev_Samp_Fields>;
  sum?: Maybe<Fuelprices_Sum_Fields>;
  var_pop?: Maybe<Fuelprices_Var_Pop_Fields>;
  var_samp?: Maybe<Fuelprices_Var_Samp_Fields>;
  variance?: Maybe<Fuelprices_Variance_Fields>;
};


/** aggregate fields of "fuelprices" */
export type Fuelprices_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Fuelprices_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Fuelprices_Avg_Fields = {
  __typename?: 'fuelprices_avg_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "fuelprices". All fields are combined with a logical 'AND'. */
export type Fuelprices_Bool_Exp = {
  _and?: InputMaybe<Array<Fuelprices_Bool_Exp>>;
  _not?: InputMaybe<Fuelprices_Bool_Exp>;
  _or?: InputMaybe<Array<Fuelprices_Bool_Exp>>;
  cost?: InputMaybe<Numeric_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<Bpchar_Comparison_Exp>;
  effective_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  eia_region_code?: InputMaybe<Bpchar_Comparison_Exp>;
  end_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  product?: InputMaybe<Bpchar_Comparison_Exp>;
  product_code?: InputMaybe<Bpchar_Comparison_Exp>;
  state_code?: InputMaybe<Bpchar_Comparison_Exp>;
  unit?: InputMaybe<Bpchar_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<Bpchar_Comparison_Exp>;
};

/** unique or primary key constraints on table "fuelprices" */
export enum Fuelprices_Constraint {
  /** unique or primary key constraint on columns "id" */
  FuelpricesPkey = 'fuelprices_pkey'
}

/** input type for incrementing numeric columns in table "fuelprices" */
export type Fuelprices_Inc_Input = {
  cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "fuelprices" */
export type Fuelprices_Insert_Input = {
  cost?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['bpchar']['input']>;
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  eia_region_code?: InputMaybe<Scalars['bpchar']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  product?: InputMaybe<Scalars['bpchar']['input']>;
  product_code?: InputMaybe<Scalars['bpchar']['input']>;
  state_code?: InputMaybe<Scalars['bpchar']['input']>;
  unit?: InputMaybe<Scalars['bpchar']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['bpchar']['input']>;
};

/** aggregate max on columns */
export type Fuelprices_Max_Fields = {
  __typename?: 'fuelprices_max_fields';
  cost?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['bpchar']['output']>;
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  eia_region_code?: Maybe<Scalars['bpchar']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  product?: Maybe<Scalars['bpchar']['output']>;
  product_code?: Maybe<Scalars['bpchar']['output']>;
  state_code?: Maybe<Scalars['bpchar']['output']>;
  unit?: Maybe<Scalars['bpchar']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['bpchar']['output']>;
};

/** aggregate min on columns */
export type Fuelprices_Min_Fields = {
  __typename?: 'fuelprices_min_fields';
  cost?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['bpchar']['output']>;
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  eia_region_code?: Maybe<Scalars['bpchar']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  product?: Maybe<Scalars['bpchar']['output']>;
  product_code?: Maybe<Scalars['bpchar']['output']>;
  state_code?: Maybe<Scalars['bpchar']['output']>;
  unit?: Maybe<Scalars['bpchar']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['bpchar']['output']>;
};

/** response of any mutation on the table "fuelprices" */
export type Fuelprices_Mutation_Response = {
  __typename?: 'fuelprices_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Fuelprices>;
};

/** on_conflict condition type for table "fuelprices" */
export type Fuelprices_On_Conflict = {
  constraint: Fuelprices_Constraint;
  update_columns?: Array<Fuelprices_Update_Column>;
  where?: InputMaybe<Fuelprices_Bool_Exp>;
};

/** Ordering options when selecting data from "fuelprices". */
export type Fuelprices_Order_By = {
  cost?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  effective_date?: InputMaybe<Order_By>;
  eia_region_code?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product?: InputMaybe<Order_By>;
  product_code?: InputMaybe<Order_By>;
  state_code?: InputMaybe<Order_By>;
  unit?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: fuelprices */
export type Fuelprices_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "fuelprices" */
export enum Fuelprices_Select_Column {
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  EiaRegionCode = 'eia_region_code',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  Product = 'product',
  /** column name */
  ProductCode = 'product_code',
  /** column name */
  StateCode = 'state_code',
  /** column name */
  Unit = 'unit',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "fuelprices" */
export type Fuelprices_Set_Input = {
  cost?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['bpchar']['input']>;
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  eia_region_code?: InputMaybe<Scalars['bpchar']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  product?: InputMaybe<Scalars['bpchar']['input']>;
  product_code?: InputMaybe<Scalars['bpchar']['input']>;
  state_code?: InputMaybe<Scalars['bpchar']['input']>;
  unit?: InputMaybe<Scalars['bpchar']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['bpchar']['input']>;
};

/** aggregate stddev on columns */
export type Fuelprices_Stddev_Fields = {
  __typename?: 'fuelprices_stddev_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Fuelprices_Stddev_Pop_Fields = {
  __typename?: 'fuelprices_stddev_pop_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Fuelprices_Stddev_Samp_Fields = {
  __typename?: 'fuelprices_stddev_samp_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "fuelprices" */
export type Fuelprices_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fuelprices_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fuelprices_Stream_Cursor_Value_Input = {
  cost?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['bpchar']['input']>;
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  eia_region_code?: InputMaybe<Scalars['bpchar']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  product?: InputMaybe<Scalars['bpchar']['input']>;
  product_code?: InputMaybe<Scalars['bpchar']['input']>;
  state_code?: InputMaybe<Scalars['bpchar']['input']>;
  unit?: InputMaybe<Scalars['bpchar']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['bpchar']['input']>;
};

/** aggregate sum on columns */
export type Fuelprices_Sum_Fields = {
  __typename?: 'fuelprices_sum_fields';
  cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "fuelprices" */
export enum Fuelprices_Update_Column {
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  EiaRegionCode = 'eia_region_code',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  Product = 'product',
  /** column name */
  ProductCode = 'product_code',
  /** column name */
  StateCode = 'state_code',
  /** column name */
  Unit = 'unit',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Fuelprices_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Fuelprices_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Fuelprices_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fuelprices_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fuelprices_Var_Pop_Fields = {
  __typename?: 'fuelprices_var_pop_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Fuelprices_Var_Samp_Fields = {
  __typename?: 'fuelprices_var_samp_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Fuelprices_Variance_Fields = {
  __typename?: 'fuelprices_variance_fields';
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

export type Geography_Cast_Exp = {
  geometry?: InputMaybe<Geometry_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type Geography_Comparison_Exp = {
  _cast?: InputMaybe<Geography_Cast_Exp>;
  _eq?: InputMaybe<Scalars['geography']['input']>;
  _gt?: InputMaybe<Scalars['geography']['input']>;
  _gte?: InputMaybe<Scalars['geography']['input']>;
  _in?: InputMaybe<Array<Scalars['geography']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['geography']['input']>;
  _lte?: InputMaybe<Scalars['geography']['input']>;
  _neq?: InputMaybe<Scalars['geography']['input']>;
  _nin?: InputMaybe<Array<Scalars['geography']['input']>>;
  /** is the column within a given distance from the given geography value */
  _st_d_within?: InputMaybe<St_D_Within_Geography_Input>;
  /** does the column spatially intersect the given geography value */
  _st_intersects?: InputMaybe<Scalars['geography']['input']>;
};

export type Geometry_Cast_Exp = {
  geography?: InputMaybe<Geography_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type Geometry_Comparison_Exp = {
  _cast?: InputMaybe<Geometry_Cast_Exp>;
  _eq?: InputMaybe<Scalars['geometry']['input']>;
  _gt?: InputMaybe<Scalars['geometry']['input']>;
  _gte?: InputMaybe<Scalars['geometry']['input']>;
  _in?: InputMaybe<Array<Scalars['geometry']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['geometry']['input']>;
  _lte?: InputMaybe<Scalars['geometry']['input']>;
  _neq?: InputMaybe<Scalars['geometry']['input']>;
  _nin?: InputMaybe<Array<Scalars['geometry']['input']>>;
  /** is the column within a given 3D distance from the given geometry value */
  _st_3d_d_within?: InputMaybe<St_D_Within_Input>;
  /** does the column spatially intersect the given geometry value in 3D */
  _st_3d_intersects?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column contain the given geometry value */
  _st_contains?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column cross the given geometry value */
  _st_crosses?: InputMaybe<Scalars['geometry']['input']>;
  /** is the column within a given distance from the given geometry value */
  _st_d_within?: InputMaybe<St_D_Within_Input>;
  /** is the column equal to given geometry value (directionality is ignored) */
  _st_equals?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column spatially intersect the given geometry value */
  _st_intersects?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  _st_overlaps?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column have atleast one point in common with the given geometry value */
  _st_touches?: InputMaybe<Scalars['geometry']['input']>;
  /** is the column contained in the given geometry value */
  _st_within?: InputMaybe<Scalars['geometry']['input']>;
};

/** columns and relationships of "groupable_moves" */
export type Groupable_Moves = {
  __typename?: 'groupable_moves';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  cancel_reason?: Maybe<Scalars['String']['output']>;
  cancel_requested_at?: Maybe<Scalars['timestamptz']['output']>;
  cancel_status?: Maybe<Scalars['String']['output']>;
  canceled_at?: Maybe<Scalars['timestamptz']['output']>;
  chargeable?: Maybe<Scalars['Boolean']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  config?: Maybe<Scalars['jsonb']['output']>;
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  consumer_name?: Maybe<Scalars['String']['output']>;
  consumer_phone?: Maybe<Scalars['String']['output']>;
  consumer_pickup?: Maybe<Scalars['Boolean']['output']>;
  consumer_type?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_contact?: Maybe<Scalars['String']['output']>;
  deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  delivery_arrived?: Maybe<Scalars['timestamptz']['output']>;
  delivery_started?: Maybe<Scalars['timestamptz']['output']>;
  delivery_stop_id?: Maybe<Scalars['String']['output']>;
  delivery_successful?: Maybe<Scalars['timestamptz']['output']>;
  delivery_template_override?: Maybe<Scalars['String']['output']>;
  delivery_time?: Maybe<Scalars['timestamptz']['output']>;
  delivery_workflow_data?: Maybe<Scalars['jsonb']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  disputed?: Maybe<Scalars['Boolean']['output']>;
  driver_app_version?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  driver_status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  groupable_move?: Maybe<Moves>;
  id?: Maybe<Scalars['bigint']['output']>;
  input_move_deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  input_move_id?: Maybe<Scalars['bigint']['output']>;
  input_move_pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  input_move_ready_by?: Maybe<Scalars['timestamptz']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  manual_flag?: Maybe<Scalars['Boolean']['output']>;
  move_details?: Maybe<Scalars['String']['output']>;
  move_failed?: Maybe<Scalars['timestamptz']['output']>;
  move_type?: Maybe<Scalars['String']['output']>;
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payable?: Maybe<Scalars['Boolean']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_arrived?: Maybe<Scalars['timestamptz']['output']>;
  pickup_started?: Maybe<Scalars['timestamptz']['output']>;
  pickup_stop_id?: Maybe<Scalars['String']['output']>;
  pickup_successful?: Maybe<Scalars['timestamptz']['output']>;
  pickup_template_override?: Maybe<Scalars['String']['output']>;
  pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  pickup_workflow_data?: Maybe<Scalars['jsonb']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  pinnable?: Maybe<Scalars['Boolean']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  ready_by?: Maybe<Scalars['timestamptz']['output']>;
  reference_num?: Maybe<Scalars['String']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  settled?: Maybe<Scalars['Boolean']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  synced_with_tookan?: Maybe<Scalars['timestamptz']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  tookan_relationship_id?: Maybe<Scalars['String']['output']>;
  tracking_link?: Maybe<Scalars['String']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  vehicle_color?: Maybe<Scalars['String']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_image?: Maybe<Scalars['String']['output']>;
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_model?: Maybe<Scalars['String']['output']>;
  vehicle_odometer?: Maybe<Scalars['String']['output']>;
  vehicle_stock?: Maybe<Scalars['String']['output']>;
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  vehicle_year?: Maybe<Scalars['String']['output']>;
  workflow_data?: Maybe<Scalars['jsonb']['output']>;
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "groupable_moves" */
export type Groupable_MovesConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "groupable_moves" */
export type Groupable_MovesDelivery_Workflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "groupable_moves" */
export type Groupable_MovesPickup_Workflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "groupable_moves" */
export type Groupable_MovesWorkflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "groupable_moves" */
export type Groupable_Moves_Aggregate = {
  __typename?: 'groupable_moves_aggregate';
  aggregate?: Maybe<Groupable_Moves_Aggregate_Fields>;
  nodes: Array<Groupable_Moves>;
};

export type Groupable_Moves_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Groupable_Moves_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Groupable_Moves_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Groupable_Moves_Aggregate_Bool_Exp_Count>;
};

export type Groupable_Moves_Aggregate_Bool_Exp_Bool_And = {
  arguments: Groupable_Moves_Select_Column_Groupable_Moves_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Groupable_Moves_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Groupable_Moves_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Groupable_Moves_Select_Column_Groupable_Moves_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Groupable_Moves_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Groupable_Moves_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Groupable_Moves_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "groupable_moves" */
export type Groupable_Moves_Aggregate_Fields = {
  __typename?: 'groupable_moves_aggregate_fields';
  avg?: Maybe<Groupable_Moves_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Groupable_Moves_Max_Fields>;
  min?: Maybe<Groupable_Moves_Min_Fields>;
  stddev?: Maybe<Groupable_Moves_Stddev_Fields>;
  stddev_pop?: Maybe<Groupable_Moves_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Groupable_Moves_Stddev_Samp_Fields>;
  sum?: Maybe<Groupable_Moves_Sum_Fields>;
  var_pop?: Maybe<Groupable_Moves_Var_Pop_Fields>;
  var_samp?: Maybe<Groupable_Moves_Var_Samp_Fields>;
  variance?: Maybe<Groupable_Moves_Variance_Fields>;
};


/** aggregate fields of "groupable_moves" */
export type Groupable_Moves_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "groupable_moves" */
export type Groupable_Moves_Aggregate_Order_By = {
  avg?: InputMaybe<Groupable_Moves_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Groupable_Moves_Max_Order_By>;
  min?: InputMaybe<Groupable_Moves_Min_Order_By>;
  stddev?: InputMaybe<Groupable_Moves_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Groupable_Moves_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Groupable_Moves_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Groupable_Moves_Sum_Order_By>;
  var_pop?: InputMaybe<Groupable_Moves_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Groupable_Moves_Var_Samp_Order_By>;
  variance?: InputMaybe<Groupable_Moves_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "groupable_moves" */
export type Groupable_Moves_Arr_Rel_Insert_Input = {
  data: Array<Groupable_Moves_Insert_Input>;
};

/** aggregate avg on columns */
export type Groupable_Moves_Avg_Fields = {
  __typename?: 'groupable_moves_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "groupable_moves" */
export type Groupable_Moves_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "groupable_moves". All fields are combined with a logical 'AND'. */
export type Groupable_Moves_Bool_Exp = {
  _and?: InputMaybe<Array<Groupable_Moves_Bool_Exp>>;
  _not?: InputMaybe<Groupable_Moves_Bool_Exp>;
  _or?: InputMaybe<Array<Groupable_Moves_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  actual_delivery_mileage?: InputMaybe<Bigint_Comparison_Exp>;
  actual_pickup_mileage?: InputMaybe<Bigint_Comparison_Exp>;
  auto_assign?: InputMaybe<Smallint_Comparison_Exp>;
  cancel_reason?: InputMaybe<String_Comparison_Exp>;
  cancel_requested_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  cancel_status?: InputMaybe<String_Comparison_Exp>;
  canceled_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  chargeable?: InputMaybe<Boolean_Comparison_Exp>;
  class?: InputMaybe<String_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  consumer_at_pickup?: InputMaybe<Smallint_Comparison_Exp>;
  consumer_name?: InputMaybe<String_Comparison_Exp>;
  consumer_phone?: InputMaybe<String_Comparison_Exp>;
  consumer_pickup?: InputMaybe<Boolean_Comparison_Exp>;
  consumer_type?: InputMaybe<String_Comparison_Exp>;
  createdBy?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  dealer_contact?: InputMaybe<String_Comparison_Exp>;
  deliver_by?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_arrived?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_started?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_stop_id?: InputMaybe<String_Comparison_Exp>;
  delivery_successful?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_template_override?: InputMaybe<String_Comparison_Exp>;
  delivery_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  delivery_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  discount_amount?: InputMaybe<Numeric_Comparison_Exp>;
  discount_reason?: InputMaybe<String_Comparison_Exp>;
  dispute_reason?: InputMaybe<String_Comparison_Exp>;
  disputed?: InputMaybe<Boolean_Comparison_Exp>;
  driver_app_version?: InputMaybe<String_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_name?: InputMaybe<String_Comparison_Exp>;
  driver_status?: InputMaybe<String_Comparison_Exp>;
  groupable_move?: InputMaybe<Moves_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  input_move_deliver_by?: InputMaybe<Timestamptz_Comparison_Exp>;
  input_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  input_move_pickup_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  input_move_ready_by?: InputMaybe<Timestamptz_Comparison_Exp>;
  lane_id?: InputMaybe<Bigint_Comparison_Exp>;
  lyft_flag?: InputMaybe<Smallint_Comparison_Exp>;
  lyft_trigger_id?: InputMaybe<Bigint_Comparison_Exp>;
  manual_flag?: InputMaybe<Boolean_Comparison_Exp>;
  move_details?: InputMaybe<String_Comparison_Exp>;
  move_failed?: InputMaybe<Timestamptz_Comparison_Exp>;
  move_type?: InputMaybe<String_Comparison_Exp>;
  parent_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  payable?: InputMaybe<Boolean_Comparison_Exp>;
  payer_id?: InputMaybe<Bigint_Comparison_Exp>;
  pickup_arrived?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_started?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_stop_id?: InputMaybe<String_Comparison_Exp>;
  pickup_successful?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_template_override?: InputMaybe<String_Comparison_Exp>;
  pickup_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  pickup_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  pinnable?: InputMaybe<Boolean_Comparison_Exp>;
  plan_id?: InputMaybe<Bigint_Comparison_Exp>;
  priority?: InputMaybe<Bigint_Comparison_Exp>;
  rate_class_override?: InputMaybe<Smallint_Comparison_Exp>;
  ready_by?: InputMaybe<Timestamptz_Comparison_Exp>;
  reference_num?: InputMaybe<String_Comparison_Exp>;
  return_ride_id?: InputMaybe<Bigint_Comparison_Exp>;
  ride_type?: InputMaybe<String_Comparison_Exp>;
  sequence?: InputMaybe<Bigint_Comparison_Exp>;
  settled?: InputMaybe<Boolean_Comparison_Exp>;
  sla_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  synced_with_tookan?: InputMaybe<Timestamptz_Comparison_Exp>;
  tags?: InputMaybe<String_Comparison_Exp>;
  tookan_relationship_id?: InputMaybe<String_Comparison_Exp>;
  tracking_link?: InputMaybe<String_Comparison_Exp>;
  trip_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedBy?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  vehicle_color?: InputMaybe<String_Comparison_Exp>;
  vehicle_gross_weight_lbs?: InputMaybe<Numeric_Comparison_Exp>;
  vehicle_id?: InputMaybe<Bigint_Comparison_Exp>;
  vehicle_image?: InputMaybe<String_Comparison_Exp>;
  vehicle_make?: InputMaybe<String_Comparison_Exp>;
  vehicle_model?: InputMaybe<String_Comparison_Exp>;
  vehicle_odometer?: InputMaybe<String_Comparison_Exp>;
  vehicle_stock?: InputMaybe<String_Comparison_Exp>;
  vehicle_vin?: InputMaybe<String_Comparison_Exp>;
  vehicle_year?: InputMaybe<String_Comparison_Exp>;
  workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  workflowset_id?: InputMaybe<Int_Comparison_Exp>;
};

/** input type for inserting data into table "groupable_moves" */
export type Groupable_Moves_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  actual_delivery_mileage?: InputMaybe<Scalars['bigint']['input']>;
  actual_pickup_mileage?: InputMaybe<Scalars['bigint']['input']>;
  auto_assign?: InputMaybe<Scalars['smallint']['input']>;
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  cancel_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cancel_status?: InputMaybe<Scalars['String']['input']>;
  canceled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  chargeable?: InputMaybe<Scalars['Boolean']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  consumer_at_pickup?: InputMaybe<Scalars['smallint']['input']>;
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  consumer_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  consumer_type?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_contact?: InputMaybe<Scalars['String']['input']>;
  deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_started?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_stop_id?: InputMaybe<Scalars['String']['input']>;
  delivery_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_template_override?: InputMaybe<Scalars['String']['input']>;
  delivery_time?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  driver_status?: InputMaybe<Scalars['String']['input']>;
  groupable_move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  input_move_deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  input_move_id?: InputMaybe<Scalars['bigint']['input']>;
  input_move_pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  input_move_ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  lyft_flag?: InputMaybe<Scalars['smallint']['input']>;
  lyft_trigger_id?: InputMaybe<Scalars['bigint']['input']>;
  manual_flag?: InputMaybe<Scalars['Boolean']['input']>;
  move_details?: InputMaybe<Scalars['String']['input']>;
  move_failed?: InputMaybe<Scalars['timestamptz']['input']>;
  move_type?: InputMaybe<Scalars['String']['input']>;
  parent_move_id?: InputMaybe<Scalars['bigint']['input']>;
  payable?: InputMaybe<Scalars['Boolean']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_started?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_stop_id?: InputMaybe<Scalars['String']['input']>;
  pickup_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_template_override?: InputMaybe<Scalars['String']['input']>;
  pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  pinnable?: InputMaybe<Scalars['Boolean']['input']>;
  plan_id?: InputMaybe<Scalars['bigint']['input']>;
  priority?: InputMaybe<Scalars['bigint']['input']>;
  rate_class_override?: InputMaybe<Scalars['smallint']['input']>;
  ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_num?: InputMaybe<Scalars['String']['input']>;
  return_ride_id?: InputMaybe<Scalars['bigint']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  settled?: InputMaybe<Scalars['Boolean']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  synced_with_tookan?: InputMaybe<Scalars['timestamptz']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  tookan_relationship_id?: InputMaybe<Scalars['String']['input']>;
  tracking_link?: InputMaybe<Scalars['String']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  vehicle_gross_weight_lbs?: InputMaybe<Scalars['numeric']['input']>;
  vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  vehicle_image?: InputMaybe<Scalars['String']['input']>;
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  vehicle_odometer?: InputMaybe<Scalars['String']['input']>;
  vehicle_stock?: InputMaybe<Scalars['String']['input']>;
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  workflowset_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Groupable_Moves_Max_Fields = {
  __typename?: 'groupable_moves_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  cancel_reason?: Maybe<Scalars['String']['output']>;
  cancel_requested_at?: Maybe<Scalars['timestamptz']['output']>;
  cancel_status?: Maybe<Scalars['String']['output']>;
  canceled_at?: Maybe<Scalars['timestamptz']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  consumer_name?: Maybe<Scalars['String']['output']>;
  consumer_phone?: Maybe<Scalars['String']['output']>;
  consumer_type?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_contact?: Maybe<Scalars['String']['output']>;
  deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  delivery_arrived?: Maybe<Scalars['timestamptz']['output']>;
  delivery_started?: Maybe<Scalars['timestamptz']['output']>;
  delivery_stop_id?: Maybe<Scalars['String']['output']>;
  delivery_successful?: Maybe<Scalars['timestamptz']['output']>;
  delivery_template_override?: Maybe<Scalars['String']['output']>;
  delivery_time?: Maybe<Scalars['timestamptz']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  driver_app_version?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  driver_status?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  input_move_deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  input_move_id?: Maybe<Scalars['bigint']['output']>;
  input_move_pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  input_move_ready_by?: Maybe<Scalars['timestamptz']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  move_details?: Maybe<Scalars['String']['output']>;
  move_failed?: Maybe<Scalars['timestamptz']['output']>;
  move_type?: Maybe<Scalars['String']['output']>;
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_arrived?: Maybe<Scalars['timestamptz']['output']>;
  pickup_started?: Maybe<Scalars['timestamptz']['output']>;
  pickup_stop_id?: Maybe<Scalars['String']['output']>;
  pickup_successful?: Maybe<Scalars['timestamptz']['output']>;
  pickup_template_override?: Maybe<Scalars['String']['output']>;
  pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  ready_by?: Maybe<Scalars['timestamptz']['output']>;
  reference_num?: Maybe<Scalars['String']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  synced_with_tookan?: Maybe<Scalars['timestamptz']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  tookan_relationship_id?: Maybe<Scalars['String']['output']>;
  tracking_link?: Maybe<Scalars['String']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  vehicle_color?: Maybe<Scalars['String']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_image?: Maybe<Scalars['String']['output']>;
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_model?: Maybe<Scalars['String']['output']>;
  vehicle_odometer?: Maybe<Scalars['String']['output']>;
  vehicle_stock?: Maybe<Scalars['String']['output']>;
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  vehicle_year?: Maybe<Scalars['String']['output']>;
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "groupable_moves" */
export type Groupable_Moves_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  cancel_reason?: InputMaybe<Order_By>;
  cancel_requested_at?: InputMaybe<Order_By>;
  cancel_status?: InputMaybe<Order_By>;
  canceled_at?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  consumer_type?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_contact?: InputMaybe<Order_By>;
  deliver_by?: InputMaybe<Order_By>;
  delivery_arrived?: InputMaybe<Order_By>;
  delivery_started?: InputMaybe<Order_By>;
  delivery_stop_id?: InputMaybe<Order_By>;
  delivery_successful?: InputMaybe<Order_By>;
  delivery_template_override?: InputMaybe<Order_By>;
  delivery_time?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  driver_app_version?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  driver_status?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_deliver_by?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  input_move_pickup_time?: InputMaybe<Order_By>;
  input_move_ready_by?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  move_details?: InputMaybe<Order_By>;
  move_failed?: InputMaybe<Order_By>;
  move_type?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_arrived?: InputMaybe<Order_By>;
  pickup_started?: InputMaybe<Order_By>;
  pickup_stop_id?: InputMaybe<Order_By>;
  pickup_successful?: InputMaybe<Order_By>;
  pickup_template_override?: InputMaybe<Order_By>;
  pickup_time?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  ready_by?: InputMaybe<Order_By>;
  reference_num?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  synced_with_tookan?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  tookan_relationship_id?: InputMaybe<Order_By>;
  tracking_link?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  vehicle_image?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_odometer?: InputMaybe<Order_By>;
  vehicle_stock?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Groupable_Moves_Min_Fields = {
  __typename?: 'groupable_moves_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  cancel_reason?: Maybe<Scalars['String']['output']>;
  cancel_requested_at?: Maybe<Scalars['timestamptz']['output']>;
  cancel_status?: Maybe<Scalars['String']['output']>;
  canceled_at?: Maybe<Scalars['timestamptz']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  consumer_name?: Maybe<Scalars['String']['output']>;
  consumer_phone?: Maybe<Scalars['String']['output']>;
  consumer_type?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_contact?: Maybe<Scalars['String']['output']>;
  deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  delivery_arrived?: Maybe<Scalars['timestamptz']['output']>;
  delivery_started?: Maybe<Scalars['timestamptz']['output']>;
  delivery_stop_id?: Maybe<Scalars['String']['output']>;
  delivery_successful?: Maybe<Scalars['timestamptz']['output']>;
  delivery_template_override?: Maybe<Scalars['String']['output']>;
  delivery_time?: Maybe<Scalars['timestamptz']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  driver_app_version?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  driver_status?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  input_move_deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  input_move_id?: Maybe<Scalars['bigint']['output']>;
  input_move_pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  input_move_ready_by?: Maybe<Scalars['timestamptz']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  move_details?: Maybe<Scalars['String']['output']>;
  move_failed?: Maybe<Scalars['timestamptz']['output']>;
  move_type?: Maybe<Scalars['String']['output']>;
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_arrived?: Maybe<Scalars['timestamptz']['output']>;
  pickup_started?: Maybe<Scalars['timestamptz']['output']>;
  pickup_stop_id?: Maybe<Scalars['String']['output']>;
  pickup_successful?: Maybe<Scalars['timestamptz']['output']>;
  pickup_template_override?: Maybe<Scalars['String']['output']>;
  pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  ready_by?: Maybe<Scalars['timestamptz']['output']>;
  reference_num?: Maybe<Scalars['String']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  synced_with_tookan?: Maybe<Scalars['timestamptz']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  tookan_relationship_id?: Maybe<Scalars['String']['output']>;
  tracking_link?: Maybe<Scalars['String']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  vehicle_color?: Maybe<Scalars['String']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_image?: Maybe<Scalars['String']['output']>;
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_model?: Maybe<Scalars['String']['output']>;
  vehicle_odometer?: Maybe<Scalars['String']['output']>;
  vehicle_stock?: Maybe<Scalars['String']['output']>;
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  vehicle_year?: Maybe<Scalars['String']['output']>;
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "groupable_moves" */
export type Groupable_Moves_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  cancel_reason?: InputMaybe<Order_By>;
  cancel_requested_at?: InputMaybe<Order_By>;
  cancel_status?: InputMaybe<Order_By>;
  canceled_at?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  consumer_type?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_contact?: InputMaybe<Order_By>;
  deliver_by?: InputMaybe<Order_By>;
  delivery_arrived?: InputMaybe<Order_By>;
  delivery_started?: InputMaybe<Order_By>;
  delivery_stop_id?: InputMaybe<Order_By>;
  delivery_successful?: InputMaybe<Order_By>;
  delivery_template_override?: InputMaybe<Order_By>;
  delivery_time?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  driver_app_version?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  driver_status?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_deliver_by?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  input_move_pickup_time?: InputMaybe<Order_By>;
  input_move_ready_by?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  move_details?: InputMaybe<Order_By>;
  move_failed?: InputMaybe<Order_By>;
  move_type?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_arrived?: InputMaybe<Order_By>;
  pickup_started?: InputMaybe<Order_By>;
  pickup_stop_id?: InputMaybe<Order_By>;
  pickup_successful?: InputMaybe<Order_By>;
  pickup_template_override?: InputMaybe<Order_By>;
  pickup_time?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  ready_by?: InputMaybe<Order_By>;
  reference_num?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  synced_with_tookan?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  tookan_relationship_id?: InputMaybe<Order_By>;
  tracking_link?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  vehicle_image?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_odometer?: InputMaybe<Order_By>;
  vehicle_stock?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "groupable_moves". */
export type Groupable_Moves_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  cancel_reason?: InputMaybe<Order_By>;
  cancel_requested_at?: InputMaybe<Order_By>;
  cancel_status?: InputMaybe<Order_By>;
  canceled_at?: InputMaybe<Order_By>;
  chargeable?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  consumer_pickup?: InputMaybe<Order_By>;
  consumer_type?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_contact?: InputMaybe<Order_By>;
  deliver_by?: InputMaybe<Order_By>;
  delivery_arrived?: InputMaybe<Order_By>;
  delivery_started?: InputMaybe<Order_By>;
  delivery_stop_id?: InputMaybe<Order_By>;
  delivery_successful?: InputMaybe<Order_By>;
  delivery_template_override?: InputMaybe<Order_By>;
  delivery_time?: InputMaybe<Order_By>;
  delivery_workflow_data?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  disputed?: InputMaybe<Order_By>;
  driver_app_version?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  driver_status?: InputMaybe<Order_By>;
  groupable_move?: InputMaybe<Moves_Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_deliver_by?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  input_move_pickup_time?: InputMaybe<Order_By>;
  input_move_ready_by?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  manual_flag?: InputMaybe<Order_By>;
  move_details?: InputMaybe<Order_By>;
  move_failed?: InputMaybe<Order_By>;
  move_type?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payable?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_arrived?: InputMaybe<Order_By>;
  pickup_started?: InputMaybe<Order_By>;
  pickup_stop_id?: InputMaybe<Order_By>;
  pickup_successful?: InputMaybe<Order_By>;
  pickup_template_override?: InputMaybe<Order_By>;
  pickup_time?: InputMaybe<Order_By>;
  pickup_workflow_data?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  pinnable?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  ready_by?: InputMaybe<Order_By>;
  reference_num?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  settled?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  synced_with_tookan?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  tookan_relationship_id?: InputMaybe<Order_By>;
  tracking_link?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  vehicle_image?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_odometer?: InputMaybe<Order_By>;
  vehicle_stock?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  workflow_data?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** select columns of table "groupable_moves" */
export enum Groupable_Moves_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  ActualDeliveryMileage = 'actual_delivery_mileage',
  /** column name */
  ActualPickupMileage = 'actual_pickup_mileage',
  /** column name */
  AutoAssign = 'auto_assign',
  /** column name */
  CancelReason = 'cancel_reason',
  /** column name */
  CancelRequestedAt = 'cancel_requested_at',
  /** column name */
  CancelStatus = 'cancel_status',
  /** column name */
  CanceledAt = 'canceled_at',
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  Class = 'class',
  /** column name */
  Config = 'config',
  /** column name */
  ConsumerAtPickup = 'consumer_at_pickup',
  /** column name */
  ConsumerName = 'consumer_name',
  /** column name */
  ConsumerPhone = 'consumer_phone',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  ConsumerType = 'consumer_type',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DealerContact = 'dealer_contact',
  /** column name */
  DeliverBy = 'deliver_by',
  /** column name */
  DeliveryArrived = 'delivery_arrived',
  /** column name */
  DeliveryStarted = 'delivery_started',
  /** column name */
  DeliveryStopId = 'delivery_stop_id',
  /** column name */
  DeliverySuccessful = 'delivery_successful',
  /** column name */
  DeliveryTemplateOverride = 'delivery_template_override',
  /** column name */
  DeliveryTime = 'delivery_time',
  /** column name */
  DeliveryWorkflowData = 'delivery_workflow_data',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DriverAppVersion = 'driver_app_version',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  DriverStatus = 'driver_status',
  /** column name */
  Id = 'id',
  /** column name */
  InputMoveDeliverBy = 'input_move_deliver_by',
  /** column name */
  InputMoveId = 'input_move_id',
  /** column name */
  InputMovePickupTime = 'input_move_pickup_time',
  /** column name */
  InputMoveReadyBy = 'input_move_ready_by',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  LyftFlag = 'lyft_flag',
  /** column name */
  LyftTriggerId = 'lyft_trigger_id',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  MoveDetails = 'move_details',
  /** column name */
  MoveFailed = 'move_failed',
  /** column name */
  MoveType = 'move_type',
  /** column name */
  ParentMoveId = 'parent_move_id',
  /** column name */
  Payable = 'payable',
  /** column name */
  PayerId = 'payer_id',
  /** column name */
  PickupArrived = 'pickup_arrived',
  /** column name */
  PickupStarted = 'pickup_started',
  /** column name */
  PickupStopId = 'pickup_stop_id',
  /** column name */
  PickupSuccessful = 'pickup_successful',
  /** column name */
  PickupTemplateOverride = 'pickup_template_override',
  /** column name */
  PickupTime = 'pickup_time',
  /** column name */
  PickupWorkflowData = 'pickup_workflow_data',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  PlanId = 'plan_id',
  /** column name */
  Priority = 'priority',
  /** column name */
  RateClassOverride = 'rate_class_override',
  /** column name */
  ReadyBy = 'ready_by',
  /** column name */
  ReferenceNum = 'reference_num',
  /** column name */
  ReturnRideId = 'return_ride_id',
  /** column name */
  RideType = 'ride_type',
  /** column name */
  Sequence = 'sequence',
  /** column name */
  Settled = 'settled',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Status = 'status',
  /** column name */
  SyncedWithTookan = 'synced_with_tookan',
  /** column name */
  Tags = 'tags',
  /** column name */
  TookanRelationshipId = 'tookan_relationship_id',
  /** column name */
  TrackingLink = 'tracking_link',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleGrossWeightLbs = 'vehicle_gross_weight_lbs',
  /** column name */
  VehicleId = 'vehicle_id',
  /** column name */
  VehicleImage = 'vehicle_image',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleOdometer = 'vehicle_odometer',
  /** column name */
  VehicleStock = 'vehicle_stock',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  WorkflowData = 'workflow_data',
  /** column name */
  WorkflowsetId = 'workflowset_id'
}

/** select "groupable_moves_aggregate_bool_exp_bool_and_arguments_columns" columns of table "groupable_moves" */
export enum Groupable_Moves_Select_Column_Groupable_Moves_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  Payable = 'payable',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  Settled = 'settled'
}

/** select "groupable_moves_aggregate_bool_exp_bool_or_arguments_columns" columns of table "groupable_moves" */
export enum Groupable_Moves_Select_Column_Groupable_Moves_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  Payable = 'payable',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  Settled = 'settled'
}

/** aggregate stddev on columns */
export type Groupable_Moves_Stddev_Fields = {
  __typename?: 'groupable_moves_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "groupable_moves" */
export type Groupable_Moves_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Groupable_Moves_Stddev_Pop_Fields = {
  __typename?: 'groupable_moves_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "groupable_moves" */
export type Groupable_Moves_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Groupable_Moves_Stddev_Samp_Fields = {
  __typename?: 'groupable_moves_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "groupable_moves" */
export type Groupable_Moves_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "groupable_moves" */
export type Groupable_Moves_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Groupable_Moves_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Groupable_Moves_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  actual_delivery_mileage?: InputMaybe<Scalars['bigint']['input']>;
  actual_pickup_mileage?: InputMaybe<Scalars['bigint']['input']>;
  auto_assign?: InputMaybe<Scalars['smallint']['input']>;
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  cancel_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cancel_status?: InputMaybe<Scalars['String']['input']>;
  canceled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  chargeable?: InputMaybe<Scalars['Boolean']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  consumer_at_pickup?: InputMaybe<Scalars['smallint']['input']>;
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  consumer_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  consumer_type?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_contact?: InputMaybe<Scalars['String']['input']>;
  deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_started?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_stop_id?: InputMaybe<Scalars['String']['input']>;
  delivery_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_template_override?: InputMaybe<Scalars['String']['input']>;
  delivery_time?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  driver_status?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  input_move_deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  input_move_id?: InputMaybe<Scalars['bigint']['input']>;
  input_move_pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  input_move_ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  lyft_flag?: InputMaybe<Scalars['smallint']['input']>;
  lyft_trigger_id?: InputMaybe<Scalars['bigint']['input']>;
  manual_flag?: InputMaybe<Scalars['Boolean']['input']>;
  move_details?: InputMaybe<Scalars['String']['input']>;
  move_failed?: InputMaybe<Scalars['timestamptz']['input']>;
  move_type?: InputMaybe<Scalars['String']['input']>;
  parent_move_id?: InputMaybe<Scalars['bigint']['input']>;
  payable?: InputMaybe<Scalars['Boolean']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_started?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_stop_id?: InputMaybe<Scalars['String']['input']>;
  pickup_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_template_override?: InputMaybe<Scalars['String']['input']>;
  pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  pinnable?: InputMaybe<Scalars['Boolean']['input']>;
  plan_id?: InputMaybe<Scalars['bigint']['input']>;
  priority?: InputMaybe<Scalars['bigint']['input']>;
  rate_class_override?: InputMaybe<Scalars['smallint']['input']>;
  ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_num?: InputMaybe<Scalars['String']['input']>;
  return_ride_id?: InputMaybe<Scalars['bigint']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  settled?: InputMaybe<Scalars['Boolean']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  synced_with_tookan?: InputMaybe<Scalars['timestamptz']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  tookan_relationship_id?: InputMaybe<Scalars['String']['input']>;
  tracking_link?: InputMaybe<Scalars['String']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  vehicle_gross_weight_lbs?: InputMaybe<Scalars['numeric']['input']>;
  vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  vehicle_image?: InputMaybe<Scalars['String']['input']>;
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  vehicle_odometer?: InputMaybe<Scalars['String']['input']>;
  vehicle_stock?: InputMaybe<Scalars['String']['input']>;
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  workflowset_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Groupable_Moves_Sum_Fields = {
  __typename?: 'groupable_moves_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  input_move_id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "groupable_moves" */
export type Groupable_Moves_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Groupable_Moves_Var_Pop_Fields = {
  __typename?: 'groupable_moves_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "groupable_moves" */
export type Groupable_Moves_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Groupable_Moves_Var_Samp_Fields = {
  __typename?: 'groupable_moves_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "groupable_moves" */
export type Groupable_Moves_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Groupable_Moves_Variance_Fields = {
  __typename?: 'groupable_moves_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  input_move_id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "groupable_moves" */
export type Groupable_Moves_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  input_move_id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** Each hang tag has a QR code that links to the tags subdomain and this table will track the state of each tag as they are associated with moves, workflows, etc and used within operational processes. */
export type Hangtags = {
  __typename?: 'hangtags';
  batch_id?: Maybe<Scalars['String']['output']>;
  config?: Maybe<Scalars['jsonb']['output']>;
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  driver?: Maybe<Drivers>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  hash_id: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  location?: Maybe<Scalars['geography']['output']>;
  location_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  move?: Maybe<Moves>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  print_layout: Scalars['String']['output'];
  rear_code?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  type: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
  /** An object relationship */
  workflow?: Maybe<Workflows>;
  workflow_data?: Maybe<Scalars['jsonb']['output']>;
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};


/** Each hang tag has a QR code that links to the tags subdomain and this table will track the state of each tag as they are associated with moves, workflows, etc and used within operational processes. */
export type HangtagsConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Each hang tag has a QR code that links to the tags subdomain and this table will track the state of each tag as they are associated with moves, workflows, etc and used within operational processes. */
export type HangtagsWorkflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "hangtags" */
export type Hangtags_Aggregate = {
  __typename?: 'hangtags_aggregate';
  aggregate?: Maybe<Hangtags_Aggregate_Fields>;
  nodes: Array<Hangtags>;
};

export type Hangtags_Aggregate_Bool_Exp = {
  count?: InputMaybe<Hangtags_Aggregate_Bool_Exp_Count>;
};

export type Hangtags_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Hangtags_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Hangtags_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "hangtags" */
export type Hangtags_Aggregate_Fields = {
  __typename?: 'hangtags_aggregate_fields';
  avg?: Maybe<Hangtags_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Hangtags_Max_Fields>;
  min?: Maybe<Hangtags_Min_Fields>;
  stddev?: Maybe<Hangtags_Stddev_Fields>;
  stddev_pop?: Maybe<Hangtags_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Hangtags_Stddev_Samp_Fields>;
  sum?: Maybe<Hangtags_Sum_Fields>;
  var_pop?: Maybe<Hangtags_Var_Pop_Fields>;
  var_samp?: Maybe<Hangtags_Var_Samp_Fields>;
  variance?: Maybe<Hangtags_Variance_Fields>;
};


/** aggregate fields of "hangtags" */
export type Hangtags_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Hangtags_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "hangtags" */
export type Hangtags_Aggregate_Order_By = {
  avg?: InputMaybe<Hangtags_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Hangtags_Max_Order_By>;
  min?: InputMaybe<Hangtags_Min_Order_By>;
  stddev?: InputMaybe<Hangtags_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Hangtags_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Hangtags_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Hangtags_Sum_Order_By>;
  var_pop?: InputMaybe<Hangtags_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Hangtags_Var_Samp_Order_By>;
  variance?: InputMaybe<Hangtags_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Hangtags_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "hangtags" */
export type Hangtags_Arr_Rel_Insert_Input = {
  data: Array<Hangtags_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Hangtags_On_Conflict>;
};

/** aggregate avg on columns */
export type Hangtags_Avg_Fields = {
  __typename?: 'hangtags_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "hangtags" */
export type Hangtags_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "hangtags". All fields are combined with a logical 'AND'. */
export type Hangtags_Bool_Exp = {
  _and?: InputMaybe<Array<Hangtags_Bool_Exp>>;
  _not?: InputMaybe<Hangtags_Bool_Exp>;
  _or?: InputMaybe<Array<Hangtags_Bool_Exp>>;
  batch_id?: InputMaybe<String_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  hash_id?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  location?: InputMaybe<Geography_Comparison_Exp>;
  location_updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  print_layout?: InputMaybe<String_Comparison_Exp>;
  rear_code?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  url?: InputMaybe<String_Comparison_Exp>;
  workflow?: InputMaybe<Workflows_Bool_Exp>;
  workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  workflow_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "hangtags" */
export enum Hangtags_Constraint {
  /** unique or primary key constraint on columns "hash_id" */
  HangtagsHashIdKey = 'hangtags_hash_id_key',
  /** unique or primary key constraint on columns "id" */
  HangtagsPkey = 'hangtags_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Hangtags_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
  workflow_data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Hangtags_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
  workflow_data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Hangtags_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
  workflow_data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "hangtags" */
export type Hangtags_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "hangtags" */
export type Hangtags_Insert_Input = {
  batch_id?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  hash_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  location_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  print_layout?: InputMaybe<Scalars['String']['input']>;
  rear_code?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Hangtags_Max_Fields = {
  __typename?: 'hangtags_max_fields';
  batch_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  hash_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  location_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  print_layout?: Maybe<Scalars['String']['output']>;
  rear_code?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "hangtags" */
export type Hangtags_Max_Order_By = {
  batch_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  hash_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_updated_at?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  print_layout?: InputMaybe<Order_By>;
  rear_code?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Hangtags_Min_Fields = {
  __typename?: 'hangtags_min_fields';
  batch_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  hash_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  location_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  print_layout?: Maybe<Scalars['String']['output']>;
  rear_code?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "hangtags" */
export type Hangtags_Min_Order_By = {
  batch_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  hash_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location_updated_at?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  print_layout?: InputMaybe<Order_By>;
  rear_code?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "hangtags" */
export type Hangtags_Mutation_Response = {
  __typename?: 'hangtags_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Hangtags>;
};

/** on_conflict condition type for table "hangtags" */
export type Hangtags_On_Conflict = {
  constraint: Hangtags_Constraint;
  update_columns?: Array<Hangtags_Update_Column>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};

/** Ordering options when selecting data from "hangtags". */
export type Hangtags_Order_By = {
  batch_id?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  hash_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location?: InputMaybe<Order_By>;
  location_updated_at?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  print_layout?: InputMaybe<Order_By>;
  rear_code?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
  workflow?: InputMaybe<Workflows_Order_By>;
  workflow_data?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: hangtags */
export type Hangtags_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Hangtags_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "hangtags" */
export enum Hangtags_Select_Column {
  /** column name */
  BatchId = 'batch_id',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  HashId = 'hash_id',
  /** column name */
  Id = 'id',
  /** column name */
  Location = 'location',
  /** column name */
  LocationUpdatedAt = 'location_updated_at',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PrintLayout = 'print_layout',
  /** column name */
  RearCode = 'rear_code',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  Url = 'url',
  /** column name */
  WorkflowData = 'workflow_data',
  /** column name */
  WorkflowId = 'workflow_id'
}

/** input type for updating data in table "hangtags" */
export type Hangtags_Set_Input = {
  batch_id?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  hash_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  location_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  print_layout?: InputMaybe<Scalars['String']['input']>;
  rear_code?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Hangtags_Stddev_Fields = {
  __typename?: 'hangtags_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "hangtags" */
export type Hangtags_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Hangtags_Stddev_Pop_Fields = {
  __typename?: 'hangtags_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "hangtags" */
export type Hangtags_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Hangtags_Stddev_Samp_Fields = {
  __typename?: 'hangtags_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "hangtags" */
export type Hangtags_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "hangtags" */
export type Hangtags_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Hangtags_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Hangtags_Stream_Cursor_Value_Input = {
  batch_id?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  hash_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  location_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  print_layout?: InputMaybe<Scalars['String']['input']>;
  rear_code?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Hangtags_Sum_Fields = {
  __typename?: 'hangtags_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "hangtags" */
export type Hangtags_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** update columns of table "hangtags" */
export enum Hangtags_Update_Column {
  /** column name */
  BatchId = 'batch_id',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  HashId = 'hash_id',
  /** column name */
  Id = 'id',
  /** column name */
  Location = 'location',
  /** column name */
  LocationUpdatedAt = 'location_updated_at',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PrintLayout = 'print_layout',
  /** column name */
  RearCode = 'rear_code',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  Url = 'url',
  /** column name */
  WorkflowData = 'workflow_data',
  /** column name */
  WorkflowId = 'workflow_id'
}

export type Hangtags_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Hangtags_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Hangtags_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Hangtags_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Hangtags_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Hangtags_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Hangtags_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Hangtags_Set_Input>;
  /** filter the rows which have to be updated */
  where: Hangtags_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Hangtags_Var_Pop_Fields = {
  __typename?: 'hangtags_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "hangtags" */
export type Hangtags_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Hangtags_Var_Samp_Fields = {
  __typename?: 'hangtags_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "hangtags" */
export type Hangtags_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Hangtags_Variance_Fields = {
  __typename?: 'hangtags_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "hangtags" */
export type Hangtags_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** Table of insurance rates used in different markets. Is related to customers through their raterulegroup */
export type Insurancerates = {
  __typename?: 'insurancerates';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou: Scalars['numeric']['output'];
  /** optional field to name who the insurance carrier is. */
  carrier_name?: Maybe<Scalars['String']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  description: Scalars['String']['output'];
  /** the date that this rate goes into effect */
  effective_date: Scalars['timestamptz']['output'];
  /** the date that this rate expired. This can be null at first since there is no set date for expiration but instead be set only when the rate changes. */
  expiration_date: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  name: Scalars['String']['output'];
  passenger_rate?: Maybe<Scalars['numeric']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['numeric']['output']>;
  /** An array relationship */
  raterulegroups: Array<Raterulegroups>;
  /** An aggregate relationship */
  raterulegroups_aggregate: Raterulegroups_Aggregate;
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** The two letter state code (all caps) */
  state?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil: Scalars['numeric']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** Table of insurance rates used in different markets. Is related to customers through their raterulegroup */
export type InsuranceratesRaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


/** Table of insurance rates used in different markets. Is related to customers through their raterulegroup */
export type InsuranceratesRaterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};

/** aggregated selection of "insurancerates" */
export type Insurancerates_Aggregate = {
  __typename?: 'insurancerates_aggregate';
  aggregate?: Maybe<Insurancerates_Aggregate_Fields>;
  nodes: Array<Insurancerates>;
};

/** aggregate fields of "insurancerates" */
export type Insurancerates_Aggregate_Fields = {
  __typename?: 'insurancerates_aggregate_fields';
  avg?: Maybe<Insurancerates_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Insurancerates_Max_Fields>;
  min?: Maybe<Insurancerates_Min_Fields>;
  stddev?: Maybe<Insurancerates_Stddev_Fields>;
  stddev_pop?: Maybe<Insurancerates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Insurancerates_Stddev_Samp_Fields>;
  sum?: Maybe<Insurancerates_Sum_Fields>;
  var_pop?: Maybe<Insurancerates_Var_Pop_Fields>;
  var_samp?: Maybe<Insurancerates_Var_Samp_Fields>;
  variance?: Maybe<Insurancerates_Variance_Fields>;
};


/** aggregate fields of "insurancerates" */
export type Insurancerates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Insurancerates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Insurancerates_Avg_Fields = {
  __typename?: 'insurancerates_avg_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "insurancerates". All fields are combined with a logical 'AND'. */
export type Insurancerates_Bool_Exp = {
  ACV_coverage_thou?: InputMaybe<Numeric_Comparison_Exp>;
  _and?: InputMaybe<Array<Insurancerates_Bool_Exp>>;
  _not?: InputMaybe<Insurancerates_Bool_Exp>;
  _or?: InputMaybe<Array<Insurancerates_Bool_Exp>>;
  carrier_name?: InputMaybe<String_Comparison_Exp>;
  class_3_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_4_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_5_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_6_rate?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  effective_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiration_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  passenger_rate?: InputMaybe<Numeric_Comparison_Exp>;
  rate?: InputMaybe<Numeric_Comparison_Exp>;
  raterulegroups?: InputMaybe<Raterulegroups_Bool_Exp>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Bool_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  state?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  umbrella_coverage_mil?: InputMaybe<Numeric_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "insurancerates" */
export enum Insurancerates_Constraint {
  /** unique or primary key constraint on columns "id" */
  InsuranceratesPkey = 'insurancerates_pkey'
}

/** input type for incrementing numeric columns in table "insurancerates" */
export type Insurancerates_Inc_Input = {
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  passenger_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "insurancerates" */
export type Insurancerates_Insert_Input = {
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: InputMaybe<Scalars['numeric']['input']>;
  /** optional field to name who the insurance carrier is. */
  carrier_name?: InputMaybe<Scalars['String']['input']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** the date that this rate goes into effect */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** the date that this rate expired. This can be null at first since there is no set date for expiration but instead be set only when the rate changes. */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passenger_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  raterulegroups?: InputMaybe<Raterulegroups_Arr_Rel_Insert_Input>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The two letter state code (all caps) */
  state?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Insurancerates_Max_Fields = {
  __typename?: 'insurancerates_max_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['numeric']['output']>;
  /** optional field to name who the insurance carrier is. */
  carrier_name?: Maybe<Scalars['String']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** the date that this rate goes into effect */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** the date that this rate expired. This can be null at first since there is no set date for expiration but instead be set only when the rate changes. */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  passenger_rate?: Maybe<Scalars['numeric']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['numeric']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** The two letter state code (all caps) */
  state?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Insurancerates_Min_Fields = {
  __typename?: 'insurancerates_min_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['numeric']['output']>;
  /** optional field to name who the insurance carrier is. */
  carrier_name?: Maybe<Scalars['String']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** the date that this rate goes into effect */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** the date that this rate expired. This can be null at first since there is no set date for expiration but instead be set only when the rate changes. */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  passenger_rate?: Maybe<Scalars['numeric']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['numeric']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** The two letter state code (all caps) */
  state?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "insurancerates" */
export type Insurancerates_Mutation_Response = {
  __typename?: 'insurancerates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Insurancerates>;
};

/** input type for inserting object relation for remote table "insurancerates" */
export type Insurancerates_Obj_Rel_Insert_Input = {
  data: Insurancerates_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Insurancerates_On_Conflict>;
};

/** on_conflict condition type for table "insurancerates" */
export type Insurancerates_On_Conflict = {
  constraint: Insurancerates_Constraint;
  update_columns?: Array<Insurancerates_Update_Column>;
  where?: InputMaybe<Insurancerates_Bool_Exp>;
};

/** Ordering options when selecting data from "insurancerates". */
export type Insurancerates_Order_By = {
  ACV_coverage_thou?: InputMaybe<Order_By>;
  carrier_name?: InputMaybe<Order_By>;
  class_3_rate?: InputMaybe<Order_By>;
  class_4_rate?: InputMaybe<Order_By>;
  class_5_rate?: InputMaybe<Order_By>;
  class_6_rate?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  effective_date?: InputMaybe<Order_By>;
  expiration_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  passenger_rate?: InputMaybe<Order_By>;
  rate?: InputMaybe<Order_By>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  umbrella_coverage_mil?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: insurancerates */
export type Insurancerates_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "insurancerates" */
export enum Insurancerates_Select_Column {
  /** column name */
  AcvCoverageThou = 'ACV_coverage_thou',
  /** column name */
  CarrierName = 'carrier_name',
  /** column name */
  Class_3Rate = 'class_3_rate',
  /** column name */
  Class_4Rate = 'class_4_rate',
  /** column name */
  Class_5Rate = 'class_5_rate',
  /** column name */
  Class_6Rate = 'class_6_rate',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PassengerRate = 'passenger_rate',
  /** column name */
  Rate = 'rate',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  State = 'state',
  /** column name */
  Type = 'type',
  /** column name */
  UmbrellaCoverageMil = 'umbrella_coverage_mil',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "insurancerates" */
export type Insurancerates_Set_Input = {
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: InputMaybe<Scalars['numeric']['input']>;
  /** optional field to name who the insurance carrier is. */
  carrier_name?: InputMaybe<Scalars['String']['input']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** the date that this rate goes into effect */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** the date that this rate expired. This can be null at first since there is no set date for expiration but instead be set only when the rate changes. */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passenger_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The two letter state code (all caps) */
  state?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Insurancerates_Stddev_Fields = {
  __typename?: 'insurancerates_stddev_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Insurancerates_Stddev_Pop_Fields = {
  __typename?: 'insurancerates_stddev_pop_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Insurancerates_Stddev_Samp_Fields = {
  __typename?: 'insurancerates_stddev_samp_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "insurancerates" */
export type Insurancerates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Insurancerates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Insurancerates_Stream_Cursor_Value_Input = {
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: InputMaybe<Scalars['numeric']['input']>;
  /** optional field to name who the insurance carrier is. */
  carrier_name?: InputMaybe<Scalars['String']['input']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** the date that this rate goes into effect */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** the date that this rate expired. This can be null at first since there is no set date for expiration but instead be set only when the rate changes. */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passenger_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The two letter state code (all caps) */
  state?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Insurancerates_Sum_Fields = {
  __typename?: 'insurancerates_sum_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  passenger_rate?: Maybe<Scalars['numeric']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['numeric']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "insurancerates" */
export enum Insurancerates_Update_Column {
  /** column name */
  AcvCoverageThou = 'ACV_coverage_thou',
  /** column name */
  CarrierName = 'carrier_name',
  /** column name */
  Class_3Rate = 'class_3_rate',
  /** column name */
  Class_4Rate = 'class_4_rate',
  /** column name */
  Class_5Rate = 'class_5_rate',
  /** column name */
  Class_6Rate = 'class_6_rate',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PassengerRate = 'passenger_rate',
  /** column name */
  Rate = 'rate',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  State = 'state',
  /** column name */
  Type = 'type',
  /** column name */
  UmbrellaCoverageMil = 'umbrella_coverage_mil',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Insurancerates_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Insurancerates_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Insurancerates_Set_Input>;
  /** filter the rows which have to be updated */
  where: Insurancerates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Insurancerates_Var_Pop_Fields = {
  __typename?: 'insurancerates_var_pop_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Insurancerates_Var_Samp_Fields = {
  __typename?: 'insurancerates_var_samp_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Insurancerates_Variance_Fields = {
  __typename?: 'insurancerates_variance_fields';
  /** Level of collision coverage in thousands of dollars */
  ACV_coverage_thou?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** insurance per mile cost for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  passenger_rate?: Maybe<Scalars['Float']['output']>;
  /** the dollar amount applied based on the type. If type == `per mile` then this would be a per mile rate. Covers class_1 and class_2 vehicle weights (up to 10,000 lbs) */
  rate?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  /** Level of umbrella coverage in millions of dollars */
  umbrella_coverage_mil?: Maybe<Scalars['Float']['output']>;
};

/** Each call to listenTo() function with context and results from any event source system */
export type Invocations = {
  __typename?: 'invocations';
  auto_load_modules?: Maybe<Scalars['Boolean']['output']>;
  context_data?: Maybe<Scalars['jsonb']['output']>;
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  error_message?: Maybe<Scalars['String']['output']>;
  error_stack?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  event_executions: Array<Event_Executions>;
  /** An aggregate relationship */
  event_executions_aggregate: Event_Executions_Aggregate;
  event_modules_directory?: Maybe<Scalars['String']['output']>;
  events_detected_count?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  /** An array relationship */
  job_executions: Array<Job_Executions>;
  /** An aggregate relationship */
  job_executions_aggregate: Job_Executions_Aggregate;
  source_event_id?: Maybe<Scalars['uuid']['output']>;
  source_event_payload: Scalars['jsonb']['output'];
  source_event_time?: Maybe<Scalars['timestamptz']['output']>;
  source_function: Scalars['String']['output'];
  source_operation?: Maybe<Scalars['String']['output']>;
  source_system?: Maybe<Scalars['String']['output']>;
  source_table?: Maybe<Scalars['String']['output']>;
  source_user_email?: Maybe<Scalars['String']['output']>;
  source_user_role?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  total_duration_ms?: Maybe<Scalars['Int']['output']>;
  total_jobs_failed?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Int']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** Each call to listenTo() function with context and results from any event source system */
export type InvocationsContext_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Each call to listenTo() function with context and results from any event source system */
export type InvocationsEvent_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Event_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Event_Executions_Order_By>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


/** Each call to listenTo() function with context and results from any event source system */
export type InvocationsEvent_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Event_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Event_Executions_Order_By>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


/** Each call to listenTo() function with context and results from any event source system */
export type InvocationsJob_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


/** Each call to listenTo() function with context and results from any event source system */
export type InvocationsJob_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


/** Each call to listenTo() function with context and results from any event source system */
export type InvocationsSource_Event_PayloadArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "invocations" */
export type Invocations_Aggregate = {
  __typename?: 'invocations_aggregate';
  aggregate?: Maybe<Invocations_Aggregate_Fields>;
  nodes: Array<Invocations>;
};

/** aggregate fields of "invocations" */
export type Invocations_Aggregate_Fields = {
  __typename?: 'invocations_aggregate_fields';
  avg?: Maybe<Invocations_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Invocations_Max_Fields>;
  min?: Maybe<Invocations_Min_Fields>;
  stddev?: Maybe<Invocations_Stddev_Fields>;
  stddev_pop?: Maybe<Invocations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Invocations_Stddev_Samp_Fields>;
  sum?: Maybe<Invocations_Sum_Fields>;
  var_pop?: Maybe<Invocations_Var_Pop_Fields>;
  var_samp?: Maybe<Invocations_Var_Samp_Fields>;
  variance?: Maybe<Invocations_Variance_Fields>;
};


/** aggregate fields of "invocations" */
export type Invocations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Invocations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Invocations_Append_Input = {
  context_data?: InputMaybe<Scalars['jsonb']['input']>;
  source_event_payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Invocations_Avg_Fields = {
  __typename?: 'invocations_avg_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "invocations". All fields are combined with a logical 'AND'. */
export type Invocations_Bool_Exp = {
  _and?: InputMaybe<Array<Invocations_Bool_Exp>>;
  _not?: InputMaybe<Invocations_Bool_Exp>;
  _or?: InputMaybe<Array<Invocations_Bool_Exp>>;
  auto_load_modules?: InputMaybe<Boolean_Comparison_Exp>;
  context_data?: InputMaybe<Jsonb_Comparison_Exp>;
  correlation_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  error_message?: InputMaybe<String_Comparison_Exp>;
  error_stack?: InputMaybe<String_Comparison_Exp>;
  event_executions?: InputMaybe<Event_Executions_Bool_Exp>;
  event_executions_aggregate?: InputMaybe<Event_Executions_Aggregate_Bool_Exp>;
  event_modules_directory?: InputMaybe<String_Comparison_Exp>;
  events_detected_count?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  job_executions?: InputMaybe<Job_Executions_Bool_Exp>;
  job_executions_aggregate?: InputMaybe<Job_Executions_Aggregate_Bool_Exp>;
  source_event_id?: InputMaybe<Uuid_Comparison_Exp>;
  source_event_payload?: InputMaybe<Jsonb_Comparison_Exp>;
  source_event_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  source_function?: InputMaybe<String_Comparison_Exp>;
  source_operation?: InputMaybe<String_Comparison_Exp>;
  source_system?: InputMaybe<String_Comparison_Exp>;
  source_table?: InputMaybe<String_Comparison_Exp>;
  source_user_email?: InputMaybe<String_Comparison_Exp>;
  source_user_role?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  total_duration_ms?: InputMaybe<Int_Comparison_Exp>;
  total_jobs_failed?: InputMaybe<Int_Comparison_Exp>;
  total_jobs_run?: InputMaybe<Int_Comparison_Exp>;
  total_jobs_succeeded?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "invocations" */
export enum Invocations_Constraint {
  /** unique or primary key constraint on columns "id" */
  InvocationsPkey = 'invocations_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Invocations_Delete_At_Path_Input = {
  context_data?: InputMaybe<Array<Scalars['String']['input']>>;
  source_event_payload?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Invocations_Delete_Elem_Input = {
  context_data?: InputMaybe<Scalars['Int']['input']>;
  source_event_payload?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Invocations_Delete_Key_Input = {
  context_data?: InputMaybe<Scalars['String']['input']>;
  source_event_payload?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "invocations" */
export type Invocations_Inc_Input = {
  events_detected_count?: InputMaybe<Scalars['Int']['input']>;
  total_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "invocations" */
export type Invocations_Insert_Input = {
  auto_load_modules?: InputMaybe<Scalars['Boolean']['input']>;
  context_data?: InputMaybe<Scalars['jsonb']['input']>;
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  error_message?: InputMaybe<Scalars['String']['input']>;
  error_stack?: InputMaybe<Scalars['String']['input']>;
  event_executions?: InputMaybe<Event_Executions_Arr_Rel_Insert_Input>;
  event_modules_directory?: InputMaybe<Scalars['String']['input']>;
  events_detected_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  job_executions?: InputMaybe<Job_Executions_Arr_Rel_Insert_Input>;
  source_event_id?: InputMaybe<Scalars['uuid']['input']>;
  source_event_payload?: InputMaybe<Scalars['jsonb']['input']>;
  source_event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  source_function?: InputMaybe<Scalars['String']['input']>;
  source_operation?: InputMaybe<Scalars['String']['input']>;
  source_system?: InputMaybe<Scalars['String']['input']>;
  source_table?: InputMaybe<Scalars['String']['input']>;
  source_user_email?: InputMaybe<Scalars['String']['input']>;
  source_user_role?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  total_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Invocations_Max_Fields = {
  __typename?: 'invocations_max_fields';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  error_message?: Maybe<Scalars['String']['output']>;
  error_stack?: Maybe<Scalars['String']['output']>;
  event_modules_directory?: Maybe<Scalars['String']['output']>;
  events_detected_count?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  source_event_id?: Maybe<Scalars['uuid']['output']>;
  source_event_time?: Maybe<Scalars['timestamptz']['output']>;
  source_function?: Maybe<Scalars['String']['output']>;
  source_operation?: Maybe<Scalars['String']['output']>;
  source_system?: Maybe<Scalars['String']['output']>;
  source_table?: Maybe<Scalars['String']['output']>;
  source_user_email?: Maybe<Scalars['String']['output']>;
  source_user_role?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  total_duration_ms?: Maybe<Scalars['Int']['output']>;
  total_jobs_failed?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Invocations_Min_Fields = {
  __typename?: 'invocations_min_fields';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  error_message?: Maybe<Scalars['String']['output']>;
  error_stack?: Maybe<Scalars['String']['output']>;
  event_modules_directory?: Maybe<Scalars['String']['output']>;
  events_detected_count?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  source_event_id?: Maybe<Scalars['uuid']['output']>;
  source_event_time?: Maybe<Scalars['timestamptz']['output']>;
  source_function?: Maybe<Scalars['String']['output']>;
  source_operation?: Maybe<Scalars['String']['output']>;
  source_system?: Maybe<Scalars['String']['output']>;
  source_table?: Maybe<Scalars['String']['output']>;
  source_user_email?: Maybe<Scalars['String']['output']>;
  source_user_role?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  total_duration_ms?: Maybe<Scalars['Int']['output']>;
  total_jobs_failed?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "invocations" */
export type Invocations_Mutation_Response = {
  __typename?: 'invocations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Invocations>;
};

/** input type for inserting object relation for remote table "invocations" */
export type Invocations_Obj_Rel_Insert_Input = {
  data: Invocations_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Invocations_On_Conflict>;
};

/** on_conflict condition type for table "invocations" */
export type Invocations_On_Conflict = {
  constraint: Invocations_Constraint;
  update_columns?: Array<Invocations_Update_Column>;
  where?: InputMaybe<Invocations_Bool_Exp>;
};

/** Ordering options when selecting data from "invocations". */
export type Invocations_Order_By = {
  auto_load_modules?: InputMaybe<Order_By>;
  context_data?: InputMaybe<Order_By>;
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  error_message?: InputMaybe<Order_By>;
  error_stack?: InputMaybe<Order_By>;
  event_executions_aggregate?: InputMaybe<Event_Executions_Aggregate_Order_By>;
  event_modules_directory?: InputMaybe<Order_By>;
  events_detected_count?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  job_executions_aggregate?: InputMaybe<Job_Executions_Aggregate_Order_By>;
  source_event_id?: InputMaybe<Order_By>;
  source_event_payload?: InputMaybe<Order_By>;
  source_event_time?: InputMaybe<Order_By>;
  source_function?: InputMaybe<Order_By>;
  source_operation?: InputMaybe<Order_By>;
  source_system?: InputMaybe<Order_By>;
  source_table?: InputMaybe<Order_By>;
  source_user_email?: InputMaybe<Order_By>;
  source_user_role?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  total_duration_ms?: InputMaybe<Order_By>;
  total_jobs_failed?: InputMaybe<Order_By>;
  total_jobs_run?: InputMaybe<Order_By>;
  total_jobs_succeeded?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: invocations */
export type Invocations_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Invocations_Prepend_Input = {
  context_data?: InputMaybe<Scalars['jsonb']['input']>;
  source_event_payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "invocations" */
export enum Invocations_Select_Column {
  /** column name */
  AutoLoadModules = 'auto_load_modules',
  /** column name */
  ContextData = 'context_data',
  /** column name */
  CorrelationId = 'correlation_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ErrorMessage = 'error_message',
  /** column name */
  ErrorStack = 'error_stack',
  /** column name */
  EventModulesDirectory = 'event_modules_directory',
  /** column name */
  EventsDetectedCount = 'events_detected_count',
  /** column name */
  Id = 'id',
  /** column name */
  SourceEventId = 'source_event_id',
  /** column name */
  SourceEventPayload = 'source_event_payload',
  /** column name */
  SourceEventTime = 'source_event_time',
  /** column name */
  SourceFunction = 'source_function',
  /** column name */
  SourceOperation = 'source_operation',
  /** column name */
  SourceSystem = 'source_system',
  /** column name */
  SourceTable = 'source_table',
  /** column name */
  SourceUserEmail = 'source_user_email',
  /** column name */
  SourceUserRole = 'source_user_role',
  /** column name */
  Status = 'status',
  /** column name */
  TotalDurationMs = 'total_duration_ms',
  /** column name */
  TotalJobsFailed = 'total_jobs_failed',
  /** column name */
  TotalJobsRun = 'total_jobs_run',
  /** column name */
  TotalJobsSucceeded = 'total_jobs_succeeded',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "invocations" */
export type Invocations_Set_Input = {
  auto_load_modules?: InputMaybe<Scalars['Boolean']['input']>;
  context_data?: InputMaybe<Scalars['jsonb']['input']>;
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  error_message?: InputMaybe<Scalars['String']['input']>;
  error_stack?: InputMaybe<Scalars['String']['input']>;
  event_modules_directory?: InputMaybe<Scalars['String']['input']>;
  events_detected_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  source_event_id?: InputMaybe<Scalars['uuid']['input']>;
  source_event_payload?: InputMaybe<Scalars['jsonb']['input']>;
  source_event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  source_function?: InputMaybe<Scalars['String']['input']>;
  source_operation?: InputMaybe<Scalars['String']['input']>;
  source_system?: InputMaybe<Scalars['String']['input']>;
  source_table?: InputMaybe<Scalars['String']['input']>;
  source_user_email?: InputMaybe<Scalars['String']['input']>;
  source_user_role?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  total_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Invocations_Stddev_Fields = {
  __typename?: 'invocations_stddev_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Invocations_Stddev_Pop_Fields = {
  __typename?: 'invocations_stddev_pop_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Invocations_Stddev_Samp_Fields = {
  __typename?: 'invocations_stddev_samp_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "invocations" */
export type Invocations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Invocations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Invocations_Stream_Cursor_Value_Input = {
  auto_load_modules?: InputMaybe<Scalars['Boolean']['input']>;
  context_data?: InputMaybe<Scalars['jsonb']['input']>;
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  error_message?: InputMaybe<Scalars['String']['input']>;
  error_stack?: InputMaybe<Scalars['String']['input']>;
  event_modules_directory?: InputMaybe<Scalars['String']['input']>;
  events_detected_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  source_event_id?: InputMaybe<Scalars['uuid']['input']>;
  source_event_payload?: InputMaybe<Scalars['jsonb']['input']>;
  source_event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  source_function?: InputMaybe<Scalars['String']['input']>;
  source_operation?: InputMaybe<Scalars['String']['input']>;
  source_system?: InputMaybe<Scalars['String']['input']>;
  source_table?: InputMaybe<Scalars['String']['input']>;
  source_user_email?: InputMaybe<Scalars['String']['input']>;
  source_user_role?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  total_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_failed?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_succeeded?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Invocations_Sum_Fields = {
  __typename?: 'invocations_sum_fields';
  events_detected_count?: Maybe<Scalars['Int']['output']>;
  total_duration_ms?: Maybe<Scalars['Int']['output']>;
  total_jobs_failed?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "invocations" */
export enum Invocations_Update_Column {
  /** column name */
  AutoLoadModules = 'auto_load_modules',
  /** column name */
  ContextData = 'context_data',
  /** column name */
  CorrelationId = 'correlation_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ErrorMessage = 'error_message',
  /** column name */
  ErrorStack = 'error_stack',
  /** column name */
  EventModulesDirectory = 'event_modules_directory',
  /** column name */
  EventsDetectedCount = 'events_detected_count',
  /** column name */
  Id = 'id',
  /** column name */
  SourceEventId = 'source_event_id',
  /** column name */
  SourceEventPayload = 'source_event_payload',
  /** column name */
  SourceEventTime = 'source_event_time',
  /** column name */
  SourceFunction = 'source_function',
  /** column name */
  SourceOperation = 'source_operation',
  /** column name */
  SourceSystem = 'source_system',
  /** column name */
  SourceTable = 'source_table',
  /** column name */
  SourceUserEmail = 'source_user_email',
  /** column name */
  SourceUserRole = 'source_user_role',
  /** column name */
  Status = 'status',
  /** column name */
  TotalDurationMs = 'total_duration_ms',
  /** column name */
  TotalJobsFailed = 'total_jobs_failed',
  /** column name */
  TotalJobsRun = 'total_jobs_run',
  /** column name */
  TotalJobsSucceeded = 'total_jobs_succeeded',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Invocations_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Invocations_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Invocations_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Invocations_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Invocations_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Invocations_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Invocations_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Invocations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Invocations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Invocations_Var_Pop_Fields = {
  __typename?: 'invocations_var_pop_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Invocations_Var_Samp_Fields = {
  __typename?: 'invocations_var_samp_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Invocations_Variance_Fields = {
  __typename?: 'invocations_variance_fields';
  events_detected_count?: Maybe<Scalars['Float']['output']>;
  total_duration_ms?: Maybe<Scalars['Float']['output']>;
  total_jobs_failed?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
  total_jobs_succeeded?: Maybe<Scalars['Float']['output']>;
};

/** Each async job executed for detected events */
export type Job_Executions = {
  __typename?: 'job_executions';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  duration_ms?: Maybe<Scalars['Int']['output']>;
  error_message?: Maybe<Scalars['String']['output']>;
  error_stack?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  event_execution: Event_Executions;
  event_execution_id: Scalars['uuid']['output'];
  id: Scalars['uuid']['output'];
  /** An object relationship */
  invocation: Invocations;
  invocation_id: Scalars['uuid']['output'];
  job_function_name?: Maybe<Scalars['String']['output']>;
  job_name: Scalars['String']['output'];
  job_options?: Maybe<Scalars['jsonb']['output']>;
  result?: Maybe<Scalars['jsonb']['output']>;
  status: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** Each async job executed for detected events */
export type Job_ExecutionsJob_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Each async job executed for detected events */
export type Job_ExecutionsResultArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "job_executions" */
export type Job_Executions_Aggregate = {
  __typename?: 'job_executions_aggregate';
  aggregate?: Maybe<Job_Executions_Aggregate_Fields>;
  nodes: Array<Job_Executions>;
};

export type Job_Executions_Aggregate_Bool_Exp = {
  count?: InputMaybe<Job_Executions_Aggregate_Bool_Exp_Count>;
};

export type Job_Executions_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Job_Executions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Job_Executions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "job_executions" */
export type Job_Executions_Aggregate_Fields = {
  __typename?: 'job_executions_aggregate_fields';
  avg?: Maybe<Job_Executions_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Job_Executions_Max_Fields>;
  min?: Maybe<Job_Executions_Min_Fields>;
  stddev?: Maybe<Job_Executions_Stddev_Fields>;
  stddev_pop?: Maybe<Job_Executions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Job_Executions_Stddev_Samp_Fields>;
  sum?: Maybe<Job_Executions_Sum_Fields>;
  var_pop?: Maybe<Job_Executions_Var_Pop_Fields>;
  var_samp?: Maybe<Job_Executions_Var_Samp_Fields>;
  variance?: Maybe<Job_Executions_Variance_Fields>;
};


/** aggregate fields of "job_executions" */
export type Job_Executions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Job_Executions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "job_executions" */
export type Job_Executions_Aggregate_Order_By = {
  avg?: InputMaybe<Job_Executions_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Job_Executions_Max_Order_By>;
  min?: InputMaybe<Job_Executions_Min_Order_By>;
  stddev?: InputMaybe<Job_Executions_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Job_Executions_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Job_Executions_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Job_Executions_Sum_Order_By>;
  var_pop?: InputMaybe<Job_Executions_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Job_Executions_Var_Samp_Order_By>;
  variance?: InputMaybe<Job_Executions_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Executions_Append_Input = {
  job_options?: InputMaybe<Scalars['jsonb']['input']>;
  result?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "job_executions" */
export type Job_Executions_Arr_Rel_Insert_Input = {
  data: Array<Job_Executions_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Job_Executions_On_Conflict>;
};

/** aggregate avg on columns */
export type Job_Executions_Avg_Fields = {
  __typename?: 'job_executions_avg_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "job_executions" */
export type Job_Executions_Avg_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "job_executions". All fields are combined with a logical 'AND'. */
export type Job_Executions_Bool_Exp = {
  _and?: InputMaybe<Array<Job_Executions_Bool_Exp>>;
  _not?: InputMaybe<Job_Executions_Bool_Exp>;
  _or?: InputMaybe<Array<Job_Executions_Bool_Exp>>;
  correlation_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  duration_ms?: InputMaybe<Int_Comparison_Exp>;
  error_message?: InputMaybe<String_Comparison_Exp>;
  error_stack?: InputMaybe<String_Comparison_Exp>;
  event_execution?: InputMaybe<Event_Executions_Bool_Exp>;
  event_execution_id?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  invocation?: InputMaybe<Invocations_Bool_Exp>;
  invocation_id?: InputMaybe<Uuid_Comparison_Exp>;
  job_function_name?: InputMaybe<String_Comparison_Exp>;
  job_name?: InputMaybe<String_Comparison_Exp>;
  job_options?: InputMaybe<Jsonb_Comparison_Exp>;
  result?: InputMaybe<Jsonb_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_executions" */
export enum Job_Executions_Constraint {
  /** unique or primary key constraint on columns "id" */
  JobExecutionsPkey = 'job_executions_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Executions_Delete_At_Path_Input = {
  job_options?: InputMaybe<Array<Scalars['String']['input']>>;
  result?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Executions_Delete_Elem_Input = {
  job_options?: InputMaybe<Scalars['Int']['input']>;
  result?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Executions_Delete_Key_Input = {
  job_options?: InputMaybe<Scalars['String']['input']>;
  result?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "job_executions" */
export type Job_Executions_Inc_Input = {
  duration_ms?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "job_executions" */
export type Job_Executions_Insert_Input = {
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  duration_ms?: InputMaybe<Scalars['Int']['input']>;
  error_message?: InputMaybe<Scalars['String']['input']>;
  error_stack?: InputMaybe<Scalars['String']['input']>;
  event_execution?: InputMaybe<Event_Executions_Obj_Rel_Insert_Input>;
  event_execution_id?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invocation?: InputMaybe<Invocations_Obj_Rel_Insert_Input>;
  invocation_id?: InputMaybe<Scalars['uuid']['input']>;
  job_function_name?: InputMaybe<Scalars['String']['input']>;
  job_name?: InputMaybe<Scalars['String']['input']>;
  job_options?: InputMaybe<Scalars['jsonb']['input']>;
  result?: InputMaybe<Scalars['jsonb']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Job_Executions_Max_Fields = {
  __typename?: 'job_executions_max_fields';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  duration_ms?: Maybe<Scalars['Int']['output']>;
  error_message?: Maybe<Scalars['String']['output']>;
  error_stack?: Maybe<Scalars['String']['output']>;
  event_execution_id?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invocation_id?: Maybe<Scalars['uuid']['output']>;
  job_function_name?: Maybe<Scalars['String']['output']>;
  job_name?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "job_executions" */
export type Job_Executions_Max_Order_By = {
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  duration_ms?: InputMaybe<Order_By>;
  error_message?: InputMaybe<Order_By>;
  error_stack?: InputMaybe<Order_By>;
  event_execution_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invocation_id?: InputMaybe<Order_By>;
  job_function_name?: InputMaybe<Order_By>;
  job_name?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Executions_Min_Fields = {
  __typename?: 'job_executions_min_fields';
  correlation_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  duration_ms?: Maybe<Scalars['Int']['output']>;
  error_message?: Maybe<Scalars['String']['output']>;
  error_stack?: Maybe<Scalars['String']['output']>;
  event_execution_id?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invocation_id?: Maybe<Scalars['uuid']['output']>;
  job_function_name?: Maybe<Scalars['String']['output']>;
  job_name?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "job_executions" */
export type Job_Executions_Min_Order_By = {
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  duration_ms?: InputMaybe<Order_By>;
  error_message?: InputMaybe<Order_By>;
  error_stack?: InputMaybe<Order_By>;
  event_execution_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invocation_id?: InputMaybe<Order_By>;
  job_function_name?: InputMaybe<Order_By>;
  job_name?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "job_executions" */
export type Job_Executions_Mutation_Response = {
  __typename?: 'job_executions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Job_Executions>;
};

/** on_conflict condition type for table "job_executions" */
export type Job_Executions_On_Conflict = {
  constraint: Job_Executions_Constraint;
  update_columns?: Array<Job_Executions_Update_Column>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};

/** Ordering options when selecting data from "job_executions". */
export type Job_Executions_Order_By = {
  correlation_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  duration_ms?: InputMaybe<Order_By>;
  error_message?: InputMaybe<Order_By>;
  error_stack?: InputMaybe<Order_By>;
  event_execution?: InputMaybe<Event_Executions_Order_By>;
  event_execution_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invocation?: InputMaybe<Invocations_Order_By>;
  invocation_id?: InputMaybe<Order_By>;
  job_function_name?: InputMaybe<Order_By>;
  job_name?: InputMaybe<Order_By>;
  job_options?: InputMaybe<Order_By>;
  result?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: job_executions */
export type Job_Executions_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Executions_Prepend_Input = {
  job_options?: InputMaybe<Scalars['jsonb']['input']>;
  result?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "job_executions" */
export enum Job_Executions_Select_Column {
  /** column name */
  CorrelationId = 'correlation_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMs = 'duration_ms',
  /** column name */
  ErrorMessage = 'error_message',
  /** column name */
  ErrorStack = 'error_stack',
  /** column name */
  EventExecutionId = 'event_execution_id',
  /** column name */
  Id = 'id',
  /** column name */
  InvocationId = 'invocation_id',
  /** column name */
  JobFunctionName = 'job_function_name',
  /** column name */
  JobName = 'job_name',
  /** column name */
  JobOptions = 'job_options',
  /** column name */
  Result = 'result',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_executions" */
export type Job_Executions_Set_Input = {
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  duration_ms?: InputMaybe<Scalars['Int']['input']>;
  error_message?: InputMaybe<Scalars['String']['input']>;
  error_stack?: InputMaybe<Scalars['String']['input']>;
  event_execution_id?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invocation_id?: InputMaybe<Scalars['uuid']['input']>;
  job_function_name?: InputMaybe<Scalars['String']['input']>;
  job_name?: InputMaybe<Scalars['String']['input']>;
  job_options?: InputMaybe<Scalars['jsonb']['input']>;
  result?: InputMaybe<Scalars['jsonb']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Job_Executions_Stddev_Fields = {
  __typename?: 'job_executions_stddev_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "job_executions" */
export type Job_Executions_Stddev_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Job_Executions_Stddev_Pop_Fields = {
  __typename?: 'job_executions_stddev_pop_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "job_executions" */
export type Job_Executions_Stddev_Pop_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Job_Executions_Stddev_Samp_Fields = {
  __typename?: 'job_executions_stddev_samp_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "job_executions" */
export type Job_Executions_Stddev_Samp_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "job_executions" */
export type Job_Executions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Job_Executions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Job_Executions_Stream_Cursor_Value_Input = {
  correlation_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  duration_ms?: InputMaybe<Scalars['Int']['input']>;
  error_message?: InputMaybe<Scalars['String']['input']>;
  error_stack?: InputMaybe<Scalars['String']['input']>;
  event_execution_id?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invocation_id?: InputMaybe<Scalars['uuid']['input']>;
  job_function_name?: InputMaybe<Scalars['String']['input']>;
  job_name?: InputMaybe<Scalars['String']['input']>;
  job_options?: InputMaybe<Scalars['jsonb']['input']>;
  result?: InputMaybe<Scalars['jsonb']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Job_Executions_Sum_Fields = {
  __typename?: 'job_executions_sum_fields';
  duration_ms?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "job_executions" */
export type Job_Executions_Sum_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** update columns of table "job_executions" */
export enum Job_Executions_Update_Column {
  /** column name */
  CorrelationId = 'correlation_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMs = 'duration_ms',
  /** column name */
  ErrorMessage = 'error_message',
  /** column name */
  ErrorStack = 'error_stack',
  /** column name */
  EventExecutionId = 'event_execution_id',
  /** column name */
  Id = 'id',
  /** column name */
  InvocationId = 'invocation_id',
  /** column name */
  JobFunctionName = 'job_function_name',
  /** column name */
  JobName = 'job_name',
  /** column name */
  JobOptions = 'job_options',
  /** column name */
  Result = 'result',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Job_Executions_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Job_Executions_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Job_Executions_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Job_Executions_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Job_Executions_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Job_Executions_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Job_Executions_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Job_Executions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Job_Executions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Job_Executions_Var_Pop_Fields = {
  __typename?: 'job_executions_var_pop_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "job_executions" */
export type Job_Executions_Var_Pop_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Job_Executions_Var_Samp_Fields = {
  __typename?: 'job_executions_var_samp_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "job_executions" */
export type Job_Executions_Var_Samp_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Job_Executions_Variance_Fields = {
  __typename?: 'job_executions_variance_fields';
  duration_ms?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "job_executions" */
export type Job_Executions_Variance_Order_By = {
  duration_ms?: InputMaybe<Order_By>;
};

export type Jsonb_Cast_Exp = {
  String?: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** Adds the ability to modify lane values that impact AP and/or AR */
export type Lanemodifiers = {
  __typename?: 'lanemodifiers';
  /** Description of what this modifier affects - AR|AP|BOTH */
  apply_to: Scalars['String']['output'];
  /** When this modifier becomes active */
  begin_date: Scalars['timestamptz']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** When this modifier expires  */
  end_date: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Int']['output']>;
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
  /** Workflow type override (e.g., yard-hangtag) - applies across customers */
  workflowset_type?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "lanemodifiers" */
export type Lanemodifiers_Aggregate = {
  __typename?: 'lanemodifiers_aggregate';
  aggregate?: Maybe<Lanemodifiers_Aggregate_Fields>;
  nodes: Array<Lanemodifiers>;
};

/** aggregate fields of "lanemodifiers" */
export type Lanemodifiers_Aggregate_Fields = {
  __typename?: 'lanemodifiers_aggregate_fields';
  avg?: Maybe<Lanemodifiers_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Lanemodifiers_Max_Fields>;
  min?: Maybe<Lanemodifiers_Min_Fields>;
  stddev?: Maybe<Lanemodifiers_Stddev_Fields>;
  stddev_pop?: Maybe<Lanemodifiers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Lanemodifiers_Stddev_Samp_Fields>;
  sum?: Maybe<Lanemodifiers_Sum_Fields>;
  var_pop?: Maybe<Lanemodifiers_Var_Pop_Fields>;
  var_samp?: Maybe<Lanemodifiers_Var_Samp_Fields>;
  variance?: Maybe<Lanemodifiers_Variance_Fields>;
};


/** aggregate fields of "lanemodifiers" */
export type Lanemodifiers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Lanemodifiers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Lanemodifiers_Avg_Fields = {
  __typename?: 'lanemodifiers_avg_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "lanemodifiers". All fields are combined with a logical 'AND'. */
export type Lanemodifiers_Bool_Exp = {
  _and?: InputMaybe<Array<Lanemodifiers_Bool_Exp>>;
  _not?: InputMaybe<Lanemodifiers_Bool_Exp>;
  _or?: InputMaybe<Array<Lanemodifiers_Bool_Exp>>;
  apply_to?: InputMaybe<String_Comparison_Exp>;
  begin_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  delivery_inspection_sec_modifier?: InputMaybe<Int_Comparison_Exp>;
  distance_miles_modifier?: InputMaybe<Int_Comparison_Exp>;
  drive_duration_sec_modifier?: InputMaybe<Int_Comparison_Exp>;
  end_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  pickup_inspection_sec_modifier?: InputMaybe<Int_Comparison_Exp>;
  return_ride_wait_sec_modifier?: InputMaybe<Int_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  workflowset_id?: InputMaybe<Bigint_Comparison_Exp>;
  workflowset_type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "lanemodifiers" */
export enum Lanemodifiers_Constraint {
  /** unique or primary key constraint on columns "id" */
  LanemodifiersPkey = 'lanemodifiers_pkey'
}

/** input type for incrementing numeric columns in table "lanemodifiers" */
export type Lanemodifiers_Inc_Input = {
  /** Customer-specific modifiers - third priority */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "lanemodifiers" */
export type Lanemodifiers_Insert_Input = {
  /** Description of what this modifier affects - AR|AP|BOTH */
  apply_to?: InputMaybe<Scalars['String']['input']>;
  /** When this modifier becomes active */
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Customer-specific modifiers - third priority */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** When this modifier expires  */
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Workflow type override (e.g., yard-hangtag) - applies across customers */
  workflowset_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Lanemodifiers_Max_Fields = {
  __typename?: 'lanemodifiers_max_fields';
  /** Description of what this modifier affects - AR|AP|BOTH */
  apply_to?: Maybe<Scalars['String']['output']>;
  /** When this modifier becomes active */
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** When this modifier expires  */
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Int']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
  /** Workflow type override (e.g., yard-hangtag) - applies across customers */
  workflowset_type?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Lanemodifiers_Min_Fields = {
  __typename?: 'lanemodifiers_min_fields';
  /** Description of what this modifier affects - AR|AP|BOTH */
  apply_to?: Maybe<Scalars['String']['output']>;
  /** When this modifier becomes active */
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** When this modifier expires  */
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Int']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
  /** Workflow type override (e.g., yard-hangtag) - applies across customers */
  workflowset_type?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "lanemodifiers" */
export type Lanemodifiers_Mutation_Response = {
  __typename?: 'lanemodifiers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Lanemodifiers>;
};

/** on_conflict condition type for table "lanemodifiers" */
export type Lanemodifiers_On_Conflict = {
  constraint: Lanemodifiers_Constraint;
  update_columns?: Array<Lanemodifiers_Update_Column>;
  where?: InputMaybe<Lanemodifiers_Bool_Exp>;
};

/** Ordering options when selecting data from "lanemodifiers". */
export type Lanemodifiers_Order_By = {
  apply_to?: InputMaybe<Order_By>;
  begin_date?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_inspection_sec_modifier?: InputMaybe<Order_By>;
  distance_miles_modifier?: InputMaybe<Order_By>;
  drive_duration_sec_modifier?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_inspection_sec_modifier?: InputMaybe<Order_By>;
  return_ride_wait_sec_modifier?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
  workflowset_type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: lanemodifiers */
export type Lanemodifiers_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "lanemodifiers" */
export enum Lanemodifiers_Select_Column {
  /** column name */
  ApplyTo = 'apply_to',
  /** column name */
  BeginDate = 'begin_date',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DeliveryInspectionSecModifier = 'delivery_inspection_sec_modifier',
  /** column name */
  DistanceMilesModifier = 'distance_miles_modifier',
  /** column name */
  DriveDurationSecModifier = 'drive_duration_sec_modifier',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PickupInspectionSecModifier = 'pickup_inspection_sec_modifier',
  /** column name */
  ReturnRideWaitSecModifier = 'return_ride_wait_sec_modifier',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowsetId = 'workflowset_id',
  /** column name */
  WorkflowsetType = 'workflowset_type'
}

/** input type for updating data in table "lanemodifiers" */
export type Lanemodifiers_Set_Input = {
  /** Description of what this modifier affects - AR|AP|BOTH */
  apply_to?: InputMaybe<Scalars['String']['input']>;
  /** When this modifier becomes active */
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Customer-specific modifiers - third priority */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** When this modifier expires  */
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Workflow type override (e.g., yard-hangtag) - applies across customers */
  workflowset_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Lanemodifiers_Stddev_Fields = {
  __typename?: 'lanemodifiers_stddev_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Lanemodifiers_Stddev_Pop_Fields = {
  __typename?: 'lanemodifiers_stddev_pop_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Lanemodifiers_Stddev_Samp_Fields = {
  __typename?: 'lanemodifiers_stddev_samp_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "lanemodifiers" */
export type Lanemodifiers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lanemodifiers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lanemodifiers_Stream_Cursor_Value_Input = {
  /** Description of what this modifier affects - AR|AP|BOTH */
  apply_to?: InputMaybe<Scalars['String']['input']>;
  /** When this modifier becomes active */
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Customer-specific modifiers - third priority */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** When this modifier expires  */
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: InputMaybe<Scalars['Int']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Workflow type override (e.g., yard-hangtag) - applies across customers */
  workflowset_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Lanemodifiers_Sum_Fields = {
  __typename?: 'lanemodifiers_sum_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Int']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "lanemodifiers" */
export enum Lanemodifiers_Update_Column {
  /** column name */
  ApplyTo = 'apply_to',
  /** column name */
  BeginDate = 'begin_date',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DeliveryInspectionSecModifier = 'delivery_inspection_sec_modifier',
  /** column name */
  DistanceMilesModifier = 'distance_miles_modifier',
  /** column name */
  DriveDurationSecModifier = 'drive_duration_sec_modifier',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PickupInspectionSecModifier = 'pickup_inspection_sec_modifier',
  /** column name */
  ReturnRideWaitSecModifier = 'return_ride_wait_sec_modifier',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowsetId = 'workflowset_id',
  /** column name */
  WorkflowsetType = 'workflowset_type'
}

export type Lanemodifiers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Lanemodifiers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Lanemodifiers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lanemodifiers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Lanemodifiers_Var_Pop_Fields = {
  __typename?: 'lanemodifiers_var_pop_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Lanemodifiers_Var_Samp_Fields = {
  __typename?: 'lanemodifiers_var_samp_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Lanemodifiers_Variance_Fields = {
  __typename?: 'lanemodifiers_variance_fields';
  /** Customer-specific modifiers - third priority */
  customer_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from delivery inspection time (NULL = no
   *   change)
   */
  delivery_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Miles to add/subtract from calculated distance (NULL = no change) */
  distance_miles_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from calculated drive time (NULL = no change) */
  drive_duration_sec_modifier?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Organization-wide modifiers - lowest priority */
  organization_id?: Maybe<Scalars['Float']['output']>;
  /**
   * Seconds to add/subtract from pickup inspection time (NULL = no
   *   change)
   */
  pickup_inspection_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Seconds to add/subtract from return ride wait time (NULL = no change) */
  return_ride_wait_sec_modifier?: Maybe<Scalars['Float']['output']>;
  /** Specific workflow instance - highest priority override */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "lanes" */
export type Lanes = {
  __typename?: 'lanes';
  active?: Maybe<Scalars['smallint']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer: Customers;
  customer_id: Scalars['bigint']['output'];
  dealer_base_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_base_price?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate_type?: Maybe<Scalars['String']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_price?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate_type?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  delivery: Locations;
  delivery_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  destination_location_id: Scalars['bigint']['output'];
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  driver_rake?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_time_pay?: Maybe<Scalars['numeric']['output']>;
  duration_sec?: Maybe<Scalars['bigint']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['numeric']['output']>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  favorite: Scalars['Boolean']['output'];
  /** An array relationship */
  favoritelanes: Array<Favoritelanes>;
  /** An aggregate relationship */
  favoritelanes_aggregate: Favoritelanes_Aggregate;
  id: Scalars['bigint']['output'];
  insurance_cost?: Maybe<Scalars['numeric']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['numeric']['output']>;
  /** An object relationship */
  inverse?: Maybe<Lanes>;
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  origin_location_id: Scalars['bigint']['output'];
  /** An object relationship */
  pickup: Locations;
  pickup_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['bigint']['output']>;
  tolls?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "lanes" */
export type LanesEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "lanes" */
export type LanesEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "lanes" */
export type LanesFavoritelanesArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


/** columns and relationships of "lanes" */
export type LanesFavoritelanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


/** columns and relationships of "lanes" */
export type LanesMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "lanes" */
export type LanesMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};

/** aggregated selection of "lanes" */
export type Lanes_Aggregate = {
  __typename?: 'lanes_aggregate';
  aggregate?: Maybe<Lanes_Aggregate_Fields>;
  nodes: Array<Lanes>;
};

export type Lanes_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Lanes_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Lanes_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Lanes_Aggregate_Bool_Exp_Count>;
};

export type Lanes_Aggregate_Bool_Exp_Bool_And = {
  arguments: Lanes_Select_Column_Lanes_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Lanes_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Lanes_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Lanes_Select_Column_Lanes_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Lanes_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Lanes_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Lanes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Lanes_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "lanes" */
export type Lanes_Aggregate_Fields = {
  __typename?: 'lanes_aggregate_fields';
  avg?: Maybe<Lanes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Lanes_Max_Fields>;
  min?: Maybe<Lanes_Min_Fields>;
  stddev?: Maybe<Lanes_Stddev_Fields>;
  stddev_pop?: Maybe<Lanes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Lanes_Stddev_Samp_Fields>;
  sum?: Maybe<Lanes_Sum_Fields>;
  var_pop?: Maybe<Lanes_Var_Pop_Fields>;
  var_samp?: Maybe<Lanes_Var_Samp_Fields>;
  variance?: Maybe<Lanes_Variance_Fields>;
};


/** aggregate fields of "lanes" */
export type Lanes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Lanes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "lanes" */
export type Lanes_Aggregate_Order_By = {
  avg?: InputMaybe<Lanes_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Lanes_Max_Order_By>;
  min?: InputMaybe<Lanes_Min_Order_By>;
  stddev?: InputMaybe<Lanes_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Lanes_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Lanes_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Lanes_Sum_Order_By>;
  var_pop?: InputMaybe<Lanes_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Lanes_Var_Samp_Order_By>;
  variance?: InputMaybe<Lanes_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "lanes" */
export type Lanes_Arr_Rel_Insert_Input = {
  data: Array<Lanes_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Lanes_On_Conflict>;
};

/** aggregate avg on columns */
export type Lanes_Avg_Fields = {
  __typename?: 'lanes_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "lanes" */
export type Lanes_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "lanes". All fields are combined with a logical 'AND'. */
export type Lanes_Bool_Exp = {
  _and?: InputMaybe<Array<Lanes_Bool_Exp>>;
  _not?: InputMaybe<Lanes_Bool_Exp>;
  _or?: InputMaybe<Array<Lanes_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  average_drive_speed_min_per_mile?: InputMaybe<Numeric_Comparison_Exp>;
  average_drive_speed_mph?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  dealer_base_discount?: InputMaybe<Numeric_Comparison_Exp>;
  dealer_base_price?: InputMaybe<Numeric_Comparison_Exp>;
  dealer_base_rate?: InputMaybe<Numeric_Comparison_Exp>;
  dealer_base_rate_type?: InputMaybe<String_Comparison_Exp>;
  dealer_stranded_discount?: InputMaybe<Numeric_Comparison_Exp>;
  dealer_stranded_price?: InputMaybe<Numeric_Comparison_Exp>;
  dealer_stranded_rate?: InputMaybe<Numeric_Comparison_Exp>;
  dealer_stranded_rate_type?: InputMaybe<String_Comparison_Exp>;
  delivery?: InputMaybe<Locations_Bool_Exp>;
  delivery_inspection_sec?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  destination_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  distance_miles?: InputMaybe<Numeric_Comparison_Exp>;
  driver_base_pay?: InputMaybe<Numeric_Comparison_Exp>;
  driver_base_pay_discount?: InputMaybe<Numeric_Comparison_Exp>;
  driver_drive_pay?: InputMaybe<Numeric_Comparison_Exp>;
  driver_pay_per_kilometer?: InputMaybe<Numeric_Comparison_Exp>;
  driver_pay_per_mile?: InputMaybe<Numeric_Comparison_Exp>;
  driver_pay_per_minute?: InputMaybe<Numeric_Comparison_Exp>;
  driver_rake?: InputMaybe<Numeric_Comparison_Exp>;
  driver_return_pay?: InputMaybe<Numeric_Comparison_Exp>;
  driver_return_pay_discount?: InputMaybe<Numeric_Comparison_Exp>;
  driver_time_pay?: InputMaybe<Numeric_Comparison_Exp>;
  duration_sec?: InputMaybe<Bigint_Comparison_Exp>;
  estimated_rideshare_return_cost?: InputMaybe<Numeric_Comparison_Exp>;
  eventlogs?: InputMaybe<Eventlogs_Bool_Exp>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Bool_Exp>;
  favorite?: InputMaybe<Boolean_Comparison_Exp>;
  favoritelanes?: InputMaybe<Favoritelanes_Bool_Exp>;
  favoritelanes_aggregate?: InputMaybe<Favoritelanes_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  insurance_cost?: InputMaybe<Numeric_Comparison_Exp>;
  insurance_cost_per_mile?: InputMaybe<Numeric_Comparison_Exp>;
  inverse?: InputMaybe<Lanes_Bool_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  origin_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  pickup?: InputMaybe<Locations_Bool_Exp>;
  pickup_inspection_sec?: InputMaybe<Bigint_Comparison_Exp>;
  return_ride_wait_sec?: InputMaybe<Bigint_Comparison_Exp>;
  tolls?: InputMaybe<Numeric_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "lanes" */
export enum Lanes_Constraint {
  /** unique or primary key constraint on columns "origin_location_id", "destination_location_id", "customer_id" */
  LanesCustomerIdOriginLocationIdDestinationLocationIdKe = 'lanes_customer_id_origin_location_id_destination_location_id_ke',
  /** unique or primary key constraint on columns "id" */
  LanesPkey = 'lanes_pkey'
}

/** input type for incrementing numeric columns in table "lanes" */
export type Lanes_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_drive_speed_min_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  average_drive_speed_mph?: InputMaybe<Scalars['numeric']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_base_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate?: InputMaybe<Scalars['numeric']['input']>;
  delivery_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  driver_rake?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  duration_sec?: InputMaybe<Scalars['bigint']['input']>;
  estimated_rideshare_return_cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_cost?: InputMaybe<Scalars['numeric']['input']>;
  insurance_cost_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  return_ride_wait_sec?: InputMaybe<Scalars['bigint']['input']>;
  tolls?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "lanes" */
export type Lanes_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_drive_speed_min_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  average_drive_speed_mph?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_base_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate_type?: InputMaybe<Scalars['String']['input']>;
  dealer_stranded_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate_type?: InputMaybe<Scalars['String']['input']>;
  delivery?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  delivery_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  driver_rake?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  duration_sec?: InputMaybe<Scalars['bigint']['input']>;
  estimated_rideshare_return_cost?: InputMaybe<Scalars['numeric']['input']>;
  eventlogs?: InputMaybe<Eventlogs_Arr_Rel_Insert_Input>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  favoritelanes?: InputMaybe<Favoritelanes_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_cost?: InputMaybe<Scalars['numeric']['input']>;
  insurance_cost_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  inverse?: InputMaybe<Lanes_Obj_Rel_Insert_Input>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  pickup_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  return_ride_wait_sec?: InputMaybe<Scalars['bigint']['input']>;
  tolls?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Lanes_Max_Fields = {
  __typename?: 'lanes_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_base_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_base_price?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate_type?: Maybe<Scalars['String']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_price?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate_type?: Maybe<Scalars['String']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  driver_rake?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_time_pay?: Maybe<Scalars['numeric']['output']>;
  duration_sec?: Maybe<Scalars['bigint']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  insurance_cost?: Maybe<Scalars['numeric']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['numeric']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['bigint']['output']>;
  tolls?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "lanes" */
export type Lanes_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_base_rate_type?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  dealer_stranded_rate_type?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Lanes_Min_Fields = {
  __typename?: 'lanes_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_base_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_base_price?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate_type?: Maybe<Scalars['String']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_price?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate_type?: Maybe<Scalars['String']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  driver_rake?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_time_pay?: Maybe<Scalars['numeric']['output']>;
  duration_sec?: Maybe<Scalars['bigint']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  insurance_cost?: Maybe<Scalars['numeric']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['numeric']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['bigint']['output']>;
  tolls?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "lanes" */
export type Lanes_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_base_rate_type?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  dealer_stranded_rate_type?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "lanes" */
export type Lanes_Mutation_Response = {
  __typename?: 'lanes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Lanes>;
};

/** input type for inserting object relation for remote table "lanes" */
export type Lanes_Obj_Rel_Insert_Input = {
  data: Lanes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Lanes_On_Conflict>;
};

/** on_conflict condition type for table "lanes" */
export type Lanes_On_Conflict = {
  constraint: Lanes_Constraint;
  update_columns?: Array<Lanes_Update_Column>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};

/** Ordering options when selecting data from "lanes". */
export type Lanes_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_base_rate_type?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  dealer_stranded_rate_type?: InputMaybe<Order_By>;
  delivery?: InputMaybe<Locations_Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Order_By>;
  favorite?: InputMaybe<Order_By>;
  favoritelanes_aggregate?: InputMaybe<Favoritelanes_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  inverse?: InputMaybe<Lanes_Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup?: InputMaybe<Locations_Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: lanes */
export type Lanes_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "lanes" */
export enum Lanes_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AverageDriveSpeedMinPerMile = 'average_drive_speed_min_per_mile',
  /** column name */
  AverageDriveSpeedMph = 'average_drive_speed_mph',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DealerBaseDiscount = 'dealer_base_discount',
  /** column name */
  DealerBasePrice = 'dealer_base_price',
  /** column name */
  DealerBaseRate = 'dealer_base_rate',
  /** column name */
  DealerBaseRateType = 'dealer_base_rate_type',
  /** column name */
  DealerStrandedDiscount = 'dealer_stranded_discount',
  /** column name */
  DealerStrandedPrice = 'dealer_stranded_price',
  /** column name */
  DealerStrandedRate = 'dealer_stranded_rate',
  /** column name */
  DealerStrandedRateType = 'dealer_stranded_rate_type',
  /** column name */
  DeliveryInspectionSec = 'delivery_inspection_sec',
  /** column name */
  Description = 'description',
  /** column name */
  DestinationLocationId = 'destination_location_id',
  /** column name */
  DistanceMiles = 'distance_miles',
  /** column name */
  DriverBasePay = 'driver_base_pay',
  /** column name */
  DriverBasePayDiscount = 'driver_base_pay_discount',
  /** column name */
  DriverDrivePay = 'driver_drive_pay',
  /** column name */
  DriverPayPerKilometer = 'driver_pay_per_kilometer',
  /** column name */
  DriverPayPerMile = 'driver_pay_per_mile',
  /** column name */
  DriverPayPerMinute = 'driver_pay_per_minute',
  /** column name */
  DriverRake = 'driver_rake',
  /** column name */
  DriverReturnPay = 'driver_return_pay',
  /** column name */
  DriverReturnPayDiscount = 'driver_return_pay_discount',
  /** column name */
  DriverTimePay = 'driver_time_pay',
  /** column name */
  DurationSec = 'duration_sec',
  /** column name */
  EstimatedRideshareReturnCost = 'estimated_rideshare_return_cost',
  /** column name */
  Favorite = 'favorite',
  /** column name */
  Id = 'id',
  /** column name */
  InsuranceCost = 'insurance_cost',
  /** column name */
  InsuranceCostPerMile = 'insurance_cost_per_mile',
  /** column name */
  OriginLocationId = 'origin_location_id',
  /** column name */
  PickupInspectionSec = 'pickup_inspection_sec',
  /** column name */
  ReturnRideWaitSec = 'return_ride_wait_sec',
  /** column name */
  Tolls = 'tolls',
  /** column name */
  Updatedat = 'updatedat'
}

/** select "lanes_aggregate_bool_exp_bool_and_arguments_columns" columns of table "lanes" */
export enum Lanes_Select_Column_Lanes_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Favorite = 'favorite'
}

/** select "lanes_aggregate_bool_exp_bool_or_arguments_columns" columns of table "lanes" */
export enum Lanes_Select_Column_Lanes_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Favorite = 'favorite'
}

/** input type for updating data in table "lanes" */
export type Lanes_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_drive_speed_min_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  average_drive_speed_mph?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_base_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate_type?: InputMaybe<Scalars['String']['input']>;
  dealer_stranded_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate_type?: InputMaybe<Scalars['String']['input']>;
  delivery_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  driver_rake?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  duration_sec?: InputMaybe<Scalars['bigint']['input']>;
  estimated_rideshare_return_cost?: InputMaybe<Scalars['numeric']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_cost?: InputMaybe<Scalars['numeric']['input']>;
  insurance_cost_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  return_ride_wait_sec?: InputMaybe<Scalars['bigint']['input']>;
  tolls?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Lanes_Stddev_Fields = {
  __typename?: 'lanes_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "lanes" */
export type Lanes_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Lanes_Stddev_Pop_Fields = {
  __typename?: 'lanes_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "lanes" */
export type Lanes_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Lanes_Stddev_Samp_Fields = {
  __typename?: 'lanes_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "lanes" */
export type Lanes_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "lanes" */
export type Lanes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lanes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lanes_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  average_drive_speed_min_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  average_drive_speed_mph?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_base_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_base_rate_type?: InputMaybe<Scalars['String']['input']>;
  dealer_stranded_discount?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_price?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate?: InputMaybe<Scalars['numeric']['input']>;
  dealer_stranded_rate_type?: InputMaybe<Scalars['String']['input']>;
  delivery_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_miles?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_base_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_drive_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_kilometer?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  driver_pay_per_minute?: InputMaybe<Scalars['numeric']['input']>;
  driver_rake?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay?: InputMaybe<Scalars['numeric']['input']>;
  driver_return_pay_discount?: InputMaybe<Scalars['numeric']['input']>;
  driver_time_pay?: InputMaybe<Scalars['numeric']['input']>;
  duration_sec?: InputMaybe<Scalars['bigint']['input']>;
  estimated_rideshare_return_cost?: InputMaybe<Scalars['numeric']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_cost?: InputMaybe<Scalars['numeric']['input']>;
  insurance_cost_per_mile?: InputMaybe<Scalars['numeric']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_inspection_sec?: InputMaybe<Scalars['bigint']['input']>;
  return_ride_wait_sec?: InputMaybe<Scalars['bigint']['input']>;
  tolls?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Lanes_Sum_Fields = {
  __typename?: 'lanes_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['numeric']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['numeric']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_base_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_base_price?: Maybe<Scalars['numeric']['output']>;
  dealer_base_rate?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_price?: Maybe<Scalars['numeric']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['numeric']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  distance_miles?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay?: Maybe<Scalars['numeric']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_drive_pay?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['numeric']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['numeric']['output']>;
  driver_rake?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay?: Maybe<Scalars['numeric']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['numeric']['output']>;
  driver_time_pay?: Maybe<Scalars['numeric']['output']>;
  duration_sec?: Maybe<Scalars['bigint']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  insurance_cost?: Maybe<Scalars['numeric']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['numeric']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['bigint']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['bigint']['output']>;
  tolls?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "lanes" */
export type Lanes_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** update columns of table "lanes" */
export enum Lanes_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AverageDriveSpeedMinPerMile = 'average_drive_speed_min_per_mile',
  /** column name */
  AverageDriveSpeedMph = 'average_drive_speed_mph',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DealerBaseDiscount = 'dealer_base_discount',
  /** column name */
  DealerBasePrice = 'dealer_base_price',
  /** column name */
  DealerBaseRate = 'dealer_base_rate',
  /** column name */
  DealerBaseRateType = 'dealer_base_rate_type',
  /** column name */
  DealerStrandedDiscount = 'dealer_stranded_discount',
  /** column name */
  DealerStrandedPrice = 'dealer_stranded_price',
  /** column name */
  DealerStrandedRate = 'dealer_stranded_rate',
  /** column name */
  DealerStrandedRateType = 'dealer_stranded_rate_type',
  /** column name */
  DeliveryInspectionSec = 'delivery_inspection_sec',
  /** column name */
  Description = 'description',
  /** column name */
  DestinationLocationId = 'destination_location_id',
  /** column name */
  DistanceMiles = 'distance_miles',
  /** column name */
  DriverBasePay = 'driver_base_pay',
  /** column name */
  DriverBasePayDiscount = 'driver_base_pay_discount',
  /** column name */
  DriverDrivePay = 'driver_drive_pay',
  /** column name */
  DriverPayPerKilometer = 'driver_pay_per_kilometer',
  /** column name */
  DriverPayPerMile = 'driver_pay_per_mile',
  /** column name */
  DriverPayPerMinute = 'driver_pay_per_minute',
  /** column name */
  DriverRake = 'driver_rake',
  /** column name */
  DriverReturnPay = 'driver_return_pay',
  /** column name */
  DriverReturnPayDiscount = 'driver_return_pay_discount',
  /** column name */
  DriverTimePay = 'driver_time_pay',
  /** column name */
  DurationSec = 'duration_sec',
  /** column name */
  EstimatedRideshareReturnCost = 'estimated_rideshare_return_cost',
  /** column name */
  Favorite = 'favorite',
  /** column name */
  Id = 'id',
  /** column name */
  InsuranceCost = 'insurance_cost',
  /** column name */
  InsuranceCostPerMile = 'insurance_cost_per_mile',
  /** column name */
  OriginLocationId = 'origin_location_id',
  /** column name */
  PickupInspectionSec = 'pickup_inspection_sec',
  /** column name */
  ReturnRideWaitSec = 'return_ride_wait_sec',
  /** column name */
  Tolls = 'tolls',
  /** column name */
  Updatedat = 'updatedat'
}

export type Lanes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Lanes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Lanes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lanes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Lanes_Var_Pop_Fields = {
  __typename?: 'lanes_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "lanes" */
export type Lanes_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Lanes_Var_Samp_Fields = {
  __typename?: 'lanes_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "lanes" */
export type Lanes_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Lanes_Variance_Fields = {
  __typename?: 'lanes_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_min_per_mile?: Maybe<Scalars['Float']['output']>;
  average_drive_speed_mph?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  dealer_base_discount?: Maybe<Scalars['Float']['output']>;
  dealer_base_price?: Maybe<Scalars['Float']['output']>;
  dealer_base_rate?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_discount?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_price?: Maybe<Scalars['Float']['output']>;
  dealer_stranded_rate?: Maybe<Scalars['Float']['output']>;
  delivery_inspection_sec?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  distance_miles?: Maybe<Scalars['Float']['output']>;
  driver_base_pay?: Maybe<Scalars['Float']['output']>;
  driver_base_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_drive_pay?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_kilometer?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_mile?: Maybe<Scalars['Float']['output']>;
  driver_pay_per_minute?: Maybe<Scalars['Float']['output']>;
  driver_rake?: Maybe<Scalars['Float']['output']>;
  driver_return_pay?: Maybe<Scalars['Float']['output']>;
  driver_return_pay_discount?: Maybe<Scalars['Float']['output']>;
  driver_time_pay?: Maybe<Scalars['Float']['output']>;
  duration_sec?: Maybe<Scalars['Float']['output']>;
  estimated_rideshare_return_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_cost?: Maybe<Scalars['Float']['output']>;
  insurance_cost_per_mile?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  pickup_inspection_sec?: Maybe<Scalars['Float']['output']>;
  return_ride_wait_sec?: Maybe<Scalars['Float']['output']>;
  tolls?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "lanes" */
export type Lanes_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  average_drive_speed_min_per_mile?: InputMaybe<Order_By>;
  average_drive_speed_mph?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_base_discount?: InputMaybe<Order_By>;
  dealer_base_price?: InputMaybe<Order_By>;
  dealer_base_rate?: InputMaybe<Order_By>;
  dealer_stranded_discount?: InputMaybe<Order_By>;
  dealer_stranded_price?: InputMaybe<Order_By>;
  dealer_stranded_rate?: InputMaybe<Order_By>;
  delivery_inspection_sec?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  distance_miles?: InputMaybe<Order_By>;
  driver_base_pay?: InputMaybe<Order_By>;
  driver_base_pay_discount?: InputMaybe<Order_By>;
  driver_drive_pay?: InputMaybe<Order_By>;
  driver_pay_per_kilometer?: InputMaybe<Order_By>;
  driver_pay_per_mile?: InputMaybe<Order_By>;
  driver_pay_per_minute?: InputMaybe<Order_By>;
  driver_rake?: InputMaybe<Order_By>;
  driver_return_pay?: InputMaybe<Order_By>;
  driver_return_pay_discount?: InputMaybe<Order_By>;
  driver_time_pay?: InputMaybe<Order_By>;
  duration_sec?: InputMaybe<Order_By>;
  estimated_rideshare_return_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_cost?: InputMaybe<Order_By>;
  insurance_cost_per_mile?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  pickup_inspection_sec?: InputMaybe<Order_By>;
  return_ride_wait_sec?: InputMaybe<Order_By>;
  tolls?: InputMaybe<Order_By>;
};

/** columns and relationships of "locations" */
export type Locations = {
  __typename?: 'locations';
  active: Scalars['smallint']['output'];
  address?: Maybe<Scalars['String']['output']>;
  /** Street address and of location */
  address_line_one?: Maybe<Scalars['String']['output']>;
  /** Apartment number or PO box */
  address_line_two?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  businesshours: Array<Businesshours>;
  /** An aggregate relationship */
  businesshours_aggregate: Businesshours_Aggregate;
  city?: Maybe<Scalars['String']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  driver?: Maybe<Drivers>;
  email?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  favorite: Scalars['Boolean']['output'];
  /** An array relationship */
  favoritelocations: Array<Favoritelocations>;
  /** An aggregate relationship */
  favoritelocations_aggregate: Favoritelocations_Aggregate;
  geopoint?: Maybe<Scalars['geography']['output']>;
  id: Scalars['bigint']['output'];
  /** An array relationship */
  lanesByDestinationLocationId: Array<Lanes>;
  /** An aggregate relationship */
  lanesByDestinationLocationId_aggregate: Lanes_Aggregate;
  /** An array relationship */
  lanesByOriginLocationId: Array<Lanes>;
  /** An aggregate relationship */
  lanesByOriginLocationId_aggregate: Lanes_Aggregate;
  latitude?: Maybe<Scalars['numeric']['output']>;
  /** An array relationship */
  locationstocertifications: Array<Locationstocertifications>;
  /** An aggregate relationship */
  locationstocertifications_aggregate: Locationstocertifications_Aggregate;
  longitude?: Maybe<Scalars['numeric']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nickname?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  notes_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  notes_updated_by?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  place_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: Maybe<Scalars['String']['output']>;
  tookan_id?: Maybe<Scalars['bigint']['output']>;
  type: Scalars['String']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  utc_time_offset?: Maybe<Scalars['numeric']['output']>;
  zip_code?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "locations" */
export type LocationsBusinesshoursArgs = {
  distinct_on?: InputMaybe<Array<Businesshours_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businesshours_Order_By>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsBusinesshours_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businesshours_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businesshours_Order_By>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsFavoritelocationsArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsFavoritelocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsLanesByDestinationLocationIdArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsLanesByDestinationLocationId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsLanesByOriginLocationIdArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsLanesByOriginLocationId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsLocationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type LocationsLocationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};

/** aggregated selection of "locations" */
export type Locations_Aggregate = {
  __typename?: 'locations_aggregate';
  aggregate?: Maybe<Locations_Aggregate_Fields>;
  nodes: Array<Locations>;
};

export type Locations_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Locations_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Locations_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Locations_Aggregate_Bool_Exp_Count>;
};

export type Locations_Aggregate_Bool_Exp_Bool_And = {
  arguments: Locations_Select_Column_Locations_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Locations_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Locations_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Locations_Select_Column_Locations_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Locations_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Locations_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Locations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Locations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "locations" */
export type Locations_Aggregate_Fields = {
  __typename?: 'locations_aggregate_fields';
  avg?: Maybe<Locations_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Locations_Max_Fields>;
  min?: Maybe<Locations_Min_Fields>;
  stddev?: Maybe<Locations_Stddev_Fields>;
  stddev_pop?: Maybe<Locations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Locations_Stddev_Samp_Fields>;
  sum?: Maybe<Locations_Sum_Fields>;
  var_pop?: Maybe<Locations_Var_Pop_Fields>;
  var_samp?: Maybe<Locations_Var_Samp_Fields>;
  variance?: Maybe<Locations_Variance_Fields>;
};


/** aggregate fields of "locations" */
export type Locations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Locations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "locations" */
export type Locations_Aggregate_Order_By = {
  avg?: InputMaybe<Locations_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Locations_Max_Order_By>;
  min?: InputMaybe<Locations_Min_Order_By>;
  stddev?: InputMaybe<Locations_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Locations_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Locations_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Locations_Sum_Order_By>;
  var_pop?: InputMaybe<Locations_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Locations_Var_Samp_Order_By>;
  variance?: InputMaybe<Locations_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "locations" */
export type Locations_Arr_Rel_Insert_Input = {
  data: Array<Locations_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Locations_On_Conflict>;
};

/** aggregate avg on columns */
export type Locations_Avg_Fields = {
  __typename?: 'locations_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "locations" */
export type Locations_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'. */
export type Locations_Bool_Exp = {
  _and?: InputMaybe<Array<Locations_Bool_Exp>>;
  _not?: InputMaybe<Locations_Bool_Exp>;
  _or?: InputMaybe<Array<Locations_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  address?: InputMaybe<String_Comparison_Exp>;
  address_line_one?: InputMaybe<String_Comparison_Exp>;
  address_line_two?: InputMaybe<String_Comparison_Exp>;
  businesshours?: InputMaybe<Businesshours_Bool_Exp>;
  businesshours_aggregate?: InputMaybe<Businesshours_Aggregate_Bool_Exp>;
  city?: InputMaybe<String_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  eventlogs?: InputMaybe<Eventlogs_Bool_Exp>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Bool_Exp>;
  favorite?: InputMaybe<Boolean_Comparison_Exp>;
  favoritelocations?: InputMaybe<Favoritelocations_Bool_Exp>;
  favoritelocations_aggregate?: InputMaybe<Favoritelocations_Aggregate_Bool_Exp>;
  geopoint?: InputMaybe<Geography_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  lanesByDestinationLocationId?: InputMaybe<Lanes_Bool_Exp>;
  lanesByDestinationLocationId_aggregate?: InputMaybe<Lanes_Aggregate_Bool_Exp>;
  lanesByOriginLocationId?: InputMaybe<Lanes_Bool_Exp>;
  lanesByOriginLocationId_aggregate?: InputMaybe<Lanes_Aggregate_Bool_Exp>;
  latitude?: InputMaybe<Numeric_Comparison_Exp>;
  locationstocertifications?: InputMaybe<Locationstocertifications_Bool_Exp>;
  locationstocertifications_aggregate?: InputMaybe<Locationstocertifications_Aggregate_Bool_Exp>;
  longitude?: InputMaybe<Numeric_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  nickname?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  notes_updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  notes_updated_by?: InputMaybe<String_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  place_id?: InputMaybe<String_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  state?: InputMaybe<String_Comparison_Exp>;
  timezone?: InputMaybe<String_Comparison_Exp>;
  tookan_id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  utc_time_offset?: InputMaybe<Numeric_Comparison_Exp>;
  zip_code?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "locations" */
export enum Locations_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25692Primary = 'idx_25692_primary',
  /** unique or primary key constraint on columns "address", "customer_id" */
  LocationsCustomerIdAddressKey = 'locations_customer_id_address_key'
}

/** input type for incrementing numeric columns in table "locations" */
export type Locations_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  tookan_id?: InputMaybe<Scalars['bigint']['input']>;
  utc_time_offset?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "locations" */
export type Locations_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  /** Street address and of location */
  address_line_one?: InputMaybe<Scalars['String']['input']>;
  /** Apartment number or PO box */
  address_line_two?: InputMaybe<Scalars['String']['input']>;
  businesshours?: InputMaybe<Businesshours_Arr_Rel_Insert_Input>;
  city?: InputMaybe<Scalars['String']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  email?: InputMaybe<Scalars['String']['input']>;
  eventlogs?: InputMaybe<Eventlogs_Arr_Rel_Insert_Input>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  favoritelocations?: InputMaybe<Favoritelocations_Arr_Rel_Insert_Input>;
  geopoint?: InputMaybe<Scalars['geography']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lanesByDestinationLocationId?: InputMaybe<Lanes_Arr_Rel_Insert_Input>;
  lanesByOriginLocationId?: InputMaybe<Lanes_Arr_Rel_Insert_Input>;
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  locationstocertifications?: InputMaybe<Locationstocertifications_Arr_Rel_Insert_Input>;
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nickname?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  notes_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  notes_updated_by?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  place_id?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  tookan_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  utc_time_offset?: InputMaybe<Scalars['numeric']['input']>;
  zip_code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Locations_Max_Fields = {
  __typename?: 'locations_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  address?: Maybe<Scalars['String']['output']>;
  /** Street address and of location */
  address_line_one?: Maybe<Scalars['String']['output']>;
  /** Apartment number or PO box */
  address_line_two?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  latitude?: Maybe<Scalars['numeric']['output']>;
  longitude?: Maybe<Scalars['numeric']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nickname?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  notes_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  notes_updated_by?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  place_id?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: Maybe<Scalars['String']['output']>;
  tookan_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  utc_time_offset?: Maybe<Scalars['numeric']['output']>;
  zip_code?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "locations" */
export type Locations_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  address?: InputMaybe<Order_By>;
  /** Street address and of location */
  address_line_one?: InputMaybe<Order_By>;
  /** Apartment number or PO box */
  address_line_two?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  notes_updated_at?: InputMaybe<Order_By>;
  notes_updated_by?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  place_id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
  zip_code?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Locations_Min_Fields = {
  __typename?: 'locations_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  address?: Maybe<Scalars['String']['output']>;
  /** Street address and of location */
  address_line_one?: Maybe<Scalars['String']['output']>;
  /** Apartment number or PO box */
  address_line_two?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  latitude?: Maybe<Scalars['numeric']['output']>;
  longitude?: Maybe<Scalars['numeric']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nickname?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  notes_updated_at?: Maybe<Scalars['timestamptz']['output']>;
  notes_updated_by?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  place_id?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: Maybe<Scalars['String']['output']>;
  tookan_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  utc_time_offset?: Maybe<Scalars['numeric']['output']>;
  zip_code?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "locations" */
export type Locations_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  address?: InputMaybe<Order_By>;
  /** Street address and of location */
  address_line_one?: InputMaybe<Order_By>;
  /** Apartment number or PO box */
  address_line_two?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  notes_updated_at?: InputMaybe<Order_By>;
  notes_updated_by?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  place_id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
  zip_code?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "locations" */
export type Locations_Mutation_Response = {
  __typename?: 'locations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Locations>;
};

/** input type for inserting object relation for remote table "locations" */
export type Locations_Obj_Rel_Insert_Input = {
  data: Locations_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Locations_On_Conflict>;
};

/** on_conflict condition type for table "locations" */
export type Locations_On_Conflict = {
  constraint: Locations_Constraint;
  update_columns?: Array<Locations_Update_Column>;
  where?: InputMaybe<Locations_Bool_Exp>;
};

/** Ordering options when selecting data from "locations". */
export type Locations_Order_By = {
  active?: InputMaybe<Order_By>;
  address?: InputMaybe<Order_By>;
  address_line_one?: InputMaybe<Order_By>;
  address_line_two?: InputMaybe<Order_By>;
  businesshours_aggregate?: InputMaybe<Businesshours_Aggregate_Order_By>;
  city?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  email?: InputMaybe<Order_By>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Order_By>;
  favorite?: InputMaybe<Order_By>;
  favoritelocations_aggregate?: InputMaybe<Favoritelocations_Aggregate_Order_By>;
  geopoint?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lanesByDestinationLocationId_aggregate?: InputMaybe<Lanes_Aggregate_Order_By>;
  lanesByOriginLocationId_aggregate?: InputMaybe<Lanes_Aggregate_Order_By>;
  latitude?: InputMaybe<Order_By>;
  locationstocertifications_aggregate?: InputMaybe<Locationstocertifications_Aggregate_Order_By>;
  longitude?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  notes_updated_at?: InputMaybe<Order_By>;
  notes_updated_by?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  place_id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  timezone?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
  zip_code?: InputMaybe<Order_By>;
};

/** primary key columns input for table: locations */
export type Locations_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "locations" */
export enum Locations_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Address = 'address',
  /** column name */
  AddressLineOne = 'address_line_one',
  /** column name */
  AddressLineTwo = 'address_line_two',
  /** column name */
  City = 'city',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Email = 'email',
  /** column name */
  Favorite = 'favorite',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  Notes = 'notes',
  /** column name */
  NotesUpdatedAt = 'notes_updated_at',
  /** column name */
  NotesUpdatedBy = 'notes_updated_by',
  /** column name */
  Phone = 'phone',
  /** column name */
  PlaceId = 'place_id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  State = 'state',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  TookanId = 'tookan_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  UtcTimeOffset = 'utc_time_offset',
  /** column name */
  ZipCode = 'zip_code'
}

/** select "locations_aggregate_bool_exp_bool_and_arguments_columns" columns of table "locations" */
export enum Locations_Select_Column_Locations_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Favorite = 'favorite'
}

/** select "locations_aggregate_bool_exp_bool_or_arguments_columns" columns of table "locations" */
export enum Locations_Select_Column_Locations_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Favorite = 'favorite'
}

/** input type for updating data in table "locations" */
export type Locations_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  /** Street address and of location */
  address_line_one?: InputMaybe<Scalars['String']['input']>;
  /** Apartment number or PO box */
  address_line_two?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  geopoint?: InputMaybe<Scalars['geography']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nickname?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  notes_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  notes_updated_by?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  place_id?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  tookan_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  utc_time_offset?: InputMaybe<Scalars['numeric']['input']>;
  zip_code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Locations_Stddev_Fields = {
  __typename?: 'locations_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "locations" */
export type Locations_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Locations_Stddev_Pop_Fields = {
  __typename?: 'locations_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "locations" */
export type Locations_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Locations_Stddev_Samp_Fields = {
  __typename?: 'locations_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "locations" */
export type Locations_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "locations" */
export type Locations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Locations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Locations_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  /** Street address and of location */
  address_line_one?: InputMaybe<Scalars['String']['input']>;
  /** Apartment number or PO box */
  address_line_two?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  favorite?: InputMaybe<Scalars['Boolean']['input']>;
  geopoint?: InputMaybe<Scalars['geography']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nickname?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  notes_updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  notes_updated_by?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  place_id?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  tookan_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  utc_time_offset?: InputMaybe<Scalars['numeric']['input']>;
  zip_code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Locations_Sum_Fields = {
  __typename?: 'locations_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  latitude?: Maybe<Scalars['numeric']['output']>;
  longitude?: Maybe<Scalars['numeric']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  tookan_id?: Maybe<Scalars['bigint']['output']>;
  utc_time_offset?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "locations" */
export type Locations_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** update columns of table "locations" */
export enum Locations_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Address = 'address',
  /** column name */
  AddressLineOne = 'address_line_one',
  /** column name */
  AddressLineTwo = 'address_line_two',
  /** column name */
  City = 'city',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Email = 'email',
  /** column name */
  Favorite = 'favorite',
  /** column name */
  Geopoint = 'geopoint',
  /** column name */
  Id = 'id',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  Name = 'name',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  Notes = 'notes',
  /** column name */
  NotesUpdatedAt = 'notes_updated_at',
  /** column name */
  NotesUpdatedBy = 'notes_updated_by',
  /** column name */
  Phone = 'phone',
  /** column name */
  PlaceId = 'place_id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  State = 'state',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  TookanId = 'tookan_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  UtcTimeOffset = 'utc_time_offset',
  /** column name */
  ZipCode = 'zip_code'
}

export type Locations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Locations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Locations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Locations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Locations_Var_Pop_Fields = {
  __typename?: 'locations_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "locations" */
export type Locations_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Locations_Var_Samp_Fields = {
  __typename?: 'locations_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "locations" */
export type Locations_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Locations_Variance_Fields = {
  __typename?: 'locations_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  tookan_id?: Maybe<Scalars['Float']['output']>;
  utc_time_offset?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "locations" */
export type Locations_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  tookan_id?: InputMaybe<Order_By>;
  utc_time_offset?: InputMaybe<Order_By>;
};

/** Many to Many relationships. This could be used if a location has a specific requirement, ie a Rail yard. */
export type Locationstocertifications = {
  __typename?: 'locationstocertifications';
  /** An object relationship */
  certification: Certifications;
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  location: Locations;
  location_id: Scalars['bigint']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "locationstocertifications" */
export type Locationstocertifications_Aggregate = {
  __typename?: 'locationstocertifications_aggregate';
  aggregate?: Maybe<Locationstocertifications_Aggregate_Fields>;
  nodes: Array<Locationstocertifications>;
};

export type Locationstocertifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Locationstocertifications_Aggregate_Bool_Exp_Count>;
};

export type Locationstocertifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Locationstocertifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "locationstocertifications" */
export type Locationstocertifications_Aggregate_Fields = {
  __typename?: 'locationstocertifications_aggregate_fields';
  avg?: Maybe<Locationstocertifications_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Locationstocertifications_Max_Fields>;
  min?: Maybe<Locationstocertifications_Min_Fields>;
  stddev?: Maybe<Locationstocertifications_Stddev_Fields>;
  stddev_pop?: Maybe<Locationstocertifications_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Locationstocertifications_Stddev_Samp_Fields>;
  sum?: Maybe<Locationstocertifications_Sum_Fields>;
  var_pop?: Maybe<Locationstocertifications_Var_Pop_Fields>;
  var_samp?: Maybe<Locationstocertifications_Var_Samp_Fields>;
  variance?: Maybe<Locationstocertifications_Variance_Fields>;
};


/** aggregate fields of "locationstocertifications" */
export type Locationstocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "locationstocertifications" */
export type Locationstocertifications_Aggregate_Order_By = {
  avg?: InputMaybe<Locationstocertifications_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Locationstocertifications_Max_Order_By>;
  min?: InputMaybe<Locationstocertifications_Min_Order_By>;
  stddev?: InputMaybe<Locationstocertifications_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Locationstocertifications_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Locationstocertifications_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Locationstocertifications_Sum_Order_By>;
  var_pop?: InputMaybe<Locationstocertifications_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Locationstocertifications_Var_Samp_Order_By>;
  variance?: InputMaybe<Locationstocertifications_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "locationstocertifications" */
export type Locationstocertifications_Arr_Rel_Insert_Input = {
  data: Array<Locationstocertifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Locationstocertifications_On_Conflict>;
};

/** aggregate avg on columns */
export type Locationstocertifications_Avg_Fields = {
  __typename?: 'locationstocertifications_avg_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "locationstocertifications" */
export type Locationstocertifications_Avg_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "locationstocertifications". All fields are combined with a logical 'AND'. */
export type Locationstocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Locationstocertifications_Bool_Exp>>;
  _not?: InputMaybe<Locationstocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Locationstocertifications_Bool_Exp>>;
  certification?: InputMaybe<Certifications_Bool_Exp>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  location?: InputMaybe<Locations_Bool_Exp>;
  location_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "locationstocertifications" */
export enum Locationstocertifications_Constraint {
  /** unique or primary key constraint on columns "certification_key", "location_id" */
  LocationstocertificationsPkey = 'locationstocertifications_pkey'
}

/** input type for incrementing numeric columns in table "locationstocertifications" */
export type Locationstocertifications_Inc_Input = {
  location_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "locationstocertifications" */
export type Locationstocertifications_Insert_Input = {
  certification?: InputMaybe<Certifications_Obj_Rel_Insert_Input>;
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Locationstocertifications_Max_Fields = {
  __typename?: 'locationstocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  location_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "locationstocertifications" */
export type Locationstocertifications_Max_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Locationstocertifications_Min_Fields = {
  __typename?: 'locationstocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  location_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "locationstocertifications" */
export type Locationstocertifications_Min_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  location_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "locationstocertifications" */
export type Locationstocertifications_Mutation_Response = {
  __typename?: 'locationstocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Locationstocertifications>;
};

/** on_conflict condition type for table "locationstocertifications" */
export type Locationstocertifications_On_Conflict = {
  constraint: Locationstocertifications_Constraint;
  update_columns?: Array<Locationstocertifications_Update_Column>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "locationstocertifications". */
export type Locationstocertifications_Order_By = {
  certification?: InputMaybe<Certifications_Order_By>;
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  location?: InputMaybe<Locations_Order_By>;
  location_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: locationstocertifications */
export type Locationstocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  location_id: Scalars['bigint']['input'];
};

/** select columns of table "locationstocertifications" */
export enum Locationstocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "locationstocertifications" */
export type Locationstocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Locationstocertifications_Stddev_Fields = {
  __typename?: 'locationstocertifications_stddev_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "locationstocertifications" */
export type Locationstocertifications_Stddev_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Locationstocertifications_Stddev_Pop_Fields = {
  __typename?: 'locationstocertifications_stddev_pop_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "locationstocertifications" */
export type Locationstocertifications_Stddev_Pop_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Locationstocertifications_Stddev_Samp_Fields = {
  __typename?: 'locationstocertifications_stddev_samp_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "locationstocertifications" */
export type Locationstocertifications_Stddev_Samp_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "locationstocertifications" */
export type Locationstocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Locationstocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Locationstocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  location_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Locationstocertifications_Sum_Fields = {
  __typename?: 'locationstocertifications_sum_fields';
  location_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "locationstocertifications" */
export type Locationstocertifications_Sum_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** update columns of table "locationstocertifications" */
export enum Locationstocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  LocationId = 'location_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

export type Locationstocertifications_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Locationstocertifications_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Locationstocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Locationstocertifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Locationstocertifications_Var_Pop_Fields = {
  __typename?: 'locationstocertifications_var_pop_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "locationstocertifications" */
export type Locationstocertifications_Var_Pop_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Locationstocertifications_Var_Samp_Fields = {
  __typename?: 'locationstocertifications_var_samp_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "locationstocertifications" */
export type Locationstocertifications_Var_Samp_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Locationstocertifications_Variance_Fields = {
  __typename?: 'locationstocertifications_variance_fields';
  location_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "locationstocertifications" */
export type Locationstocertifications_Variance_Order_By = {
  location_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "lyftrideattempts" */
export type Lyftrideattempts = {
  __typename?: 'lyftrideattempts';
  active: Scalars['smallint']['output'];
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  driver_first_name?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['String']['output']>;
  driver_phone?: Maybe<Scalars['String']['output']>;
  driver_rating?: Maybe<Scalars['numeric']['output']>;
  driver_vehicle_color?: Maybe<Scalars['String']['output']>;
  driver_vehicle_img_url?: Maybe<Scalars['String']['output']>;
  driver_vehicle_license_plate?: Maybe<Scalars['String']['output']>;
  driver_vehicle_license_plate_state?: Maybe<Scalars['String']['output']>;
  driver_vehicle_make?: Maybe<Scalars['String']['output']>;
  driver_vehicle_model?: Maybe<Scalars['String']['output']>;
  driver_vehicle_year?: Maybe<Scalars['bigint']['output']>;
  estimate_id?: Maybe<Scalars['String']['output']>;
  estimated_arrival_time?: Maybe<Scalars['timestamptz']['output']>;
  estimated_cost_max?: Maybe<Scalars['numeric']['output']>;
  estimated_cost_min?: Maybe<Scalars['numeric']['output']>;
  estimated_ride_cost?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  lyftride?: Maybe<Lyftrides>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['bigint']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  passenger_phone?: Maybe<Scalars['String']['output']>;
  requested_at?: Maybe<Scalars['timestamptz']['output']>;
  requester?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  ride?: Maybe<Lyftrides>;
  ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['numeric']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['numeric']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type: Scalars['String']['output'];
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: Maybe<Scalars['String']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['numeric']['output']>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: Maybe<Scalars['String']['output']>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: Maybe<Scalars['String']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['numeric']['output']>;
  status: Scalars['String']['output'];
  stop_id?: Maybe<Scalars['bigint']['output']>;
  surge_cost_percentage?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "lyftrideattempts" */
export type Lyftrideattempts_Aggregate = {
  __typename?: 'lyftrideattempts_aggregate';
  aggregate?: Maybe<Lyftrideattempts_Aggregate_Fields>;
  nodes: Array<Lyftrideattempts>;
};

export type Lyftrideattempts_Aggregate_Bool_Exp = {
  count?: InputMaybe<Lyftrideattempts_Aggregate_Bool_Exp_Count>;
};

export type Lyftrideattempts_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Lyftrideattempts_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "lyftrideattempts" */
export type Lyftrideattempts_Aggregate_Fields = {
  __typename?: 'lyftrideattempts_aggregate_fields';
  avg?: Maybe<Lyftrideattempts_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Lyftrideattempts_Max_Fields>;
  min?: Maybe<Lyftrideattempts_Min_Fields>;
  stddev?: Maybe<Lyftrideattempts_Stddev_Fields>;
  stddev_pop?: Maybe<Lyftrideattempts_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Lyftrideattempts_Stddev_Samp_Fields>;
  sum?: Maybe<Lyftrideattempts_Sum_Fields>;
  var_pop?: Maybe<Lyftrideattempts_Var_Pop_Fields>;
  var_samp?: Maybe<Lyftrideattempts_Var_Samp_Fields>;
  variance?: Maybe<Lyftrideattempts_Variance_Fields>;
};


/** aggregate fields of "lyftrideattempts" */
export type Lyftrideattempts_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "lyftrideattempts" */
export type Lyftrideattempts_Aggregate_Order_By = {
  avg?: InputMaybe<Lyftrideattempts_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Lyftrideattempts_Max_Order_By>;
  min?: InputMaybe<Lyftrideattempts_Min_Order_By>;
  stddev?: InputMaybe<Lyftrideattempts_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Lyftrideattempts_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Lyftrideattempts_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Lyftrideattempts_Sum_Order_By>;
  var_pop?: InputMaybe<Lyftrideattempts_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Lyftrideattempts_Var_Samp_Order_By>;
  variance?: InputMaybe<Lyftrideattempts_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "lyftrideattempts" */
export type Lyftrideattempts_Arr_Rel_Insert_Input = {
  data: Array<Lyftrideattempts_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Lyftrideattempts_On_Conflict>;
};

/** aggregate avg on columns */
export type Lyftrideattempts_Avg_Fields = {
  __typename?: 'lyftrideattempts_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "lyftrideattempts". All fields are combined with a logical 'AND'. */
export type Lyftrideattempts_Bool_Exp = {
  _and?: InputMaybe<Array<Lyftrideattempts_Bool_Exp>>;
  _not?: InputMaybe<Lyftrideattempts_Bool_Exp>;
  _or?: InputMaybe<Array<Lyftrideattempts_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  destination_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_first_name?: InputMaybe<String_Comparison_Exp>;
  driver_id?: InputMaybe<String_Comparison_Exp>;
  driver_phone?: InputMaybe<String_Comparison_Exp>;
  driver_rating?: InputMaybe<Numeric_Comparison_Exp>;
  driver_vehicle_color?: InputMaybe<String_Comparison_Exp>;
  driver_vehicle_img_url?: InputMaybe<String_Comparison_Exp>;
  driver_vehicle_license_plate?: InputMaybe<String_Comparison_Exp>;
  driver_vehicle_license_plate_state?: InputMaybe<String_Comparison_Exp>;
  driver_vehicle_make?: InputMaybe<String_Comparison_Exp>;
  driver_vehicle_model?: InputMaybe<String_Comparison_Exp>;
  driver_vehicle_year?: InputMaybe<Bigint_Comparison_Exp>;
  estimate_id?: InputMaybe<String_Comparison_Exp>;
  estimated_arrival_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  estimated_cost_max?: InputMaybe<Numeric_Comparison_Exp>;
  estimated_cost_min?: InputMaybe<Numeric_Comparison_Exp>;
  estimated_ride_cost?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  lyftride?: InputMaybe<Lyftrides_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  origin_location_id?: InputMaybe<Bigint_Comparison_Exp>;
  passenger_phone?: InputMaybe<String_Comparison_Exp>;
  requested_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  requester?: InputMaybe<String_Comparison_Exp>;
  ride?: InputMaybe<Lyftrides_Bool_Exp>;
  ride_cost?: InputMaybe<Numeric_Comparison_Exp>;
  ride_distance?: InputMaybe<Numeric_Comparison_Exp>;
  ride_duration?: InputMaybe<Numeric_Comparison_Exp>;
  ride_id?: InputMaybe<Bigint_Comparison_Exp>;
  ride_type?: InputMaybe<String_Comparison_Exp>;
  rideshare_delivery_address?: InputMaybe<String_Comparison_Exp>;
  rideshare_delivery_latitude?: InputMaybe<Numeric_Comparison_Exp>;
  rideshare_delivery_longitude?: InputMaybe<Numeric_Comparison_Exp>;
  rideshare_id?: InputMaybe<String_Comparison_Exp>;
  rideshare_pickup_address?: InputMaybe<String_Comparison_Exp>;
  rideshare_pickup_latitude?: InputMaybe<Numeric_Comparison_Exp>;
  rideshare_pickup_longitude?: InputMaybe<Numeric_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  stop_id?: InputMaybe<Bigint_Comparison_Exp>;
  surge_cost_percentage?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "lyftrideattempts" */
export enum Lyftrideattempts_Constraint {
  /** unique or primary key constraint on columns "id" */
  LyftrideattemptsIdKey = 'lyftrideattempts_id_key',
  /** unique or primary key constraint on columns "id" */
  LyftrideattemptsPkey = 'lyftrideattempts_pkey'
}

/** input type for incrementing numeric columns in table "lyftrideattempts" */
export type Lyftrideattempts_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_rating?: InputMaybe<Scalars['numeric']['input']>;
  driver_vehicle_year?: InputMaybe<Scalars['bigint']['input']>;
  estimated_cost_max?: InputMaybe<Scalars['numeric']['input']>;
  estimated_cost_min?: InputMaybe<Scalars['numeric']['input']>;
  estimated_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Scalars['numeric']['input']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Scalars['numeric']['input']>;
  stop_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "lyftrideattempts" */
export type Lyftrideattempts_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_first_name?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['String']['input']>;
  driver_phone?: InputMaybe<Scalars['String']['input']>;
  driver_rating?: InputMaybe<Scalars['numeric']['input']>;
  driver_vehicle_color?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_img_url?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_license_plate?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_license_plate_state?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_make?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_model?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_year?: InputMaybe<Scalars['bigint']['input']>;
  estimate_id?: InputMaybe<Scalars['String']['input']>;
  estimated_arrival_time?: InputMaybe<Scalars['timestamptz']['input']>;
  estimated_cost_max?: InputMaybe<Scalars['numeric']['input']>;
  estimated_cost_min?: InputMaybe<Scalars['numeric']['input']>;
  estimated_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lyftride?: InputMaybe<Lyftrides_Obj_Rel_Insert_Input>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  passenger_phone?: InputMaybe<Scalars['String']['input']>;
  requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  requester?: InputMaybe<Scalars['String']['input']>;
  ride?: InputMaybe<Lyftrides_Obj_Rel_Insert_Input>;
  ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Scalars['numeric']['input']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Scalars['bigint']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: InputMaybe<Scalars['String']['input']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: InputMaybe<Scalars['String']['input']>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: InputMaybe<Scalars['String']['input']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Scalars['numeric']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  stop_id?: InputMaybe<Scalars['bigint']['input']>;
  surge_cost_percentage?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Lyftrideattempts_Max_Fields = {
  __typename?: 'lyftrideattempts_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  driver_first_name?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['String']['output']>;
  driver_phone?: Maybe<Scalars['String']['output']>;
  driver_rating?: Maybe<Scalars['numeric']['output']>;
  driver_vehicle_color?: Maybe<Scalars['String']['output']>;
  driver_vehicle_img_url?: Maybe<Scalars['String']['output']>;
  driver_vehicle_license_plate?: Maybe<Scalars['String']['output']>;
  driver_vehicle_license_plate_state?: Maybe<Scalars['String']['output']>;
  driver_vehicle_make?: Maybe<Scalars['String']['output']>;
  driver_vehicle_model?: Maybe<Scalars['String']['output']>;
  driver_vehicle_year?: Maybe<Scalars['bigint']['output']>;
  estimate_id?: Maybe<Scalars['String']['output']>;
  estimated_arrival_time?: Maybe<Scalars['timestamptz']['output']>;
  estimated_cost_max?: Maybe<Scalars['numeric']['output']>;
  estimated_cost_min?: Maybe<Scalars['numeric']['output']>;
  estimated_ride_cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['bigint']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  passenger_phone?: Maybe<Scalars['String']['output']>;
  requested_at?: Maybe<Scalars['timestamptz']['output']>;
  requester?: Maybe<Scalars['String']['output']>;
  ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['numeric']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['numeric']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: Maybe<Scalars['String']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['numeric']['output']>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: Maybe<Scalars['String']['output']>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: Maybe<Scalars['String']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['numeric']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  stop_id?: Maybe<Scalars['bigint']['output']>;
  surge_cost_percentage?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_first_name?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_phone?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_color?: InputMaybe<Order_By>;
  driver_vehicle_img_url?: InputMaybe<Order_By>;
  driver_vehicle_license_plate?: InputMaybe<Order_By>;
  driver_vehicle_license_plate_state?: InputMaybe<Order_By>;
  driver_vehicle_make?: InputMaybe<Order_By>;
  driver_vehicle_model?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimate_id?: InputMaybe<Order_By>;
  estimated_arrival_time?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  passenger_phone?: InputMaybe<Order_By>;
  requested_at?: InputMaybe<Order_By>;
  requester?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: InputMaybe<Order_By>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
  surge_cost_percentage?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Lyftrideattempts_Min_Fields = {
  __typename?: 'lyftrideattempts_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  driver_first_name?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['String']['output']>;
  driver_phone?: Maybe<Scalars['String']['output']>;
  driver_rating?: Maybe<Scalars['numeric']['output']>;
  driver_vehicle_color?: Maybe<Scalars['String']['output']>;
  driver_vehicle_img_url?: Maybe<Scalars['String']['output']>;
  driver_vehicle_license_plate?: Maybe<Scalars['String']['output']>;
  driver_vehicle_license_plate_state?: Maybe<Scalars['String']['output']>;
  driver_vehicle_make?: Maybe<Scalars['String']['output']>;
  driver_vehicle_model?: Maybe<Scalars['String']['output']>;
  driver_vehicle_year?: Maybe<Scalars['bigint']['output']>;
  estimate_id?: Maybe<Scalars['String']['output']>;
  estimated_arrival_time?: Maybe<Scalars['timestamptz']['output']>;
  estimated_cost_max?: Maybe<Scalars['numeric']['output']>;
  estimated_cost_min?: Maybe<Scalars['numeric']['output']>;
  estimated_ride_cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['bigint']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  passenger_phone?: Maybe<Scalars['String']['output']>;
  requested_at?: Maybe<Scalars['timestamptz']['output']>;
  requester?: Maybe<Scalars['String']['output']>;
  ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['numeric']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['numeric']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: Maybe<Scalars['String']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['numeric']['output']>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: Maybe<Scalars['String']['output']>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: Maybe<Scalars['String']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['numeric']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  stop_id?: Maybe<Scalars['bigint']['output']>;
  surge_cost_percentage?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_first_name?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_phone?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_color?: InputMaybe<Order_By>;
  driver_vehicle_img_url?: InputMaybe<Order_By>;
  driver_vehicle_license_plate?: InputMaybe<Order_By>;
  driver_vehicle_license_plate_state?: InputMaybe<Order_By>;
  driver_vehicle_make?: InputMaybe<Order_By>;
  driver_vehicle_model?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimate_id?: InputMaybe<Order_By>;
  estimated_arrival_time?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  passenger_phone?: InputMaybe<Order_By>;
  requested_at?: InputMaybe<Order_By>;
  requester?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: InputMaybe<Order_By>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
  surge_cost_percentage?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "lyftrideattempts" */
export type Lyftrideattempts_Mutation_Response = {
  __typename?: 'lyftrideattempts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Lyftrideattempts>;
};

/** input type for inserting object relation for remote table "lyftrideattempts" */
export type Lyftrideattempts_Obj_Rel_Insert_Input = {
  data: Lyftrideattempts_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Lyftrideattempts_On_Conflict>;
};

/** on_conflict condition type for table "lyftrideattempts" */
export type Lyftrideattempts_On_Conflict = {
  constraint: Lyftrideattempts_Constraint;
  update_columns?: Array<Lyftrideattempts_Update_Column>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};

/** Ordering options when selecting data from "lyftrideattempts". */
export type Lyftrideattempts_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_first_name?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_phone?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_color?: InputMaybe<Order_By>;
  driver_vehicle_img_url?: InputMaybe<Order_By>;
  driver_vehicle_license_plate?: InputMaybe<Order_By>;
  driver_vehicle_license_plate_state?: InputMaybe<Order_By>;
  driver_vehicle_make?: InputMaybe<Order_By>;
  driver_vehicle_model?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimate_id?: InputMaybe<Order_By>;
  estimated_arrival_time?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lyftride?: InputMaybe<Lyftrides_Order_By>;
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  passenger_phone?: InputMaybe<Order_By>;
  requested_at?: InputMaybe<Order_By>;
  requester?: InputMaybe<Order_By>;
  ride?: InputMaybe<Lyftrides_Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  ride_distance?: InputMaybe<Order_By>;
  ride_duration?: InputMaybe<Order_By>;
  ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  rideshare_delivery_address?: InputMaybe<Order_By>;
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  rideshare_id?: InputMaybe<Order_By>;
  rideshare_pickup_address?: InputMaybe<Order_By>;
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
  surge_cost_percentage?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: lyftrideattempts */
export type Lyftrideattempts_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "lyftrideattempts" */
export enum Lyftrideattempts_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DestinationLocationId = 'destination_location_id',
  /** column name */
  DriverFirstName = 'driver_first_name',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverPhone = 'driver_phone',
  /** column name */
  DriverRating = 'driver_rating',
  /** column name */
  DriverVehicleColor = 'driver_vehicle_color',
  /** column name */
  DriverVehicleImgUrl = 'driver_vehicle_img_url',
  /** column name */
  DriverVehicleLicensePlate = 'driver_vehicle_license_plate',
  /** column name */
  DriverVehicleLicensePlateState = 'driver_vehicle_license_plate_state',
  /** column name */
  DriverVehicleMake = 'driver_vehicle_make',
  /** column name */
  DriverVehicleModel = 'driver_vehicle_model',
  /** column name */
  DriverVehicleYear = 'driver_vehicle_year',
  /** column name */
  EstimateId = 'estimate_id',
  /** column name */
  EstimatedArrivalTime = 'estimated_arrival_time',
  /** column name */
  EstimatedCostMax = 'estimated_cost_max',
  /** column name */
  EstimatedCostMin = 'estimated_cost_min',
  /** column name */
  EstimatedRideCost = 'estimated_ride_cost',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  OriginLocationId = 'origin_location_id',
  /** column name */
  PassengerPhone = 'passenger_phone',
  /** column name */
  RequestedAt = 'requested_at',
  /** column name */
  Requester = 'requester',
  /** column name */
  RideCost = 'ride_cost',
  /** column name */
  RideDistance = 'ride_distance',
  /** column name */
  RideDuration = 'ride_duration',
  /** column name */
  RideId = 'ride_id',
  /** column name */
  RideType = 'ride_type',
  /** column name */
  RideshareDeliveryAddress = 'rideshare_delivery_address',
  /** column name */
  RideshareDeliveryLatitude = 'rideshare_delivery_latitude',
  /** column name */
  RideshareDeliveryLongitude = 'rideshare_delivery_longitude',
  /** column name */
  RideshareId = 'rideshare_id',
  /** column name */
  RidesharePickupAddress = 'rideshare_pickup_address',
  /** column name */
  RidesharePickupLatitude = 'rideshare_pickup_latitude',
  /** column name */
  RidesharePickupLongitude = 'rideshare_pickup_longitude',
  /** column name */
  Status = 'status',
  /** column name */
  StopId = 'stop_id',
  /** column name */
  SurgeCostPercentage = 'surge_cost_percentage',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "lyftrideattempts" */
export type Lyftrideattempts_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_first_name?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['String']['input']>;
  driver_phone?: InputMaybe<Scalars['String']['input']>;
  driver_rating?: InputMaybe<Scalars['numeric']['input']>;
  driver_vehicle_color?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_img_url?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_license_plate?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_license_plate_state?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_make?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_model?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_year?: InputMaybe<Scalars['bigint']['input']>;
  estimate_id?: InputMaybe<Scalars['String']['input']>;
  estimated_arrival_time?: InputMaybe<Scalars['timestamptz']['input']>;
  estimated_cost_max?: InputMaybe<Scalars['numeric']['input']>;
  estimated_cost_min?: InputMaybe<Scalars['numeric']['input']>;
  estimated_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  passenger_phone?: InputMaybe<Scalars['String']['input']>;
  requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  requester?: InputMaybe<Scalars['String']['input']>;
  ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Scalars['numeric']['input']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Scalars['bigint']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: InputMaybe<Scalars['String']['input']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: InputMaybe<Scalars['String']['input']>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: InputMaybe<Scalars['String']['input']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Scalars['numeric']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  stop_id?: InputMaybe<Scalars['bigint']['input']>;
  surge_cost_percentage?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Lyftrideattempts_Stddev_Fields = {
  __typename?: 'lyftrideattempts_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Lyftrideattempts_Stddev_Pop_Fields = {
  __typename?: 'lyftrideattempts_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Lyftrideattempts_Stddev_Samp_Fields = {
  __typename?: 'lyftrideattempts_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "lyftrideattempts" */
export type Lyftrideattempts_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lyftrideattempts_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lyftrideattempts_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  destination_location_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_first_name?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['String']['input']>;
  driver_phone?: InputMaybe<Scalars['String']['input']>;
  driver_rating?: InputMaybe<Scalars['numeric']['input']>;
  driver_vehicle_color?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_img_url?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_license_plate?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_license_plate_state?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_make?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_model?: InputMaybe<Scalars['String']['input']>;
  driver_vehicle_year?: InputMaybe<Scalars['bigint']['input']>;
  estimate_id?: InputMaybe<Scalars['String']['input']>;
  estimated_arrival_time?: InputMaybe<Scalars['timestamptz']['input']>;
  estimated_cost_max?: InputMaybe<Scalars['numeric']['input']>;
  estimated_cost_min?: InputMaybe<Scalars['numeric']['input']>;
  estimated_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  origin_location_id?: InputMaybe<Scalars['bigint']['input']>;
  passenger_phone?: InputMaybe<Scalars['String']['input']>;
  requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  requester?: InputMaybe<Scalars['String']['input']>;
  ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Scalars['numeric']['input']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Scalars['bigint']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  /** Address of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_address?: InputMaybe<Scalars['String']['input']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Reference ID gotten from the rideshare partner. Used to reference Lyft or Uber. */
  rideshare_id?: InputMaybe<Scalars['String']['input']>;
  /** Address of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_address?: InputMaybe<Scalars['String']['input']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Scalars['numeric']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  stop_id?: InputMaybe<Scalars['bigint']['input']>;
  surge_cost_percentage?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Lyftrideattempts_Sum_Fields = {
  __typename?: 'lyftrideattempts_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  destination_location_id?: Maybe<Scalars['bigint']['output']>;
  driver_rating?: Maybe<Scalars['numeric']['output']>;
  driver_vehicle_year?: Maybe<Scalars['bigint']['output']>;
  estimated_cost_max?: Maybe<Scalars['numeric']['output']>;
  estimated_cost_min?: Maybe<Scalars['numeric']['output']>;
  estimated_ride_cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['bigint']['output']>;
  origin_location_id?: Maybe<Scalars['bigint']['output']>;
  ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['numeric']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['numeric']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['bigint']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['numeric']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['numeric']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['numeric']['output']>;
  stop_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** update columns of table "lyftrideattempts" */
export enum Lyftrideattempts_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DestinationLocationId = 'destination_location_id',
  /** column name */
  DriverFirstName = 'driver_first_name',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverPhone = 'driver_phone',
  /** column name */
  DriverRating = 'driver_rating',
  /** column name */
  DriverVehicleColor = 'driver_vehicle_color',
  /** column name */
  DriverVehicleImgUrl = 'driver_vehicle_img_url',
  /** column name */
  DriverVehicleLicensePlate = 'driver_vehicle_license_plate',
  /** column name */
  DriverVehicleLicensePlateState = 'driver_vehicle_license_plate_state',
  /** column name */
  DriverVehicleMake = 'driver_vehicle_make',
  /** column name */
  DriverVehicleModel = 'driver_vehicle_model',
  /** column name */
  DriverVehicleYear = 'driver_vehicle_year',
  /** column name */
  EstimateId = 'estimate_id',
  /** column name */
  EstimatedArrivalTime = 'estimated_arrival_time',
  /** column name */
  EstimatedCostMax = 'estimated_cost_max',
  /** column name */
  EstimatedCostMin = 'estimated_cost_min',
  /** column name */
  EstimatedRideCost = 'estimated_ride_cost',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  OriginLocationId = 'origin_location_id',
  /** column name */
  PassengerPhone = 'passenger_phone',
  /** column name */
  RequestedAt = 'requested_at',
  /** column name */
  Requester = 'requester',
  /** column name */
  RideCost = 'ride_cost',
  /** column name */
  RideDistance = 'ride_distance',
  /** column name */
  RideDuration = 'ride_duration',
  /** column name */
  RideId = 'ride_id',
  /** column name */
  RideType = 'ride_type',
  /** column name */
  RideshareDeliveryAddress = 'rideshare_delivery_address',
  /** column name */
  RideshareDeliveryLatitude = 'rideshare_delivery_latitude',
  /** column name */
  RideshareDeliveryLongitude = 'rideshare_delivery_longitude',
  /** column name */
  RideshareId = 'rideshare_id',
  /** column name */
  RidesharePickupAddress = 'rideshare_pickup_address',
  /** column name */
  RidesharePickupLatitude = 'rideshare_pickup_latitude',
  /** column name */
  RidesharePickupLongitude = 'rideshare_pickup_longitude',
  /** column name */
  Status = 'status',
  /** column name */
  StopId = 'stop_id',
  /** column name */
  SurgeCostPercentage = 'surge_cost_percentage',
  /** column name */
  Updatedat = 'updatedat'
}

export type Lyftrideattempts_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Lyftrideattempts_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Lyftrideattempts_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lyftrideattempts_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Lyftrideattempts_Var_Pop_Fields = {
  __typename?: 'lyftrideattempts_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Lyftrideattempts_Var_Samp_Fields = {
  __typename?: 'lyftrideattempts_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Lyftrideattempts_Variance_Fields = {
  __typename?: 'lyftrideattempts_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  destination_location_id?: Maybe<Scalars['Float']['output']>;
  driver_rating?: Maybe<Scalars['Float']['output']>;
  driver_vehicle_year?: Maybe<Scalars['Float']['output']>;
  estimated_cost_max?: Maybe<Scalars['Float']['output']>;
  estimated_cost_min?: Maybe<Scalars['Float']['output']>;
  estimated_ride_cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Deprecated, will be deleted soon */
  move_id?: Maybe<Scalars['Float']['output']>;
  origin_location_id?: Maybe<Scalars['Float']['output']>;
  ride_cost?: Maybe<Scalars['Float']['output']>;
  /** The total distance of the ride in miles */
  ride_distance?: Maybe<Scalars['Float']['output']>;
  /** The total duration of the ride in seconds */
  ride_duration?: Maybe<Scalars['Float']['output']>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: Maybe<Scalars['Float']['output']>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: Maybe<Scalars['Float']['output']>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: Maybe<Scalars['Float']['output']>;
  stop_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "lyftrideattempts" */
export type Lyftrideattempts_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  destination_location_id?: InputMaybe<Order_By>;
  driver_rating?: InputMaybe<Order_By>;
  driver_vehicle_year?: InputMaybe<Order_By>;
  estimated_cost_max?: InputMaybe<Order_By>;
  estimated_cost_min?: InputMaybe<Order_By>;
  estimated_ride_cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Deprecated, will be deleted soon */
  move_id?: InputMaybe<Order_By>;
  origin_location_id?: InputMaybe<Order_By>;
  ride_cost?: InputMaybe<Order_By>;
  /** The total distance of the ride in miles */
  ride_distance?: InputMaybe<Order_By>;
  /** The total duration of the ride in seconds */
  ride_duration?: InputMaybe<Order_By>;
  /** Ride ID to create a ride object relationship for. */
  ride_id?: InputMaybe<Order_By>;
  /** Latitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_latitude?: InputMaybe<Order_By>;
  /** Longitude of the delivery location gotten back from Lyft or Uber. */
  rideshare_delivery_longitude?: InputMaybe<Order_By>;
  /** Latitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_latitude?: InputMaybe<Order_By>;
  /** Longitude of the pickup location gotten back from Lyft or Uber. */
  rideshare_pickup_longitude?: InputMaybe<Order_By>;
  stop_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "lyftrides" */
export type Lyftrides = {
  __typename?: 'lyftrides';
  /** An object relationship */
  activeAttempt?: Maybe<Lyftrideattempts>;
  /** An array relationship */
  activeEstimateAttempts: Array<Lyftrideattempts>;
  /** An aggregate relationship */
  activeEstimateAttempts_aggregate: Lyftrideattempts_Aggregate;
  active_attempt?: Maybe<Scalars['bigint']['output']>;
  active_estimate_attempts?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  attempts: Array<Lyftrideattempts>;
  /** An aggregate relationship */
  attempts_aggregate: Lyftrideattempts_Aggregate;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  decision_reason?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  driversInRidegroupByDriveMoveId?: Maybe<Driversinridegroupbymoveid>;
  /** An object relationship */
  driversInRidegroupByRideMoveId?: Maybe<Driversinridegroupbymoveid>;
  id: Scalars['bigint']['output'];
  last_attempt?: Maybe<Scalars['timestamptz']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['numeric']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['numeric']['output']>;
  /** An object relationship */
  move?: Maybe<Moves>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: Maybe<Scalars['String']['output']>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  ride_move?: Maybe<Moves>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines the current state of the ride. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "lyftrides" */
export type LyftridesActiveEstimateAttemptsArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


/** columns and relationships of "lyftrides" */
export type LyftridesActiveEstimateAttempts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


/** columns and relationships of "lyftrides" */
export type LyftridesAttemptsArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


/** columns and relationships of "lyftrides" */
export type LyftridesAttempts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};

/** aggregated selection of "lyftrides" */
export type Lyftrides_Aggregate = {
  __typename?: 'lyftrides_aggregate';
  aggregate?: Maybe<Lyftrides_Aggregate_Fields>;
  nodes: Array<Lyftrides>;
};

export type Lyftrides_Aggregate_Bool_Exp = {
  count?: InputMaybe<Lyftrides_Aggregate_Bool_Exp_Count>;
};

export type Lyftrides_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Lyftrides_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Lyftrides_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "lyftrides" */
export type Lyftrides_Aggregate_Fields = {
  __typename?: 'lyftrides_aggregate_fields';
  avg?: Maybe<Lyftrides_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Lyftrides_Max_Fields>;
  min?: Maybe<Lyftrides_Min_Fields>;
  stddev?: Maybe<Lyftrides_Stddev_Fields>;
  stddev_pop?: Maybe<Lyftrides_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Lyftrides_Stddev_Samp_Fields>;
  sum?: Maybe<Lyftrides_Sum_Fields>;
  var_pop?: Maybe<Lyftrides_Var_Pop_Fields>;
  var_samp?: Maybe<Lyftrides_Var_Samp_Fields>;
  variance?: Maybe<Lyftrides_Variance_Fields>;
};


/** aggregate fields of "lyftrides" */
export type Lyftrides_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Lyftrides_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "lyftrides" */
export type Lyftrides_Aggregate_Order_By = {
  avg?: InputMaybe<Lyftrides_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Lyftrides_Max_Order_By>;
  min?: InputMaybe<Lyftrides_Min_Order_By>;
  stddev?: InputMaybe<Lyftrides_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Lyftrides_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Lyftrides_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Lyftrides_Sum_Order_By>;
  var_pop?: InputMaybe<Lyftrides_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Lyftrides_Var_Samp_Order_By>;
  variance?: InputMaybe<Lyftrides_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "lyftrides" */
export type Lyftrides_Arr_Rel_Insert_Input = {
  data: Array<Lyftrides_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Lyftrides_On_Conflict>;
};

/** aggregate avg on columns */
export type Lyftrides_Avg_Fields = {
  __typename?: 'lyftrides_avg_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "lyftrides" */
export type Lyftrides_Avg_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "lyftrides". All fields are combined with a logical 'AND'. */
export type Lyftrides_Bool_Exp = {
  _and?: InputMaybe<Array<Lyftrides_Bool_Exp>>;
  _not?: InputMaybe<Lyftrides_Bool_Exp>;
  _or?: InputMaybe<Array<Lyftrides_Bool_Exp>>;
  activeAttempt?: InputMaybe<Lyftrideattempts_Bool_Exp>;
  activeEstimateAttempts?: InputMaybe<Lyftrideattempts_Bool_Exp>;
  activeEstimateAttempts_aggregate?: InputMaybe<Lyftrideattempts_Aggregate_Bool_Exp>;
  active_attempt?: InputMaybe<Bigint_Comparison_Exp>;
  active_estimate_attempts?: InputMaybe<String_Comparison_Exp>;
  attempts?: InputMaybe<Lyftrideattempts_Bool_Exp>;
  attempts_aggregate?: InputMaybe<Lyftrideattempts_Aggregate_Bool_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  decision_reason?: InputMaybe<String_Comparison_Exp>;
  driversInRidegroupByDriveMoveId?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
  driversInRidegroupByRideMoveId?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  last_attempt?: InputMaybe<Timestamptz_Comparison_Exp>;
  latitude?: InputMaybe<Numeric_Comparison_Exp>;
  longitude?: InputMaybe<Numeric_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  passenger_phone?: InputMaybe<String_Comparison_Exp>;
  pickup_location_type?: InputMaybe<String_Comparison_Exp>;
  ride_move?: InputMaybe<Moves_Bool_Exp>;
  ride_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "lyftrides" */
export enum Lyftrides_Constraint {
  /** unique or primary key constraint on columns "active_attempt" */
  LyftridesActiveAttemptKey = 'lyftrides_active_attempt_key',
  /** unique or primary key constraint on columns "id" */
  LyftridesIdKey = 'lyftrides_id_key',
  /** unique or primary key constraint on columns "move_id" */
  LyftridesMoveIdKey = 'lyftrides_move_id_key',
  /** unique or primary key constraint on columns "id" */
  LyftridesPkey = 'lyftrides_pkey',
  /** unique or primary key constraint on columns "ride_move_id" */
  LyftridesRideMoveIdKey = 'lyftrides_ride_move_id_key'
}

/** input type for incrementing numeric columns in table "lyftrides" */
export type Lyftrides_Inc_Input = {
  active_attempt?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "lyftrides" */
export type Lyftrides_Insert_Input = {
  activeAttempt?: InputMaybe<Lyftrideattempts_Obj_Rel_Insert_Input>;
  activeEstimateAttempts?: InputMaybe<Lyftrideattempts_Arr_Rel_Insert_Input>;
  active_attempt?: InputMaybe<Scalars['bigint']['input']>;
  active_estimate_attempts?: InputMaybe<Scalars['String']['input']>;
  attempts?: InputMaybe<Lyftrideattempts_Arr_Rel_Insert_Input>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  decision_reason?: InputMaybe<Scalars['String']['input']>;
  driversInRidegroupByDriveMoveId?: InputMaybe<Driversinridegroupbymoveid_Obj_Rel_Insert_Input>;
  driversInRidegroupByRideMoveId?: InputMaybe<Driversinridegroupbymoveid_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_attempt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: InputMaybe<Scalars['String']['input']>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: InputMaybe<Scalars['String']['input']>;
  ride_move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines the current state of the ride. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Lyftrides_Max_Fields = {
  __typename?: 'lyftrides_max_fields';
  active_attempt?: Maybe<Scalars['bigint']['output']>;
  active_estimate_attempts?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  decision_reason?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_attempt?: Maybe<Scalars['timestamptz']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['numeric']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['numeric']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: Maybe<Scalars['String']['output']>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: Maybe<Scalars['String']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines the current state of the ride. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "lyftrides" */
export type Lyftrides_Max_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  active_estimate_attempts?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  decision_reason?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_attempt?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: InputMaybe<Order_By>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
  /** Determines the current state of the ride. */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Lyftrides_Min_Fields = {
  __typename?: 'lyftrides_min_fields';
  active_attempt?: Maybe<Scalars['bigint']['output']>;
  active_estimate_attempts?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  decision_reason?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_attempt?: Maybe<Scalars['timestamptz']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['numeric']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['numeric']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: Maybe<Scalars['String']['output']>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: Maybe<Scalars['String']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines the current state of the ride. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "lyftrides" */
export type Lyftrides_Min_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  active_estimate_attempts?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  decision_reason?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_attempt?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: InputMaybe<Order_By>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
  /** Determines the current state of the ride. */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "lyftrides" */
export type Lyftrides_Mutation_Response = {
  __typename?: 'lyftrides_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Lyftrides>;
};

/** input type for inserting object relation for remote table "lyftrides" */
export type Lyftrides_Obj_Rel_Insert_Input = {
  data: Lyftrides_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Lyftrides_On_Conflict>;
};

/** on_conflict condition type for table "lyftrides" */
export type Lyftrides_On_Conflict = {
  constraint: Lyftrides_Constraint;
  update_columns?: Array<Lyftrides_Update_Column>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};

/** Ordering options when selecting data from "lyftrides". */
export type Lyftrides_Order_By = {
  activeAttempt?: InputMaybe<Lyftrideattempts_Order_By>;
  activeEstimateAttempts_aggregate?: InputMaybe<Lyftrideattempts_Aggregate_Order_By>;
  active_attempt?: InputMaybe<Order_By>;
  active_estimate_attempts?: InputMaybe<Order_By>;
  attempts_aggregate?: InputMaybe<Lyftrideattempts_Aggregate_Order_By>;
  createdat?: InputMaybe<Order_By>;
  decision_reason?: InputMaybe<Order_By>;
  driversInRidegroupByDriveMoveId?: InputMaybe<Driversinridegroupbymoveid_Order_By>;
  driversInRidegroupByRideMoveId?: InputMaybe<Driversinridegroupbymoveid_Order_By>;
  id?: InputMaybe<Order_By>;
  last_attempt?: InputMaybe<Order_By>;
  latitude?: InputMaybe<Order_By>;
  longitude?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  passenger_phone?: InputMaybe<Order_By>;
  pickup_location_type?: InputMaybe<Order_By>;
  ride_move?: InputMaybe<Moves_Order_By>;
  ride_move_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: lyftrides */
export type Lyftrides_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "lyftrides" */
export enum Lyftrides_Select_Column {
  /** column name */
  ActiveAttempt = 'active_attempt',
  /** column name */
  ActiveEstimateAttempts = 'active_estimate_attempts',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DecisionReason = 'decision_reason',
  /** column name */
  Id = 'id',
  /** column name */
  LastAttempt = 'last_attempt',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PassengerPhone = 'passenger_phone',
  /** column name */
  PickupLocationType = 'pickup_location_type',
  /** column name */
  RideMoveId = 'ride_move_id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "lyftrides" */
export type Lyftrides_Set_Input = {
  active_attempt?: InputMaybe<Scalars['bigint']['input']>;
  active_estimate_attempts?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  decision_reason?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_attempt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: InputMaybe<Scalars['String']['input']>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: InputMaybe<Scalars['String']['input']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines the current state of the ride. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Lyftrides_Stddev_Fields = {
  __typename?: 'lyftrides_stddev_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "lyftrides" */
export type Lyftrides_Stddev_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Lyftrides_Stddev_Pop_Fields = {
  __typename?: 'lyftrides_stddev_pop_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "lyftrides" */
export type Lyftrides_Stddev_Pop_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Lyftrides_Stddev_Samp_Fields = {
  __typename?: 'lyftrides_stddev_samp_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "lyftrides" */
export type Lyftrides_Stddev_Samp_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "lyftrides" */
export type Lyftrides_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lyftrides_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lyftrides_Stream_Cursor_Value_Input = {
  active_attempt?: InputMaybe<Scalars['bigint']['input']>;
  active_estimate_attempts?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  decision_reason?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_attempt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Scalars['numeric']['input']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Scalars['numeric']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** If a non-null value is present, it will be used instead of the SAT driver's default phone number */
  passenger_phone?: InputMaybe<Scalars['String']['input']>;
  /** Indicates what location coordinates are being used for the ride call; either 'database coords', 'phone coords', or 'tookan coords' */
  pickup_location_type?: InputMaybe<Scalars['String']['input']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines the current state of the ride. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Lyftrides_Sum_Fields = {
  __typename?: 'lyftrides_sum_fields';
  active_attempt?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['numeric']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['numeric']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "lyftrides" */
export type Lyftrides_Sum_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** update columns of table "lyftrides" */
export enum Lyftrides_Update_Column {
  /** column name */
  ActiveAttempt = 'active_attempt',
  /** column name */
  ActiveEstimateAttempts = 'active_estimate_attempts',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DecisionReason = 'decision_reason',
  /** column name */
  Id = 'id',
  /** column name */
  LastAttempt = 'last_attempt',
  /** column name */
  Latitude = 'latitude',
  /** column name */
  Longitude = 'longitude',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PassengerPhone = 'passenger_phone',
  /** column name */
  PickupLocationType = 'pickup_location_type',
  /** column name */
  RideMoveId = 'ride_move_id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat'
}

export type Lyftrides_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Lyftrides_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Lyftrides_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lyftrides_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Lyftrides_Var_Pop_Fields = {
  __typename?: 'lyftrides_var_pop_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "lyftrides" */
export type Lyftrides_Var_Pop_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Lyftrides_Var_Samp_Fields = {
  __typename?: 'lyftrides_var_samp_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "lyftrides" */
export type Lyftrides_Var_Samp_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Lyftrides_Variance_Fields = {
  __typename?: 'lyftrides_variance_fields';
  active_attempt?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: Maybe<Scalars['Float']['output']>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "lyftrides" */
export type Lyftrides_Variance_Order_By = {
  active_attempt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default latitude */
  latitude?: InputMaybe<Order_By>;
  /** If a non-null value is present, it will be used instead of the pickup location's default longitude */
  longitude?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Ride-type move ID to create a ride_move object relationship from. */
  ride_move_id?: InputMaybe<Order_By>;
};

/** Pre-aggregated hourly metrics for dashboard performance */
export type Metrics_Hourly = {
  __typename?: 'metrics_hourly';
  avg_duration_ms?: Maybe<Scalars['numeric']['output']>;
  created_at: Scalars['timestamptz']['output'];
  failed_invocations?: Maybe<Scalars['Int']['output']>;
  hour_bucket: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  max_duration_ms?: Maybe<Scalars['Int']['output']>;
  min_duration_ms?: Maybe<Scalars['Int']['output']>;
  most_failed_jobs?: Maybe<Scalars['jsonb']['output']>;
  p95_duration_ms?: Maybe<Scalars['numeric']['output']>;
  source_function: Scalars['String']['output'];
  successful_invocations?: Maybe<Scalars['Int']['output']>;
  top_detected_events?: Maybe<Scalars['jsonb']['output']>;
  total_events_detected?: Maybe<Scalars['Int']['output']>;
  total_invocations?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
};


/** Pre-aggregated hourly metrics for dashboard performance */
export type Metrics_HourlyMost_Failed_JobsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Pre-aggregated hourly metrics for dashboard performance */
export type Metrics_HourlyTop_Detected_EventsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "metrics_hourly" */
export type Metrics_Hourly_Aggregate = {
  __typename?: 'metrics_hourly_aggregate';
  aggregate?: Maybe<Metrics_Hourly_Aggregate_Fields>;
  nodes: Array<Metrics_Hourly>;
};

/** aggregate fields of "metrics_hourly" */
export type Metrics_Hourly_Aggregate_Fields = {
  __typename?: 'metrics_hourly_aggregate_fields';
  avg?: Maybe<Metrics_Hourly_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Metrics_Hourly_Max_Fields>;
  min?: Maybe<Metrics_Hourly_Min_Fields>;
  stddev?: Maybe<Metrics_Hourly_Stddev_Fields>;
  stddev_pop?: Maybe<Metrics_Hourly_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metrics_Hourly_Stddev_Samp_Fields>;
  sum?: Maybe<Metrics_Hourly_Sum_Fields>;
  var_pop?: Maybe<Metrics_Hourly_Var_Pop_Fields>;
  var_samp?: Maybe<Metrics_Hourly_Var_Samp_Fields>;
  variance?: Maybe<Metrics_Hourly_Variance_Fields>;
};


/** aggregate fields of "metrics_hourly" */
export type Metrics_Hourly_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Metrics_Hourly_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Metrics_Hourly_Append_Input = {
  most_failed_jobs?: InputMaybe<Scalars['jsonb']['input']>;
  top_detected_events?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Metrics_Hourly_Avg_Fields = {
  __typename?: 'metrics_hourly_avg_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "metrics_hourly". All fields are combined with a logical 'AND'. */
export type Metrics_Hourly_Bool_Exp = {
  _and?: InputMaybe<Array<Metrics_Hourly_Bool_Exp>>;
  _not?: InputMaybe<Metrics_Hourly_Bool_Exp>;
  _or?: InputMaybe<Array<Metrics_Hourly_Bool_Exp>>;
  avg_duration_ms?: InputMaybe<Numeric_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  failed_invocations?: InputMaybe<Int_Comparison_Exp>;
  hour_bucket?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  max_duration_ms?: InputMaybe<Int_Comparison_Exp>;
  min_duration_ms?: InputMaybe<Int_Comparison_Exp>;
  most_failed_jobs?: InputMaybe<Jsonb_Comparison_Exp>;
  p95_duration_ms?: InputMaybe<Numeric_Comparison_Exp>;
  source_function?: InputMaybe<String_Comparison_Exp>;
  successful_invocations?: InputMaybe<Int_Comparison_Exp>;
  top_detected_events?: InputMaybe<Jsonb_Comparison_Exp>;
  total_events_detected?: InputMaybe<Int_Comparison_Exp>;
  total_invocations?: InputMaybe<Int_Comparison_Exp>;
  total_jobs_run?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "metrics_hourly" */
export enum Metrics_Hourly_Constraint {
  /** unique or primary key constraint on columns "source_function", "hour_bucket" */
  MetricsHourlyHourBucketSourceFunctionKey = 'metrics_hourly_hour_bucket_source_function_key',
  /** unique or primary key constraint on columns "id" */
  MetricsHourlyPkey = 'metrics_hourly_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Metrics_Hourly_Delete_At_Path_Input = {
  most_failed_jobs?: InputMaybe<Array<Scalars['String']['input']>>;
  top_detected_events?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Metrics_Hourly_Delete_Elem_Input = {
  most_failed_jobs?: InputMaybe<Scalars['Int']['input']>;
  top_detected_events?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Metrics_Hourly_Delete_Key_Input = {
  most_failed_jobs?: InputMaybe<Scalars['String']['input']>;
  top_detected_events?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "metrics_hourly" */
export type Metrics_Hourly_Inc_Input = {
  avg_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  failed_invocations?: InputMaybe<Scalars['Int']['input']>;
  max_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  min_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  p95_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  successful_invocations?: InputMaybe<Scalars['Int']['input']>;
  total_events_detected?: InputMaybe<Scalars['Int']['input']>;
  total_invocations?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "metrics_hourly" */
export type Metrics_Hourly_Insert_Input = {
  avg_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  failed_invocations?: InputMaybe<Scalars['Int']['input']>;
  hour_bucket?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  max_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  min_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  most_failed_jobs?: InputMaybe<Scalars['jsonb']['input']>;
  p95_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  source_function?: InputMaybe<Scalars['String']['input']>;
  successful_invocations?: InputMaybe<Scalars['Int']['input']>;
  top_detected_events?: InputMaybe<Scalars['jsonb']['input']>;
  total_events_detected?: InputMaybe<Scalars['Int']['input']>;
  total_invocations?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Metrics_Hourly_Max_Fields = {
  __typename?: 'metrics_hourly_max_fields';
  avg_duration_ms?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  failed_invocations?: Maybe<Scalars['Int']['output']>;
  hour_bucket?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  max_duration_ms?: Maybe<Scalars['Int']['output']>;
  min_duration_ms?: Maybe<Scalars['Int']['output']>;
  p95_duration_ms?: Maybe<Scalars['numeric']['output']>;
  source_function?: Maybe<Scalars['String']['output']>;
  successful_invocations?: Maybe<Scalars['Int']['output']>;
  total_events_detected?: Maybe<Scalars['Int']['output']>;
  total_invocations?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Metrics_Hourly_Min_Fields = {
  __typename?: 'metrics_hourly_min_fields';
  avg_duration_ms?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  failed_invocations?: Maybe<Scalars['Int']['output']>;
  hour_bucket?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  max_duration_ms?: Maybe<Scalars['Int']['output']>;
  min_duration_ms?: Maybe<Scalars['Int']['output']>;
  p95_duration_ms?: Maybe<Scalars['numeric']['output']>;
  source_function?: Maybe<Scalars['String']['output']>;
  successful_invocations?: Maybe<Scalars['Int']['output']>;
  total_events_detected?: Maybe<Scalars['Int']['output']>;
  total_invocations?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "metrics_hourly" */
export type Metrics_Hourly_Mutation_Response = {
  __typename?: 'metrics_hourly_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Metrics_Hourly>;
};

/** on_conflict condition type for table "metrics_hourly" */
export type Metrics_Hourly_On_Conflict = {
  constraint: Metrics_Hourly_Constraint;
  update_columns?: Array<Metrics_Hourly_Update_Column>;
  where?: InputMaybe<Metrics_Hourly_Bool_Exp>;
};

/** Ordering options when selecting data from "metrics_hourly". */
export type Metrics_Hourly_Order_By = {
  avg_duration_ms?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  failed_invocations?: InputMaybe<Order_By>;
  hour_bucket?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_duration_ms?: InputMaybe<Order_By>;
  min_duration_ms?: InputMaybe<Order_By>;
  most_failed_jobs?: InputMaybe<Order_By>;
  p95_duration_ms?: InputMaybe<Order_By>;
  source_function?: InputMaybe<Order_By>;
  successful_invocations?: InputMaybe<Order_By>;
  top_detected_events?: InputMaybe<Order_By>;
  total_events_detected?: InputMaybe<Order_By>;
  total_invocations?: InputMaybe<Order_By>;
  total_jobs_run?: InputMaybe<Order_By>;
};

/** primary key columns input for table: metrics_hourly */
export type Metrics_Hourly_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Metrics_Hourly_Prepend_Input = {
  most_failed_jobs?: InputMaybe<Scalars['jsonb']['input']>;
  top_detected_events?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "metrics_hourly" */
export enum Metrics_Hourly_Select_Column {
  /** column name */
  AvgDurationMs = 'avg_duration_ms',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FailedInvocations = 'failed_invocations',
  /** column name */
  HourBucket = 'hour_bucket',
  /** column name */
  Id = 'id',
  /** column name */
  MaxDurationMs = 'max_duration_ms',
  /** column name */
  MinDurationMs = 'min_duration_ms',
  /** column name */
  MostFailedJobs = 'most_failed_jobs',
  /** column name */
  P95DurationMs = 'p95_duration_ms',
  /** column name */
  SourceFunction = 'source_function',
  /** column name */
  SuccessfulInvocations = 'successful_invocations',
  /** column name */
  TopDetectedEvents = 'top_detected_events',
  /** column name */
  TotalEventsDetected = 'total_events_detected',
  /** column name */
  TotalInvocations = 'total_invocations',
  /** column name */
  TotalJobsRun = 'total_jobs_run'
}

/** input type for updating data in table "metrics_hourly" */
export type Metrics_Hourly_Set_Input = {
  avg_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  failed_invocations?: InputMaybe<Scalars['Int']['input']>;
  hour_bucket?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  max_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  min_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  most_failed_jobs?: InputMaybe<Scalars['jsonb']['input']>;
  p95_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  source_function?: InputMaybe<Scalars['String']['input']>;
  successful_invocations?: InputMaybe<Scalars['Int']['input']>;
  top_detected_events?: InputMaybe<Scalars['jsonb']['input']>;
  total_events_detected?: InputMaybe<Scalars['Int']['input']>;
  total_invocations?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Metrics_Hourly_Stddev_Fields = {
  __typename?: 'metrics_hourly_stddev_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Metrics_Hourly_Stddev_Pop_Fields = {
  __typename?: 'metrics_hourly_stddev_pop_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Metrics_Hourly_Stddev_Samp_Fields = {
  __typename?: 'metrics_hourly_stddev_samp_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "metrics_hourly" */
export type Metrics_Hourly_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Metrics_Hourly_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Metrics_Hourly_Stream_Cursor_Value_Input = {
  avg_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  failed_invocations?: InputMaybe<Scalars['Int']['input']>;
  hour_bucket?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  max_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  min_duration_ms?: InputMaybe<Scalars['Int']['input']>;
  most_failed_jobs?: InputMaybe<Scalars['jsonb']['input']>;
  p95_duration_ms?: InputMaybe<Scalars['numeric']['input']>;
  source_function?: InputMaybe<Scalars['String']['input']>;
  successful_invocations?: InputMaybe<Scalars['Int']['input']>;
  top_detected_events?: InputMaybe<Scalars['jsonb']['input']>;
  total_events_detected?: InputMaybe<Scalars['Int']['input']>;
  total_invocations?: InputMaybe<Scalars['Int']['input']>;
  total_jobs_run?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Metrics_Hourly_Sum_Fields = {
  __typename?: 'metrics_hourly_sum_fields';
  avg_duration_ms?: Maybe<Scalars['numeric']['output']>;
  failed_invocations?: Maybe<Scalars['Int']['output']>;
  max_duration_ms?: Maybe<Scalars['Int']['output']>;
  min_duration_ms?: Maybe<Scalars['Int']['output']>;
  p95_duration_ms?: Maybe<Scalars['numeric']['output']>;
  successful_invocations?: Maybe<Scalars['Int']['output']>;
  total_events_detected?: Maybe<Scalars['Int']['output']>;
  total_invocations?: Maybe<Scalars['Int']['output']>;
  total_jobs_run?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "metrics_hourly" */
export enum Metrics_Hourly_Update_Column {
  /** column name */
  AvgDurationMs = 'avg_duration_ms',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FailedInvocations = 'failed_invocations',
  /** column name */
  HourBucket = 'hour_bucket',
  /** column name */
  Id = 'id',
  /** column name */
  MaxDurationMs = 'max_duration_ms',
  /** column name */
  MinDurationMs = 'min_duration_ms',
  /** column name */
  MostFailedJobs = 'most_failed_jobs',
  /** column name */
  P95DurationMs = 'p95_duration_ms',
  /** column name */
  SourceFunction = 'source_function',
  /** column name */
  SuccessfulInvocations = 'successful_invocations',
  /** column name */
  TopDetectedEvents = 'top_detected_events',
  /** column name */
  TotalEventsDetected = 'total_events_detected',
  /** column name */
  TotalInvocations = 'total_invocations',
  /** column name */
  TotalJobsRun = 'total_jobs_run'
}

export type Metrics_Hourly_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Metrics_Hourly_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Metrics_Hourly_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Metrics_Hourly_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Metrics_Hourly_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Metrics_Hourly_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Metrics_Hourly_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Metrics_Hourly_Set_Input>;
  /** filter the rows which have to be updated */
  where: Metrics_Hourly_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Metrics_Hourly_Var_Pop_Fields = {
  __typename?: 'metrics_hourly_var_pop_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Metrics_Hourly_Var_Samp_Fields = {
  __typename?: 'metrics_hourly_var_samp_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Metrics_Hourly_Variance_Fields = {
  __typename?: 'metrics_hourly_variance_fields';
  avg_duration_ms?: Maybe<Scalars['Float']['output']>;
  failed_invocations?: Maybe<Scalars['Float']['output']>;
  max_duration_ms?: Maybe<Scalars['Float']['output']>;
  min_duration_ms?: Maybe<Scalars['Float']['output']>;
  p95_duration_ms?: Maybe<Scalars['Float']['output']>;
  successful_invocations?: Maybe<Scalars['Float']['output']>;
  total_events_detected?: Maybe<Scalars['Float']['output']>;
  total_invocations?: Maybe<Scalars['Float']['output']>;
  total_jobs_run?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "move_counts_by_customer" */
export type Move_Counts_By_Customer = {
  __typename?: 'move_counts_by_customer';
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  date?: Maybe<Scalars['date']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "move_counts_by_customer" */
export type Move_Counts_By_Customer_Aggregate = {
  __typename?: 'move_counts_by_customer_aggregate';
  aggregate?: Maybe<Move_Counts_By_Customer_Aggregate_Fields>;
  nodes: Array<Move_Counts_By_Customer>;
};

/** aggregate fields of "move_counts_by_customer" */
export type Move_Counts_By_Customer_Aggregate_Fields = {
  __typename?: 'move_counts_by_customer_aggregate_fields';
  avg?: Maybe<Move_Counts_By_Customer_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Move_Counts_By_Customer_Max_Fields>;
  min?: Maybe<Move_Counts_By_Customer_Min_Fields>;
  stddev?: Maybe<Move_Counts_By_Customer_Stddev_Fields>;
  stddev_pop?: Maybe<Move_Counts_By_Customer_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Move_Counts_By_Customer_Stddev_Samp_Fields>;
  sum?: Maybe<Move_Counts_By_Customer_Sum_Fields>;
  var_pop?: Maybe<Move_Counts_By_Customer_Var_Pop_Fields>;
  var_samp?: Maybe<Move_Counts_By_Customer_Var_Samp_Fields>;
  variance?: Maybe<Move_Counts_By_Customer_Variance_Fields>;
};


/** aggregate fields of "move_counts_by_customer" */
export type Move_Counts_By_Customer_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Move_Counts_By_Customer_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Move_Counts_By_Customer_Avg_Fields = {
  __typename?: 'move_counts_by_customer_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "move_counts_by_customer". All fields are combined with a logical 'AND'. */
export type Move_Counts_By_Customer_Bool_Exp = {
  _and?: InputMaybe<Array<Move_Counts_By_Customer_Bool_Exp>>;
  _not?: InputMaybe<Move_Counts_By_Customer_Bool_Exp>;
  _or?: InputMaybe<Array<Move_Counts_By_Customer_Bool_Exp>>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  date?: InputMaybe<Date_Comparison_Exp>;
  move_count?: InputMaybe<Bigint_Comparison_Exp>;
};

/** aggregate max on columns */
export type Move_Counts_By_Customer_Max_Fields = {
  __typename?: 'move_counts_by_customer_max_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  date?: Maybe<Scalars['date']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Move_Counts_By_Customer_Min_Fields = {
  __typename?: 'move_counts_by_customer_min_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  date?: Maybe<Scalars['date']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "move_counts_by_customer". */
export type Move_Counts_By_Customer_Order_By = {
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  date?: InputMaybe<Order_By>;
  move_count?: InputMaybe<Order_By>;
};

/** select columns of table "move_counts_by_customer" */
export enum Move_Counts_By_Customer_Select_Column {
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Date = 'date',
  /** column name */
  MoveCount = 'move_count'
}

/** aggregate stddev on columns */
export type Move_Counts_By_Customer_Stddev_Fields = {
  __typename?: 'move_counts_by_customer_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Move_Counts_By_Customer_Stddev_Pop_Fields = {
  __typename?: 'move_counts_by_customer_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Move_Counts_By_Customer_Stddev_Samp_Fields = {
  __typename?: 'move_counts_by_customer_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "move_counts_by_customer" */
export type Move_Counts_By_Customer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Move_Counts_By_Customer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Move_Counts_By_Customer_Stream_Cursor_Value_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
  move_count?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Move_Counts_By_Customer_Sum_Fields = {
  __typename?: 'move_counts_by_customer_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Move_Counts_By_Customer_Var_Pop_Fields = {
  __typename?: 'move_counts_by_customer_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Move_Counts_By_Customer_Var_Samp_Fields = {
  __typename?: 'move_counts_by_customer_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Move_Counts_By_Customer_Variance_Fields = {
  __typename?: 'move_counts_by_customer_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "move_pricing" */
export type Move_Pricing = {
  __typename?: 'move_pricing';
  applicable_lane_discount?: Maybe<Scalars['numeric']['output']>;
  explain?: Maybe<Scalars['String']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "move_pricing" */
export type Move_Pricing_Aggregate = {
  __typename?: 'move_pricing_aggregate';
  aggregate?: Maybe<Move_Pricing_Aggregate_Fields>;
  nodes: Array<Move_Pricing>;
};

/** aggregate fields of "move_pricing" */
export type Move_Pricing_Aggregate_Fields = {
  __typename?: 'move_pricing_aggregate_fields';
  avg?: Maybe<Move_Pricing_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Move_Pricing_Max_Fields>;
  min?: Maybe<Move_Pricing_Min_Fields>;
  stddev?: Maybe<Move_Pricing_Stddev_Fields>;
  stddev_pop?: Maybe<Move_Pricing_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Move_Pricing_Stddev_Samp_Fields>;
  sum?: Maybe<Move_Pricing_Sum_Fields>;
  var_pop?: Maybe<Move_Pricing_Var_Pop_Fields>;
  var_samp?: Maybe<Move_Pricing_Var_Samp_Fields>;
  variance?: Maybe<Move_Pricing_Variance_Fields>;
};


/** aggregate fields of "move_pricing" */
export type Move_Pricing_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Move_Pricing_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Move_Pricing_Avg_Fields = {
  __typename?: 'move_pricing_avg_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "move_pricing". All fields are combined with a logical 'AND'. */
export type Move_Pricing_Bool_Exp = {
  _and?: InputMaybe<Array<Move_Pricing_Bool_Exp>>;
  _not?: InputMaybe<Move_Pricing_Bool_Exp>;
  _or?: InputMaybe<Array<Move_Pricing_Bool_Exp>>;
  applicable_lane_discount?: InputMaybe<Numeric_Comparison_Exp>;
  explain?: InputMaybe<String_Comparison_Exp>;
  moveid?: InputMaybe<Bigint_Comparison_Exp>;
  price?: InputMaybe<Numeric_Comparison_Exp>;
};

/** input type for inserting data into table "move_pricing" */
export type Move_Pricing_Insert_Input = {
  applicable_lane_discount?: InputMaybe<Scalars['numeric']['input']>;
  explain?: InputMaybe<Scalars['String']['input']>;
  moveid?: InputMaybe<Scalars['bigint']['input']>;
  price?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate max on columns */
export type Move_Pricing_Max_Fields = {
  __typename?: 'move_pricing_max_fields';
  applicable_lane_discount?: Maybe<Scalars['numeric']['output']>;
  explain?: Maybe<Scalars['String']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type Move_Pricing_Min_Fields = {
  __typename?: 'move_pricing_min_fields';
  applicable_lane_discount?: Maybe<Scalars['numeric']['output']>;
  explain?: Maybe<Scalars['String']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
};

/** input type for inserting object relation for remote table "move_pricing" */
export type Move_Pricing_Obj_Rel_Insert_Input = {
  data: Move_Pricing_Insert_Input;
};

/** Ordering options when selecting data from "move_pricing". */
export type Move_Pricing_Order_By = {
  applicable_lane_discount?: InputMaybe<Order_By>;
  explain?: InputMaybe<Order_By>;
  moveid?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
};

/** select columns of table "move_pricing" */
export enum Move_Pricing_Select_Column {
  /** column name */
  ApplicableLaneDiscount = 'applicable_lane_discount',
  /** column name */
  Explain = 'explain',
  /** column name */
  Moveid = 'moveid',
  /** column name */
  Price = 'price'
}

/** aggregate stddev on columns */
export type Move_Pricing_Stddev_Fields = {
  __typename?: 'move_pricing_stddev_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Move_Pricing_Stddev_Pop_Fields = {
  __typename?: 'move_pricing_stddev_pop_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Move_Pricing_Stddev_Samp_Fields = {
  __typename?: 'move_pricing_stddev_samp_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "move_pricing" */
export type Move_Pricing_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Move_Pricing_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Move_Pricing_Stream_Cursor_Value_Input = {
  applicable_lane_discount?: InputMaybe<Scalars['numeric']['input']>;
  explain?: InputMaybe<Scalars['String']['input']>;
  moveid?: InputMaybe<Scalars['bigint']['input']>;
  price?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type Move_Pricing_Sum_Fields = {
  __typename?: 'move_pricing_sum_fields';
  applicable_lane_discount?: Maybe<Scalars['numeric']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  price?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate var_pop on columns */
export type Move_Pricing_Var_Pop_Fields = {
  __typename?: 'move_pricing_var_pop_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Move_Pricing_Var_Samp_Fields = {
  __typename?: 'move_pricing_var_samp_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Move_Pricing_Variance_Fields = {
  __typename?: 'move_pricing_variance_fields';
  applicable_lane_discount?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "move_raterule" */
export type Move_Raterule = {
  __typename?: 'move_raterule';
  active?: Maybe<Scalars['smallint']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  raterulegroup?: Maybe<Raterulegroups>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "move_raterule" */
export type Move_Raterule_Aggregate = {
  __typename?: 'move_raterule_aggregate';
  aggregate?: Maybe<Move_Raterule_Aggregate_Fields>;
  nodes: Array<Move_Raterule>;
};

/** aggregate fields of "move_raterule" */
export type Move_Raterule_Aggregate_Fields = {
  __typename?: 'move_raterule_aggregate_fields';
  avg?: Maybe<Move_Raterule_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Move_Raterule_Max_Fields>;
  min?: Maybe<Move_Raterule_Min_Fields>;
  stddev?: Maybe<Move_Raterule_Stddev_Fields>;
  stddev_pop?: Maybe<Move_Raterule_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Move_Raterule_Stddev_Samp_Fields>;
  sum?: Maybe<Move_Raterule_Sum_Fields>;
  var_pop?: Maybe<Move_Raterule_Var_Pop_Fields>;
  var_samp?: Maybe<Move_Raterule_Var_Samp_Fields>;
  variance?: Maybe<Move_Raterule_Variance_Fields>;
};


/** aggregate fields of "move_raterule" */
export type Move_Raterule_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Move_Raterule_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Move_Raterule_Avg_Fields = {
  __typename?: 'move_raterule_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "move_raterule". All fields are combined with a logical 'AND'. */
export type Move_Raterule_Bool_Exp = {
  _and?: InputMaybe<Array<Move_Raterule_Bool_Exp>>;
  _not?: InputMaybe<Move_Raterule_Bool_Exp>;
  _or?: InputMaybe<Array<Move_Raterule_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  class?: InputMaybe<String_Comparison_Exp>;
  class_3_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_4_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_5_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_6_rate?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  distance_end?: InputMaybe<Numeric_Comparison_Exp>;
  distance_start?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  moveid?: InputMaybe<Bigint_Comparison_Exp>;
  pay_rate_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  rate?: InputMaybe<Numeric_Comparison_Exp>;
  rate_rule_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  raterulegroup?: InputMaybe<Raterulegroups_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** input type for inserting data into table "move_raterule" */
export type Move_Raterule_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  moveid?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  rate?: InputMaybe<Scalars['numeric']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  raterulegroup?: InputMaybe<Raterulegroups_Obj_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Move_Raterule_Max_Fields = {
  __typename?: 'move_raterule_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Move_Raterule_Min_Fields = {
  __typename?: 'move_raterule_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** input type for inserting object relation for remote table "move_raterule" */
export type Move_Raterule_Obj_Rel_Insert_Input = {
  data: Move_Raterule_Insert_Input;
};

/** Ordering options when selecting data from "move_raterule". */
export type Move_Raterule_Order_By = {
  active?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  class_3_rate?: InputMaybe<Order_By>;
  class_4_rate?: InputMaybe<Order_By>;
  class_5_rate?: InputMaybe<Order_By>;
  class_6_rate?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moveid?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  raterulegroup?: InputMaybe<Raterulegroups_Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** select columns of table "move_raterule" */
export enum Move_Raterule_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Class = 'class',
  /** column name */
  Class_3Rate = 'class_3_rate',
  /** column name */
  Class_4Rate = 'class_4_rate',
  /** column name */
  Class_5Rate = 'class_5_rate',
  /** column name */
  Class_6Rate = 'class_6_rate',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DistanceEnd = 'distance_end',
  /** column name */
  DistanceStart = 'distance_start',
  /** column name */
  Id = 'id',
  /** column name */
  Moveid = 'moveid',
  /** column name */
  PayRateGroupId = 'pay_rate_group_id',
  /** column name */
  Rate = 'rate',
  /** column name */
  RateRuleGroupId = 'rate_rule_group_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** aggregate stddev on columns */
export type Move_Raterule_Stddev_Fields = {
  __typename?: 'move_raterule_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Move_Raterule_Stddev_Pop_Fields = {
  __typename?: 'move_raterule_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Move_Raterule_Stddev_Samp_Fields = {
  __typename?: 'move_raterule_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "move_raterule" */
export type Move_Raterule_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Move_Raterule_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Move_Raterule_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  moveid?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  rate?: InputMaybe<Scalars['numeric']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Move_Raterule_Sum_Fields = {
  __typename?: 'move_raterule_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  moveid?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Move_Raterule_Var_Pop_Fields = {
  __typename?: 'move_raterule_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Move_Raterule_Var_Samp_Fields = {
  __typename?: 'move_raterule_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Move_Raterule_Variance_Fields = {
  __typename?: 'move_raterule_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  moveid?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** Move audit table to check against customer tolerances for delivery gps, pickup gps, and duration of move */
export type Moveaudit = {
  __typename?: 'moveaudit';
  /** Combination of GPS location at delivery and delivery inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  delivery_location_within_bounds: Scalars['Boolean']['output'];
  id: Scalars['bigint']['output'];
  /** Contains the audit trail for each check on the move */
  metadata?: Maybe<Scalars['jsonb']['output']>;
  /** Result of the comparing the expected lane duration vs the actual duration of the move. True if within bounds of the customer's tolerance. */
  move_duration_within_bounds: Scalars['Boolean']['output'];
  move_id: Scalars['bigint']['output'];
  /** Combination of GPS location at pickup and pickup inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  pickup_location_within_bounds: Scalars['Boolean']['output'];
};


/** Move audit table to check against customer tolerances for delivery gps, pickup gps, and duration of move */
export type MoveauditMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "moveaudit" */
export type Moveaudit_Aggregate = {
  __typename?: 'moveaudit_aggregate';
  aggregate?: Maybe<Moveaudit_Aggregate_Fields>;
  nodes: Array<Moveaudit>;
};

/** aggregate fields of "moveaudit" */
export type Moveaudit_Aggregate_Fields = {
  __typename?: 'moveaudit_aggregate_fields';
  avg?: Maybe<Moveaudit_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Moveaudit_Max_Fields>;
  min?: Maybe<Moveaudit_Min_Fields>;
  stddev?: Maybe<Moveaudit_Stddev_Fields>;
  stddev_pop?: Maybe<Moveaudit_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moveaudit_Stddev_Samp_Fields>;
  sum?: Maybe<Moveaudit_Sum_Fields>;
  var_pop?: Maybe<Moveaudit_Var_Pop_Fields>;
  var_samp?: Maybe<Moveaudit_Var_Samp_Fields>;
  variance?: Maybe<Moveaudit_Variance_Fields>;
};


/** aggregate fields of "moveaudit" */
export type Moveaudit_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Moveaudit_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Moveaudit_Append_Input = {
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Moveaudit_Avg_Fields = {
  __typename?: 'moveaudit_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "moveaudit". All fields are combined with a logical 'AND'. */
export type Moveaudit_Bool_Exp = {
  _and?: InputMaybe<Array<Moveaudit_Bool_Exp>>;
  _not?: InputMaybe<Moveaudit_Bool_Exp>;
  _or?: InputMaybe<Array<Moveaudit_Bool_Exp>>;
  delivery_location_within_bounds?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  move_duration_within_bounds?: InputMaybe<Boolean_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  pickup_location_within_bounds?: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "moveaudit" */
export enum Moveaudit_Constraint {
  /** unique or primary key constraint on columns "move_id" */
  MoveauditMoveIdKey = 'moveaudit_move_id_key',
  /** unique or primary key constraint on columns "id" */
  MoveauditPkey = 'moveaudit_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Moveaudit_Delete_At_Path_Input = {
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Moveaudit_Delete_Elem_Input = {
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Moveaudit_Delete_Key_Input = {
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "moveaudit" */
export type Moveaudit_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "moveaudit" */
export type Moveaudit_Insert_Input = {
  /** Combination of GPS location at delivery and delivery inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  delivery_location_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Result of the comparing the expected lane duration vs the actual duration of the move. True if within bounds of the customer's tolerance. */
  move_duration_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Combination of GPS location at pickup and pickup inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  pickup_location_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type Moveaudit_Max_Fields = {
  __typename?: 'moveaudit_max_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Moveaudit_Min_Fields = {
  __typename?: 'moveaudit_min_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "moveaudit" */
export type Moveaudit_Mutation_Response = {
  __typename?: 'moveaudit_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Moveaudit>;
};

/** on_conflict condition type for table "moveaudit" */
export type Moveaudit_On_Conflict = {
  constraint: Moveaudit_Constraint;
  update_columns?: Array<Moveaudit_Update_Column>;
  where?: InputMaybe<Moveaudit_Bool_Exp>;
};

/** Ordering options when selecting data from "moveaudit". */
export type Moveaudit_Order_By = {
  delivery_location_within_bounds?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  move_duration_within_bounds?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  pickup_location_within_bounds?: InputMaybe<Order_By>;
};

/** primary key columns input for table: moveaudit */
export type Moveaudit_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Moveaudit_Prepend_Input = {
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "moveaudit" */
export enum Moveaudit_Select_Column {
  /** column name */
  DeliveryLocationWithinBounds = 'delivery_location_within_bounds',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MoveDurationWithinBounds = 'move_duration_within_bounds',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PickupLocationWithinBounds = 'pickup_location_within_bounds'
}

/** input type for updating data in table "moveaudit" */
export type Moveaudit_Set_Input = {
  /** Combination of GPS location at delivery and delivery inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  delivery_location_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Result of the comparing the expected lane duration vs the actual duration of the move. True if within bounds of the customer's tolerance. */
  move_duration_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Combination of GPS location at pickup and pickup inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  pickup_location_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate stddev on columns */
export type Moveaudit_Stddev_Fields = {
  __typename?: 'moveaudit_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Moveaudit_Stddev_Pop_Fields = {
  __typename?: 'moveaudit_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Moveaudit_Stddev_Samp_Fields = {
  __typename?: 'moveaudit_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "moveaudit" */
export type Moveaudit_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Moveaudit_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Moveaudit_Stream_Cursor_Value_Input = {
  /** Combination of GPS location at delivery and delivery inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  delivery_location_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Contains the audit trail for each check on the move */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Result of the comparing the expected lane duration vs the actual duration of the move. True if within bounds of the customer's tolerance. */
  move_duration_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Combination of GPS location at pickup and pickup inspection photo's GPS location. True if within bounds of the customer's tolerance. */
  pickup_location_within_bounds?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate sum on columns */
export type Moveaudit_Sum_Fields = {
  __typename?: 'moveaudit_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "moveaudit" */
export enum Moveaudit_Update_Column {
  /** column name */
  DeliveryLocationWithinBounds = 'delivery_location_within_bounds',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MoveDurationWithinBounds = 'move_duration_within_bounds',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  PickupLocationWithinBounds = 'pickup_location_within_bounds'
}

export type Moveaudit_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Moveaudit_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Moveaudit_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Moveaudit_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Moveaudit_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Moveaudit_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Moveaudit_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Moveaudit_Set_Input>;
  /** filter the rows which have to be updated */
  where: Moveaudit_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Moveaudit_Var_Pop_Fields = {
  __typename?: 'moveaudit_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Moveaudit_Var_Samp_Fields = {
  __typename?: 'moveaudit_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Moveaudit_Variance_Fields = {
  __typename?: 'moveaudit_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "moves" */
export type Moves = {
  __typename?: 'moves';
  /** An array relationship */
  accessorials: Array<Accessorials>;
  /** An aggregate relationship */
  accessorials_aggregate: Accessorials_Aggregate;
  /** An object relationship */
  accountsReceivable?: Maybe<Armoves>;
  active: Scalars['smallint']['output'];
  /** An object relationship */
  activeTime?: Maybe<Activetimes>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  appayments: Array<Appayments>;
  /** An aggregate relationship */
  appayments_aggregate: Appayments_Aggregate;
  /** An object relationship */
  appointment?: Maybe<Appointments>;
  auto_assign: Scalars['smallint']['output'];
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: Maybe<Scalars['String']['output']>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: Maybe<Scalars['timestamptz']['output']>;
  cancel_status?: Maybe<Scalars['String']['output']>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: Maybe<Scalars['timestamptz']['output']>;
  chargeable: Scalars['Boolean']['output'];
  /** An array relationship */
  childMoves: Array<Moves>;
  /** An aggregate relationship */
  childMoves_aggregate: Moves_Aggregate;
  class?: Maybe<Scalars['String']['output']>;
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: Maybe<Scalars['jsonb']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup: Scalars['smallint']['output'];
  consumer_name?: Maybe<Scalars['String']['output']>;
  consumer_phone?: Maybe<Scalars['String']['output']>;
  consumer_pickup?: Maybe<Scalars['Boolean']['output']>;
  consumer_type?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_contact?: Maybe<Scalars['String']['output']>;
  deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  delivery_arrived?: Maybe<Scalars['timestamptz']['output']>;
  delivery_started?: Maybe<Scalars['timestamptz']['output']>;
  delivery_stop_id?: Maybe<Scalars['String']['output']>;
  delivery_successful?: Maybe<Scalars['timestamptz']['output']>;
  delivery_template_override?: Maybe<Scalars['String']['output']>;
  delivery_time?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  delivery_workflow?: Maybe<Workflows>;
  delivery_workflow_data?: Maybe<Scalars['jsonb']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount: Scalars['numeric']['output'];
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  disputed: Scalars['Boolean']['output'];
  /** An object relationship */
  driver?: Maybe<Drivers>;
  /** An object relationship */
  driverPayRate?: Maybe<Driver_Pay_By_Move>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  driversinridegroupbymoveid?: Maybe<Driversinridegroupbymoveid>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  /** An array relationship */
  groupable_moves: Array<Groupable_Moves>;
  /** An aggregate relationship */
  groupable_moves_aggregate: Groupable_Moves_Aggregate;
  /** An array relationship */
  hangtags: Array<Hangtags>;
  /** An aggregate relationship */
  hangtags_aggregate: Hangtags_Aggregate;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  lane?: Maybe<Lanes>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  /** True indicates move is part of the HopDrive Lite service. Its dispatching will be processed on the customer side, and will be excluded from many systems other moves are part of */
  lite: Scalars['Boolean']['output'];
  /** An array relationship */
  lyftRidesByRideMoveId: Array<Lyftrides>;
  /** An aggregate relationship */
  lyftRidesByRideMoveId_aggregate: Lyftrides_Aggregate;
  lyft_flag: Scalars['smallint']['output'];
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  lyft_trigger_move?: Maybe<Moves>;
  /** An object relationship */
  lyftride?: Maybe<Lyftrides>;
  /** An array relationship */
  lyftrides: Array<Lyftrides>;
  /** An aggregate relationship */
  lyftrides_aggregate: Lyftrides_Aggregate;
  manual_flag: Scalars['Boolean']['output'];
  /** An object relationship */
  moveByReturnRideId?: Maybe<Moves>;
  move_details?: Maybe<Scalars['String']['output']>;
  move_failed?: Maybe<Scalars['timestamptz']['output']>;
  move_type: Scalars['String']['output'];
  /** An array relationship */
  moves: Array<Moves>;
  /** An array relationship */
  movesByLyftTriggerId: Array<Moves>;
  /** An aggregate relationship */
  movesByLyftTriggerId_aggregate: Moves_Aggregate;
  /** An array relationship */
  movesByReturnRideId: Array<Moves>;
  /** An aggregate relationship */
  movesByReturnRideId_aggregate: Moves_Aggregate;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** An object relationship */
  parentMove?: Maybe<Moves>;
  /** An object relationship */
  parent_move?: Maybe<Moves>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payable: Scalars['Boolean']['output'];
  /** An object relationship */
  payer?: Maybe<Customers>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_arrived?: Maybe<Scalars['timestamptz']['output']>;
  pickup_started?: Maybe<Scalars['timestamptz']['output']>;
  pickup_stop_id?: Maybe<Scalars['String']['output']>;
  pickup_successful?: Maybe<Scalars['timestamptz']['output']>;
  pickup_template_override?: Maybe<Scalars['String']['output']>;
  pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  pickup_workflow?: Maybe<Workflows>;
  pickup_workflow_data?: Maybe<Scalars['jsonb']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  pinnable: Scalars['Boolean']['output'];
  /** An object relationship */
  plan?: Maybe<Plans>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  price_override?: Maybe<Arpriceoverrides>;
  /** An object relationship */
  pricing?: Maybe<Move_Pricing>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override: Scalars['smallint']['output'];
  /** An object relationship */
  raterule?: Maybe<Move_Raterule>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: Maybe<Scalars['timestamptz']['output']>;
  reference_num?: Maybe<Scalars['String']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  ride?: Maybe<Lyftrides>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: Maybe<Scalars['jsonb']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  ridegroup?: Maybe<Ridegroups>;
  /** An array relationship */
  scenariotomoves: Array<Scenariotomoves>;
  /** An aggregate relationship */
  scenariotomoves_aggregate: Scenariotomoves_Aggregate;
  sequence?: Maybe<Scalars['bigint']['output']>;
  /** If true, prevents editing of move in Admin Portal */
  settled: Scalars['Boolean']['output'];
  /** An object relationship */
  sla?: Maybe<Slas>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  synced_with_tookan?: Maybe<Scalars['timestamptz']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  tookan_relationship_id?: Maybe<Scalars['String']['output']>;
  tracking_link?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  trip?: Maybe<Trips>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  usecase?: Maybe<Usecases>;
  usecase_key?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  vehicle?: Maybe<Vehicles>;
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_image?: Maybe<Scalars['String']['output']>;
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_model?: Maybe<Scalars['String']['output']>;
  vehicle_odometer?: Maybe<Scalars['String']['output']>;
  vehicle_stock?: Maybe<Scalars['String']['output']>;
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  vehicle_year?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  vehiclephotos: Array<Vehiclephotos>;
  /** An aggregate relationship */
  vehiclephotos_aggregate: Vehiclephotos_Aggregate;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  workflowset?: Maybe<Workflowsets>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "moves" */
export type MovesAccessorialsArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesAccessorials_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesAppaymentsArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesAppayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesChildMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesChildMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "moves" */
export type MovesDelivery_Workflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "moves" */
export type MovesEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesGroupable_MovesArgs = {
  distinct_on?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Groupable_Moves_Order_By>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesGroupable_Moves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Groupable_Moves_Order_By>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesHangtagsArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesHangtags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesLyftRidesByRideMoveIdArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesLyftRidesByRideMoveId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesLyftridesArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesLyftrides_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesMovesByLyftTriggerIdArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesMovesByLyftTriggerId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesMovesByReturnRideIdArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesMovesByReturnRideId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesPickup_Workflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "moves" */
export type MovesRide_ConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "moves" */
export type MovesScenariotomovesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesScenariotomoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesVehiclephotosArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesVehiclephotos_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


/** columns and relationships of "moves" */
export type MovesWorkflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "moves" */
export type Moves_Aggregate = {
  __typename?: 'moves_aggregate';
  aggregate?: Maybe<Moves_Aggregate_Fields>;
  nodes: Array<Moves>;
};

export type Moves_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Moves_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Moves_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Moves_Aggregate_Bool_Exp_Count>;
};

export type Moves_Aggregate_Bool_Exp_Bool_And = {
  arguments: Moves_Select_Column_Moves_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Moves_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Moves_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Moves_Select_Column_Moves_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Moves_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Moves_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Moves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Moves_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "moves" */
export type Moves_Aggregate_Fields = {
  __typename?: 'moves_aggregate_fields';
  avg?: Maybe<Moves_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Moves_Max_Fields>;
  min?: Maybe<Moves_Min_Fields>;
  stddev?: Maybe<Moves_Stddev_Fields>;
  stddev_pop?: Maybe<Moves_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moves_Stddev_Samp_Fields>;
  sum?: Maybe<Moves_Sum_Fields>;
  var_pop?: Maybe<Moves_Var_Pop_Fields>;
  var_samp?: Maybe<Moves_Var_Samp_Fields>;
  variance?: Maybe<Moves_Variance_Fields>;
};


/** aggregate fields of "moves" */
export type Moves_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Moves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "moves" */
export type Moves_Aggregate_Order_By = {
  avg?: InputMaybe<Moves_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Moves_Max_Order_By>;
  min?: InputMaybe<Moves_Min_Order_By>;
  stddev?: InputMaybe<Moves_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Moves_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Moves_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Moves_Sum_Order_By>;
  var_pop?: InputMaybe<Moves_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Moves_Var_Samp_Order_By>;
  variance?: InputMaybe<Moves_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Moves_Append_Input = {
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "moves" */
export type Moves_Arr_Rel_Insert_Input = {
  data: Array<Moves_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Moves_On_Conflict>;
};

/** aggregate avg on columns */
export type Moves_Avg_Fields = {
  __typename?: 'moves_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "moves" */
export type Moves_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "moves". All fields are combined with a logical 'AND'. */
export type Moves_Bool_Exp = {
  _and?: InputMaybe<Array<Moves_Bool_Exp>>;
  _not?: InputMaybe<Moves_Bool_Exp>;
  _or?: InputMaybe<Array<Moves_Bool_Exp>>;
  accessorials?: InputMaybe<Accessorials_Bool_Exp>;
  accessorials_aggregate?: InputMaybe<Accessorials_Aggregate_Bool_Exp>;
  accountsReceivable?: InputMaybe<Armoves_Bool_Exp>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  activeTime?: InputMaybe<Activetimes_Bool_Exp>;
  actual_delivery_mileage?: InputMaybe<Bigint_Comparison_Exp>;
  actual_pickup_mileage?: InputMaybe<Bigint_Comparison_Exp>;
  appayments?: InputMaybe<Appayments_Bool_Exp>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Bool_Exp>;
  appointment?: InputMaybe<Appointments_Bool_Exp>;
  auto_assign?: InputMaybe<Smallint_Comparison_Exp>;
  cancel_reason?: InputMaybe<String_Comparison_Exp>;
  cancel_requested_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  cancel_status?: InputMaybe<String_Comparison_Exp>;
  canceled_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  chargeable?: InputMaybe<Boolean_Comparison_Exp>;
  childMoves?: InputMaybe<Moves_Bool_Exp>;
  childMoves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  class?: InputMaybe<String_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  consumer_at_pickup?: InputMaybe<Smallint_Comparison_Exp>;
  consumer_name?: InputMaybe<String_Comparison_Exp>;
  consumer_phone?: InputMaybe<String_Comparison_Exp>;
  consumer_pickup?: InputMaybe<Boolean_Comparison_Exp>;
  consumer_type?: InputMaybe<String_Comparison_Exp>;
  createdBy?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  dealer_contact?: InputMaybe<String_Comparison_Exp>;
  deliver_by?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_arrived?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_started?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_stop_id?: InputMaybe<String_Comparison_Exp>;
  delivery_successful?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_template_override?: InputMaybe<String_Comparison_Exp>;
  delivery_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  delivery_workflow?: InputMaybe<Workflows_Bool_Exp>;
  delivery_workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  delivery_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  discount_amount?: InputMaybe<Numeric_Comparison_Exp>;
  discount_reason?: InputMaybe<String_Comparison_Exp>;
  dispute_reason?: InputMaybe<String_Comparison_Exp>;
  disputed?: InputMaybe<Boolean_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driverPayRate?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
  driver_app_version?: InputMaybe<String_Comparison_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_name?: InputMaybe<String_Comparison_Exp>;
  driver_status?: InputMaybe<String_Comparison_Exp>;
  driversinridegroupbymoveid?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
  earliest_available_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  eventlogs?: InputMaybe<Eventlogs_Bool_Exp>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Bool_Exp>;
  groupable_moves?: InputMaybe<Groupable_Moves_Bool_Exp>;
  groupable_moves_aggregate?: InputMaybe<Groupable_Moves_Aggregate_Bool_Exp>;
  hangtags?: InputMaybe<Hangtags_Bool_Exp>;
  hangtags_aggregate?: InputMaybe<Hangtags_Aggregate_Bool_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  lane?: InputMaybe<Lanes_Bool_Exp>;
  lane_id?: InputMaybe<Bigint_Comparison_Exp>;
  lite?: InputMaybe<Boolean_Comparison_Exp>;
  lyftRidesByRideMoveId?: InputMaybe<Lyftrides_Bool_Exp>;
  lyftRidesByRideMoveId_aggregate?: InputMaybe<Lyftrides_Aggregate_Bool_Exp>;
  lyft_flag?: InputMaybe<Smallint_Comparison_Exp>;
  lyft_trigger_id?: InputMaybe<Bigint_Comparison_Exp>;
  lyft_trigger_move?: InputMaybe<Moves_Bool_Exp>;
  lyftride?: InputMaybe<Lyftrides_Bool_Exp>;
  lyftrides?: InputMaybe<Lyftrides_Bool_Exp>;
  lyftrides_aggregate?: InputMaybe<Lyftrides_Aggregate_Bool_Exp>;
  manual_flag?: InputMaybe<Boolean_Comparison_Exp>;
  moveByReturnRideId?: InputMaybe<Moves_Bool_Exp>;
  move_details?: InputMaybe<String_Comparison_Exp>;
  move_failed?: InputMaybe<Timestamptz_Comparison_Exp>;
  move_type?: InputMaybe<String_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  movesByLyftTriggerId?: InputMaybe<Moves_Bool_Exp>;
  movesByLyftTriggerId_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  movesByReturnRideId?: InputMaybe<Moves_Bool_Exp>;
  movesByReturnRideId_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  parentMove?: InputMaybe<Moves_Bool_Exp>;
  parent_move?: InputMaybe<Moves_Bool_Exp>;
  parent_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  payable?: InputMaybe<Boolean_Comparison_Exp>;
  payer?: InputMaybe<Customers_Bool_Exp>;
  payer_id?: InputMaybe<Bigint_Comparison_Exp>;
  pickup_arrived?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_started?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_stop_id?: InputMaybe<String_Comparison_Exp>;
  pickup_successful?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_template_override?: InputMaybe<String_Comparison_Exp>;
  pickup_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  pickup_workflow?: InputMaybe<Workflows_Bool_Exp>;
  pickup_workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  pickup_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  pinnable?: InputMaybe<Boolean_Comparison_Exp>;
  plan?: InputMaybe<Plans_Bool_Exp>;
  plan_id?: InputMaybe<Bigint_Comparison_Exp>;
  price_override?: InputMaybe<Arpriceoverrides_Bool_Exp>;
  pricing?: InputMaybe<Move_Pricing_Bool_Exp>;
  priority?: InputMaybe<Bigint_Comparison_Exp>;
  rate_class_override?: InputMaybe<Smallint_Comparison_Exp>;
  raterule?: InputMaybe<Move_Raterule_Bool_Exp>;
  ready_by?: InputMaybe<Timestamptz_Comparison_Exp>;
  reference_num?: InputMaybe<String_Comparison_Exp>;
  return_ride_id?: InputMaybe<Bigint_Comparison_Exp>;
  ride?: InputMaybe<Lyftrides_Bool_Exp>;
  ride_config?: InputMaybe<Jsonb_Comparison_Exp>;
  ride_type?: InputMaybe<String_Comparison_Exp>;
  ridegroup?: InputMaybe<Ridegroups_Bool_Exp>;
  scenariotomoves?: InputMaybe<Scenariotomoves_Bool_Exp>;
  scenariotomoves_aggregate?: InputMaybe<Scenariotomoves_Aggregate_Bool_Exp>;
  sequence?: InputMaybe<Bigint_Comparison_Exp>;
  settled?: InputMaybe<Boolean_Comparison_Exp>;
  sla?: InputMaybe<Slas_Bool_Exp>;
  sla_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  synced_with_tookan?: InputMaybe<Timestamptz_Comparison_Exp>;
  tags?: InputMaybe<String_Comparison_Exp>;
  target_pickup_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  tookan_relationship_id?: InputMaybe<String_Comparison_Exp>;
  tracking_link?: InputMaybe<String_Comparison_Exp>;
  trip?: InputMaybe<Trips_Bool_Exp>;
  trip_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedBy?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  usecase?: InputMaybe<Usecases_Bool_Exp>;
  usecase_key?: InputMaybe<String_Comparison_Exp>;
  vehicle?: InputMaybe<Vehicles_Bool_Exp>;
  vehicle_color?: InputMaybe<String_Comparison_Exp>;
  vehicle_gross_weight_lbs?: InputMaybe<Numeric_Comparison_Exp>;
  vehicle_id?: InputMaybe<Bigint_Comparison_Exp>;
  vehicle_image?: InputMaybe<String_Comparison_Exp>;
  vehicle_make?: InputMaybe<String_Comparison_Exp>;
  vehicle_model?: InputMaybe<String_Comparison_Exp>;
  vehicle_odometer?: InputMaybe<String_Comparison_Exp>;
  vehicle_stock?: InputMaybe<String_Comparison_Exp>;
  vehicle_vin?: InputMaybe<String_Comparison_Exp>;
  vehicle_year?: InputMaybe<String_Comparison_Exp>;
  vehiclephotos?: InputMaybe<Vehiclephotos_Bool_Exp>;
  vehiclephotos_aggregate?: InputMaybe<Vehiclephotos_Aggregate_Bool_Exp>;
  workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
  workflowset?: InputMaybe<Workflowsets_Bool_Exp>;
  workflowset_id?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "moves" */
export enum Moves_Constraint {
  /** unique or primary key constraint on columns "id" */
  MovesPkey = 'moves_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Moves_Delete_At_Path_Input = {
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
  delivery_workflow_data?: InputMaybe<Array<Scalars['String']['input']>>;
  pickup_workflow_data?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Moves_Delete_Elem_Input = {
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['Int']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['Int']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['Int']['input']>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['Int']['input']>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Moves_Delete_Key_Input = {
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['String']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['String']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['String']['input']>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['String']['input']>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "moves" */
export type Moves_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  actual_delivery_mileage?: InputMaybe<Scalars['bigint']['input']>;
  actual_pickup_mileage?: InputMaybe<Scalars['bigint']['input']>;
  auto_assign?: InputMaybe<Scalars['smallint']['input']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Scalars['smallint']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  lyft_flag?: InputMaybe<Scalars['smallint']['input']>;
  lyft_trigger_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Scalars['bigint']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  plan_id?: InputMaybe<Scalars['bigint']['input']>;
  priority?: InputMaybe<Scalars['bigint']['input']>;
  rate_class_override?: InputMaybe<Scalars['smallint']['input']>;
  return_ride_id?: InputMaybe<Scalars['bigint']['input']>;
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Scalars['numeric']['input']>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "moves" */
export type Moves_Insert_Input = {
  accessorials?: InputMaybe<Accessorials_Arr_Rel_Insert_Input>;
  accountsReceivable?: InputMaybe<Armoves_Obj_Rel_Insert_Input>;
  active?: InputMaybe<Scalars['smallint']['input']>;
  activeTime?: InputMaybe<Activetimes_Obj_Rel_Insert_Input>;
  actual_delivery_mileage?: InputMaybe<Scalars['bigint']['input']>;
  actual_pickup_mileage?: InputMaybe<Scalars['bigint']['input']>;
  appayments?: InputMaybe<Appayments_Arr_Rel_Insert_Input>;
  appointment?: InputMaybe<Appointments_Obj_Rel_Insert_Input>;
  auto_assign?: InputMaybe<Scalars['smallint']['input']>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cancel_status?: InputMaybe<Scalars['String']['input']>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  chargeable?: InputMaybe<Scalars['Boolean']['input']>;
  childMoves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  class?: InputMaybe<Scalars['String']['input']>;
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Scalars['smallint']['input']>;
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  consumer_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  consumer_type?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_contact?: InputMaybe<Scalars['String']['input']>;
  deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_started?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_stop_id?: InputMaybe<Scalars['String']['input']>;
  delivery_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_template_override?: InputMaybe<Scalars['String']['input']>;
  delivery_time?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_workflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driverPayRate?: InputMaybe<Driver_Pay_By_Move_Obj_Rel_Insert_Input>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: InputMaybe<Scalars['String']['input']>;
  driversinridegroupbymoveid?: InputMaybe<Driversinridegroupbymoveid_Obj_Rel_Insert_Input>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: InputMaybe<Scalars['timestamptz']['input']>;
  eventlogs?: InputMaybe<Eventlogs_Arr_Rel_Insert_Input>;
  groupable_moves?: InputMaybe<Groupable_Moves_Arr_Rel_Insert_Input>;
  hangtags?: InputMaybe<Hangtags_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane?: InputMaybe<Lanes_Obj_Rel_Insert_Input>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  /** True indicates move is part of the HopDrive Lite service. Its dispatching will be processed on the customer side, and will be excluded from many systems other moves are part of */
  lite?: InputMaybe<Scalars['Boolean']['input']>;
  lyftRidesByRideMoveId?: InputMaybe<Lyftrides_Arr_Rel_Insert_Input>;
  lyft_flag?: InputMaybe<Scalars['smallint']['input']>;
  lyft_trigger_id?: InputMaybe<Scalars['bigint']['input']>;
  lyft_trigger_move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  lyftride?: InputMaybe<Lyftrides_Obj_Rel_Insert_Input>;
  lyftrides?: InputMaybe<Lyftrides_Arr_Rel_Insert_Input>;
  manual_flag?: InputMaybe<Scalars['Boolean']['input']>;
  moveByReturnRideId?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_details?: InputMaybe<Scalars['String']['input']>;
  move_failed?: InputMaybe<Scalars['timestamptz']['input']>;
  move_type?: InputMaybe<Scalars['String']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  movesByLyftTriggerId?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  movesByReturnRideId?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  parentMove?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  parent_move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Scalars['bigint']['input']>;
  payable?: InputMaybe<Scalars['Boolean']['input']>;
  payer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_started?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_stop_id?: InputMaybe<Scalars['String']['input']>;
  pickup_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_template_override?: InputMaybe<Scalars['String']['input']>;
  pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_workflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  pinnable?: InputMaybe<Scalars['Boolean']['input']>;
  plan?: InputMaybe<Plans_Obj_Rel_Insert_Input>;
  plan_id?: InputMaybe<Scalars['bigint']['input']>;
  price_override?: InputMaybe<Arpriceoverrides_Obj_Rel_Insert_Input>;
  pricing?: InputMaybe<Move_Pricing_Obj_Rel_Insert_Input>;
  priority?: InputMaybe<Scalars['bigint']['input']>;
  rate_class_override?: InputMaybe<Scalars['smallint']['input']>;
  raterule?: InputMaybe<Move_Raterule_Obj_Rel_Insert_Input>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_num?: InputMaybe<Scalars['String']['input']>;
  return_ride_id?: InputMaybe<Scalars['bigint']['input']>;
  ride?: InputMaybe<Lyftrides_Obj_Rel_Insert_Input>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['jsonb']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  ridegroup?: InputMaybe<Ridegroups_Obj_Rel_Insert_Input>;
  scenariotomoves?: InputMaybe<Scenariotomoves_Arr_Rel_Insert_Input>;
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  /** If true, prevents editing of move in Admin Portal */
  settled?: InputMaybe<Scalars['Boolean']['input']>;
  sla?: InputMaybe<Slas_Obj_Rel_Insert_Input>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  synced_with_tookan?: InputMaybe<Scalars['timestamptz']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  tookan_relationship_id?: InputMaybe<Scalars['String']['input']>;
  tracking_link?: InputMaybe<Scalars['String']['input']>;
  trip?: InputMaybe<Trips_Obj_Rel_Insert_Input>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  usecase?: InputMaybe<Usecases_Obj_Rel_Insert_Input>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
  vehicle?: InputMaybe<Vehicles_Obj_Rel_Insert_Input>;
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Scalars['numeric']['input']>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  vehicle_image?: InputMaybe<Scalars['String']['input']>;
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  vehicle_odometer?: InputMaybe<Scalars['String']['input']>;
  vehicle_stock?: InputMaybe<Scalars['String']['input']>;
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  vehiclephotos?: InputMaybe<Vehiclephotos_Arr_Rel_Insert_Input>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  workflowset?: InputMaybe<Workflowsets_Obj_Rel_Insert_Input>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Moves_Max_Fields = {
  __typename?: 'moves_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: Maybe<Scalars['String']['output']>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: Maybe<Scalars['timestamptz']['output']>;
  cancel_status?: Maybe<Scalars['String']['output']>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: Maybe<Scalars['timestamptz']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  consumer_name?: Maybe<Scalars['String']['output']>;
  consumer_phone?: Maybe<Scalars['String']['output']>;
  consumer_type?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_contact?: Maybe<Scalars['String']['output']>;
  deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  delivery_arrived?: Maybe<Scalars['timestamptz']['output']>;
  delivery_started?: Maybe<Scalars['timestamptz']['output']>;
  delivery_stop_id?: Maybe<Scalars['String']['output']>;
  delivery_successful?: Maybe<Scalars['timestamptz']['output']>;
  delivery_template_override?: Maybe<Scalars['String']['output']>;
  delivery_time?: Maybe<Scalars['timestamptz']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: Maybe<Scalars['String']['output']>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  move_details?: Maybe<Scalars['String']['output']>;
  move_failed?: Maybe<Scalars['timestamptz']['output']>;
  move_type?: Maybe<Scalars['String']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_arrived?: Maybe<Scalars['timestamptz']['output']>;
  pickup_started?: Maybe<Scalars['timestamptz']['output']>;
  pickup_stop_id?: Maybe<Scalars['String']['output']>;
  pickup_successful?: Maybe<Scalars['timestamptz']['output']>;
  pickup_template_override?: Maybe<Scalars['String']['output']>;
  pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: Maybe<Scalars['timestamptz']['output']>;
  reference_num?: Maybe<Scalars['String']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  synced_with_tookan?: Maybe<Scalars['timestamptz']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  tookan_relationship_id?: Maybe<Scalars['String']['output']>;
  tracking_link?: Maybe<Scalars['String']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  usecase_key?: Maybe<Scalars['String']['output']>;
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_image?: Maybe<Scalars['String']['output']>;
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_model?: Maybe<Scalars['String']['output']>;
  vehicle_odometer?: Maybe<Scalars['String']['output']>;
  vehicle_stock?: Maybe<Scalars['String']['output']>;
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  vehicle_year?: Maybe<Scalars['String']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "moves" */
export type Moves_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: InputMaybe<Order_By>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: InputMaybe<Order_By>;
  cancel_status?: InputMaybe<Order_By>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  consumer_type?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_contact?: InputMaybe<Order_By>;
  deliver_by?: InputMaybe<Order_By>;
  delivery_arrived?: InputMaybe<Order_By>;
  delivery_started?: InputMaybe<Order_By>;
  delivery_stop_id?: InputMaybe<Order_By>;
  delivery_successful?: InputMaybe<Order_By>;
  delivery_template_override?: InputMaybe<Order_By>;
  delivery_time?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: InputMaybe<Order_By>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  move_details?: InputMaybe<Order_By>;
  move_failed?: InputMaybe<Order_By>;
  move_type?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_arrived?: InputMaybe<Order_By>;
  pickup_started?: InputMaybe<Order_By>;
  pickup_stop_id?: InputMaybe<Order_By>;
  pickup_successful?: InputMaybe<Order_By>;
  pickup_template_override?: InputMaybe<Order_By>;
  pickup_time?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: InputMaybe<Order_By>;
  reference_num?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  synced_with_tookan?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: InputMaybe<Order_By>;
  tookan_relationship_id?: InputMaybe<Order_By>;
  tracking_link?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  usecase_key?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  vehicle_image?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_odometer?: InputMaybe<Order_By>;
  vehicle_stock?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Moves_Min_Fields = {
  __typename?: 'moves_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: Maybe<Scalars['String']['output']>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: Maybe<Scalars['timestamptz']['output']>;
  cancel_status?: Maybe<Scalars['String']['output']>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: Maybe<Scalars['timestamptz']['output']>;
  class?: Maybe<Scalars['String']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  consumer_name?: Maybe<Scalars['String']['output']>;
  consumer_phone?: Maybe<Scalars['String']['output']>;
  consumer_type?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  dealer_contact?: Maybe<Scalars['String']['output']>;
  deliver_by?: Maybe<Scalars['timestamptz']['output']>;
  delivery_arrived?: Maybe<Scalars['timestamptz']['output']>;
  delivery_started?: Maybe<Scalars['timestamptz']['output']>;
  delivery_stop_id?: Maybe<Scalars['String']['output']>;
  delivery_successful?: Maybe<Scalars['timestamptz']['output']>;
  delivery_template_override?: Maybe<Scalars['String']['output']>;
  delivery_time?: Maybe<Scalars['timestamptz']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  discount_reason?: Maybe<Scalars['String']['output']>;
  dispute_reason?: Maybe<Scalars['String']['output']>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: Maybe<Scalars['String']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: Maybe<Scalars['String']['output']>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  move_details?: Maybe<Scalars['String']['output']>;
  move_failed?: Maybe<Scalars['timestamptz']['output']>;
  move_type?: Maybe<Scalars['String']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_arrived?: Maybe<Scalars['timestamptz']['output']>;
  pickup_started?: Maybe<Scalars['timestamptz']['output']>;
  pickup_stop_id?: Maybe<Scalars['String']['output']>;
  pickup_successful?: Maybe<Scalars['timestamptz']['output']>;
  pickup_template_override?: Maybe<Scalars['String']['output']>;
  pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: Maybe<Scalars['timestamptz']['output']>;
  reference_num?: Maybe<Scalars['String']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  ride_type?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  synced_with_tookan?: Maybe<Scalars['timestamptz']['output']>;
  tags?: Maybe<Scalars['String']['output']>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: Maybe<Scalars['timestamptz']['output']>;
  tookan_relationship_id?: Maybe<Scalars['String']['output']>;
  tracking_link?: Maybe<Scalars['String']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  usecase_key?: Maybe<Scalars['String']['output']>;
  vehicle_color?: Maybe<Scalars['String']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  vehicle_image?: Maybe<Scalars['String']['output']>;
  vehicle_make?: Maybe<Scalars['String']['output']>;
  vehicle_model?: Maybe<Scalars['String']['output']>;
  vehicle_odometer?: Maybe<Scalars['String']['output']>;
  vehicle_stock?: Maybe<Scalars['String']['output']>;
  vehicle_vin?: Maybe<Scalars['String']['output']>;
  vehicle_year?: Maybe<Scalars['String']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "moves" */
export type Moves_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: InputMaybe<Order_By>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: InputMaybe<Order_By>;
  cancel_status?: InputMaybe<Order_By>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: InputMaybe<Order_By>;
  class?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  consumer_type?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_contact?: InputMaybe<Order_By>;
  deliver_by?: InputMaybe<Order_By>;
  delivery_arrived?: InputMaybe<Order_By>;
  delivery_started?: InputMaybe<Order_By>;
  delivery_stop_id?: InputMaybe<Order_By>;
  delivery_successful?: InputMaybe<Order_By>;
  delivery_template_override?: InputMaybe<Order_By>;
  delivery_time?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: InputMaybe<Order_By>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  move_details?: InputMaybe<Order_By>;
  move_failed?: InputMaybe<Order_By>;
  move_type?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_arrived?: InputMaybe<Order_By>;
  pickup_started?: InputMaybe<Order_By>;
  pickup_stop_id?: InputMaybe<Order_By>;
  pickup_successful?: InputMaybe<Order_By>;
  pickup_template_override?: InputMaybe<Order_By>;
  pickup_time?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: InputMaybe<Order_By>;
  reference_num?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  synced_with_tookan?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: InputMaybe<Order_By>;
  tookan_relationship_id?: InputMaybe<Order_By>;
  tracking_link?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  usecase_key?: InputMaybe<Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  vehicle_image?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_odometer?: InputMaybe<Order_By>;
  vehicle_stock?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "moves" */
export type Moves_Mutation_Response = {
  __typename?: 'moves_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Moves>;
};

/** input type for inserting object relation for remote table "moves" */
export type Moves_Obj_Rel_Insert_Input = {
  data: Moves_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Moves_On_Conflict>;
};

/** on_conflict condition type for table "moves" */
export type Moves_On_Conflict = {
  constraint: Moves_Constraint;
  update_columns?: Array<Moves_Update_Column>;
  where?: InputMaybe<Moves_Bool_Exp>;
};

/** Ordering options when selecting data from "moves". */
export type Moves_Order_By = {
  accessorials_aggregate?: InputMaybe<Accessorials_Aggregate_Order_By>;
  accountsReceivable?: InputMaybe<Armoves_Order_By>;
  active?: InputMaybe<Order_By>;
  activeTime?: InputMaybe<Activetimes_Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Order_By>;
  appointment?: InputMaybe<Appointments_Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  cancel_reason?: InputMaybe<Order_By>;
  cancel_requested_at?: InputMaybe<Order_By>;
  cancel_status?: InputMaybe<Order_By>;
  canceled_at?: InputMaybe<Order_By>;
  chargeable?: InputMaybe<Order_By>;
  childMoves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  class?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  consumer_at_pickup?: InputMaybe<Order_By>;
  consumer_name?: InputMaybe<Order_By>;
  consumer_phone?: InputMaybe<Order_By>;
  consumer_pickup?: InputMaybe<Order_By>;
  consumer_type?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  dealer_contact?: InputMaybe<Order_By>;
  deliver_by?: InputMaybe<Order_By>;
  delivery_arrived?: InputMaybe<Order_By>;
  delivery_started?: InputMaybe<Order_By>;
  delivery_stop_id?: InputMaybe<Order_By>;
  delivery_successful?: InputMaybe<Order_By>;
  delivery_template_override?: InputMaybe<Order_By>;
  delivery_time?: InputMaybe<Order_By>;
  delivery_workflow?: InputMaybe<Workflows_Order_By>;
  delivery_workflow_data?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  discount_reason?: InputMaybe<Order_By>;
  dispute_reason?: InputMaybe<Order_By>;
  disputed?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driverPayRate?: InputMaybe<Driver_Pay_By_Move_Order_By>;
  driver_app_version?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  driver_status?: InputMaybe<Order_By>;
  driversinridegroupbymoveid?: InputMaybe<Driversinridegroupbymoveid_Order_By>;
  earliest_available_time?: InputMaybe<Order_By>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Order_By>;
  groupable_moves_aggregate?: InputMaybe<Groupable_Moves_Aggregate_Order_By>;
  hangtags_aggregate?: InputMaybe<Hangtags_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  lane?: InputMaybe<Lanes_Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lite?: InputMaybe<Order_By>;
  lyftRidesByRideMoveId_aggregate?: InputMaybe<Lyftrides_Aggregate_Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  lyft_trigger_move?: InputMaybe<Moves_Order_By>;
  lyftride?: InputMaybe<Lyftrides_Order_By>;
  lyftrides_aggregate?: InputMaybe<Lyftrides_Aggregate_Order_By>;
  manual_flag?: InputMaybe<Order_By>;
  moveByReturnRideId?: InputMaybe<Moves_Order_By>;
  move_details?: InputMaybe<Order_By>;
  move_failed?: InputMaybe<Order_By>;
  move_type?: InputMaybe<Order_By>;
  movesByLyftTriggerId_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  movesByReturnRideId_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  parentMove?: InputMaybe<Moves_Order_By>;
  parent_move?: InputMaybe<Moves_Order_By>;
  parent_move_id?: InputMaybe<Order_By>;
  payable?: InputMaybe<Order_By>;
  payer?: InputMaybe<Customers_Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_arrived?: InputMaybe<Order_By>;
  pickup_started?: InputMaybe<Order_By>;
  pickup_stop_id?: InputMaybe<Order_By>;
  pickup_successful?: InputMaybe<Order_By>;
  pickup_template_override?: InputMaybe<Order_By>;
  pickup_time?: InputMaybe<Order_By>;
  pickup_workflow?: InputMaybe<Workflows_Order_By>;
  pickup_workflow_data?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  pinnable?: InputMaybe<Order_By>;
  plan?: InputMaybe<Plans_Order_By>;
  plan_id?: InputMaybe<Order_By>;
  price_override?: InputMaybe<Arpriceoverrides_Order_By>;
  pricing?: InputMaybe<Move_Pricing_Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  raterule?: InputMaybe<Move_Raterule_Order_By>;
  ready_by?: InputMaybe<Order_By>;
  reference_num?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  ride?: InputMaybe<Lyftrides_Order_By>;
  ride_config?: InputMaybe<Order_By>;
  ride_type?: InputMaybe<Order_By>;
  ridegroup?: InputMaybe<Ridegroups_Order_By>;
  scenariotomoves_aggregate?: InputMaybe<Scenariotomoves_Aggregate_Order_By>;
  sequence?: InputMaybe<Order_By>;
  settled?: InputMaybe<Order_By>;
  sla?: InputMaybe<Slas_Order_By>;
  sla_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  synced_with_tookan?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  target_pickup_time?: InputMaybe<Order_By>;
  tookan_relationship_id?: InputMaybe<Order_By>;
  tracking_link?: InputMaybe<Order_By>;
  trip?: InputMaybe<Trips_Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  usecase?: InputMaybe<Usecases_Order_By>;
  usecase_key?: InputMaybe<Order_By>;
  vehicle?: InputMaybe<Vehicles_Order_By>;
  vehicle_color?: InputMaybe<Order_By>;
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  vehicle_id?: InputMaybe<Order_By>;
  vehicle_image?: InputMaybe<Order_By>;
  vehicle_make?: InputMaybe<Order_By>;
  vehicle_model?: InputMaybe<Order_By>;
  vehicle_odometer?: InputMaybe<Order_By>;
  vehicle_stock?: InputMaybe<Order_By>;
  vehicle_vin?: InputMaybe<Order_By>;
  vehicle_year?: InputMaybe<Order_By>;
  vehiclephotos_aggregate?: InputMaybe<Vehiclephotos_Aggregate_Order_By>;
  workflow_data?: InputMaybe<Order_By>;
  workflowset?: InputMaybe<Workflowsets_Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: moves */
export type Moves_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Moves_Prepend_Input = {
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "moves" */
export enum Moves_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  ActualDeliveryMileage = 'actual_delivery_mileage',
  /** column name */
  ActualPickupMileage = 'actual_pickup_mileage',
  /** column name */
  AutoAssign = 'auto_assign',
  /** column name */
  CancelReason = 'cancel_reason',
  /** column name */
  CancelRequestedAt = 'cancel_requested_at',
  /** column name */
  CancelStatus = 'cancel_status',
  /** column name */
  CanceledAt = 'canceled_at',
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  Class = 'class',
  /** column name */
  Config = 'config',
  /** column name */
  ConsumerAtPickup = 'consumer_at_pickup',
  /** column name */
  ConsumerName = 'consumer_name',
  /** column name */
  ConsumerPhone = 'consumer_phone',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  ConsumerType = 'consumer_type',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DealerContact = 'dealer_contact',
  /** column name */
  DeliverBy = 'deliver_by',
  /** column name */
  DeliveryArrived = 'delivery_arrived',
  /** column name */
  DeliveryStarted = 'delivery_started',
  /** column name */
  DeliveryStopId = 'delivery_stop_id',
  /** column name */
  DeliverySuccessful = 'delivery_successful',
  /** column name */
  DeliveryTemplateOverride = 'delivery_template_override',
  /** column name */
  DeliveryTime = 'delivery_time',
  /** column name */
  DeliveryWorkflowData = 'delivery_workflow_data',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DriverAppVersion = 'driver_app_version',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  DriverStatus = 'driver_status',
  /** column name */
  EarliestAvailableTime = 'earliest_available_time',
  /** column name */
  Id = 'id',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  Lite = 'lite',
  /** column name */
  LyftFlag = 'lyft_flag',
  /** column name */
  LyftTriggerId = 'lyft_trigger_id',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  MoveDetails = 'move_details',
  /** column name */
  MoveFailed = 'move_failed',
  /** column name */
  MoveType = 'move_type',
  /** column name */
  ParentMoveId = 'parent_move_id',
  /** column name */
  Payable = 'payable',
  /** column name */
  PayerId = 'payer_id',
  /** column name */
  PickupArrived = 'pickup_arrived',
  /** column name */
  PickupStarted = 'pickup_started',
  /** column name */
  PickupStopId = 'pickup_stop_id',
  /** column name */
  PickupSuccessful = 'pickup_successful',
  /** column name */
  PickupTemplateOverride = 'pickup_template_override',
  /** column name */
  PickupTime = 'pickup_time',
  /** column name */
  PickupWorkflowData = 'pickup_workflow_data',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  PlanId = 'plan_id',
  /** column name */
  Priority = 'priority',
  /** column name */
  RateClassOverride = 'rate_class_override',
  /** column name */
  ReadyBy = 'ready_by',
  /** column name */
  ReferenceNum = 'reference_num',
  /** column name */
  ReturnRideId = 'return_ride_id',
  /** column name */
  RideConfig = 'ride_config',
  /** column name */
  RideType = 'ride_type',
  /** column name */
  Sequence = 'sequence',
  /** column name */
  Settled = 'settled',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Status = 'status',
  /** column name */
  SyncedWithTookan = 'synced_with_tookan',
  /** column name */
  Tags = 'tags',
  /** column name */
  TargetPickupTime = 'target_pickup_time',
  /** column name */
  TookanRelationshipId = 'tookan_relationship_id',
  /** column name */
  TrackingLink = 'tracking_link',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  UsecaseKey = 'usecase_key',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleGrossWeightLbs = 'vehicle_gross_weight_lbs',
  /** column name */
  VehicleId = 'vehicle_id',
  /** column name */
  VehicleImage = 'vehicle_image',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleOdometer = 'vehicle_odometer',
  /** column name */
  VehicleStock = 'vehicle_stock',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  WorkflowData = 'workflow_data',
  /** column name */
  WorkflowsetId = 'workflowset_id'
}

/** select "moves_aggregate_bool_exp_bool_and_arguments_columns" columns of table "moves" */
export enum Moves_Select_Column_Moves_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  Lite = 'lite',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  Payable = 'payable',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  Settled = 'settled'
}

/** select "moves_aggregate_bool_exp_bool_or_arguments_columns" columns of table "moves" */
export enum Moves_Select_Column_Moves_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  Lite = 'lite',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  Payable = 'payable',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  Settled = 'settled'
}

/** input type for updating data in table "moves" */
export type Moves_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  actual_delivery_mileage?: InputMaybe<Scalars['bigint']['input']>;
  actual_pickup_mileage?: InputMaybe<Scalars['bigint']['input']>;
  auto_assign?: InputMaybe<Scalars['smallint']['input']>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cancel_status?: InputMaybe<Scalars['String']['input']>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  chargeable?: InputMaybe<Scalars['Boolean']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Scalars['smallint']['input']>;
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  consumer_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  consumer_type?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_contact?: InputMaybe<Scalars['String']['input']>;
  deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_started?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_stop_id?: InputMaybe<Scalars['String']['input']>;
  delivery_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_template_override?: InputMaybe<Scalars['String']['input']>;
  delivery_time?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: InputMaybe<Scalars['String']['input']>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  /** True indicates move is part of the HopDrive Lite service. Its dispatching will be processed on the customer side, and will be excluded from many systems other moves are part of */
  lite?: InputMaybe<Scalars['Boolean']['input']>;
  lyft_flag?: InputMaybe<Scalars['smallint']['input']>;
  lyft_trigger_id?: InputMaybe<Scalars['bigint']['input']>;
  manual_flag?: InputMaybe<Scalars['Boolean']['input']>;
  move_details?: InputMaybe<Scalars['String']['input']>;
  move_failed?: InputMaybe<Scalars['timestamptz']['input']>;
  move_type?: InputMaybe<Scalars['String']['input']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Scalars['bigint']['input']>;
  payable?: InputMaybe<Scalars['Boolean']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_started?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_stop_id?: InputMaybe<Scalars['String']['input']>;
  pickup_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_template_override?: InputMaybe<Scalars['String']['input']>;
  pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  pinnable?: InputMaybe<Scalars['Boolean']['input']>;
  plan_id?: InputMaybe<Scalars['bigint']['input']>;
  priority?: InputMaybe<Scalars['bigint']['input']>;
  rate_class_override?: InputMaybe<Scalars['smallint']['input']>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_num?: InputMaybe<Scalars['String']['input']>;
  return_ride_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['jsonb']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  /** If true, prevents editing of move in Admin Portal */
  settled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  synced_with_tookan?: InputMaybe<Scalars['timestamptz']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  tookan_relationship_id?: InputMaybe<Scalars['String']['input']>;
  tracking_link?: InputMaybe<Scalars['String']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Scalars['numeric']['input']>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  vehicle_image?: InputMaybe<Scalars['String']['input']>;
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  vehicle_odometer?: InputMaybe<Scalars['String']['input']>;
  vehicle_stock?: InputMaybe<Scalars['String']['input']>;
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Moves_Stddev_Fields = {
  __typename?: 'moves_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "moves" */
export type Moves_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Moves_Stddev_Pop_Fields = {
  __typename?: 'moves_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "moves" */
export type Moves_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Moves_Stddev_Samp_Fields = {
  __typename?: 'moves_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "moves" */
export type Moves_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "moves" */
export type Moves_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Moves_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Moves_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  actual_delivery_mileage?: InputMaybe<Scalars['bigint']['input']>;
  actual_pickup_mileage?: InputMaybe<Scalars['bigint']['input']>;
  auto_assign?: InputMaybe<Scalars['smallint']['input']>;
  /** Reason for canceling the move (customer facing) */
  cancel_reason?: InputMaybe<Scalars['String']['input']>;
  /** When was the move requested to be canceled? */
  cancel_requested_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cancel_status?: InputMaybe<Scalars['String']['input']>;
  /** When was the move actually canceled by an admin? */
  canceled_at?: InputMaybe<Scalars['timestamptz']['input']>;
  chargeable?: InputMaybe<Scalars['Boolean']['input']>;
  class?: InputMaybe<Scalars['String']['input']>;
  /** Dynamic configuration added to a move. Can be customized by a dealer when creating a move. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Scalars['smallint']['input']>;
  consumer_name?: InputMaybe<Scalars['String']['input']>;
  consumer_phone?: InputMaybe<Scalars['String']['input']>;
  consumer_pickup?: InputMaybe<Scalars['Boolean']['input']>;
  consumer_type?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  dealer_contact?: InputMaybe<Scalars['String']['input']>;
  deliver_by?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_started?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_stop_id?: InputMaybe<Scalars['String']['input']>;
  delivery_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_template_override?: InputMaybe<Scalars['String']['input']>;
  delivery_time?: InputMaybe<Scalars['timestamptz']['input']>;
  delivery_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  discount_amount?: InputMaybe<Scalars['numeric']['input']>;
  discount_reason?: InputMaybe<Scalars['String']['input']>;
  dispute_reason?: InputMaybe<Scalars['String']['input']>;
  disputed?: InputMaybe<Scalars['Boolean']['input']>;
  /** To support the driver app, we record the version used for that move. Tookan will be 1.0.0, and our own driver app will start with 2.0.0 and version up from there. */
  driver_app_version?: InputMaybe<Scalars['String']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  /** Lifecycle status for driver accept or reject of the move after assignment. Possible values are unassigned | assigned | accepted | rejected. After a move is planned to a driver, the plan_id, driver_id, and driver_name is set and now this field will also be set then from unassigned to assigned. Once the driver accepts that move in the driver app, it will change to accepted, otherwise if it is declined, this driver_status will change to rejected. */
  driver_status?: InputMaybe<Scalars['String']['input']>;
  /** Earliest the move can contractually be started according to business hours. Will always be after the ready_by time. */
  earliest_available_time?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  lane_id?: InputMaybe<Scalars['bigint']['input']>;
  /** True indicates move is part of the HopDrive Lite service. Its dispatching will be processed on the customer side, and will be excluded from many systems other moves are part of */
  lite?: InputMaybe<Scalars['Boolean']['input']>;
  lyft_flag?: InputMaybe<Scalars['smallint']['input']>;
  lyft_trigger_id?: InputMaybe<Scalars['bigint']['input']>;
  manual_flag?: InputMaybe<Scalars['Boolean']['input']>;
  move_details?: InputMaybe<Scalars['String']['input']>;
  move_failed?: InputMaybe<Scalars['timestamptz']['input']>;
  move_type?: InputMaybe<Scalars['String']['input']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Scalars['bigint']['input']>;
  payable?: InputMaybe<Scalars['Boolean']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_arrived?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_started?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_stop_id?: InputMaybe<Scalars['String']['input']>;
  pickup_successful?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_template_override?: InputMaybe<Scalars['String']['input']>;
  pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  pickup_workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  pinnable?: InputMaybe<Scalars['Boolean']['input']>;
  plan_id?: InputMaybe<Scalars['bigint']['input']>;
  priority?: InputMaybe<Scalars['bigint']['input']>;
  rate_class_override?: InputMaybe<Scalars['smallint']['input']>;
  /** Time the vehicle is ready to be moved (set by customer) */
  ready_by?: InputMaybe<Scalars['timestamptz']['input']>;
  reference_num?: InputMaybe<Scalars['String']['input']>;
  return_ride_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Config for ride algorithm selection and quality criteria */
  ride_config?: InputMaybe<Scalars['jsonb']['input']>;
  ride_type?: InputMaybe<Scalars['String']['input']>;
  sequence?: InputMaybe<Scalars['bigint']['input']>;
  /** If true, prevents editing of move in Admin Portal */
  settled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  synced_with_tookan?: InputMaybe<Scalars['timestamptz']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  /** Target time for our driver to arrive at the pickup. This field is used for appointments and time-sensitive moves. */
  target_pickup_time?: InputMaybe<Scalars['timestamptz']['input']>;
  tookan_relationship_id?: InputMaybe<Scalars['String']['input']>;
  tracking_link?: InputMaybe<Scalars['String']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
  vehicle_color?: InputMaybe<Scalars['String']['input']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Scalars['numeric']['input']>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Scalars['bigint']['input']>;
  vehicle_image?: InputMaybe<Scalars['String']['input']>;
  vehicle_make?: InputMaybe<Scalars['String']['input']>;
  vehicle_model?: InputMaybe<Scalars['String']['input']>;
  vehicle_odometer?: InputMaybe<Scalars['String']['input']>;
  vehicle_stock?: InputMaybe<Scalars['String']['input']>;
  vehicle_vin?: InputMaybe<Scalars['String']['input']>;
  vehicle_year?: InputMaybe<Scalars['String']['input']>;
  /** Dynamic workflow data from custom Tookan templates. These can only be stored in a JSONB format because they depend on the customer. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Moves_Sum_Fields = {
  __typename?: 'moves_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['bigint']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['bigint']['output']>;
  auto_assign?: Maybe<Scalars['smallint']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['smallint']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  discount_amount?: Maybe<Scalars['numeric']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  lane_id?: Maybe<Scalars['bigint']['output']>;
  lyft_flag?: Maybe<Scalars['smallint']['output']>;
  lyft_trigger_id?: Maybe<Scalars['bigint']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  plan_id?: Maybe<Scalars['bigint']['output']>;
  priority?: Maybe<Scalars['bigint']['output']>;
  rate_class_override?: Maybe<Scalars['smallint']['output']>;
  return_ride_id?: Maybe<Scalars['bigint']['output']>;
  sequence?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['numeric']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "moves" */
export type Moves_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** update columns of table "moves" */
export enum Moves_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  ActualDeliveryMileage = 'actual_delivery_mileage',
  /** column name */
  ActualPickupMileage = 'actual_pickup_mileage',
  /** column name */
  AutoAssign = 'auto_assign',
  /** column name */
  CancelReason = 'cancel_reason',
  /** column name */
  CancelRequestedAt = 'cancel_requested_at',
  /** column name */
  CancelStatus = 'cancel_status',
  /** column name */
  CanceledAt = 'canceled_at',
  /** column name */
  Chargeable = 'chargeable',
  /** column name */
  Class = 'class',
  /** column name */
  Config = 'config',
  /** column name */
  ConsumerAtPickup = 'consumer_at_pickup',
  /** column name */
  ConsumerName = 'consumer_name',
  /** column name */
  ConsumerPhone = 'consumer_phone',
  /** column name */
  ConsumerPickup = 'consumer_pickup',
  /** column name */
  ConsumerType = 'consumer_type',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DealerContact = 'dealer_contact',
  /** column name */
  DeliverBy = 'deliver_by',
  /** column name */
  DeliveryArrived = 'delivery_arrived',
  /** column name */
  DeliveryStarted = 'delivery_started',
  /** column name */
  DeliveryStopId = 'delivery_stop_id',
  /** column name */
  DeliverySuccessful = 'delivery_successful',
  /** column name */
  DeliveryTemplateOverride = 'delivery_template_override',
  /** column name */
  DeliveryTime = 'delivery_time',
  /** column name */
  DeliveryWorkflowData = 'delivery_workflow_data',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  DiscountAmount = 'discount_amount',
  /** column name */
  DiscountReason = 'discount_reason',
  /** column name */
  DisputeReason = 'dispute_reason',
  /** column name */
  Disputed = 'disputed',
  /** column name */
  DriverAppVersion = 'driver_app_version',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  DriverStatus = 'driver_status',
  /** column name */
  EarliestAvailableTime = 'earliest_available_time',
  /** column name */
  Id = 'id',
  /** column name */
  LaneId = 'lane_id',
  /** column name */
  Lite = 'lite',
  /** column name */
  LyftFlag = 'lyft_flag',
  /** column name */
  LyftTriggerId = 'lyft_trigger_id',
  /** column name */
  ManualFlag = 'manual_flag',
  /** column name */
  MoveDetails = 'move_details',
  /** column name */
  MoveFailed = 'move_failed',
  /** column name */
  MoveType = 'move_type',
  /** column name */
  ParentMoveId = 'parent_move_id',
  /** column name */
  Payable = 'payable',
  /** column name */
  PayerId = 'payer_id',
  /** column name */
  PickupArrived = 'pickup_arrived',
  /** column name */
  PickupStarted = 'pickup_started',
  /** column name */
  PickupStopId = 'pickup_stop_id',
  /** column name */
  PickupSuccessful = 'pickup_successful',
  /** column name */
  PickupTemplateOverride = 'pickup_template_override',
  /** column name */
  PickupTime = 'pickup_time',
  /** column name */
  PickupWorkflowData = 'pickup_workflow_data',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  Pinnable = 'pinnable',
  /** column name */
  PlanId = 'plan_id',
  /** column name */
  Priority = 'priority',
  /** column name */
  RateClassOverride = 'rate_class_override',
  /** column name */
  ReadyBy = 'ready_by',
  /** column name */
  ReferenceNum = 'reference_num',
  /** column name */
  ReturnRideId = 'return_ride_id',
  /** column name */
  RideConfig = 'ride_config',
  /** column name */
  RideType = 'ride_type',
  /** column name */
  Sequence = 'sequence',
  /** column name */
  Settled = 'settled',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Status = 'status',
  /** column name */
  SyncedWithTookan = 'synced_with_tookan',
  /** column name */
  Tags = 'tags',
  /** column name */
  TargetPickupTime = 'target_pickup_time',
  /** column name */
  TookanRelationshipId = 'tookan_relationship_id',
  /** column name */
  TrackingLink = 'tracking_link',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  UsecaseKey = 'usecase_key',
  /** column name */
  VehicleColor = 'vehicle_color',
  /** column name */
  VehicleGrossWeightLbs = 'vehicle_gross_weight_lbs',
  /** column name */
  VehicleId = 'vehicle_id',
  /** column name */
  VehicleImage = 'vehicle_image',
  /** column name */
  VehicleMake = 'vehicle_make',
  /** column name */
  VehicleModel = 'vehicle_model',
  /** column name */
  VehicleOdometer = 'vehicle_odometer',
  /** column name */
  VehicleStock = 'vehicle_stock',
  /** column name */
  VehicleVin = 'vehicle_vin',
  /** column name */
  VehicleYear = 'vehicle_year',
  /** column name */
  WorkflowData = 'workflow_data',
  /** column name */
  WorkflowsetId = 'workflowset_id'
}

export type Moves_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Moves_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Moves_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Moves_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Moves_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Moves_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Moves_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Moves_Set_Input>;
  /** filter the rows which have to be updated */
  where: Moves_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Moves_Var_Pop_Fields = {
  __typename?: 'moves_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "moves" */
export type Moves_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Moves_Var_Samp_Fields = {
  __typename?: 'moves_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "moves" */
export type Moves_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Moves_Variance_Fields = {
  __typename?: 'moves_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  actual_delivery_mileage?: Maybe<Scalars['Float']['output']>;
  actual_pickup_mileage?: Maybe<Scalars['Float']['output']>;
  auto_assign?: Maybe<Scalars['Float']['output']>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  discount_amount?: Maybe<Scalars['Float']['output']>;
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  lane_id?: Maybe<Scalars['Float']['output']>;
  lyft_flag?: Maybe<Scalars['Float']['output']>;
  lyft_trigger_id?: Maybe<Scalars['Float']['output']>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  plan_id?: Maybe<Scalars['Float']['output']>;
  priority?: Maybe<Scalars['Float']['output']>;
  rate_class_override?: Maybe<Scalars['Float']['output']>;
  return_ride_id?: Maybe<Scalars['Float']['output']>;
  sequence?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: Maybe<Scalars['Float']['output']>;
  /** relates move to a vehicle */
  vehicle_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "moves" */
export type Moves_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  actual_delivery_mileage?: InputMaybe<Order_By>;
  actual_pickup_mileage?: InputMaybe<Order_By>;
  auto_assign?: InputMaybe<Order_By>;
  /** Signifies whether or not a concierge move's end consumer is at the pickup location (0 = either not a concierge move or consumer is at delivery, 1 = consumer is at pickup) */
  consumer_at_pickup?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  discount_amount?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lane_id?: InputMaybe<Order_By>;
  lyft_flag?: InputMaybe<Order_By>;
  lyft_trigger_id?: InputMaybe<Order_By>;
  /** The id of a ride move's "parent" drive move. The inverse of and replacement for return_ride_id */
  parent_move_id?: InputMaybe<Order_By>;
  payer_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  plan_id?: InputMaybe<Order_By>;
  priority?: InputMaybe<Order_By>;
  rate_class_override?: InputMaybe<Order_By>;
  return_ride_id?: InputMaybe<Order_By>;
  sequence?: InputMaybe<Order_By>;
  /** Relationship to the SLA record that helps determine deliver_by time. */
  sla_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  /** The gross weight value of the vehicle in pounds */
  vehicle_gross_weight_lbs?: InputMaybe<Order_By>;
  /** relates move to a vehicle */
  vehicle_id?: InputMaybe<Order_By>;
  /** Relationship to the workflowset of this move. */
  workflowset_id?: InputMaybe<Order_By>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "accessorials" */
  delete_accessorials?: Maybe<Accessorials_Mutation_Response>;
  /** delete single row from the table: "accessorials" */
  delete_accessorials_by_pk?: Maybe<Accessorials>;
  /** delete data from the table: "accessorialstoalgorithms" */
  delete_accessorialstoalgorithms?: Maybe<Accessorialstoalgorithms_Mutation_Response>;
  /** delete single row from the table: "accessorialstoalgorithms" */
  delete_accessorialstoalgorithms_by_pk?: Maybe<Accessorialstoalgorithms>;
  /** delete data from the table: "actiontypes" */
  delete_actiontypes?: Maybe<Actiontypes_Mutation_Response>;
  /** delete single row from the table: "actiontypes" */
  delete_actiontypes_by_pk?: Maybe<Actiontypes>;
  /** delete data from the table: "activetimes" */
  delete_activetimes?: Maybe<Activetimes_Mutation_Response>;
  /** delete single row from the table: "activetimes" */
  delete_activetimes_by_pk?: Maybe<Activetimes>;
  /** delete data from the table: "algorithms" */
  delete_algorithms?: Maybe<Algorithms_Mutation_Response>;
  /** delete single row from the table: "algorithms" */
  delete_algorithms_by_pk?: Maybe<Algorithms>;
  /** delete data from the table: "apcharges" */
  delete_apcharges?: Maybe<Apcharges_Mutation_Response>;
  /** delete single row from the table: "apcharges" */
  delete_apcharges_by_pk?: Maybe<Apcharges>;
  /** delete data from the table: "appayments" */
  delete_appayments?: Maybe<Appayments_Mutation_Response>;
  /** delete single row from the table: "appayments" */
  delete_appayments_by_pk?: Maybe<Appayments>;
  /** delete data from the table: "appointments" */
  delete_appointments?: Maybe<Appointments_Mutation_Response>;
  /** delete single row from the table: "appointments" */
  delete_appointments_by_pk?: Maybe<Appointments>;
  /** delete data from the table: "appraisals" */
  delete_appraisals?: Maybe<Appraisals_Mutation_Response>;
  /** delete single row from the table: "appraisals" */
  delete_appraisals_by_pk?: Maybe<Appraisals>;
  /** delete data from the table: "arevents" */
  delete_arevents?: Maybe<Arevents_Mutation_Response>;
  /** delete single row from the table: "arevents" */
  delete_arevents_by_pk?: Maybe<Arevents>;
  /** delete data from the table: "arinvoices" */
  delete_arinvoices?: Maybe<Arinvoices_Mutation_Response>;
  /** delete single row from the table: "arinvoices" */
  delete_arinvoices_by_pk?: Maybe<Arinvoices>;
  /** delete data from the table: "armovedetails" */
  delete_armovedetails?: Maybe<Armovedetails_Mutation_Response>;
  /** delete single row from the table: "armovedetails" */
  delete_armovedetails_by_pk?: Maybe<Armovedetails>;
  /** delete data from the table: "armovedetailshistory" */
  delete_armovedetailshistory?: Maybe<Armovedetailshistory_Mutation_Response>;
  /** delete single row from the table: "armovedetailshistory" */
  delete_armovedetailshistory_by_pk?: Maybe<Armovedetailshistory>;
  /** delete data from the table: "armoves" */
  delete_armoves?: Maybe<Armoves_Mutation_Response>;
  /** delete single row from the table: "armoves" */
  delete_armoves_by_pk?: Maybe<Armoves>;
  /** delete data from the table: "armoveshistory" */
  delete_armoveshistory?: Maybe<Armoveshistory_Mutation_Response>;
  /** delete single row from the table: "armoveshistory" */
  delete_armoveshistory_by_pk?: Maybe<Armoveshistory>;
  /** delete data from the table: "arpaymentdetails" */
  delete_arpaymentdetails?: Maybe<Arpaymentdetails_Mutation_Response>;
  /** delete single row from the table: "arpaymentdetails" */
  delete_arpaymentdetails_by_pk?: Maybe<Arpaymentdetails>;
  /** delete data from the table: "arpaymentmethods" */
  delete_arpaymentmethods?: Maybe<Arpaymentmethods_Mutation_Response>;
  /** delete single row from the table: "arpaymentmethods" */
  delete_arpaymentmethods_by_pk?: Maybe<Arpaymentmethods>;
  /** delete data from the table: "arpayments" */
  delete_arpayments?: Maybe<Arpayments_Mutation_Response>;
  /** delete single row from the table: "arpayments" */
  delete_arpayments_by_pk?: Maybe<Arpayments>;
  /** delete data from the table: "arpriceoverrides" */
  delete_arpriceoverrides?: Maybe<Arpriceoverrides_Mutation_Response>;
  /** delete single row from the table: "arpriceoverrides" */
  delete_arpriceoverrides_by_pk?: Maybe<Arpriceoverrides>;
  /** delete data from the table: "authkeys" */
  delete_authkeys?: Maybe<Authkeys_Mutation_Response>;
  /** delete single row from the table: "authkeys" */
  delete_authkeys_by_pk?: Maybe<Authkeys>;
  /** delete data from the table: "authorizations" */
  delete_authorizations?: Maybe<Authorizations_Mutation_Response>;
  /** delete single row from the table: "authorizations" */
  delete_authorizations_by_pk?: Maybe<Authorizations>;
  /** delete data from the table: "batch_jobs" */
  delete_batch_jobs?: Maybe<Batch_Jobs_Mutation_Response>;
  /** delete single row from the table: "batch_jobs" */
  delete_batch_jobs_by_pk?: Maybe<Batch_Jobs>;
  /** delete data from the table: "bundles" */
  delete_bundles?: Maybe<Bundles_Mutation_Response>;
  /** delete single row from the table: "bundles" */
  delete_bundles_by_pk?: Maybe<Bundles>;
  /** delete data from the table: "bundlesets" */
  delete_bundlesets?: Maybe<Bundlesets_Mutation_Response>;
  /** delete single row from the table: "bundlesets" */
  delete_bundlesets_by_pk?: Maybe<Bundlesets>;
  /** delete data from the table: "bundletoscenarios" */
  delete_bundletoscenarios?: Maybe<Bundletoscenarios_Mutation_Response>;
  /** delete single row from the table: "bundletoscenarios" */
  delete_bundletoscenarios_by_pk?: Maybe<Bundletoscenarios>;
  /** delete data from the table: "businesshours" */
  delete_businesshours?: Maybe<Businesshours_Mutation_Response>;
  /** delete single row from the table: "businesshours" */
  delete_businesshours_by_pk?: Maybe<Businesshours>;
  /** delete data from the table: "businessrules" */
  delete_businessrules?: Maybe<Businessrules_Mutation_Response>;
  /** delete single row from the table: "businessrules" */
  delete_businessrules_by_pk?: Maybe<Businessrules>;
  /** delete data from the table: "businessruletypes" */
  delete_businessruletypes?: Maybe<Businessruletypes_Mutation_Response>;
  /** delete single row from the table: "businessruletypes" */
  delete_businessruletypes_by_pk?: Maybe<Businessruletypes>;
  /** delete data from the table: "certifications" */
  delete_certifications?: Maybe<Certifications_Mutation_Response>;
  /** delete single row from the table: "certifications" */
  delete_certifications_by_pk?: Maybe<Certifications>;
  /** delete data from the table: "chasevehicles" */
  delete_chasevehicles?: Maybe<Chasevehicles_Mutation_Response>;
  /** delete single row from the table: "chasevehicles" */
  delete_chasevehicles_by_pk?: Maybe<Chasevehicles>;
  /** delete data from the table: "chasevehiclesassigned" */
  delete_chasevehiclesassigned?: Maybe<Chasevehiclesassigned_Mutation_Response>;
  /** delete single row from the table: "chasevehiclesassigned" */
  delete_chasevehiclesassigned_by_pk?: Maybe<Chasevehiclesassigned>;
  /** delete data from the table: "consumer_numbers" */
  delete_consumer_numbers?: Maybe<Consumer_Numbers_Mutation_Response>;
  /** delete single row from the table: "consumer_numbers" */
  delete_consumer_numbers_by_pk?: Maybe<Consumer_Numbers>;
  /** delete data from the table: "coordinatedplans" */
  delete_coordinatedplans?: Maybe<Coordinatedplans_Mutation_Response>;
  /** delete single row from the table: "coordinatedplans" */
  delete_coordinatedplans_by_pk?: Maybe<Coordinatedplans>;
  /** delete data from the table: "coordinatedplantoscenarios" */
  delete_coordinatedplantoscenarios?: Maybe<Coordinatedplantoscenarios_Mutation_Response>;
  /** delete single row from the table: "coordinatedplantoscenarios" */
  delete_coordinatedplantoscenarios_by_pk?: Maybe<Coordinatedplantoscenarios>;
  /** delete data from the table: "customers" */
  delete_customers?: Maybe<Customers_Mutation_Response>;
  /** delete single row from the table: "customers" */
  delete_customers_by_pk?: Maybe<Customers>;
  /** delete data from the table: "customerstocertifications" */
  delete_customerstocertifications?: Maybe<Customerstocertifications_Mutation_Response>;
  /** delete single row from the table: "customerstocertifications" */
  delete_customerstocertifications_by_pk?: Maybe<Customerstocertifications>;
  /** delete data from the table: "documents" */
  delete_documents?: Maybe<Documents_Mutation_Response>;
  /** delete single row from the table: "documents" */
  delete_documents_by_pk?: Maybe<Documents>;
  /** delete data from the table: "driverappconfig" */
  delete_driverappconfig?: Maybe<Driverappconfig_Mutation_Response>;
  /** delete single row from the table: "driverappconfig" */
  delete_driverappconfig_by_pk?: Maybe<Driverappconfig>;
  /** delete data from the table: "driverblacklist" */
  delete_driverblacklist?: Maybe<Driverblacklist_Mutation_Response>;
  /** delete single row from the table: "driverblacklist" */
  delete_driverblacklist_by_pk?: Maybe<Driverblacklist>;
  /** delete data from the table: "driverdetails" */
  delete_driverdetails?: Maybe<Driverdetails_Mutation_Response>;
  /** delete single row from the table: "driverdetails" */
  delete_driverdetails_by_pk?: Maybe<Driverdetails>;
  /** delete data from the table: "driverequipment" */
  delete_driverequipment?: Maybe<Driverequipment_Mutation_Response>;
  /** delete single row from the table: "driverequipment" */
  delete_driverequipment_by_pk?: Maybe<Driverequipment>;
  /** delete data from the table: "driverlocations" */
  delete_driverlocations?: Maybe<Driverlocations_Mutation_Response>;
  /** delete data from the table: "driverpayouts" */
  delete_driverpayouts?: Maybe<Driverpayouts_Mutation_Response>;
  /** delete single row from the table: "driverpayouts" */
  delete_driverpayouts_by_pk?: Maybe<Driverpayouts>;
  /** delete data from the table: "driverpays" */
  delete_driverpays?: Maybe<Driverpays_Mutation_Response>;
  /** delete single row from the table: "driverpays" */
  delete_driverpays_by_pk?: Maybe<Driverpays>;
  /** delete data from the table: "drivers" */
  delete_drivers?: Maybe<Drivers_Mutation_Response>;
  /** delete single row from the table: "drivers" */
  delete_drivers_by_pk?: Maybe<Drivers>;
  /** delete data from the table: "driverscheduledetails" */
  delete_driverscheduledetails?: Maybe<Driverscheduledetails_Mutation_Response>;
  /** delete single row from the table: "driverscheduledetails" */
  delete_driverscheduledetails_by_pk?: Maybe<Driverscheduledetails>;
  /** delete data from the table: "driverschedules" */
  delete_driverschedules?: Maybe<Driverschedules_Mutation_Response>;
  /** delete single row from the table: "driverschedules" */
  delete_driverschedules_by_pk?: Maybe<Driverschedules>;
  /** delete data from the table: "driverstocertifications" */
  delete_driverstocertifications?: Maybe<Driverstocertifications_Mutation_Response>;
  /** delete single row from the table: "driverstocertifications" */
  delete_driverstocertifications_by_pk?: Maybe<Driverstocertifications>;
  /** delete data from the table: "driverstousecasesoptout" */
  delete_driverstousecasesoptout?: Maybe<Driverstousecasesoptout_Mutation_Response>;
  /** delete single row from the table: "driverstousecasesoptout" */
  delete_driverstousecasesoptout_by_pk?: Maybe<Driverstousecasesoptout>;
  /** delete data from the table: "email_events" */
  delete_email_events?: Maybe<Email_Events_Mutation_Response>;
  /** delete single row from the table: "email_events" */
  delete_email_events_by_pk?: Maybe<Email_Events>;
  /** delete data from the table: "equipment" */
  delete_equipment?: Maybe<Equipment_Mutation_Response>;
  /** delete single row from the table: "equipment" */
  delete_equipment_by_pk?: Maybe<Equipment>;
  /** delete data from the table: "event_executions" */
  delete_event_executions?: Maybe<Event_Executions_Mutation_Response>;
  /** delete single row from the table: "event_executions" */
  delete_event_executions_by_pk?: Maybe<Event_Executions>;
  /** delete data from the table: "eventlogs" */
  delete_eventlogs?: Maybe<Eventlogs_Mutation_Response>;
  /** delete single row from the table: "eventlogs" */
  delete_eventlogs_by_pk?: Maybe<Eventlogs>;
  /** delete data from the table: "events" */
  delete_events?: Maybe<Events_Mutation_Response>;
  /** delete single row from the table: "events" */
  delete_events_by_pk?: Maybe<Events>;
  /** delete data from the table: "faqs" */
  delete_faqs?: Maybe<Faqs_Mutation_Response>;
  /** delete single row from the table: "faqs" */
  delete_faqs_by_pk?: Maybe<Faqs>;
  /** delete data from the table: "favoritelanes" */
  delete_favoritelanes?: Maybe<Favoritelanes_Mutation_Response>;
  /** delete single row from the table: "favoritelanes" */
  delete_favoritelanes_by_pk?: Maybe<Favoritelanes>;
  /** delete data from the table: "favoritelocations" */
  delete_favoritelocations?: Maybe<Favoritelocations_Mutation_Response>;
  /** delete single row from the table: "favoritelocations" */
  delete_favoritelocations_by_pk?: Maybe<Favoritelocations>;
  /** delete data from the table: "features" */
  delete_features?: Maybe<Features_Mutation_Response>;
  /** delete single row from the table: "features" */
  delete_features_by_pk?: Maybe<Features>;
  /** delete data from the table: "fuelprices" */
  delete_fuelprices?: Maybe<Fuelprices_Mutation_Response>;
  /** delete single row from the table: "fuelprices" */
  delete_fuelprices_by_pk?: Maybe<Fuelprices>;
  /** delete data from the table: "hangtags" */
  delete_hangtags?: Maybe<Hangtags_Mutation_Response>;
  /** delete single row from the table: "hangtags" */
  delete_hangtags_by_pk?: Maybe<Hangtags>;
  /** delete data from the table: "insurancerates" */
  delete_insurancerates?: Maybe<Insurancerates_Mutation_Response>;
  /** delete single row from the table: "insurancerates" */
  delete_insurancerates_by_pk?: Maybe<Insurancerates>;
  /** delete data from the table: "invocations" */
  delete_invocations?: Maybe<Invocations_Mutation_Response>;
  /** delete single row from the table: "invocations" */
  delete_invocations_by_pk?: Maybe<Invocations>;
  /** delete data from the table: "job_executions" */
  delete_job_executions?: Maybe<Job_Executions_Mutation_Response>;
  /** delete single row from the table: "job_executions" */
  delete_job_executions_by_pk?: Maybe<Job_Executions>;
  /** delete data from the table: "lanemodifiers" */
  delete_lanemodifiers?: Maybe<Lanemodifiers_Mutation_Response>;
  /** delete single row from the table: "lanemodifiers" */
  delete_lanemodifiers_by_pk?: Maybe<Lanemodifiers>;
  /** delete data from the table: "lanes" */
  delete_lanes?: Maybe<Lanes_Mutation_Response>;
  /** delete single row from the table: "lanes" */
  delete_lanes_by_pk?: Maybe<Lanes>;
  /** delete data from the table: "locations" */
  delete_locations?: Maybe<Locations_Mutation_Response>;
  /** delete single row from the table: "locations" */
  delete_locations_by_pk?: Maybe<Locations>;
  /** delete data from the table: "locationstocertifications" */
  delete_locationstocertifications?: Maybe<Locationstocertifications_Mutation_Response>;
  /** delete single row from the table: "locationstocertifications" */
  delete_locationstocertifications_by_pk?: Maybe<Locationstocertifications>;
  /** delete data from the table: "lyftrideattempts" */
  delete_lyftrideattempts?: Maybe<Lyftrideattempts_Mutation_Response>;
  /** delete single row from the table: "lyftrideattempts" */
  delete_lyftrideattempts_by_pk?: Maybe<Lyftrideattempts>;
  /** delete data from the table: "lyftrides" */
  delete_lyftrides?: Maybe<Lyftrides_Mutation_Response>;
  /** delete single row from the table: "lyftrides" */
  delete_lyftrides_by_pk?: Maybe<Lyftrides>;
  /** delete data from the table: "metrics_hourly" */
  delete_metrics_hourly?: Maybe<Metrics_Hourly_Mutation_Response>;
  /** delete single row from the table: "metrics_hourly" */
  delete_metrics_hourly_by_pk?: Maybe<Metrics_Hourly>;
  /** delete data from the table: "moveaudit" */
  delete_moveaudit?: Maybe<Moveaudit_Mutation_Response>;
  /** delete single row from the table: "moveaudit" */
  delete_moveaudit_by_pk?: Maybe<Moveaudit>;
  /** delete data from the table: "moves" */
  delete_moves?: Maybe<Moves_Mutation_Response>;
  /** delete single row from the table: "moves" */
  delete_moves_by_pk?: Maybe<Moves>;
  /** delete data from the table: "notifications" */
  delete_notifications?: Maybe<Notifications_Mutation_Response>;
  /** delete single row from the table: "notifications" */
  delete_notifications_by_pk?: Maybe<Notifications>;
  /** delete data from the table: "offers" */
  delete_offers?: Maybe<Offers_Mutation_Response>;
  /** delete single row from the table: "offers" */
  delete_offers_by_pk?: Maybe<Offers>;
  /** delete data from the table: "organizations" */
  delete_organizations?: Maybe<Organizations_Mutation_Response>;
  /** delete single row from the table: "organizations" */
  delete_organizations_by_pk?: Maybe<Organizations>;
  /** delete data from the table: "organizationstocertifications" */
  delete_organizationstocertifications?: Maybe<Organizationstocertifications_Mutation_Response>;
  /** delete single row from the table: "organizationstocertifications" */
  delete_organizationstocertifications_by_pk?: Maybe<Organizationstocertifications>;
  /** delete data from the table: "paycycles" */
  delete_paycycles?: Maybe<Paycycles_Mutation_Response>;
  /** delete single row from the table: "paycycles" */
  delete_paycycles_by_pk?: Maybe<Paycycles>;
  /** delete data from the table: "paycycletodrivertodocuments" */
  delete_paycycletodrivertodocuments?: Maybe<Paycycletodrivertodocuments_Mutation_Response>;
  /** delete single row from the table: "paycycletodrivertodocuments" */
  delete_paycycletodrivertodocuments_by_pk?: Maybe<Paycycletodrivertodocuments>;
  /** delete data from the table: "payertocustomer" */
  delete_payertocustomer?: Maybe<Payertocustomer_Mutation_Response>;
  /** delete single row from the table: "payertocustomer" */
  delete_payertocustomer_by_pk?: Maybe<Payertocustomer>;
  /** delete data from the table: "payrategroups" */
  delete_payrategroups?: Maybe<Payrategroups_Mutation_Response>;
  /** delete single row from the table: "payrategroups" */
  delete_payrategroups_by_pk?: Maybe<Payrategroups>;
  /** delete data from the table: "payraterules" */
  delete_payraterules?: Maybe<Payraterules_Mutation_Response>;
  /** delete single row from the table: "payraterules" */
  delete_payraterules_by_pk?: Maybe<Payraterules>;
  /** delete data from the table: "plans" */
  delete_plans?: Maybe<Plans_Mutation_Response>;
  /** delete single row from the table: "plans" */
  delete_plans_by_pk?: Maybe<Plans>;
  /** delete data from the table: "platedetails" */
  delete_platedetails?: Maybe<Platedetails_Mutation_Response>;
  /** delete single row from the table: "platedetails" */
  delete_platedetails_by_pk?: Maybe<Platedetails>;
  /** delete data from the table: "plates" */
  delete_plates?: Maybe<Plates_Mutation_Response>;
  /** delete single row from the table: "plates" */
  delete_plates_by_pk?: Maybe<Plates>;
  /** delete data from the table: "productfees" */
  delete_productfees?: Maybe<Productfees_Mutation_Response>;
  /** delete single row from the table: "productfees" */
  delete_productfees_by_pk?: Maybe<Productfees>;
  /** delete data from the table: "products" */
  delete_products?: Maybe<Products_Mutation_Response>;
  /** delete single row from the table: "products" */
  delete_products_by_pk?: Maybe<Products>;
  /** delete data from the table: "promos" */
  delete_promos?: Maybe<Promos_Mutation_Response>;
  /** delete single row from the table: "promos" */
  delete_promos_by_pk?: Maybe<Promos>;
  /** delete data from the table: "raterulegroups" */
  delete_raterulegroups?: Maybe<Raterulegroups_Mutation_Response>;
  /** delete single row from the table: "raterulegroups" */
  delete_raterulegroups_by_pk?: Maybe<Raterulegroups>;
  /** delete data from the table: "raterules" */
  delete_raterules?: Maybe<Raterules_Mutation_Response>;
  /** delete single row from the table: "raterules" */
  delete_raterules_by_pk?: Maybe<Raterules>;
  /** delete data from the table: "regions" */
  delete_regions?: Maybe<Regions_Mutation_Response>;
  /** delete single row from the table: "regions" */
  delete_regions_by_pk?: Maybe<Regions>;
  /** delete data from the table: "ridegroups" */
  delete_ridegroups?: Maybe<Ridegroups_Mutation_Response>;
  /** delete single row from the table: "ridegroups" */
  delete_ridegroups_by_pk?: Maybe<Ridegroups>;
  /** delete data from the table: "ridesharefares" */
  delete_ridesharefares?: Maybe<Ridesharefares_Mutation_Response>;
  /** delete single row from the table: "ridesharefares" */
  delete_ridesharefares_by_pk?: Maybe<Ridesharefares>;
  /** delete data from the table: "ridesharerates" */
  delete_ridesharerates?: Maybe<Ridesharerates_Mutation_Response>;
  /** delete single row from the table: "ridesharerates" */
  delete_ridesharerates_by_pk?: Maybe<Ridesharerates>;
  /** delete data from the table: "rideshareratetoridesharefares" */
  delete_rideshareratetoridesharefares?: Maybe<Rideshareratetoridesharefares_Mutation_Response>;
  /** delete single row from the table: "rideshareratetoridesharefares" */
  delete_rideshareratetoridesharefares_by_pk?: Maybe<Rideshareratetoridesharefares>;
  /** delete data from the table: "roletypes" */
  delete_roletypes?: Maybe<Roletypes_Mutation_Response>;
  /** delete single row from the table: "roletypes" */
  delete_roletypes_by_pk?: Maybe<Roletypes>;
  /** delete data from the table: "scenarios" */
  delete_scenarios?: Maybe<Scenarios_Mutation_Response>;
  /** delete single row from the table: "scenarios" */
  delete_scenarios_by_pk?: Maybe<Scenarios>;
  /** delete data from the table: "scenariotomoves" */
  delete_scenariotomoves?: Maybe<Scenariotomoves_Mutation_Response>;
  /** delete single row from the table: "scenariotomoves" */
  delete_scenariotomoves_by_pk?: Maybe<Scenariotomoves>;
  /** delete data from the table: "scenariotypes" */
  delete_scenariotypes?: Maybe<Scenariotypes_Mutation_Response>;
  /** delete single row from the table: "scenariotypes" */
  delete_scenariotypes_by_pk?: Maybe<Scenariotypes>;
  /** delete data from the table: "scenariotypestocertifications" */
  delete_scenariotypestocertifications?: Maybe<Scenariotypestocertifications_Mutation_Response>;
  /** delete single row from the table: "scenariotypestocertifications" */
  delete_scenariotypestocertifications_by_pk?: Maybe<Scenariotypestocertifications>;
  /** delete data from the table: "sequelizemeta" */
  delete_sequelizemeta?: Maybe<Sequelizemeta_Mutation_Response>;
  /** delete single row from the table: "sequelizemeta" */
  delete_sequelizemeta_by_pk?: Maybe<Sequelizemeta>;
  /** delete data from the table: "slas" */
  delete_slas?: Maybe<Slas_Mutation_Response>;
  /** delete single row from the table: "slas" */
  delete_slas_by_pk?: Maybe<Slas>;
  /** delete data from the table: "slas_to_raterulegroups" */
  delete_slas_to_raterulegroups?: Maybe<Slas_To_Raterulegroups_Mutation_Response>;
  /** delete single row from the table: "slas_to_raterulegroups" */
  delete_slas_to_raterulegroups_by_pk?: Maybe<Slas_To_Raterulegroups>;
  /** delete data from the table: "smsmedia" */
  delete_smsmedia?: Maybe<Smsmedia_Mutation_Response>;
  /** delete single row from the table: "smsmedia" */
  delete_smsmedia_by_pk?: Maybe<Smsmedia>;
  /** delete data from the table: "smsmessages" */
  delete_smsmessages?: Maybe<Smsmessages_Mutation_Response>;
  /** delete single row from the table: "smsmessages" */
  delete_smsmessages_by_pk?: Maybe<Smsmessages>;
  /** delete data from the table: "smstemplates" */
  delete_smstemplates?: Maybe<Smstemplates_Mutation_Response>;
  /** delete single row from the table: "smstemplates" */
  delete_smstemplates_by_pk?: Maybe<Smstemplates>;
  /** delete data from the table: "subscriptions" */
  delete_subscriptions?: Maybe<Subscriptions_Mutation_Response>;
  /** delete single row from the table: "subscriptions" */
  delete_subscriptions_by_pk?: Maybe<Subscriptions>;
  /** delete data from the table: "templates" */
  delete_templates?: Maybe<Templates_Mutation_Response>;
  /** delete single row from the table: "templates" */
  delete_templates_by_pk?: Maybe<Templates>;
  /** delete data from the table: "trips" */
  delete_trips?: Maybe<Trips_Mutation_Response>;
  /** delete single row from the table: "trips" */
  delete_trips_by_pk?: Maybe<Trips>;
  /** delete data from the table: "usecases" */
  delete_usecases?: Maybe<Usecases_Mutation_Response>;
  /** delete single row from the table: "usecases" */
  delete_usecases_by_pk?: Maybe<Usecases>;
  /** delete data from the table: "usecasetocertifications" */
  delete_usecasetocertifications?: Maybe<Usecasetocertifications_Mutation_Response>;
  /** delete single row from the table: "usecasetocertifications" */
  delete_usecasetocertifications_by_pk?: Maybe<Usecasetocertifications>;
  /** delete data from the table: "usereventlogs" */
  delete_usereventlogs?: Maybe<Usereventlogs_Mutation_Response>;
  /** delete single row from the table: "usereventlogs" */
  delete_usereventlogs_by_pk?: Maybe<Usereventlogs>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  /** delete data from the table: "usertocustomers" */
  delete_usertocustomers?: Maybe<Usertocustomers_Mutation_Response>;
  /** delete single row from the table: "usertocustomers" */
  delete_usertocustomers_by_pk?: Maybe<Usertocustomers>;
  /** delete data from the table: "usertofeatures" */
  delete_usertofeatures?: Maybe<Usertofeatures_Mutation_Response>;
  /** delete single row from the table: "usertofeatures" */
  delete_usertofeatures_by_pk?: Maybe<Usertofeatures>;
  /** delete data from the table: "usertoregions" */
  delete_usertoregions?: Maybe<Usertoregions_Mutation_Response>;
  /** delete single row from the table: "usertoregions" */
  delete_usertoregions_by_pk?: Maybe<Usertoregions>;
  /** delete data from the table: "usertoroles" */
  delete_usertoroles?: Maybe<Usertoroles_Mutation_Response>;
  /** delete single row from the table: "usertoroles" */
  delete_usertoroles_by_pk?: Maybe<Usertoroles>;
  /** delete data from the table: "vehiclemakes" */
  delete_vehiclemakes?: Maybe<Vehiclemakes_Mutation_Response>;
  /** delete single row from the table: "vehiclemakes" */
  delete_vehiclemakes_by_pk?: Maybe<Vehiclemakes>;
  /** delete data from the table: "vehiclemodels" */
  delete_vehiclemodels?: Maybe<Vehiclemodels_Mutation_Response>;
  /** delete single row from the table: "vehiclemodels" */
  delete_vehiclemodels_by_pk?: Maybe<Vehiclemodels>;
  /** delete data from the table: "vehiclephotos" */
  delete_vehiclephotos?: Maybe<Vehiclephotos_Mutation_Response>;
  /** delete single row from the table: "vehiclephotos" */
  delete_vehiclephotos_by_pk?: Maybe<Vehiclephotos>;
  /** delete data from the table: "vehicles" */
  delete_vehicles?: Maybe<Vehicles_Mutation_Response>;
  /** delete single row from the table: "vehicles" */
  delete_vehicles_by_pk?: Maybe<Vehicles>;
  /** delete data from the table: "webhook_events" */
  delete_webhook_events?: Maybe<Webhook_Events_Mutation_Response>;
  /** delete single row from the table: "webhook_events" */
  delete_webhook_events_by_pk?: Maybe<Webhook_Events>;
  /** delete data from the table: "workflows" */
  delete_workflows?: Maybe<Workflows_Mutation_Response>;
  /** delete single row from the table: "workflows" */
  delete_workflows_by_pk?: Maybe<Workflows>;
  /** delete data from the table: "workflowsets" */
  delete_workflowsets?: Maybe<Workflowsets_Mutation_Response>;
  /** delete single row from the table: "workflowsets" */
  delete_workflowsets_by_pk?: Maybe<Workflowsets>;
  /** delete data from the table: "workflowsettypes" */
  delete_workflowsettypes?: Maybe<Workflowsettypes_Mutation_Response>;
  /** delete single row from the table: "workflowsettypes" */
  delete_workflowsettypes_by_pk?: Maybe<Workflowsettypes>;
  /** delete data from the table: "workflowsettypestocertifications" */
  delete_workflowsettypestocertifications?: Maybe<Workflowsettypestocertifications_Mutation_Response>;
  /** delete single row from the table: "workflowsettypestocertifications" */
  delete_workflowsettypestocertifications_by_pk?: Maybe<Workflowsettypestocertifications>;
  /** insert data into the table: "accessorials" */
  insert_accessorials?: Maybe<Accessorials_Mutation_Response>;
  /** insert a single row into the table: "accessorials" */
  insert_accessorials_one?: Maybe<Accessorials>;
  /** insert data into the table: "accessorialstoalgorithms" */
  insert_accessorialstoalgorithms?: Maybe<Accessorialstoalgorithms_Mutation_Response>;
  /** insert a single row into the table: "accessorialstoalgorithms" */
  insert_accessorialstoalgorithms_one?: Maybe<Accessorialstoalgorithms>;
  /** insert data into the table: "actiontypes" */
  insert_actiontypes?: Maybe<Actiontypes_Mutation_Response>;
  /** insert a single row into the table: "actiontypes" */
  insert_actiontypes_one?: Maybe<Actiontypes>;
  /** insert data into the table: "activetimes" */
  insert_activetimes?: Maybe<Activetimes_Mutation_Response>;
  /** insert a single row into the table: "activetimes" */
  insert_activetimes_one?: Maybe<Activetimes>;
  /** insert data into the table: "algorithms" */
  insert_algorithms?: Maybe<Algorithms_Mutation_Response>;
  /** insert a single row into the table: "algorithms" */
  insert_algorithms_one?: Maybe<Algorithms>;
  /** insert data into the table: "apcharges" */
  insert_apcharges?: Maybe<Apcharges_Mutation_Response>;
  /** insert a single row into the table: "apcharges" */
  insert_apcharges_one?: Maybe<Apcharges>;
  /** insert data into the table: "appayments" */
  insert_appayments?: Maybe<Appayments_Mutation_Response>;
  /** insert a single row into the table: "appayments" */
  insert_appayments_one?: Maybe<Appayments>;
  /** insert data into the table: "appointments" */
  insert_appointments?: Maybe<Appointments_Mutation_Response>;
  /** insert a single row into the table: "appointments" */
  insert_appointments_one?: Maybe<Appointments>;
  /** insert data into the table: "appraisals" */
  insert_appraisals?: Maybe<Appraisals_Mutation_Response>;
  /** insert a single row into the table: "appraisals" */
  insert_appraisals_one?: Maybe<Appraisals>;
  /** insert data into the table: "arevents" */
  insert_arevents?: Maybe<Arevents_Mutation_Response>;
  /** insert a single row into the table: "arevents" */
  insert_arevents_one?: Maybe<Arevents>;
  /** insert data into the table: "arinvoices" */
  insert_arinvoices?: Maybe<Arinvoices_Mutation_Response>;
  /** insert a single row into the table: "arinvoices" */
  insert_arinvoices_one?: Maybe<Arinvoices>;
  /** insert data into the table: "armovedetails" */
  insert_armovedetails?: Maybe<Armovedetails_Mutation_Response>;
  /** insert a single row into the table: "armovedetails" */
  insert_armovedetails_one?: Maybe<Armovedetails>;
  /** insert data into the table: "armovedetailshistory" */
  insert_armovedetailshistory?: Maybe<Armovedetailshistory_Mutation_Response>;
  /** insert a single row into the table: "armovedetailshistory" */
  insert_armovedetailshistory_one?: Maybe<Armovedetailshistory>;
  /** insert data into the table: "armoves" */
  insert_armoves?: Maybe<Armoves_Mutation_Response>;
  /** insert a single row into the table: "armoves" */
  insert_armoves_one?: Maybe<Armoves>;
  /** insert data into the table: "armoveshistory" */
  insert_armoveshistory?: Maybe<Armoveshistory_Mutation_Response>;
  /** insert a single row into the table: "armoveshistory" */
  insert_armoveshistory_one?: Maybe<Armoveshistory>;
  /** insert data into the table: "arpaymentdetails" */
  insert_arpaymentdetails?: Maybe<Arpaymentdetails_Mutation_Response>;
  /** insert a single row into the table: "arpaymentdetails" */
  insert_arpaymentdetails_one?: Maybe<Arpaymentdetails>;
  /** insert data into the table: "arpaymentmethods" */
  insert_arpaymentmethods?: Maybe<Arpaymentmethods_Mutation_Response>;
  /** insert a single row into the table: "arpaymentmethods" */
  insert_arpaymentmethods_one?: Maybe<Arpaymentmethods>;
  /** insert data into the table: "arpayments" */
  insert_arpayments?: Maybe<Arpayments_Mutation_Response>;
  /** insert a single row into the table: "arpayments" */
  insert_arpayments_one?: Maybe<Arpayments>;
  /** insert data into the table: "arpriceoverrides" */
  insert_arpriceoverrides?: Maybe<Arpriceoverrides_Mutation_Response>;
  /** insert a single row into the table: "arpriceoverrides" */
  insert_arpriceoverrides_one?: Maybe<Arpriceoverrides>;
  /** insert data into the table: "authkeys" */
  insert_authkeys?: Maybe<Authkeys_Mutation_Response>;
  /** insert a single row into the table: "authkeys" */
  insert_authkeys_one?: Maybe<Authkeys>;
  /** insert data into the table: "authorizations" */
  insert_authorizations?: Maybe<Authorizations_Mutation_Response>;
  /** insert a single row into the table: "authorizations" */
  insert_authorizations_one?: Maybe<Authorizations>;
  /** insert data into the table: "batch_jobs" */
  insert_batch_jobs?: Maybe<Batch_Jobs_Mutation_Response>;
  /** insert a single row into the table: "batch_jobs" */
  insert_batch_jobs_one?: Maybe<Batch_Jobs>;
  /** insert data into the table: "bundles" */
  insert_bundles?: Maybe<Bundles_Mutation_Response>;
  /** insert a single row into the table: "bundles" */
  insert_bundles_one?: Maybe<Bundles>;
  /** insert data into the table: "bundlesets" */
  insert_bundlesets?: Maybe<Bundlesets_Mutation_Response>;
  /** insert a single row into the table: "bundlesets" */
  insert_bundlesets_one?: Maybe<Bundlesets>;
  /** insert data into the table: "bundletoscenarios" */
  insert_bundletoscenarios?: Maybe<Bundletoscenarios_Mutation_Response>;
  /** insert a single row into the table: "bundletoscenarios" */
  insert_bundletoscenarios_one?: Maybe<Bundletoscenarios>;
  /** insert data into the table: "businesshours" */
  insert_businesshours?: Maybe<Businesshours_Mutation_Response>;
  /** insert a single row into the table: "businesshours" */
  insert_businesshours_one?: Maybe<Businesshours>;
  /** insert data into the table: "businessrules" */
  insert_businessrules?: Maybe<Businessrules_Mutation_Response>;
  /** insert a single row into the table: "businessrules" */
  insert_businessrules_one?: Maybe<Businessrules>;
  /** insert data into the table: "businessruletypes" */
  insert_businessruletypes?: Maybe<Businessruletypes_Mutation_Response>;
  /** insert a single row into the table: "businessruletypes" */
  insert_businessruletypes_one?: Maybe<Businessruletypes>;
  /** insert data into the table: "certifications" */
  insert_certifications?: Maybe<Certifications_Mutation_Response>;
  /** insert a single row into the table: "certifications" */
  insert_certifications_one?: Maybe<Certifications>;
  /** insert data into the table: "chasevehicles" */
  insert_chasevehicles?: Maybe<Chasevehicles_Mutation_Response>;
  /** insert a single row into the table: "chasevehicles" */
  insert_chasevehicles_one?: Maybe<Chasevehicles>;
  /** insert data into the table: "chasevehiclesassigned" */
  insert_chasevehiclesassigned?: Maybe<Chasevehiclesassigned_Mutation_Response>;
  /** insert a single row into the table: "chasevehiclesassigned" */
  insert_chasevehiclesassigned_one?: Maybe<Chasevehiclesassigned>;
  /** insert data into the table: "consumer_numbers" */
  insert_consumer_numbers?: Maybe<Consumer_Numbers_Mutation_Response>;
  /** insert a single row into the table: "consumer_numbers" */
  insert_consumer_numbers_one?: Maybe<Consumer_Numbers>;
  /** insert data into the table: "coordinatedplans" */
  insert_coordinatedplans?: Maybe<Coordinatedplans_Mutation_Response>;
  /** insert a single row into the table: "coordinatedplans" */
  insert_coordinatedplans_one?: Maybe<Coordinatedplans>;
  /** insert data into the table: "coordinatedplantoscenarios" */
  insert_coordinatedplantoscenarios?: Maybe<Coordinatedplantoscenarios_Mutation_Response>;
  /** insert a single row into the table: "coordinatedplantoscenarios" */
  insert_coordinatedplantoscenarios_one?: Maybe<Coordinatedplantoscenarios>;
  /** insert data into the table: "customers" */
  insert_customers?: Maybe<Customers_Mutation_Response>;
  /** insert a single row into the table: "customers" */
  insert_customers_one?: Maybe<Customers>;
  /** insert data into the table: "customerstocertifications" */
  insert_customerstocertifications?: Maybe<Customerstocertifications_Mutation_Response>;
  /** insert a single row into the table: "customerstocertifications" */
  insert_customerstocertifications_one?: Maybe<Customerstocertifications>;
  /** insert data into the table: "documents" */
  insert_documents?: Maybe<Documents_Mutation_Response>;
  /** insert a single row into the table: "documents" */
  insert_documents_one?: Maybe<Documents>;
  /** insert data into the table: "driverappconfig" */
  insert_driverappconfig?: Maybe<Driverappconfig_Mutation_Response>;
  /** insert a single row into the table: "driverappconfig" */
  insert_driverappconfig_one?: Maybe<Driverappconfig>;
  /** insert data into the table: "driverblacklist" */
  insert_driverblacklist?: Maybe<Driverblacklist_Mutation_Response>;
  /** insert a single row into the table: "driverblacklist" */
  insert_driverblacklist_one?: Maybe<Driverblacklist>;
  /** insert data into the table: "driverdetails" */
  insert_driverdetails?: Maybe<Driverdetails_Mutation_Response>;
  /** insert a single row into the table: "driverdetails" */
  insert_driverdetails_one?: Maybe<Driverdetails>;
  /** insert data into the table: "driverequipment" */
  insert_driverequipment?: Maybe<Driverequipment_Mutation_Response>;
  /** insert a single row into the table: "driverequipment" */
  insert_driverequipment_one?: Maybe<Driverequipment>;
  /** insert data into the table: "driverlocations" */
  insert_driverlocations?: Maybe<Driverlocations_Mutation_Response>;
  /** insert a single row into the table: "driverlocations" */
  insert_driverlocations_one?: Maybe<Driverlocations>;
  /** insert data into the table: "driverpayouts" */
  insert_driverpayouts?: Maybe<Driverpayouts_Mutation_Response>;
  /** insert a single row into the table: "driverpayouts" */
  insert_driverpayouts_one?: Maybe<Driverpayouts>;
  /** insert data into the table: "driverpays" */
  insert_driverpays?: Maybe<Driverpays_Mutation_Response>;
  /** insert a single row into the table: "driverpays" */
  insert_driverpays_one?: Maybe<Driverpays>;
  /** insert data into the table: "drivers" */
  insert_drivers?: Maybe<Drivers_Mutation_Response>;
  /** insert a single row into the table: "drivers" */
  insert_drivers_one?: Maybe<Drivers>;
  /** insert data into the table: "driverscheduledetails" */
  insert_driverscheduledetails?: Maybe<Driverscheduledetails_Mutation_Response>;
  /** insert a single row into the table: "driverscheduledetails" */
  insert_driverscheduledetails_one?: Maybe<Driverscheduledetails>;
  /** insert data into the table: "driverschedules" */
  insert_driverschedules?: Maybe<Driverschedules_Mutation_Response>;
  /** insert a single row into the table: "driverschedules" */
  insert_driverschedules_one?: Maybe<Driverschedules>;
  /** insert data into the table: "driverstocertifications" */
  insert_driverstocertifications?: Maybe<Driverstocertifications_Mutation_Response>;
  /** insert a single row into the table: "driverstocertifications" */
  insert_driverstocertifications_one?: Maybe<Driverstocertifications>;
  /** insert data into the table: "driverstousecasesoptout" */
  insert_driverstousecasesoptout?: Maybe<Driverstousecasesoptout_Mutation_Response>;
  /** insert a single row into the table: "driverstousecasesoptout" */
  insert_driverstousecasesoptout_one?: Maybe<Driverstousecasesoptout>;
  /** insert data into the table: "email_events" */
  insert_email_events?: Maybe<Email_Events_Mutation_Response>;
  /** insert a single row into the table: "email_events" */
  insert_email_events_one?: Maybe<Email_Events>;
  /** insert data into the table: "equipment" */
  insert_equipment?: Maybe<Equipment_Mutation_Response>;
  /** insert a single row into the table: "equipment" */
  insert_equipment_one?: Maybe<Equipment>;
  /** insert data into the table: "event_executions" */
  insert_event_executions?: Maybe<Event_Executions_Mutation_Response>;
  /** insert a single row into the table: "event_executions" */
  insert_event_executions_one?: Maybe<Event_Executions>;
  /** insert data into the table: "eventlogs" */
  insert_eventlogs?: Maybe<Eventlogs_Mutation_Response>;
  /** insert a single row into the table: "eventlogs" */
  insert_eventlogs_one?: Maybe<Eventlogs>;
  /** insert data into the table: "events" */
  insert_events?: Maybe<Events_Mutation_Response>;
  /** insert a single row into the table: "events" */
  insert_events_one?: Maybe<Events>;
  /** insert data into the table: "faqs" */
  insert_faqs?: Maybe<Faqs_Mutation_Response>;
  /** insert a single row into the table: "faqs" */
  insert_faqs_one?: Maybe<Faqs>;
  /** insert data into the table: "favoritelanes" */
  insert_favoritelanes?: Maybe<Favoritelanes_Mutation_Response>;
  /** insert a single row into the table: "favoritelanes" */
  insert_favoritelanes_one?: Maybe<Favoritelanes>;
  /** insert data into the table: "favoritelocations" */
  insert_favoritelocations?: Maybe<Favoritelocations_Mutation_Response>;
  /** insert a single row into the table: "favoritelocations" */
  insert_favoritelocations_one?: Maybe<Favoritelocations>;
  /** insert data into the table: "features" */
  insert_features?: Maybe<Features_Mutation_Response>;
  /** insert a single row into the table: "features" */
  insert_features_one?: Maybe<Features>;
  /** insert data into the table: "fuelprices" */
  insert_fuelprices?: Maybe<Fuelprices_Mutation_Response>;
  /** insert a single row into the table: "fuelprices" */
  insert_fuelprices_one?: Maybe<Fuelprices>;
  /** insert data into the table: "hangtags" */
  insert_hangtags?: Maybe<Hangtags_Mutation_Response>;
  /** insert a single row into the table: "hangtags" */
  insert_hangtags_one?: Maybe<Hangtags>;
  /** insert data into the table: "insurancerates" */
  insert_insurancerates?: Maybe<Insurancerates_Mutation_Response>;
  /** insert a single row into the table: "insurancerates" */
  insert_insurancerates_one?: Maybe<Insurancerates>;
  /** insert data into the table: "invocations" */
  insert_invocations?: Maybe<Invocations_Mutation_Response>;
  /** insert a single row into the table: "invocations" */
  insert_invocations_one?: Maybe<Invocations>;
  /** insert data into the table: "job_executions" */
  insert_job_executions?: Maybe<Job_Executions_Mutation_Response>;
  /** insert a single row into the table: "job_executions" */
  insert_job_executions_one?: Maybe<Job_Executions>;
  /** insert data into the table: "lanemodifiers" */
  insert_lanemodifiers?: Maybe<Lanemodifiers_Mutation_Response>;
  /** insert a single row into the table: "lanemodifiers" */
  insert_lanemodifiers_one?: Maybe<Lanemodifiers>;
  /** insert data into the table: "lanes" */
  insert_lanes?: Maybe<Lanes_Mutation_Response>;
  /** insert a single row into the table: "lanes" */
  insert_lanes_one?: Maybe<Lanes>;
  /** insert data into the table: "locations" */
  insert_locations?: Maybe<Locations_Mutation_Response>;
  /** insert a single row into the table: "locations" */
  insert_locations_one?: Maybe<Locations>;
  /** insert data into the table: "locationstocertifications" */
  insert_locationstocertifications?: Maybe<Locationstocertifications_Mutation_Response>;
  /** insert a single row into the table: "locationstocertifications" */
  insert_locationstocertifications_one?: Maybe<Locationstocertifications>;
  /** insert data into the table: "lyftrideattempts" */
  insert_lyftrideattempts?: Maybe<Lyftrideattempts_Mutation_Response>;
  /** insert a single row into the table: "lyftrideattempts" */
  insert_lyftrideattempts_one?: Maybe<Lyftrideattempts>;
  /** insert data into the table: "lyftrides" */
  insert_lyftrides?: Maybe<Lyftrides_Mutation_Response>;
  /** insert a single row into the table: "lyftrides" */
  insert_lyftrides_one?: Maybe<Lyftrides>;
  /** insert data into the table: "metrics_hourly" */
  insert_metrics_hourly?: Maybe<Metrics_Hourly_Mutation_Response>;
  /** insert a single row into the table: "metrics_hourly" */
  insert_metrics_hourly_one?: Maybe<Metrics_Hourly>;
  /** insert data into the table: "moveaudit" */
  insert_moveaudit?: Maybe<Moveaudit_Mutation_Response>;
  /** insert a single row into the table: "moveaudit" */
  insert_moveaudit_one?: Maybe<Moveaudit>;
  /** insert data into the table: "moves" */
  insert_moves?: Maybe<Moves_Mutation_Response>;
  /** insert a single row into the table: "moves" */
  insert_moves_one?: Maybe<Moves>;
  /** insert data into the table: "notifications" */
  insert_notifications?: Maybe<Notifications_Mutation_Response>;
  /** insert a single row into the table: "notifications" */
  insert_notifications_one?: Maybe<Notifications>;
  /** insert data into the table: "offers" */
  insert_offers?: Maybe<Offers_Mutation_Response>;
  /** insert a single row into the table: "offers" */
  insert_offers_one?: Maybe<Offers>;
  /** insert data into the table: "organizations" */
  insert_organizations?: Maybe<Organizations_Mutation_Response>;
  /** insert a single row into the table: "organizations" */
  insert_organizations_one?: Maybe<Organizations>;
  /** insert data into the table: "organizationstocertifications" */
  insert_organizationstocertifications?: Maybe<Organizationstocertifications_Mutation_Response>;
  /** insert a single row into the table: "organizationstocertifications" */
  insert_organizationstocertifications_one?: Maybe<Organizationstocertifications>;
  /** insert data into the table: "paycycles" */
  insert_paycycles?: Maybe<Paycycles_Mutation_Response>;
  /** insert a single row into the table: "paycycles" */
  insert_paycycles_one?: Maybe<Paycycles>;
  /** insert data into the table: "paycycletodrivertodocuments" */
  insert_paycycletodrivertodocuments?: Maybe<Paycycletodrivertodocuments_Mutation_Response>;
  /** insert a single row into the table: "paycycletodrivertodocuments" */
  insert_paycycletodrivertodocuments_one?: Maybe<Paycycletodrivertodocuments>;
  /** insert data into the table: "payertocustomer" */
  insert_payertocustomer?: Maybe<Payertocustomer_Mutation_Response>;
  /** insert a single row into the table: "payertocustomer" */
  insert_payertocustomer_one?: Maybe<Payertocustomer>;
  /** insert data into the table: "payrategroups" */
  insert_payrategroups?: Maybe<Payrategroups_Mutation_Response>;
  /** insert a single row into the table: "payrategroups" */
  insert_payrategroups_one?: Maybe<Payrategroups>;
  /** insert data into the table: "payraterules" */
  insert_payraterules?: Maybe<Payraterules_Mutation_Response>;
  /** insert a single row into the table: "payraterules" */
  insert_payraterules_one?: Maybe<Payraterules>;
  /** insert data into the table: "plans" */
  insert_plans?: Maybe<Plans_Mutation_Response>;
  /** insert a single row into the table: "plans" */
  insert_plans_one?: Maybe<Plans>;
  /** insert data into the table: "platedetails" */
  insert_platedetails?: Maybe<Platedetails_Mutation_Response>;
  /** insert a single row into the table: "platedetails" */
  insert_platedetails_one?: Maybe<Platedetails>;
  /** insert data into the table: "plates" */
  insert_plates?: Maybe<Plates_Mutation_Response>;
  /** insert a single row into the table: "plates" */
  insert_plates_one?: Maybe<Plates>;
  /** insert data into the table: "productfees" */
  insert_productfees?: Maybe<Productfees_Mutation_Response>;
  /** insert a single row into the table: "productfees" */
  insert_productfees_one?: Maybe<Productfees>;
  /** insert data into the table: "products" */
  insert_products?: Maybe<Products_Mutation_Response>;
  /** insert a single row into the table: "products" */
  insert_products_one?: Maybe<Products>;
  /** insert data into the table: "promos" */
  insert_promos?: Maybe<Promos_Mutation_Response>;
  /** insert a single row into the table: "promos" */
  insert_promos_one?: Maybe<Promos>;
  /** insert data into the table: "raterulegroups" */
  insert_raterulegroups?: Maybe<Raterulegroups_Mutation_Response>;
  /** insert a single row into the table: "raterulegroups" */
  insert_raterulegroups_one?: Maybe<Raterulegroups>;
  /** insert data into the table: "raterules" */
  insert_raterules?: Maybe<Raterules_Mutation_Response>;
  /** insert a single row into the table: "raterules" */
  insert_raterules_one?: Maybe<Raterules>;
  /** insert data into the table: "regions" */
  insert_regions?: Maybe<Regions_Mutation_Response>;
  /** insert a single row into the table: "regions" */
  insert_regions_one?: Maybe<Regions>;
  /** insert data into the table: "ridegroups" */
  insert_ridegroups?: Maybe<Ridegroups_Mutation_Response>;
  /** insert a single row into the table: "ridegroups" */
  insert_ridegroups_one?: Maybe<Ridegroups>;
  /** insert data into the table: "ridesharefares" */
  insert_ridesharefares?: Maybe<Ridesharefares_Mutation_Response>;
  /** insert a single row into the table: "ridesharefares" */
  insert_ridesharefares_one?: Maybe<Ridesharefares>;
  /** insert data into the table: "ridesharerates" */
  insert_ridesharerates?: Maybe<Ridesharerates_Mutation_Response>;
  /** insert a single row into the table: "ridesharerates" */
  insert_ridesharerates_one?: Maybe<Ridesharerates>;
  /** insert data into the table: "rideshareratetoridesharefares" */
  insert_rideshareratetoridesharefares?: Maybe<Rideshareratetoridesharefares_Mutation_Response>;
  /** insert a single row into the table: "rideshareratetoridesharefares" */
  insert_rideshareratetoridesharefares_one?: Maybe<Rideshareratetoridesharefares>;
  /** insert data into the table: "roletypes" */
  insert_roletypes?: Maybe<Roletypes_Mutation_Response>;
  /** insert a single row into the table: "roletypes" */
  insert_roletypes_one?: Maybe<Roletypes>;
  /** insert data into the table: "scenarios" */
  insert_scenarios?: Maybe<Scenarios_Mutation_Response>;
  /** insert a single row into the table: "scenarios" */
  insert_scenarios_one?: Maybe<Scenarios>;
  /** insert data into the table: "scenariotomoves" */
  insert_scenariotomoves?: Maybe<Scenariotomoves_Mutation_Response>;
  /** insert a single row into the table: "scenariotomoves" */
  insert_scenariotomoves_one?: Maybe<Scenariotomoves>;
  /** insert data into the table: "scenariotypes" */
  insert_scenariotypes?: Maybe<Scenariotypes_Mutation_Response>;
  /** insert a single row into the table: "scenariotypes" */
  insert_scenariotypes_one?: Maybe<Scenariotypes>;
  /** insert data into the table: "scenariotypestocertifications" */
  insert_scenariotypestocertifications?: Maybe<Scenariotypestocertifications_Mutation_Response>;
  /** insert a single row into the table: "scenariotypestocertifications" */
  insert_scenariotypestocertifications_one?: Maybe<Scenariotypestocertifications>;
  /** insert data into the table: "sequelizemeta" */
  insert_sequelizemeta?: Maybe<Sequelizemeta_Mutation_Response>;
  /** insert a single row into the table: "sequelizemeta" */
  insert_sequelizemeta_one?: Maybe<Sequelizemeta>;
  /** insert data into the table: "slas" */
  insert_slas?: Maybe<Slas_Mutation_Response>;
  /** insert a single row into the table: "slas" */
  insert_slas_one?: Maybe<Slas>;
  /** insert data into the table: "slas_to_raterulegroups" */
  insert_slas_to_raterulegroups?: Maybe<Slas_To_Raterulegroups_Mutation_Response>;
  /** insert a single row into the table: "slas_to_raterulegroups" */
  insert_slas_to_raterulegroups_one?: Maybe<Slas_To_Raterulegroups>;
  /** insert data into the table: "smsmedia" */
  insert_smsmedia?: Maybe<Smsmedia_Mutation_Response>;
  /** insert a single row into the table: "smsmedia" */
  insert_smsmedia_one?: Maybe<Smsmedia>;
  /** insert data into the table: "smsmessages" */
  insert_smsmessages?: Maybe<Smsmessages_Mutation_Response>;
  /** insert a single row into the table: "smsmessages" */
  insert_smsmessages_one?: Maybe<Smsmessages>;
  /** insert data into the table: "smstemplates" */
  insert_smstemplates?: Maybe<Smstemplates_Mutation_Response>;
  /** insert a single row into the table: "smstemplates" */
  insert_smstemplates_one?: Maybe<Smstemplates>;
  /** insert data into the table: "subscriptions" */
  insert_subscriptions?: Maybe<Subscriptions_Mutation_Response>;
  /** insert a single row into the table: "subscriptions" */
  insert_subscriptions_one?: Maybe<Subscriptions>;
  /** insert data into the table: "templates" */
  insert_templates?: Maybe<Templates_Mutation_Response>;
  /** insert a single row into the table: "templates" */
  insert_templates_one?: Maybe<Templates>;
  /** insert data into the table: "trips" */
  insert_trips?: Maybe<Trips_Mutation_Response>;
  /** insert a single row into the table: "trips" */
  insert_trips_one?: Maybe<Trips>;
  /** insert data into the table: "usecases" */
  insert_usecases?: Maybe<Usecases_Mutation_Response>;
  /** insert a single row into the table: "usecases" */
  insert_usecases_one?: Maybe<Usecases>;
  /** insert data into the table: "usecasetocertifications" */
  insert_usecasetocertifications?: Maybe<Usecasetocertifications_Mutation_Response>;
  /** insert a single row into the table: "usecasetocertifications" */
  insert_usecasetocertifications_one?: Maybe<Usecasetocertifications>;
  /** insert data into the table: "usereventlogs" */
  insert_usereventlogs?: Maybe<Usereventlogs_Mutation_Response>;
  /** insert a single row into the table: "usereventlogs" */
  insert_usereventlogs_one?: Maybe<Usereventlogs>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  /** insert data into the table: "usertocustomers" */
  insert_usertocustomers?: Maybe<Usertocustomers_Mutation_Response>;
  /** insert a single row into the table: "usertocustomers" */
  insert_usertocustomers_one?: Maybe<Usertocustomers>;
  /** insert data into the table: "usertofeatures" */
  insert_usertofeatures?: Maybe<Usertofeatures_Mutation_Response>;
  /** insert a single row into the table: "usertofeatures" */
  insert_usertofeatures_one?: Maybe<Usertofeatures>;
  /** insert data into the table: "usertoregions" */
  insert_usertoregions?: Maybe<Usertoregions_Mutation_Response>;
  /** insert a single row into the table: "usertoregions" */
  insert_usertoregions_one?: Maybe<Usertoregions>;
  /** insert data into the table: "usertoroles" */
  insert_usertoroles?: Maybe<Usertoroles_Mutation_Response>;
  /** insert a single row into the table: "usertoroles" */
  insert_usertoroles_one?: Maybe<Usertoroles>;
  /** insert data into the table: "vehiclemakes" */
  insert_vehiclemakes?: Maybe<Vehiclemakes_Mutation_Response>;
  /** insert a single row into the table: "vehiclemakes" */
  insert_vehiclemakes_one?: Maybe<Vehiclemakes>;
  /** insert data into the table: "vehiclemodels" */
  insert_vehiclemodels?: Maybe<Vehiclemodels_Mutation_Response>;
  /** insert a single row into the table: "vehiclemodels" */
  insert_vehiclemodels_one?: Maybe<Vehiclemodels>;
  /** insert data into the table: "vehiclephotos" */
  insert_vehiclephotos?: Maybe<Vehiclephotos_Mutation_Response>;
  /** insert a single row into the table: "vehiclephotos" */
  insert_vehiclephotos_one?: Maybe<Vehiclephotos>;
  /** insert data into the table: "vehicles" */
  insert_vehicles?: Maybe<Vehicles_Mutation_Response>;
  /** insert a single row into the table: "vehicles" */
  insert_vehicles_one?: Maybe<Vehicles>;
  /** insert data into the table: "webhook_events" */
  insert_webhook_events?: Maybe<Webhook_Events_Mutation_Response>;
  /** insert a single row into the table: "webhook_events" */
  insert_webhook_events_one?: Maybe<Webhook_Events>;
  /** insert data into the table: "workflows" */
  insert_workflows?: Maybe<Workflows_Mutation_Response>;
  /** insert a single row into the table: "workflows" */
  insert_workflows_one?: Maybe<Workflows>;
  /** insert data into the table: "workflowsets" */
  insert_workflowsets?: Maybe<Workflowsets_Mutation_Response>;
  /** insert a single row into the table: "workflowsets" */
  insert_workflowsets_one?: Maybe<Workflowsets>;
  /** insert data into the table: "workflowsettypes" */
  insert_workflowsettypes?: Maybe<Workflowsettypes_Mutation_Response>;
  /** insert a single row into the table: "workflowsettypes" */
  insert_workflowsettypes_one?: Maybe<Workflowsettypes>;
  /** insert data into the table: "workflowsettypestocertifications" */
  insert_workflowsettypestocertifications?: Maybe<Workflowsettypestocertifications_Mutation_Response>;
  /** insert a single row into the table: "workflowsettypestocertifications" */
  insert_workflowsettypestocertifications_one?: Maybe<Workflowsettypestocertifications>;
  /** update data of the table: "accessorials" */
  update_accessorials?: Maybe<Accessorials_Mutation_Response>;
  /** update single row of the table: "accessorials" */
  update_accessorials_by_pk?: Maybe<Accessorials>;
  /** update multiples rows of table: "accessorials" */
  update_accessorials_many?: Maybe<Array<Maybe<Accessorials_Mutation_Response>>>;
  /** update data of the table: "accessorialstoalgorithms" */
  update_accessorialstoalgorithms?: Maybe<Accessorialstoalgorithms_Mutation_Response>;
  /** update single row of the table: "accessorialstoalgorithms" */
  update_accessorialstoalgorithms_by_pk?: Maybe<Accessorialstoalgorithms>;
  /** update multiples rows of table: "accessorialstoalgorithms" */
  update_accessorialstoalgorithms_many?: Maybe<Array<Maybe<Accessorialstoalgorithms_Mutation_Response>>>;
  /** update data of the table: "actiontypes" */
  update_actiontypes?: Maybe<Actiontypes_Mutation_Response>;
  /** update single row of the table: "actiontypes" */
  update_actiontypes_by_pk?: Maybe<Actiontypes>;
  /** update multiples rows of table: "actiontypes" */
  update_actiontypes_many?: Maybe<Array<Maybe<Actiontypes_Mutation_Response>>>;
  /** update data of the table: "activetimes" */
  update_activetimes?: Maybe<Activetimes_Mutation_Response>;
  /** update single row of the table: "activetimes" */
  update_activetimes_by_pk?: Maybe<Activetimes>;
  /** update multiples rows of table: "activetimes" */
  update_activetimes_many?: Maybe<Array<Maybe<Activetimes_Mutation_Response>>>;
  /** update data of the table: "algorithms" */
  update_algorithms?: Maybe<Algorithms_Mutation_Response>;
  /** update single row of the table: "algorithms" */
  update_algorithms_by_pk?: Maybe<Algorithms>;
  /** update multiples rows of table: "algorithms" */
  update_algorithms_many?: Maybe<Array<Maybe<Algorithms_Mutation_Response>>>;
  /** update data of the table: "apcharges" */
  update_apcharges?: Maybe<Apcharges_Mutation_Response>;
  /** update single row of the table: "apcharges" */
  update_apcharges_by_pk?: Maybe<Apcharges>;
  /** update multiples rows of table: "apcharges" */
  update_apcharges_many?: Maybe<Array<Maybe<Apcharges_Mutation_Response>>>;
  /** update data of the table: "appayments" */
  update_appayments?: Maybe<Appayments_Mutation_Response>;
  /** update single row of the table: "appayments" */
  update_appayments_by_pk?: Maybe<Appayments>;
  /** update multiples rows of table: "appayments" */
  update_appayments_many?: Maybe<Array<Maybe<Appayments_Mutation_Response>>>;
  /** update data of the table: "appointments" */
  update_appointments?: Maybe<Appointments_Mutation_Response>;
  /** update single row of the table: "appointments" */
  update_appointments_by_pk?: Maybe<Appointments>;
  /** update multiples rows of table: "appointments" */
  update_appointments_many?: Maybe<Array<Maybe<Appointments_Mutation_Response>>>;
  /** update data of the table: "appraisals" */
  update_appraisals?: Maybe<Appraisals_Mutation_Response>;
  /** update single row of the table: "appraisals" */
  update_appraisals_by_pk?: Maybe<Appraisals>;
  /** update multiples rows of table: "appraisals" */
  update_appraisals_many?: Maybe<Array<Maybe<Appraisals_Mutation_Response>>>;
  /** update data of the table: "arevents" */
  update_arevents?: Maybe<Arevents_Mutation_Response>;
  /** update single row of the table: "arevents" */
  update_arevents_by_pk?: Maybe<Arevents>;
  /** update multiples rows of table: "arevents" */
  update_arevents_many?: Maybe<Array<Maybe<Arevents_Mutation_Response>>>;
  /** update data of the table: "arinvoices" */
  update_arinvoices?: Maybe<Arinvoices_Mutation_Response>;
  /** update single row of the table: "arinvoices" */
  update_arinvoices_by_pk?: Maybe<Arinvoices>;
  /** update multiples rows of table: "arinvoices" */
  update_arinvoices_many?: Maybe<Array<Maybe<Arinvoices_Mutation_Response>>>;
  /** update data of the table: "armovedetails" */
  update_armovedetails?: Maybe<Armovedetails_Mutation_Response>;
  /** update single row of the table: "armovedetails" */
  update_armovedetails_by_pk?: Maybe<Armovedetails>;
  /** update multiples rows of table: "armovedetails" */
  update_armovedetails_many?: Maybe<Array<Maybe<Armovedetails_Mutation_Response>>>;
  /** update data of the table: "armovedetailshistory" */
  update_armovedetailshistory?: Maybe<Armovedetailshistory_Mutation_Response>;
  /** update single row of the table: "armovedetailshistory" */
  update_armovedetailshistory_by_pk?: Maybe<Armovedetailshistory>;
  /** update multiples rows of table: "armovedetailshistory" */
  update_armovedetailshistory_many?: Maybe<Array<Maybe<Armovedetailshistory_Mutation_Response>>>;
  /** update data of the table: "armoves" */
  update_armoves?: Maybe<Armoves_Mutation_Response>;
  /** update single row of the table: "armoves" */
  update_armoves_by_pk?: Maybe<Armoves>;
  /** update multiples rows of table: "armoves" */
  update_armoves_many?: Maybe<Array<Maybe<Armoves_Mutation_Response>>>;
  /** update data of the table: "armoveshistory" */
  update_armoveshistory?: Maybe<Armoveshistory_Mutation_Response>;
  /** update single row of the table: "armoveshistory" */
  update_armoveshistory_by_pk?: Maybe<Armoveshistory>;
  /** update multiples rows of table: "armoveshistory" */
  update_armoveshistory_many?: Maybe<Array<Maybe<Armoveshistory_Mutation_Response>>>;
  /** update data of the table: "arpaymentdetails" */
  update_arpaymentdetails?: Maybe<Arpaymentdetails_Mutation_Response>;
  /** update single row of the table: "arpaymentdetails" */
  update_arpaymentdetails_by_pk?: Maybe<Arpaymentdetails>;
  /** update multiples rows of table: "arpaymentdetails" */
  update_arpaymentdetails_many?: Maybe<Array<Maybe<Arpaymentdetails_Mutation_Response>>>;
  /** update data of the table: "arpaymentmethods" */
  update_arpaymentmethods?: Maybe<Arpaymentmethods_Mutation_Response>;
  /** update single row of the table: "arpaymentmethods" */
  update_arpaymentmethods_by_pk?: Maybe<Arpaymentmethods>;
  /** update multiples rows of table: "arpaymentmethods" */
  update_arpaymentmethods_many?: Maybe<Array<Maybe<Arpaymentmethods_Mutation_Response>>>;
  /** update data of the table: "arpayments" */
  update_arpayments?: Maybe<Arpayments_Mutation_Response>;
  /** update single row of the table: "arpayments" */
  update_arpayments_by_pk?: Maybe<Arpayments>;
  /** update multiples rows of table: "arpayments" */
  update_arpayments_many?: Maybe<Array<Maybe<Arpayments_Mutation_Response>>>;
  /** update data of the table: "arpriceoverrides" */
  update_arpriceoverrides?: Maybe<Arpriceoverrides_Mutation_Response>;
  /** update single row of the table: "arpriceoverrides" */
  update_arpriceoverrides_by_pk?: Maybe<Arpriceoverrides>;
  /** update multiples rows of table: "arpriceoverrides" */
  update_arpriceoverrides_many?: Maybe<Array<Maybe<Arpriceoverrides_Mutation_Response>>>;
  /** update data of the table: "authkeys" */
  update_authkeys?: Maybe<Authkeys_Mutation_Response>;
  /** update single row of the table: "authkeys" */
  update_authkeys_by_pk?: Maybe<Authkeys>;
  /** update multiples rows of table: "authkeys" */
  update_authkeys_many?: Maybe<Array<Maybe<Authkeys_Mutation_Response>>>;
  /** update data of the table: "authorizations" */
  update_authorizations?: Maybe<Authorizations_Mutation_Response>;
  /** update single row of the table: "authorizations" */
  update_authorizations_by_pk?: Maybe<Authorizations>;
  /** update multiples rows of table: "authorizations" */
  update_authorizations_many?: Maybe<Array<Maybe<Authorizations_Mutation_Response>>>;
  /** update data of the table: "batch_jobs" */
  update_batch_jobs?: Maybe<Batch_Jobs_Mutation_Response>;
  /** update single row of the table: "batch_jobs" */
  update_batch_jobs_by_pk?: Maybe<Batch_Jobs>;
  /** update multiples rows of table: "batch_jobs" */
  update_batch_jobs_many?: Maybe<Array<Maybe<Batch_Jobs_Mutation_Response>>>;
  /** update data of the table: "bundles" */
  update_bundles?: Maybe<Bundles_Mutation_Response>;
  /** update single row of the table: "bundles" */
  update_bundles_by_pk?: Maybe<Bundles>;
  /** update multiples rows of table: "bundles" */
  update_bundles_many?: Maybe<Array<Maybe<Bundles_Mutation_Response>>>;
  /** update data of the table: "bundlesets" */
  update_bundlesets?: Maybe<Bundlesets_Mutation_Response>;
  /** update single row of the table: "bundlesets" */
  update_bundlesets_by_pk?: Maybe<Bundlesets>;
  /** update multiples rows of table: "bundlesets" */
  update_bundlesets_many?: Maybe<Array<Maybe<Bundlesets_Mutation_Response>>>;
  /** update data of the table: "bundletoscenarios" */
  update_bundletoscenarios?: Maybe<Bundletoscenarios_Mutation_Response>;
  /** update single row of the table: "bundletoscenarios" */
  update_bundletoscenarios_by_pk?: Maybe<Bundletoscenarios>;
  /** update multiples rows of table: "bundletoscenarios" */
  update_bundletoscenarios_many?: Maybe<Array<Maybe<Bundletoscenarios_Mutation_Response>>>;
  /** update data of the table: "businesshours" */
  update_businesshours?: Maybe<Businesshours_Mutation_Response>;
  /** update single row of the table: "businesshours" */
  update_businesshours_by_pk?: Maybe<Businesshours>;
  /** update multiples rows of table: "businesshours" */
  update_businesshours_many?: Maybe<Array<Maybe<Businesshours_Mutation_Response>>>;
  /** update data of the table: "businessrules" */
  update_businessrules?: Maybe<Businessrules_Mutation_Response>;
  /** update single row of the table: "businessrules" */
  update_businessrules_by_pk?: Maybe<Businessrules>;
  /** update multiples rows of table: "businessrules" */
  update_businessrules_many?: Maybe<Array<Maybe<Businessrules_Mutation_Response>>>;
  /** update data of the table: "businessruletypes" */
  update_businessruletypes?: Maybe<Businessruletypes_Mutation_Response>;
  /** update single row of the table: "businessruletypes" */
  update_businessruletypes_by_pk?: Maybe<Businessruletypes>;
  /** update multiples rows of table: "businessruletypes" */
  update_businessruletypes_many?: Maybe<Array<Maybe<Businessruletypes_Mutation_Response>>>;
  /** update data of the table: "certifications" */
  update_certifications?: Maybe<Certifications_Mutation_Response>;
  /** update single row of the table: "certifications" */
  update_certifications_by_pk?: Maybe<Certifications>;
  /** update multiples rows of table: "certifications" */
  update_certifications_many?: Maybe<Array<Maybe<Certifications_Mutation_Response>>>;
  /** update data of the table: "chasevehicles" */
  update_chasevehicles?: Maybe<Chasevehicles_Mutation_Response>;
  /** update single row of the table: "chasevehicles" */
  update_chasevehicles_by_pk?: Maybe<Chasevehicles>;
  /** update multiples rows of table: "chasevehicles" */
  update_chasevehicles_many?: Maybe<Array<Maybe<Chasevehicles_Mutation_Response>>>;
  /** update data of the table: "chasevehiclesassigned" */
  update_chasevehiclesassigned?: Maybe<Chasevehiclesassigned_Mutation_Response>;
  /** update single row of the table: "chasevehiclesassigned" */
  update_chasevehiclesassigned_by_pk?: Maybe<Chasevehiclesassigned>;
  /** update multiples rows of table: "chasevehiclesassigned" */
  update_chasevehiclesassigned_many?: Maybe<Array<Maybe<Chasevehiclesassigned_Mutation_Response>>>;
  /** update data of the table: "consumer_numbers" */
  update_consumer_numbers?: Maybe<Consumer_Numbers_Mutation_Response>;
  /** update single row of the table: "consumer_numbers" */
  update_consumer_numbers_by_pk?: Maybe<Consumer_Numbers>;
  /** update multiples rows of table: "consumer_numbers" */
  update_consumer_numbers_many?: Maybe<Array<Maybe<Consumer_Numbers_Mutation_Response>>>;
  /** update data of the table: "coordinatedplans" */
  update_coordinatedplans?: Maybe<Coordinatedplans_Mutation_Response>;
  /** update single row of the table: "coordinatedplans" */
  update_coordinatedplans_by_pk?: Maybe<Coordinatedplans>;
  /** update multiples rows of table: "coordinatedplans" */
  update_coordinatedplans_many?: Maybe<Array<Maybe<Coordinatedplans_Mutation_Response>>>;
  /** update data of the table: "coordinatedplantoscenarios" */
  update_coordinatedplantoscenarios?: Maybe<Coordinatedplantoscenarios_Mutation_Response>;
  /** update single row of the table: "coordinatedplantoscenarios" */
  update_coordinatedplantoscenarios_by_pk?: Maybe<Coordinatedplantoscenarios>;
  /** update multiples rows of table: "coordinatedplantoscenarios" */
  update_coordinatedplantoscenarios_many?: Maybe<Array<Maybe<Coordinatedplantoscenarios_Mutation_Response>>>;
  /** update data of the table: "customers" */
  update_customers?: Maybe<Customers_Mutation_Response>;
  /** update single row of the table: "customers" */
  update_customers_by_pk?: Maybe<Customers>;
  /** update multiples rows of table: "customers" */
  update_customers_many?: Maybe<Array<Maybe<Customers_Mutation_Response>>>;
  /** update data of the table: "customerstocertifications" */
  update_customerstocertifications?: Maybe<Customerstocertifications_Mutation_Response>;
  /** update single row of the table: "customerstocertifications" */
  update_customerstocertifications_by_pk?: Maybe<Customerstocertifications>;
  /** update multiples rows of table: "customerstocertifications" */
  update_customerstocertifications_many?: Maybe<Array<Maybe<Customerstocertifications_Mutation_Response>>>;
  /** update data of the table: "documents" */
  update_documents?: Maybe<Documents_Mutation_Response>;
  /** update single row of the table: "documents" */
  update_documents_by_pk?: Maybe<Documents>;
  /** update multiples rows of table: "documents" */
  update_documents_many?: Maybe<Array<Maybe<Documents_Mutation_Response>>>;
  /** update data of the table: "driverappconfig" */
  update_driverappconfig?: Maybe<Driverappconfig_Mutation_Response>;
  /** update single row of the table: "driverappconfig" */
  update_driverappconfig_by_pk?: Maybe<Driverappconfig>;
  /** update multiples rows of table: "driverappconfig" */
  update_driverappconfig_many?: Maybe<Array<Maybe<Driverappconfig_Mutation_Response>>>;
  /** update data of the table: "driverblacklist" */
  update_driverblacklist?: Maybe<Driverblacklist_Mutation_Response>;
  /** update single row of the table: "driverblacklist" */
  update_driverblacklist_by_pk?: Maybe<Driverblacklist>;
  /** update multiples rows of table: "driverblacklist" */
  update_driverblacklist_many?: Maybe<Array<Maybe<Driverblacklist_Mutation_Response>>>;
  /** update data of the table: "driverdetails" */
  update_driverdetails?: Maybe<Driverdetails_Mutation_Response>;
  /** update single row of the table: "driverdetails" */
  update_driverdetails_by_pk?: Maybe<Driverdetails>;
  /** update multiples rows of table: "driverdetails" */
  update_driverdetails_many?: Maybe<Array<Maybe<Driverdetails_Mutation_Response>>>;
  /** update data of the table: "driverequipment" */
  update_driverequipment?: Maybe<Driverequipment_Mutation_Response>;
  /** update single row of the table: "driverequipment" */
  update_driverequipment_by_pk?: Maybe<Driverequipment>;
  /** update multiples rows of table: "driverequipment" */
  update_driverequipment_many?: Maybe<Array<Maybe<Driverequipment_Mutation_Response>>>;
  /** update data of the table: "driverlocations" */
  update_driverlocations?: Maybe<Driverlocations_Mutation_Response>;
  /** update multiples rows of table: "driverlocations" */
  update_driverlocations_many?: Maybe<Array<Maybe<Driverlocations_Mutation_Response>>>;
  /** update data of the table: "driverpayouts" */
  update_driverpayouts?: Maybe<Driverpayouts_Mutation_Response>;
  /** update single row of the table: "driverpayouts" */
  update_driverpayouts_by_pk?: Maybe<Driverpayouts>;
  /** update multiples rows of table: "driverpayouts" */
  update_driverpayouts_many?: Maybe<Array<Maybe<Driverpayouts_Mutation_Response>>>;
  /** update data of the table: "driverpays" */
  update_driverpays?: Maybe<Driverpays_Mutation_Response>;
  /** update single row of the table: "driverpays" */
  update_driverpays_by_pk?: Maybe<Driverpays>;
  /** update multiples rows of table: "driverpays" */
  update_driverpays_many?: Maybe<Array<Maybe<Driverpays_Mutation_Response>>>;
  /** update data of the table: "drivers" */
  update_drivers?: Maybe<Drivers_Mutation_Response>;
  /** update single row of the table: "drivers" */
  update_drivers_by_pk?: Maybe<Drivers>;
  /** update multiples rows of table: "drivers" */
  update_drivers_many?: Maybe<Array<Maybe<Drivers_Mutation_Response>>>;
  /** update data of the table: "driverscheduledetails" */
  update_driverscheduledetails?: Maybe<Driverscheduledetails_Mutation_Response>;
  /** update single row of the table: "driverscheduledetails" */
  update_driverscheduledetails_by_pk?: Maybe<Driverscheduledetails>;
  /** update multiples rows of table: "driverscheduledetails" */
  update_driverscheduledetails_many?: Maybe<Array<Maybe<Driverscheduledetails_Mutation_Response>>>;
  /** update data of the table: "driverschedules" */
  update_driverschedules?: Maybe<Driverschedules_Mutation_Response>;
  /** update single row of the table: "driverschedules" */
  update_driverschedules_by_pk?: Maybe<Driverschedules>;
  /** update multiples rows of table: "driverschedules" */
  update_driverschedules_many?: Maybe<Array<Maybe<Driverschedules_Mutation_Response>>>;
  /** update data of the table: "driverstocertifications" */
  update_driverstocertifications?: Maybe<Driverstocertifications_Mutation_Response>;
  /** update single row of the table: "driverstocertifications" */
  update_driverstocertifications_by_pk?: Maybe<Driverstocertifications>;
  /** update multiples rows of table: "driverstocertifications" */
  update_driverstocertifications_many?: Maybe<Array<Maybe<Driverstocertifications_Mutation_Response>>>;
  /** update data of the table: "driverstousecasesoptout" */
  update_driverstousecasesoptout?: Maybe<Driverstousecasesoptout_Mutation_Response>;
  /** update single row of the table: "driverstousecasesoptout" */
  update_driverstousecasesoptout_by_pk?: Maybe<Driverstousecasesoptout>;
  /** update multiples rows of table: "driverstousecasesoptout" */
  update_driverstousecasesoptout_many?: Maybe<Array<Maybe<Driverstousecasesoptout_Mutation_Response>>>;
  /** update data of the table: "email_events" */
  update_email_events?: Maybe<Email_Events_Mutation_Response>;
  /** update single row of the table: "email_events" */
  update_email_events_by_pk?: Maybe<Email_Events>;
  /** update multiples rows of table: "email_events" */
  update_email_events_many?: Maybe<Array<Maybe<Email_Events_Mutation_Response>>>;
  /** update data of the table: "equipment" */
  update_equipment?: Maybe<Equipment_Mutation_Response>;
  /** update single row of the table: "equipment" */
  update_equipment_by_pk?: Maybe<Equipment>;
  /** update multiples rows of table: "equipment" */
  update_equipment_many?: Maybe<Array<Maybe<Equipment_Mutation_Response>>>;
  /** update data of the table: "event_executions" */
  update_event_executions?: Maybe<Event_Executions_Mutation_Response>;
  /** update single row of the table: "event_executions" */
  update_event_executions_by_pk?: Maybe<Event_Executions>;
  /** update multiples rows of table: "event_executions" */
  update_event_executions_many?: Maybe<Array<Maybe<Event_Executions_Mutation_Response>>>;
  /** update data of the table: "eventlogs" */
  update_eventlogs?: Maybe<Eventlogs_Mutation_Response>;
  /** update single row of the table: "eventlogs" */
  update_eventlogs_by_pk?: Maybe<Eventlogs>;
  /** update multiples rows of table: "eventlogs" */
  update_eventlogs_many?: Maybe<Array<Maybe<Eventlogs_Mutation_Response>>>;
  /** update data of the table: "events" */
  update_events?: Maybe<Events_Mutation_Response>;
  /** update single row of the table: "events" */
  update_events_by_pk?: Maybe<Events>;
  /** update multiples rows of table: "events" */
  update_events_many?: Maybe<Array<Maybe<Events_Mutation_Response>>>;
  /** update data of the table: "faqs" */
  update_faqs?: Maybe<Faqs_Mutation_Response>;
  /** update single row of the table: "faqs" */
  update_faqs_by_pk?: Maybe<Faqs>;
  /** update multiples rows of table: "faqs" */
  update_faqs_many?: Maybe<Array<Maybe<Faqs_Mutation_Response>>>;
  /** update data of the table: "favoritelanes" */
  update_favoritelanes?: Maybe<Favoritelanes_Mutation_Response>;
  /** update single row of the table: "favoritelanes" */
  update_favoritelanes_by_pk?: Maybe<Favoritelanes>;
  /** update multiples rows of table: "favoritelanes" */
  update_favoritelanes_many?: Maybe<Array<Maybe<Favoritelanes_Mutation_Response>>>;
  /** update data of the table: "favoritelocations" */
  update_favoritelocations?: Maybe<Favoritelocations_Mutation_Response>;
  /** update single row of the table: "favoritelocations" */
  update_favoritelocations_by_pk?: Maybe<Favoritelocations>;
  /** update multiples rows of table: "favoritelocations" */
  update_favoritelocations_many?: Maybe<Array<Maybe<Favoritelocations_Mutation_Response>>>;
  /** update data of the table: "features" */
  update_features?: Maybe<Features_Mutation_Response>;
  /** update single row of the table: "features" */
  update_features_by_pk?: Maybe<Features>;
  /** update multiples rows of table: "features" */
  update_features_many?: Maybe<Array<Maybe<Features_Mutation_Response>>>;
  /** update data of the table: "fuelprices" */
  update_fuelprices?: Maybe<Fuelprices_Mutation_Response>;
  /** update single row of the table: "fuelprices" */
  update_fuelprices_by_pk?: Maybe<Fuelprices>;
  /** update multiples rows of table: "fuelprices" */
  update_fuelprices_many?: Maybe<Array<Maybe<Fuelprices_Mutation_Response>>>;
  /** update data of the table: "hangtags" */
  update_hangtags?: Maybe<Hangtags_Mutation_Response>;
  /** update single row of the table: "hangtags" */
  update_hangtags_by_pk?: Maybe<Hangtags>;
  /** update multiples rows of table: "hangtags" */
  update_hangtags_many?: Maybe<Array<Maybe<Hangtags_Mutation_Response>>>;
  /** update data of the table: "insurancerates" */
  update_insurancerates?: Maybe<Insurancerates_Mutation_Response>;
  /** update single row of the table: "insurancerates" */
  update_insurancerates_by_pk?: Maybe<Insurancerates>;
  /** update multiples rows of table: "insurancerates" */
  update_insurancerates_many?: Maybe<Array<Maybe<Insurancerates_Mutation_Response>>>;
  /** update data of the table: "invocations" */
  update_invocations?: Maybe<Invocations_Mutation_Response>;
  /** update single row of the table: "invocations" */
  update_invocations_by_pk?: Maybe<Invocations>;
  /** update multiples rows of table: "invocations" */
  update_invocations_many?: Maybe<Array<Maybe<Invocations_Mutation_Response>>>;
  /** update data of the table: "job_executions" */
  update_job_executions?: Maybe<Job_Executions_Mutation_Response>;
  /** update single row of the table: "job_executions" */
  update_job_executions_by_pk?: Maybe<Job_Executions>;
  /** update multiples rows of table: "job_executions" */
  update_job_executions_many?: Maybe<Array<Maybe<Job_Executions_Mutation_Response>>>;
  /** update data of the table: "lanemodifiers" */
  update_lanemodifiers?: Maybe<Lanemodifiers_Mutation_Response>;
  /** update single row of the table: "lanemodifiers" */
  update_lanemodifiers_by_pk?: Maybe<Lanemodifiers>;
  /** update multiples rows of table: "lanemodifiers" */
  update_lanemodifiers_many?: Maybe<Array<Maybe<Lanemodifiers_Mutation_Response>>>;
  /** update data of the table: "lanes" */
  update_lanes?: Maybe<Lanes_Mutation_Response>;
  /** update single row of the table: "lanes" */
  update_lanes_by_pk?: Maybe<Lanes>;
  /** update multiples rows of table: "lanes" */
  update_lanes_many?: Maybe<Array<Maybe<Lanes_Mutation_Response>>>;
  /** update data of the table: "locations" */
  update_locations?: Maybe<Locations_Mutation_Response>;
  /** update single row of the table: "locations" */
  update_locations_by_pk?: Maybe<Locations>;
  /** update multiples rows of table: "locations" */
  update_locations_many?: Maybe<Array<Maybe<Locations_Mutation_Response>>>;
  /** update data of the table: "locationstocertifications" */
  update_locationstocertifications?: Maybe<Locationstocertifications_Mutation_Response>;
  /** update single row of the table: "locationstocertifications" */
  update_locationstocertifications_by_pk?: Maybe<Locationstocertifications>;
  /** update multiples rows of table: "locationstocertifications" */
  update_locationstocertifications_many?: Maybe<Array<Maybe<Locationstocertifications_Mutation_Response>>>;
  /** update data of the table: "lyftrideattempts" */
  update_lyftrideattempts?: Maybe<Lyftrideattempts_Mutation_Response>;
  /** update single row of the table: "lyftrideattempts" */
  update_lyftrideattempts_by_pk?: Maybe<Lyftrideattempts>;
  /** update multiples rows of table: "lyftrideattempts" */
  update_lyftrideattempts_many?: Maybe<Array<Maybe<Lyftrideattempts_Mutation_Response>>>;
  /** update data of the table: "lyftrides" */
  update_lyftrides?: Maybe<Lyftrides_Mutation_Response>;
  /** update single row of the table: "lyftrides" */
  update_lyftrides_by_pk?: Maybe<Lyftrides>;
  /** update multiples rows of table: "lyftrides" */
  update_lyftrides_many?: Maybe<Array<Maybe<Lyftrides_Mutation_Response>>>;
  /** update data of the table: "metrics_hourly" */
  update_metrics_hourly?: Maybe<Metrics_Hourly_Mutation_Response>;
  /** update single row of the table: "metrics_hourly" */
  update_metrics_hourly_by_pk?: Maybe<Metrics_Hourly>;
  /** update multiples rows of table: "metrics_hourly" */
  update_metrics_hourly_many?: Maybe<Array<Maybe<Metrics_Hourly_Mutation_Response>>>;
  /** update data of the table: "moveaudit" */
  update_moveaudit?: Maybe<Moveaudit_Mutation_Response>;
  /** update single row of the table: "moveaudit" */
  update_moveaudit_by_pk?: Maybe<Moveaudit>;
  /** update multiples rows of table: "moveaudit" */
  update_moveaudit_many?: Maybe<Array<Maybe<Moveaudit_Mutation_Response>>>;
  /** update data of the table: "moves" */
  update_moves?: Maybe<Moves_Mutation_Response>;
  /** update single row of the table: "moves" */
  update_moves_by_pk?: Maybe<Moves>;
  /** update multiples rows of table: "moves" */
  update_moves_many?: Maybe<Array<Maybe<Moves_Mutation_Response>>>;
  /** update data of the table: "notifications" */
  update_notifications?: Maybe<Notifications_Mutation_Response>;
  /** update single row of the table: "notifications" */
  update_notifications_by_pk?: Maybe<Notifications>;
  /** update multiples rows of table: "notifications" */
  update_notifications_many?: Maybe<Array<Maybe<Notifications_Mutation_Response>>>;
  /** update data of the table: "offers" */
  update_offers?: Maybe<Offers_Mutation_Response>;
  /** update single row of the table: "offers" */
  update_offers_by_pk?: Maybe<Offers>;
  /** update multiples rows of table: "offers" */
  update_offers_many?: Maybe<Array<Maybe<Offers_Mutation_Response>>>;
  /** update data of the table: "organizations" */
  update_organizations?: Maybe<Organizations_Mutation_Response>;
  /** update single row of the table: "organizations" */
  update_organizations_by_pk?: Maybe<Organizations>;
  /** update multiples rows of table: "organizations" */
  update_organizations_many?: Maybe<Array<Maybe<Organizations_Mutation_Response>>>;
  /** update data of the table: "organizationstocertifications" */
  update_organizationstocertifications?: Maybe<Organizationstocertifications_Mutation_Response>;
  /** update single row of the table: "organizationstocertifications" */
  update_organizationstocertifications_by_pk?: Maybe<Organizationstocertifications>;
  /** update multiples rows of table: "organizationstocertifications" */
  update_organizationstocertifications_many?: Maybe<Array<Maybe<Organizationstocertifications_Mutation_Response>>>;
  /** update data of the table: "paycycles" */
  update_paycycles?: Maybe<Paycycles_Mutation_Response>;
  /** update single row of the table: "paycycles" */
  update_paycycles_by_pk?: Maybe<Paycycles>;
  /** update multiples rows of table: "paycycles" */
  update_paycycles_many?: Maybe<Array<Maybe<Paycycles_Mutation_Response>>>;
  /** update data of the table: "paycycletodrivertodocuments" */
  update_paycycletodrivertodocuments?: Maybe<Paycycletodrivertodocuments_Mutation_Response>;
  /** update single row of the table: "paycycletodrivertodocuments" */
  update_paycycletodrivertodocuments_by_pk?: Maybe<Paycycletodrivertodocuments>;
  /** update multiples rows of table: "paycycletodrivertodocuments" */
  update_paycycletodrivertodocuments_many?: Maybe<Array<Maybe<Paycycletodrivertodocuments_Mutation_Response>>>;
  /** update data of the table: "payertocustomer" */
  update_payertocustomer?: Maybe<Payertocustomer_Mutation_Response>;
  /** update single row of the table: "payertocustomer" */
  update_payertocustomer_by_pk?: Maybe<Payertocustomer>;
  /** update multiples rows of table: "payertocustomer" */
  update_payertocustomer_many?: Maybe<Array<Maybe<Payertocustomer_Mutation_Response>>>;
  /** update data of the table: "payrategroups" */
  update_payrategroups?: Maybe<Payrategroups_Mutation_Response>;
  /** update single row of the table: "payrategroups" */
  update_payrategroups_by_pk?: Maybe<Payrategroups>;
  /** update multiples rows of table: "payrategroups" */
  update_payrategroups_many?: Maybe<Array<Maybe<Payrategroups_Mutation_Response>>>;
  /** update data of the table: "payraterules" */
  update_payraterules?: Maybe<Payraterules_Mutation_Response>;
  /** update single row of the table: "payraterules" */
  update_payraterules_by_pk?: Maybe<Payraterules>;
  /** update multiples rows of table: "payraterules" */
  update_payraterules_many?: Maybe<Array<Maybe<Payraterules_Mutation_Response>>>;
  /** update data of the table: "plans" */
  update_plans?: Maybe<Plans_Mutation_Response>;
  /** update single row of the table: "plans" */
  update_plans_by_pk?: Maybe<Plans>;
  /** update multiples rows of table: "plans" */
  update_plans_many?: Maybe<Array<Maybe<Plans_Mutation_Response>>>;
  /** update data of the table: "platedetails" */
  update_platedetails?: Maybe<Platedetails_Mutation_Response>;
  /** update single row of the table: "platedetails" */
  update_platedetails_by_pk?: Maybe<Platedetails>;
  /** update multiples rows of table: "platedetails" */
  update_platedetails_many?: Maybe<Array<Maybe<Platedetails_Mutation_Response>>>;
  /** update data of the table: "plates" */
  update_plates?: Maybe<Plates_Mutation_Response>;
  /** update single row of the table: "plates" */
  update_plates_by_pk?: Maybe<Plates>;
  /** update multiples rows of table: "plates" */
  update_plates_many?: Maybe<Array<Maybe<Plates_Mutation_Response>>>;
  /** update data of the table: "productfees" */
  update_productfees?: Maybe<Productfees_Mutation_Response>;
  /** update single row of the table: "productfees" */
  update_productfees_by_pk?: Maybe<Productfees>;
  /** update multiples rows of table: "productfees" */
  update_productfees_many?: Maybe<Array<Maybe<Productfees_Mutation_Response>>>;
  /** update data of the table: "products" */
  update_products?: Maybe<Products_Mutation_Response>;
  /** update single row of the table: "products" */
  update_products_by_pk?: Maybe<Products>;
  /** update multiples rows of table: "products" */
  update_products_many?: Maybe<Array<Maybe<Products_Mutation_Response>>>;
  /** update data of the table: "promos" */
  update_promos?: Maybe<Promos_Mutation_Response>;
  /** update single row of the table: "promos" */
  update_promos_by_pk?: Maybe<Promos>;
  /** update multiples rows of table: "promos" */
  update_promos_many?: Maybe<Array<Maybe<Promos_Mutation_Response>>>;
  /** update data of the table: "raterulegroups" */
  update_raterulegroups?: Maybe<Raterulegroups_Mutation_Response>;
  /** update single row of the table: "raterulegroups" */
  update_raterulegroups_by_pk?: Maybe<Raterulegroups>;
  /** update multiples rows of table: "raterulegroups" */
  update_raterulegroups_many?: Maybe<Array<Maybe<Raterulegroups_Mutation_Response>>>;
  /** update data of the table: "raterules" */
  update_raterules?: Maybe<Raterules_Mutation_Response>;
  /** update single row of the table: "raterules" */
  update_raterules_by_pk?: Maybe<Raterules>;
  /** update multiples rows of table: "raterules" */
  update_raterules_many?: Maybe<Array<Maybe<Raterules_Mutation_Response>>>;
  /** update data of the table: "regions" */
  update_regions?: Maybe<Regions_Mutation_Response>;
  /** update single row of the table: "regions" */
  update_regions_by_pk?: Maybe<Regions>;
  /** update multiples rows of table: "regions" */
  update_regions_many?: Maybe<Array<Maybe<Regions_Mutation_Response>>>;
  /** update data of the table: "ridegroups" */
  update_ridegroups?: Maybe<Ridegroups_Mutation_Response>;
  /** update single row of the table: "ridegroups" */
  update_ridegroups_by_pk?: Maybe<Ridegroups>;
  /** update multiples rows of table: "ridegroups" */
  update_ridegroups_many?: Maybe<Array<Maybe<Ridegroups_Mutation_Response>>>;
  /** update data of the table: "ridesharefares" */
  update_ridesharefares?: Maybe<Ridesharefares_Mutation_Response>;
  /** update single row of the table: "ridesharefares" */
  update_ridesharefares_by_pk?: Maybe<Ridesharefares>;
  /** update multiples rows of table: "ridesharefares" */
  update_ridesharefares_many?: Maybe<Array<Maybe<Ridesharefares_Mutation_Response>>>;
  /** update data of the table: "ridesharerates" */
  update_ridesharerates?: Maybe<Ridesharerates_Mutation_Response>;
  /** update single row of the table: "ridesharerates" */
  update_ridesharerates_by_pk?: Maybe<Ridesharerates>;
  /** update multiples rows of table: "ridesharerates" */
  update_ridesharerates_many?: Maybe<Array<Maybe<Ridesharerates_Mutation_Response>>>;
  /** update data of the table: "rideshareratetoridesharefares" */
  update_rideshareratetoridesharefares?: Maybe<Rideshareratetoridesharefares_Mutation_Response>;
  /** update single row of the table: "rideshareratetoridesharefares" */
  update_rideshareratetoridesharefares_by_pk?: Maybe<Rideshareratetoridesharefares>;
  /** update multiples rows of table: "rideshareratetoridesharefares" */
  update_rideshareratetoridesharefares_many?: Maybe<Array<Maybe<Rideshareratetoridesharefares_Mutation_Response>>>;
  /** update data of the table: "roletypes" */
  update_roletypes?: Maybe<Roletypes_Mutation_Response>;
  /** update single row of the table: "roletypes" */
  update_roletypes_by_pk?: Maybe<Roletypes>;
  /** update multiples rows of table: "roletypes" */
  update_roletypes_many?: Maybe<Array<Maybe<Roletypes_Mutation_Response>>>;
  /** update data of the table: "scenarios" */
  update_scenarios?: Maybe<Scenarios_Mutation_Response>;
  /** update single row of the table: "scenarios" */
  update_scenarios_by_pk?: Maybe<Scenarios>;
  /** update multiples rows of table: "scenarios" */
  update_scenarios_many?: Maybe<Array<Maybe<Scenarios_Mutation_Response>>>;
  /** update data of the table: "scenariotomoves" */
  update_scenariotomoves?: Maybe<Scenariotomoves_Mutation_Response>;
  /** update single row of the table: "scenariotomoves" */
  update_scenariotomoves_by_pk?: Maybe<Scenariotomoves>;
  /** update multiples rows of table: "scenariotomoves" */
  update_scenariotomoves_many?: Maybe<Array<Maybe<Scenariotomoves_Mutation_Response>>>;
  /** update data of the table: "scenariotypes" */
  update_scenariotypes?: Maybe<Scenariotypes_Mutation_Response>;
  /** update single row of the table: "scenariotypes" */
  update_scenariotypes_by_pk?: Maybe<Scenariotypes>;
  /** update multiples rows of table: "scenariotypes" */
  update_scenariotypes_many?: Maybe<Array<Maybe<Scenariotypes_Mutation_Response>>>;
  /** update data of the table: "scenariotypestocertifications" */
  update_scenariotypestocertifications?: Maybe<Scenariotypestocertifications_Mutation_Response>;
  /** update single row of the table: "scenariotypestocertifications" */
  update_scenariotypestocertifications_by_pk?: Maybe<Scenariotypestocertifications>;
  /** update multiples rows of table: "scenariotypestocertifications" */
  update_scenariotypestocertifications_many?: Maybe<Array<Maybe<Scenariotypestocertifications_Mutation_Response>>>;
  /** update data of the table: "sequelizemeta" */
  update_sequelizemeta?: Maybe<Sequelizemeta_Mutation_Response>;
  /** update single row of the table: "sequelizemeta" */
  update_sequelizemeta_by_pk?: Maybe<Sequelizemeta>;
  /** update multiples rows of table: "sequelizemeta" */
  update_sequelizemeta_many?: Maybe<Array<Maybe<Sequelizemeta_Mutation_Response>>>;
  /** update data of the table: "slas" */
  update_slas?: Maybe<Slas_Mutation_Response>;
  /** update single row of the table: "slas" */
  update_slas_by_pk?: Maybe<Slas>;
  /** update multiples rows of table: "slas" */
  update_slas_many?: Maybe<Array<Maybe<Slas_Mutation_Response>>>;
  /** update data of the table: "slas_to_raterulegroups" */
  update_slas_to_raterulegroups?: Maybe<Slas_To_Raterulegroups_Mutation_Response>;
  /** update single row of the table: "slas_to_raterulegroups" */
  update_slas_to_raterulegroups_by_pk?: Maybe<Slas_To_Raterulegroups>;
  /** update multiples rows of table: "slas_to_raterulegroups" */
  update_slas_to_raterulegroups_many?: Maybe<Array<Maybe<Slas_To_Raterulegroups_Mutation_Response>>>;
  /** update data of the table: "smsmedia" */
  update_smsmedia?: Maybe<Smsmedia_Mutation_Response>;
  /** update single row of the table: "smsmedia" */
  update_smsmedia_by_pk?: Maybe<Smsmedia>;
  /** update multiples rows of table: "smsmedia" */
  update_smsmedia_many?: Maybe<Array<Maybe<Smsmedia_Mutation_Response>>>;
  /** update data of the table: "smsmessages" */
  update_smsmessages?: Maybe<Smsmessages_Mutation_Response>;
  /** update single row of the table: "smsmessages" */
  update_smsmessages_by_pk?: Maybe<Smsmessages>;
  /** update multiples rows of table: "smsmessages" */
  update_smsmessages_many?: Maybe<Array<Maybe<Smsmessages_Mutation_Response>>>;
  /** update data of the table: "smstemplates" */
  update_smstemplates?: Maybe<Smstemplates_Mutation_Response>;
  /** update single row of the table: "smstemplates" */
  update_smstemplates_by_pk?: Maybe<Smstemplates>;
  /** update multiples rows of table: "smstemplates" */
  update_smstemplates_many?: Maybe<Array<Maybe<Smstemplates_Mutation_Response>>>;
  /** update data of the table: "subscriptions" */
  update_subscriptions?: Maybe<Subscriptions_Mutation_Response>;
  /** update single row of the table: "subscriptions" */
  update_subscriptions_by_pk?: Maybe<Subscriptions>;
  /** update multiples rows of table: "subscriptions" */
  update_subscriptions_many?: Maybe<Array<Maybe<Subscriptions_Mutation_Response>>>;
  /** update data of the table: "templates" */
  update_templates?: Maybe<Templates_Mutation_Response>;
  /** update single row of the table: "templates" */
  update_templates_by_pk?: Maybe<Templates>;
  /** update multiples rows of table: "templates" */
  update_templates_many?: Maybe<Array<Maybe<Templates_Mutation_Response>>>;
  /** update data of the table: "trips" */
  update_trips?: Maybe<Trips_Mutation_Response>;
  /** update single row of the table: "trips" */
  update_trips_by_pk?: Maybe<Trips>;
  /** update multiples rows of table: "trips" */
  update_trips_many?: Maybe<Array<Maybe<Trips_Mutation_Response>>>;
  /** update data of the table: "usecases" */
  update_usecases?: Maybe<Usecases_Mutation_Response>;
  /** update single row of the table: "usecases" */
  update_usecases_by_pk?: Maybe<Usecases>;
  /** update multiples rows of table: "usecases" */
  update_usecases_many?: Maybe<Array<Maybe<Usecases_Mutation_Response>>>;
  /** update data of the table: "usecasetocertifications" */
  update_usecasetocertifications?: Maybe<Usecasetocertifications_Mutation_Response>;
  /** update single row of the table: "usecasetocertifications" */
  update_usecasetocertifications_by_pk?: Maybe<Usecasetocertifications>;
  /** update multiples rows of table: "usecasetocertifications" */
  update_usecasetocertifications_many?: Maybe<Array<Maybe<Usecasetocertifications_Mutation_Response>>>;
  /** update data of the table: "usereventlogs" */
  update_usereventlogs?: Maybe<Usereventlogs_Mutation_Response>;
  /** update single row of the table: "usereventlogs" */
  update_usereventlogs_by_pk?: Maybe<Usereventlogs>;
  /** update multiples rows of table: "usereventlogs" */
  update_usereventlogs_many?: Maybe<Array<Maybe<Usereventlogs_Mutation_Response>>>;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  /** update data of the table: "usertocustomers" */
  update_usertocustomers?: Maybe<Usertocustomers_Mutation_Response>;
  /** update single row of the table: "usertocustomers" */
  update_usertocustomers_by_pk?: Maybe<Usertocustomers>;
  /** update multiples rows of table: "usertocustomers" */
  update_usertocustomers_many?: Maybe<Array<Maybe<Usertocustomers_Mutation_Response>>>;
  /** update data of the table: "usertofeatures" */
  update_usertofeatures?: Maybe<Usertofeatures_Mutation_Response>;
  /** update single row of the table: "usertofeatures" */
  update_usertofeatures_by_pk?: Maybe<Usertofeatures>;
  /** update multiples rows of table: "usertofeatures" */
  update_usertofeatures_many?: Maybe<Array<Maybe<Usertofeatures_Mutation_Response>>>;
  /** update data of the table: "usertoregions" */
  update_usertoregions?: Maybe<Usertoregions_Mutation_Response>;
  /** update single row of the table: "usertoregions" */
  update_usertoregions_by_pk?: Maybe<Usertoregions>;
  /** update multiples rows of table: "usertoregions" */
  update_usertoregions_many?: Maybe<Array<Maybe<Usertoregions_Mutation_Response>>>;
  /** update data of the table: "usertoroles" */
  update_usertoroles?: Maybe<Usertoroles_Mutation_Response>;
  /** update single row of the table: "usertoroles" */
  update_usertoroles_by_pk?: Maybe<Usertoroles>;
  /** update multiples rows of table: "usertoroles" */
  update_usertoroles_many?: Maybe<Array<Maybe<Usertoroles_Mutation_Response>>>;
  /** update data of the table: "vehiclemakes" */
  update_vehiclemakes?: Maybe<Vehiclemakes_Mutation_Response>;
  /** update single row of the table: "vehiclemakes" */
  update_vehiclemakes_by_pk?: Maybe<Vehiclemakes>;
  /** update multiples rows of table: "vehiclemakes" */
  update_vehiclemakes_many?: Maybe<Array<Maybe<Vehiclemakes_Mutation_Response>>>;
  /** update data of the table: "vehiclemodels" */
  update_vehiclemodels?: Maybe<Vehiclemodels_Mutation_Response>;
  /** update single row of the table: "vehiclemodels" */
  update_vehiclemodels_by_pk?: Maybe<Vehiclemodels>;
  /** update multiples rows of table: "vehiclemodels" */
  update_vehiclemodels_many?: Maybe<Array<Maybe<Vehiclemodels_Mutation_Response>>>;
  /** update data of the table: "vehiclephotos" */
  update_vehiclephotos?: Maybe<Vehiclephotos_Mutation_Response>;
  /** update single row of the table: "vehiclephotos" */
  update_vehiclephotos_by_pk?: Maybe<Vehiclephotos>;
  /** update multiples rows of table: "vehiclephotos" */
  update_vehiclephotos_many?: Maybe<Array<Maybe<Vehiclephotos_Mutation_Response>>>;
  /** update data of the table: "vehicles" */
  update_vehicles?: Maybe<Vehicles_Mutation_Response>;
  /** update single row of the table: "vehicles" */
  update_vehicles_by_pk?: Maybe<Vehicles>;
  /** update multiples rows of table: "vehicles" */
  update_vehicles_many?: Maybe<Array<Maybe<Vehicles_Mutation_Response>>>;
  /** update data of the table: "webhook_events" */
  update_webhook_events?: Maybe<Webhook_Events_Mutation_Response>;
  /** update single row of the table: "webhook_events" */
  update_webhook_events_by_pk?: Maybe<Webhook_Events>;
  /** update multiples rows of table: "webhook_events" */
  update_webhook_events_many?: Maybe<Array<Maybe<Webhook_Events_Mutation_Response>>>;
  /** update data of the table: "workflows" */
  update_workflows?: Maybe<Workflows_Mutation_Response>;
  /** update single row of the table: "workflows" */
  update_workflows_by_pk?: Maybe<Workflows>;
  /** update multiples rows of table: "workflows" */
  update_workflows_many?: Maybe<Array<Maybe<Workflows_Mutation_Response>>>;
  /** update data of the table: "workflowsets" */
  update_workflowsets?: Maybe<Workflowsets_Mutation_Response>;
  /** update single row of the table: "workflowsets" */
  update_workflowsets_by_pk?: Maybe<Workflowsets>;
  /** update multiples rows of table: "workflowsets" */
  update_workflowsets_many?: Maybe<Array<Maybe<Workflowsets_Mutation_Response>>>;
  /** update data of the table: "workflowsettypes" */
  update_workflowsettypes?: Maybe<Workflowsettypes_Mutation_Response>;
  /** update single row of the table: "workflowsettypes" */
  update_workflowsettypes_by_pk?: Maybe<Workflowsettypes>;
  /** update multiples rows of table: "workflowsettypes" */
  update_workflowsettypes_many?: Maybe<Array<Maybe<Workflowsettypes_Mutation_Response>>>;
  /** update data of the table: "workflowsettypestocertifications" */
  update_workflowsettypestocertifications?: Maybe<Workflowsettypestocertifications_Mutation_Response>;
  /** update single row of the table: "workflowsettypestocertifications" */
  update_workflowsettypestocertifications_by_pk?: Maybe<Workflowsettypestocertifications>;
  /** update multiples rows of table: "workflowsettypestocertifications" */
  update_workflowsettypestocertifications_many?: Maybe<Array<Maybe<Workflowsettypestocertifications_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootDelete_AccessorialsArgs = {
  where: Accessorials_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Accessorials_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AccessorialstoalgorithmsArgs = {
  where: Accessorialstoalgorithms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Accessorialstoalgorithms_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ActiontypesArgs = {
  where: Actiontypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Actiontypes_By_PkArgs = {
  id: Scalars['smallint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ActivetimesArgs = {
  where: Activetimes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Activetimes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AlgorithmsArgs = {
  where: Algorithms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Algorithms_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ApchargesArgs = {
  where: Apcharges_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Apcharges_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AppaymentsArgs = {
  where: Appayments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Appayments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AppointmentsArgs = {
  where: Appointments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Appointments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AppraisalsArgs = {
  where: Appraisals_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Appraisals_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AreventsArgs = {
  where: Arevents_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arevents_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArinvoicesArgs = {
  where: Arinvoices_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arinvoices_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArmovedetailsArgs = {
  where: Armovedetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Armovedetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArmovedetailshistoryArgs = {
  where: Armovedetailshistory_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Armovedetailshistory_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArmovesArgs = {
  where: Armoves_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Armoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArmoveshistoryArgs = {
  where: Armoveshistory_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Armoveshistory_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArpaymentdetailsArgs = {
  where: Arpaymentdetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arpaymentdetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArpaymentmethodsArgs = {
  where: Arpaymentmethods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arpaymentmethods_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArpaymentsArgs = {
  where: Arpayments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arpayments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ArpriceoverridesArgs = {
  where: Arpriceoverrides_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arpriceoverrides_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AuthkeysArgs = {
  where: Authkeys_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Authkeys_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_AuthorizationsArgs = {
  where: Authorizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Authorizations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Batch_JobsArgs = {
  where: Batch_Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Batch_Jobs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_BundlesArgs = {
  where: Bundles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bundles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_BundlesetsArgs = {
  where: Bundlesets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bundlesets_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_BundletoscenariosArgs = {
  where: Bundletoscenarios_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Bundletoscenarios_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_BusinesshoursArgs = {
  where: Businesshours_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Businesshours_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_BusinessrulesArgs = {
  where: Businessrules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Businessrules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_BusinessruletypesArgs = {
  where: Businessruletypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Businessruletypes_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CertificationsArgs = {
  where: Certifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Certifications_By_PkArgs = {
  key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ChasevehiclesArgs = {
  where: Chasevehicles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chasevehicles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ChasevehiclesassignedArgs = {
  where: Chasevehiclesassigned_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chasevehiclesassigned_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Consumer_NumbersArgs = {
  where: Consumer_Numbers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Consumer_Numbers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CoordinatedplansArgs = {
  where: Coordinatedplans_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Coordinatedplans_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CoordinatedplantoscenariosArgs = {
  where: Coordinatedplantoscenarios_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Coordinatedplantoscenarios_By_PkArgs = {
  coordinatedplan_id: Scalars['bigint']['input'];
  scenario_id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CustomersArgs = {
  where: Customers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Customers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CustomerstocertificationsArgs = {
  where: Customerstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Customerstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  customer_id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DocumentsArgs = {
  where: Documents_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Documents_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverappconfigArgs = {
  where: Driverappconfig_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverappconfig_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverblacklistArgs = {
  where: Driverblacklist_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverblacklist_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverdetailsArgs = {
  where: Driverdetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverdetails_By_PkArgs = {
  driver_id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverequipmentArgs = {
  where: Driverequipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverequipment_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverlocationsArgs = {
  where: Driverlocations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_DriverpayoutsArgs = {
  where: Driverpayouts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverpayouts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverpaysArgs = {
  where: Driverpays_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverpays_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriversArgs = {
  where: Drivers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Drivers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverscheduledetailsArgs = {
  where: Driverscheduledetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverscheduledetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverschedulesArgs = {
  where: Driverschedules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverschedules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverstocertificationsArgs = {
  where: Driverstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  driver_id: Scalars['bigint']['input'];
  effective_date: Scalars['timestamptz']['input'];
};


/** mutation root */
export type Mutation_RootDelete_DriverstousecasesoptoutArgs = {
  where: Driverstousecasesoptout_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Driverstousecasesoptout_By_PkArgs = {
  driver_id: Scalars['bigint']['input'];
  usecase_key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Email_EventsArgs = {
  where: Email_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Email_Events_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_EquipmentArgs = {
  where: Equipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Equipment_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Event_ExecutionsArgs = {
  where: Event_Executions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Event_Executions_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_EventlogsArgs = {
  where: Eventlogs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Eventlogs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_EventsArgs = {
  where: Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Events_By_PkArgs = {
  eventid: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FaqsArgs = {
  where: Faqs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faqs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FavoritelanesArgs = {
  where: Favoritelanes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Favoritelanes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FavoritelocationsArgs = {
  where: Favoritelocations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Favoritelocations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FeaturesArgs = {
  where: Features_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Features_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FuelpricesArgs = {
  where: Fuelprices_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Fuelprices_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_HangtagsArgs = {
  where: Hangtags_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Hangtags_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_InsuranceratesArgs = {
  where: Insurancerates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Insurancerates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_InvocationsArgs = {
  where: Invocations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Invocations_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Job_ExecutionsArgs = {
  where: Job_Executions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Executions_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LanemodifiersArgs = {
  where: Lanemodifiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Lanemodifiers_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LanesArgs = {
  where: Lanes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Lanes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LocationsArgs = {
  where: Locations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Locations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LocationstocertificationsArgs = {
  where: Locationstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Locationstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  location_id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LyftrideattemptsArgs = {
  where: Lyftrideattempts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Lyftrideattempts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_LyftridesArgs = {
  where: Lyftrides_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Lyftrides_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Metrics_HourlyArgs = {
  where: Metrics_Hourly_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Metrics_Hourly_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_MoveauditArgs = {
  where: Moveaudit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Moveaudit_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_MovesArgs = {
  where: Moves_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Moves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_NotificationsArgs = {
  where: Notifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Notifications_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_OffersArgs = {
  where: Offers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Offers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_OrganizationsArgs = {
  where: Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organizations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_OrganizationstocertificationsArgs = {
  where: Organizationstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organizationstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  organization_id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PaycyclesArgs = {
  where: Paycycles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Paycycles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PaycycletodrivertodocumentsArgs = {
  where: Paycycletodrivertodocuments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Paycycletodrivertodocuments_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PayertocustomerArgs = {
  where: Payertocustomer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Payertocustomer_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PayrategroupsArgs = {
  where: Payrategroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Payrategroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PayraterulesArgs = {
  where: Payraterules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Payraterules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PlansArgs = {
  where: Plans_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Plans_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PlatedetailsArgs = {
  where: Platedetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Platedetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PlatesArgs = {
  where: Plates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Plates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ProductfeesArgs = {
  where: Productfees_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Productfees_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ProductsArgs = {
  where: Products_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Products_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_PromosArgs = {
  where: Promos_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Promos_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RaterulegroupsArgs = {
  where: Raterulegroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Raterulegroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RaterulesArgs = {
  where: Raterules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Raterules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RegionsArgs = {
  where: Regions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Regions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RidegroupsArgs = {
  where: Ridegroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Ridegroups_By_PkArgs = {
  drive_move_id: Scalars['bigint']['input'];
  group_id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RidesharefaresArgs = {
  where: Ridesharefares_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Ridesharefares_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RideshareratesArgs = {
  where: Ridesharerates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Ridesharerates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RideshareratetoridesharefaresArgs = {
  where: Rideshareratetoridesharefares_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rideshareratetoridesharefares_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RoletypesArgs = {
  where: Roletypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Roletypes_By_PkArgs = {
  id: Scalars['smallint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ScenariosArgs = {
  where: Scenarios_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Scenarios_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ScenariotomovesArgs = {
  where: Scenariotomoves_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Scenariotomoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ScenariotypesArgs = {
  where: Scenariotypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Scenariotypes_By_PkArgs = {
  key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_ScenariotypestocertificationsArgs = {
  where: Scenariotypestocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Scenariotypestocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  scenario_key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SequelizemetaArgs = {
  where: Sequelizemeta_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Sequelizemeta_By_PkArgs = {
  name: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SlasArgs = {
  where: Slas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Slas_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Slas_To_RaterulegroupsArgs = {
  where: Slas_To_Raterulegroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Slas_To_Raterulegroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SmsmediaArgs = {
  where: Smsmedia_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Smsmedia_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SmsmessagesArgs = {
  where: Smsmessages_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Smsmessages_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SmstemplatesArgs = {
  where: Smstemplates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Smstemplates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_SubscriptionsArgs = {
  where: Subscriptions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Subscriptions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_TemplatesArgs = {
  where: Templates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Templates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_TripsArgs = {
  where: Trips_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Trips_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsecasesArgs = {
  where: Usecases_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usecases_By_PkArgs = {
  key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsecasetocertificationsArgs = {
  where: Usecasetocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usecasetocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  usecase_key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsereventlogsArgs = {
  where: Usereventlogs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usereventlogs_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsertocustomersArgs = {
  where: Usertocustomers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usertocustomers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsertofeaturesArgs = {
  where: Usertofeatures_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usertofeatures_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsertoregionsArgs = {
  where: Usertoregions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usertoregions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsertorolesArgs = {
  where: Usertoroles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Usertoroles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VehiclemakesArgs = {
  where: Vehiclemakes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vehiclemakes_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VehiclemodelsArgs = {
  where: Vehiclemodels_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vehiclemodels_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VehiclephotosArgs = {
  where: Vehiclephotos_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vehiclephotos_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_VehiclesArgs = {
  where: Vehicles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Vehicles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Webhook_EventsArgs = {
  where: Webhook_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Webhook_Events_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_WorkflowsArgs = {
  where: Workflows_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Workflows_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_WorkflowsetsArgs = {
  where: Workflowsets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Workflowsets_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_WorkflowsettypesArgs = {
  where: Workflowsettypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Workflowsettypes_By_PkArgs = {
  key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_WorkflowsettypestocertificationsArgs = {
  where: Workflowsettypestocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Workflowsettypestocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  workflow_set_type_key: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootInsert_AccessorialsArgs = {
  objects: Array<Accessorials_Insert_Input>;
  on_conflict?: InputMaybe<Accessorials_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Accessorials_OneArgs = {
  object: Accessorials_Insert_Input;
  on_conflict?: InputMaybe<Accessorials_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AccessorialstoalgorithmsArgs = {
  objects: Array<Accessorialstoalgorithms_Insert_Input>;
  on_conflict?: InputMaybe<Accessorialstoalgorithms_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Accessorialstoalgorithms_OneArgs = {
  object: Accessorialstoalgorithms_Insert_Input;
  on_conflict?: InputMaybe<Accessorialstoalgorithms_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ActiontypesArgs = {
  objects: Array<Actiontypes_Insert_Input>;
  on_conflict?: InputMaybe<Actiontypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Actiontypes_OneArgs = {
  object: Actiontypes_Insert_Input;
  on_conflict?: InputMaybe<Actiontypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ActivetimesArgs = {
  objects: Array<Activetimes_Insert_Input>;
  on_conflict?: InputMaybe<Activetimes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Activetimes_OneArgs = {
  object: Activetimes_Insert_Input;
  on_conflict?: InputMaybe<Activetimes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AlgorithmsArgs = {
  objects: Array<Algorithms_Insert_Input>;
  on_conflict?: InputMaybe<Algorithms_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Algorithms_OneArgs = {
  object: Algorithms_Insert_Input;
  on_conflict?: InputMaybe<Algorithms_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ApchargesArgs = {
  objects: Array<Apcharges_Insert_Input>;
  on_conflict?: InputMaybe<Apcharges_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Apcharges_OneArgs = {
  object: Apcharges_Insert_Input;
  on_conflict?: InputMaybe<Apcharges_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AppaymentsArgs = {
  objects: Array<Appayments_Insert_Input>;
  on_conflict?: InputMaybe<Appayments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Appayments_OneArgs = {
  object: Appayments_Insert_Input;
  on_conflict?: InputMaybe<Appayments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AppointmentsArgs = {
  objects: Array<Appointments_Insert_Input>;
  on_conflict?: InputMaybe<Appointments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Appointments_OneArgs = {
  object: Appointments_Insert_Input;
  on_conflict?: InputMaybe<Appointments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AppraisalsArgs = {
  objects: Array<Appraisals_Insert_Input>;
  on_conflict?: InputMaybe<Appraisals_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Appraisals_OneArgs = {
  object: Appraisals_Insert_Input;
  on_conflict?: InputMaybe<Appraisals_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AreventsArgs = {
  objects: Array<Arevents_Insert_Input>;
  on_conflict?: InputMaybe<Arevents_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arevents_OneArgs = {
  object: Arevents_Insert_Input;
  on_conflict?: InputMaybe<Arevents_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArinvoicesArgs = {
  objects: Array<Arinvoices_Insert_Input>;
  on_conflict?: InputMaybe<Arinvoices_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arinvoices_OneArgs = {
  object: Arinvoices_Insert_Input;
  on_conflict?: InputMaybe<Arinvoices_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArmovedetailsArgs = {
  objects: Array<Armovedetails_Insert_Input>;
  on_conflict?: InputMaybe<Armovedetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Armovedetails_OneArgs = {
  object: Armovedetails_Insert_Input;
  on_conflict?: InputMaybe<Armovedetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArmovedetailshistoryArgs = {
  objects: Array<Armovedetailshistory_Insert_Input>;
  on_conflict?: InputMaybe<Armovedetailshistory_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Armovedetailshistory_OneArgs = {
  object: Armovedetailshistory_Insert_Input;
  on_conflict?: InputMaybe<Armovedetailshistory_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArmovesArgs = {
  objects: Array<Armoves_Insert_Input>;
  on_conflict?: InputMaybe<Armoves_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Armoves_OneArgs = {
  object: Armoves_Insert_Input;
  on_conflict?: InputMaybe<Armoves_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArmoveshistoryArgs = {
  objects: Array<Armoveshistory_Insert_Input>;
  on_conflict?: InputMaybe<Armoveshistory_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Armoveshistory_OneArgs = {
  object: Armoveshistory_Insert_Input;
  on_conflict?: InputMaybe<Armoveshistory_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArpaymentdetailsArgs = {
  objects: Array<Arpaymentdetails_Insert_Input>;
  on_conflict?: InputMaybe<Arpaymentdetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arpaymentdetails_OneArgs = {
  object: Arpaymentdetails_Insert_Input;
  on_conflict?: InputMaybe<Arpaymentdetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArpaymentmethodsArgs = {
  objects: Array<Arpaymentmethods_Insert_Input>;
  on_conflict?: InputMaybe<Arpaymentmethods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arpaymentmethods_OneArgs = {
  object: Arpaymentmethods_Insert_Input;
  on_conflict?: InputMaybe<Arpaymentmethods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArpaymentsArgs = {
  objects: Array<Arpayments_Insert_Input>;
  on_conflict?: InputMaybe<Arpayments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arpayments_OneArgs = {
  object: Arpayments_Insert_Input;
  on_conflict?: InputMaybe<Arpayments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ArpriceoverridesArgs = {
  objects: Array<Arpriceoverrides_Insert_Input>;
  on_conflict?: InputMaybe<Arpriceoverrides_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arpriceoverrides_OneArgs = {
  object: Arpriceoverrides_Insert_Input;
  on_conflict?: InputMaybe<Arpriceoverrides_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AuthkeysArgs = {
  objects: Array<Authkeys_Insert_Input>;
  on_conflict?: InputMaybe<Authkeys_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Authkeys_OneArgs = {
  object: Authkeys_Insert_Input;
  on_conflict?: InputMaybe<Authkeys_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AuthorizationsArgs = {
  objects: Array<Authorizations_Insert_Input>;
  on_conflict?: InputMaybe<Authorizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Authorizations_OneArgs = {
  object: Authorizations_Insert_Input;
  on_conflict?: InputMaybe<Authorizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Batch_JobsArgs = {
  objects: Array<Batch_Jobs_Insert_Input>;
  on_conflict?: InputMaybe<Batch_Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Batch_Jobs_OneArgs = {
  object: Batch_Jobs_Insert_Input;
  on_conflict?: InputMaybe<Batch_Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BundlesArgs = {
  objects: Array<Bundles_Insert_Input>;
  on_conflict?: InputMaybe<Bundles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bundles_OneArgs = {
  object: Bundles_Insert_Input;
  on_conflict?: InputMaybe<Bundles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BundlesetsArgs = {
  objects: Array<Bundlesets_Insert_Input>;
  on_conflict?: InputMaybe<Bundlesets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bundlesets_OneArgs = {
  object: Bundlesets_Insert_Input;
  on_conflict?: InputMaybe<Bundlesets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BundletoscenariosArgs = {
  objects: Array<Bundletoscenarios_Insert_Input>;
  on_conflict?: InputMaybe<Bundletoscenarios_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Bundletoscenarios_OneArgs = {
  object: Bundletoscenarios_Insert_Input;
  on_conflict?: InputMaybe<Bundletoscenarios_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BusinesshoursArgs = {
  objects: Array<Businesshours_Insert_Input>;
  on_conflict?: InputMaybe<Businesshours_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Businesshours_OneArgs = {
  object: Businesshours_Insert_Input;
  on_conflict?: InputMaybe<Businesshours_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BusinessrulesArgs = {
  objects: Array<Businessrules_Insert_Input>;
  on_conflict?: InputMaybe<Businessrules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Businessrules_OneArgs = {
  object: Businessrules_Insert_Input;
  on_conflict?: InputMaybe<Businessrules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BusinessruletypesArgs = {
  objects: Array<Businessruletypes_Insert_Input>;
  on_conflict?: InputMaybe<Businessruletypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Businessruletypes_OneArgs = {
  object: Businessruletypes_Insert_Input;
  on_conflict?: InputMaybe<Businessruletypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CertificationsArgs = {
  objects: Array<Certifications_Insert_Input>;
  on_conflict?: InputMaybe<Certifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Certifications_OneArgs = {
  object: Certifications_Insert_Input;
  on_conflict?: InputMaybe<Certifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ChasevehiclesArgs = {
  objects: Array<Chasevehicles_Insert_Input>;
  on_conflict?: InputMaybe<Chasevehicles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chasevehicles_OneArgs = {
  object: Chasevehicles_Insert_Input;
  on_conflict?: InputMaybe<Chasevehicles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ChasevehiclesassignedArgs = {
  objects: Array<Chasevehiclesassigned_Insert_Input>;
  on_conflict?: InputMaybe<Chasevehiclesassigned_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chasevehiclesassigned_OneArgs = {
  object: Chasevehiclesassigned_Insert_Input;
  on_conflict?: InputMaybe<Chasevehiclesassigned_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Consumer_NumbersArgs = {
  objects: Array<Consumer_Numbers_Insert_Input>;
  on_conflict?: InputMaybe<Consumer_Numbers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Consumer_Numbers_OneArgs = {
  object: Consumer_Numbers_Insert_Input;
  on_conflict?: InputMaybe<Consumer_Numbers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CoordinatedplansArgs = {
  objects: Array<Coordinatedplans_Insert_Input>;
  on_conflict?: InputMaybe<Coordinatedplans_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Coordinatedplans_OneArgs = {
  object: Coordinatedplans_Insert_Input;
  on_conflict?: InputMaybe<Coordinatedplans_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CoordinatedplantoscenariosArgs = {
  objects: Array<Coordinatedplantoscenarios_Insert_Input>;
  on_conflict?: InputMaybe<Coordinatedplantoscenarios_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Coordinatedplantoscenarios_OneArgs = {
  object: Coordinatedplantoscenarios_Insert_Input;
  on_conflict?: InputMaybe<Coordinatedplantoscenarios_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CustomersArgs = {
  objects: Array<Customers_Insert_Input>;
  on_conflict?: InputMaybe<Customers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Customers_OneArgs = {
  object: Customers_Insert_Input;
  on_conflict?: InputMaybe<Customers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CustomerstocertificationsArgs = {
  objects: Array<Customerstocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Customerstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Customerstocertifications_OneArgs = {
  object: Customerstocertifications_Insert_Input;
  on_conflict?: InputMaybe<Customerstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DocumentsArgs = {
  objects: Array<Documents_Insert_Input>;
  on_conflict?: InputMaybe<Documents_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Documents_OneArgs = {
  object: Documents_Insert_Input;
  on_conflict?: InputMaybe<Documents_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverappconfigArgs = {
  objects: Array<Driverappconfig_Insert_Input>;
  on_conflict?: InputMaybe<Driverappconfig_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverappconfig_OneArgs = {
  object: Driverappconfig_Insert_Input;
  on_conflict?: InputMaybe<Driverappconfig_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverblacklistArgs = {
  objects: Array<Driverblacklist_Insert_Input>;
  on_conflict?: InputMaybe<Driverblacklist_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverblacklist_OneArgs = {
  object: Driverblacklist_Insert_Input;
  on_conflict?: InputMaybe<Driverblacklist_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverdetailsArgs = {
  objects: Array<Driverdetails_Insert_Input>;
  on_conflict?: InputMaybe<Driverdetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverdetails_OneArgs = {
  object: Driverdetails_Insert_Input;
  on_conflict?: InputMaybe<Driverdetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverequipmentArgs = {
  objects: Array<Driverequipment_Insert_Input>;
  on_conflict?: InputMaybe<Driverequipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverequipment_OneArgs = {
  object: Driverequipment_Insert_Input;
  on_conflict?: InputMaybe<Driverequipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverlocationsArgs = {
  objects: Array<Driverlocations_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Driverlocations_OneArgs = {
  object: Driverlocations_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_DriverpayoutsArgs = {
  objects: Array<Driverpayouts_Insert_Input>;
  on_conflict?: InputMaybe<Driverpayouts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverpayouts_OneArgs = {
  object: Driverpayouts_Insert_Input;
  on_conflict?: InputMaybe<Driverpayouts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverpaysArgs = {
  objects: Array<Driverpays_Insert_Input>;
  on_conflict?: InputMaybe<Driverpays_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverpays_OneArgs = {
  object: Driverpays_Insert_Input;
  on_conflict?: InputMaybe<Driverpays_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriversArgs = {
  objects: Array<Drivers_Insert_Input>;
  on_conflict?: InputMaybe<Drivers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Drivers_OneArgs = {
  object: Drivers_Insert_Input;
  on_conflict?: InputMaybe<Drivers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverscheduledetailsArgs = {
  objects: Array<Driverscheduledetails_Insert_Input>;
  on_conflict?: InputMaybe<Driverscheduledetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverscheduledetails_OneArgs = {
  object: Driverscheduledetails_Insert_Input;
  on_conflict?: InputMaybe<Driverscheduledetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverschedulesArgs = {
  objects: Array<Driverschedules_Insert_Input>;
  on_conflict?: InputMaybe<Driverschedules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverschedules_OneArgs = {
  object: Driverschedules_Insert_Input;
  on_conflict?: InputMaybe<Driverschedules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverstocertificationsArgs = {
  objects: Array<Driverstocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Driverstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverstocertifications_OneArgs = {
  object: Driverstocertifications_Insert_Input;
  on_conflict?: InputMaybe<Driverstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_DriverstousecasesoptoutArgs = {
  objects: Array<Driverstousecasesoptout_Insert_Input>;
  on_conflict?: InputMaybe<Driverstousecasesoptout_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Driverstousecasesoptout_OneArgs = {
  object: Driverstousecasesoptout_Insert_Input;
  on_conflict?: InputMaybe<Driverstousecasesoptout_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Email_EventsArgs = {
  objects: Array<Email_Events_Insert_Input>;
  on_conflict?: InputMaybe<Email_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Email_Events_OneArgs = {
  object: Email_Events_Insert_Input;
  on_conflict?: InputMaybe<Email_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EquipmentArgs = {
  objects: Array<Equipment_Insert_Input>;
  on_conflict?: InputMaybe<Equipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Equipment_OneArgs = {
  object: Equipment_Insert_Input;
  on_conflict?: InputMaybe<Equipment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_ExecutionsArgs = {
  objects: Array<Event_Executions_Insert_Input>;
  on_conflict?: InputMaybe<Event_Executions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_Executions_OneArgs = {
  object: Event_Executions_Insert_Input;
  on_conflict?: InputMaybe<Event_Executions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventlogsArgs = {
  objects: Array<Eventlogs_Insert_Input>;
  on_conflict?: InputMaybe<Eventlogs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Eventlogs_OneArgs = {
  object: Eventlogs_Insert_Input;
  on_conflict?: InputMaybe<Eventlogs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventsArgs = {
  objects: Array<Events_Insert_Input>;
  on_conflict?: InputMaybe<Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Events_OneArgs = {
  object: Events_Insert_Input;
  on_conflict?: InputMaybe<Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FaqsArgs = {
  objects: Array<Faqs_Insert_Input>;
  on_conflict?: InputMaybe<Faqs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faqs_OneArgs = {
  object: Faqs_Insert_Input;
  on_conflict?: InputMaybe<Faqs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FavoritelanesArgs = {
  objects: Array<Favoritelanes_Insert_Input>;
  on_conflict?: InputMaybe<Favoritelanes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favoritelanes_OneArgs = {
  object: Favoritelanes_Insert_Input;
  on_conflict?: InputMaybe<Favoritelanes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FavoritelocationsArgs = {
  objects: Array<Favoritelocations_Insert_Input>;
  on_conflict?: InputMaybe<Favoritelocations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Favoritelocations_OneArgs = {
  object: Favoritelocations_Insert_Input;
  on_conflict?: InputMaybe<Favoritelocations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FeaturesArgs = {
  objects: Array<Features_Insert_Input>;
  on_conflict?: InputMaybe<Features_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Features_OneArgs = {
  object: Features_Insert_Input;
  on_conflict?: InputMaybe<Features_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FuelpricesArgs = {
  objects: Array<Fuelprices_Insert_Input>;
  on_conflict?: InputMaybe<Fuelprices_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Fuelprices_OneArgs = {
  object: Fuelprices_Insert_Input;
  on_conflict?: InputMaybe<Fuelprices_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_HangtagsArgs = {
  objects: Array<Hangtags_Insert_Input>;
  on_conflict?: InputMaybe<Hangtags_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Hangtags_OneArgs = {
  object: Hangtags_Insert_Input;
  on_conflict?: InputMaybe<Hangtags_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InsuranceratesArgs = {
  objects: Array<Insurancerates_Insert_Input>;
  on_conflict?: InputMaybe<Insurancerates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Insurancerates_OneArgs = {
  object: Insurancerates_Insert_Input;
  on_conflict?: InputMaybe<Insurancerates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InvocationsArgs = {
  objects: Array<Invocations_Insert_Input>;
  on_conflict?: InputMaybe<Invocations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Invocations_OneArgs = {
  object: Invocations_Insert_Input;
  on_conflict?: InputMaybe<Invocations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_ExecutionsArgs = {
  objects: Array<Job_Executions_Insert_Input>;
  on_conflict?: InputMaybe<Job_Executions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Executions_OneArgs = {
  object: Job_Executions_Insert_Input;
  on_conflict?: InputMaybe<Job_Executions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LanemodifiersArgs = {
  objects: Array<Lanemodifiers_Insert_Input>;
  on_conflict?: InputMaybe<Lanemodifiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Lanemodifiers_OneArgs = {
  object: Lanemodifiers_Insert_Input;
  on_conflict?: InputMaybe<Lanemodifiers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LanesArgs = {
  objects: Array<Lanes_Insert_Input>;
  on_conflict?: InputMaybe<Lanes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Lanes_OneArgs = {
  object: Lanes_Insert_Input;
  on_conflict?: InputMaybe<Lanes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LocationsArgs = {
  objects: Array<Locations_Insert_Input>;
  on_conflict?: InputMaybe<Locations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Locations_OneArgs = {
  object: Locations_Insert_Input;
  on_conflict?: InputMaybe<Locations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LocationstocertificationsArgs = {
  objects: Array<Locationstocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Locationstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Locationstocertifications_OneArgs = {
  object: Locationstocertifications_Insert_Input;
  on_conflict?: InputMaybe<Locationstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LyftrideattemptsArgs = {
  objects: Array<Lyftrideattempts_Insert_Input>;
  on_conflict?: InputMaybe<Lyftrideattempts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Lyftrideattempts_OneArgs = {
  object: Lyftrideattempts_Insert_Input;
  on_conflict?: InputMaybe<Lyftrideattempts_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_LyftridesArgs = {
  objects: Array<Lyftrides_Insert_Input>;
  on_conflict?: InputMaybe<Lyftrides_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Lyftrides_OneArgs = {
  object: Lyftrides_Insert_Input;
  on_conflict?: InputMaybe<Lyftrides_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Metrics_HourlyArgs = {
  objects: Array<Metrics_Hourly_Insert_Input>;
  on_conflict?: InputMaybe<Metrics_Hourly_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Metrics_Hourly_OneArgs = {
  object: Metrics_Hourly_Insert_Input;
  on_conflict?: InputMaybe<Metrics_Hourly_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MoveauditArgs = {
  objects: Array<Moveaudit_Insert_Input>;
  on_conflict?: InputMaybe<Moveaudit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Moveaudit_OneArgs = {
  object: Moveaudit_Insert_Input;
  on_conflict?: InputMaybe<Moveaudit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MovesArgs = {
  objects: Array<Moves_Insert_Input>;
  on_conflict?: InputMaybe<Moves_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Moves_OneArgs = {
  object: Moves_Insert_Input;
  on_conflict?: InputMaybe<Moves_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_NotificationsArgs = {
  objects: Array<Notifications_Insert_Input>;
  on_conflict?: InputMaybe<Notifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Notifications_OneArgs = {
  object: Notifications_Insert_Input;
  on_conflict?: InputMaybe<Notifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OffersArgs = {
  objects: Array<Offers_Insert_Input>;
  on_conflict?: InputMaybe<Offers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Offers_OneArgs = {
  object: Offers_Insert_Input;
  on_conflict?: InputMaybe<Offers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OrganizationsArgs = {
  objects: Array<Organizations_Insert_Input>;
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organizations_OneArgs = {
  object: Organizations_Insert_Input;
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OrganizationstocertificationsArgs = {
  objects: Array<Organizationstocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Organizationstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organizationstocertifications_OneArgs = {
  object: Organizationstocertifications_Insert_Input;
  on_conflict?: InputMaybe<Organizationstocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PaycyclesArgs = {
  objects: Array<Paycycles_Insert_Input>;
  on_conflict?: InputMaybe<Paycycles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Paycycles_OneArgs = {
  object: Paycycles_Insert_Input;
  on_conflict?: InputMaybe<Paycycles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PaycycletodrivertodocumentsArgs = {
  objects: Array<Paycycletodrivertodocuments_Insert_Input>;
  on_conflict?: InputMaybe<Paycycletodrivertodocuments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Paycycletodrivertodocuments_OneArgs = {
  object: Paycycletodrivertodocuments_Insert_Input;
  on_conflict?: InputMaybe<Paycycletodrivertodocuments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PayertocustomerArgs = {
  objects: Array<Payertocustomer_Insert_Input>;
  on_conflict?: InputMaybe<Payertocustomer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payertocustomer_OneArgs = {
  object: Payertocustomer_Insert_Input;
  on_conflict?: InputMaybe<Payertocustomer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PayrategroupsArgs = {
  objects: Array<Payrategroups_Insert_Input>;
  on_conflict?: InputMaybe<Payrategroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payrategroups_OneArgs = {
  object: Payrategroups_Insert_Input;
  on_conflict?: InputMaybe<Payrategroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PayraterulesArgs = {
  objects: Array<Payraterules_Insert_Input>;
  on_conflict?: InputMaybe<Payraterules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payraterules_OneArgs = {
  object: Payraterules_Insert_Input;
  on_conflict?: InputMaybe<Payraterules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PlansArgs = {
  objects: Array<Plans_Insert_Input>;
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Plans_OneArgs = {
  object: Plans_Insert_Input;
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PlatedetailsArgs = {
  objects: Array<Platedetails_Insert_Input>;
  on_conflict?: InputMaybe<Platedetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Platedetails_OneArgs = {
  object: Platedetails_Insert_Input;
  on_conflict?: InputMaybe<Platedetails_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PlatesArgs = {
  objects: Array<Plates_Insert_Input>;
  on_conflict?: InputMaybe<Plates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Plates_OneArgs = {
  object: Plates_Insert_Input;
  on_conflict?: InputMaybe<Plates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProductfeesArgs = {
  objects: Array<Productfees_Insert_Input>;
  on_conflict?: InputMaybe<Productfees_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Productfees_OneArgs = {
  object: Productfees_Insert_Input;
  on_conflict?: InputMaybe<Productfees_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProductsArgs = {
  objects: Array<Products_Insert_Input>;
  on_conflict?: InputMaybe<Products_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Products_OneArgs = {
  object: Products_Insert_Input;
  on_conflict?: InputMaybe<Products_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PromosArgs = {
  objects: Array<Promos_Insert_Input>;
  on_conflict?: InputMaybe<Promos_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Promos_OneArgs = {
  object: Promos_Insert_Input;
  on_conflict?: InputMaybe<Promos_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RaterulegroupsArgs = {
  objects: Array<Raterulegroups_Insert_Input>;
  on_conflict?: InputMaybe<Raterulegroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Raterulegroups_OneArgs = {
  object: Raterulegroups_Insert_Input;
  on_conflict?: InputMaybe<Raterulegroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RaterulesArgs = {
  objects: Array<Raterules_Insert_Input>;
  on_conflict?: InputMaybe<Raterules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Raterules_OneArgs = {
  object: Raterules_Insert_Input;
  on_conflict?: InputMaybe<Raterules_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RegionsArgs = {
  objects: Array<Regions_Insert_Input>;
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Regions_OneArgs = {
  object: Regions_Insert_Input;
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RidegroupsArgs = {
  objects: Array<Ridegroups_Insert_Input>;
  on_conflict?: InputMaybe<Ridegroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Ridegroups_OneArgs = {
  object: Ridegroups_Insert_Input;
  on_conflict?: InputMaybe<Ridegroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RidesharefaresArgs = {
  objects: Array<Ridesharefares_Insert_Input>;
  on_conflict?: InputMaybe<Ridesharefares_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Ridesharefares_OneArgs = {
  object: Ridesharefares_Insert_Input;
  on_conflict?: InputMaybe<Ridesharefares_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RideshareratesArgs = {
  objects: Array<Ridesharerates_Insert_Input>;
  on_conflict?: InputMaybe<Ridesharerates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Ridesharerates_OneArgs = {
  object: Ridesharerates_Insert_Input;
  on_conflict?: InputMaybe<Ridesharerates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RideshareratetoridesharefaresArgs = {
  objects: Array<Rideshareratetoridesharefares_Insert_Input>;
  on_conflict?: InputMaybe<Rideshareratetoridesharefares_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rideshareratetoridesharefares_OneArgs = {
  object: Rideshareratetoridesharefares_Insert_Input;
  on_conflict?: InputMaybe<Rideshareratetoridesharefares_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoletypesArgs = {
  objects: Array<Roletypes_Insert_Input>;
  on_conflict?: InputMaybe<Roletypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Roletypes_OneArgs = {
  object: Roletypes_Insert_Input;
  on_conflict?: InputMaybe<Roletypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ScenariosArgs = {
  objects: Array<Scenarios_Insert_Input>;
  on_conflict?: InputMaybe<Scenarios_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Scenarios_OneArgs = {
  object: Scenarios_Insert_Input;
  on_conflict?: InputMaybe<Scenarios_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ScenariotomovesArgs = {
  objects: Array<Scenariotomoves_Insert_Input>;
  on_conflict?: InputMaybe<Scenariotomoves_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Scenariotomoves_OneArgs = {
  object: Scenariotomoves_Insert_Input;
  on_conflict?: InputMaybe<Scenariotomoves_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ScenariotypesArgs = {
  objects: Array<Scenariotypes_Insert_Input>;
  on_conflict?: InputMaybe<Scenariotypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Scenariotypes_OneArgs = {
  object: Scenariotypes_Insert_Input;
  on_conflict?: InputMaybe<Scenariotypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ScenariotypestocertificationsArgs = {
  objects: Array<Scenariotypestocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Scenariotypestocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Scenariotypestocertifications_OneArgs = {
  object: Scenariotypestocertifications_Insert_Input;
  on_conflict?: InputMaybe<Scenariotypestocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_SequelizemetaArgs = {
  objects: Array<Sequelizemeta_Insert_Input>;
  on_conflict?: InputMaybe<Sequelizemeta_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Sequelizemeta_OneArgs = {
  object: Sequelizemeta_Insert_Input;
  on_conflict?: InputMaybe<Sequelizemeta_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_SlasArgs = {
  objects: Array<Slas_Insert_Input>;
  on_conflict?: InputMaybe<Slas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Slas_OneArgs = {
  object: Slas_Insert_Input;
  on_conflict?: InputMaybe<Slas_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Slas_To_RaterulegroupsArgs = {
  objects: Array<Slas_To_Raterulegroups_Insert_Input>;
  on_conflict?: InputMaybe<Slas_To_Raterulegroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Slas_To_Raterulegroups_OneArgs = {
  object: Slas_To_Raterulegroups_Insert_Input;
  on_conflict?: InputMaybe<Slas_To_Raterulegroups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_SmsmediaArgs = {
  objects: Array<Smsmedia_Insert_Input>;
  on_conflict?: InputMaybe<Smsmedia_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Smsmedia_OneArgs = {
  object: Smsmedia_Insert_Input;
  on_conflict?: InputMaybe<Smsmedia_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_SmsmessagesArgs = {
  objects: Array<Smsmessages_Insert_Input>;
  on_conflict?: InputMaybe<Smsmessages_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Smsmessages_OneArgs = {
  object: Smsmessages_Insert_Input;
  on_conflict?: InputMaybe<Smsmessages_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_SmstemplatesArgs = {
  objects: Array<Smstemplates_Insert_Input>;
  on_conflict?: InputMaybe<Smstemplates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Smstemplates_OneArgs = {
  object: Smstemplates_Insert_Input;
  on_conflict?: InputMaybe<Smstemplates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_SubscriptionsArgs = {
  objects: Array<Subscriptions_Insert_Input>;
  on_conflict?: InputMaybe<Subscriptions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Subscriptions_OneArgs = {
  object: Subscriptions_Insert_Input;
  on_conflict?: InputMaybe<Subscriptions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TemplatesArgs = {
  objects: Array<Templates_Insert_Input>;
  on_conflict?: InputMaybe<Templates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Templates_OneArgs = {
  object: Templates_Insert_Input;
  on_conflict?: InputMaybe<Templates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TripsArgs = {
  objects: Array<Trips_Insert_Input>;
  on_conflict?: InputMaybe<Trips_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Trips_OneArgs = {
  object: Trips_Insert_Input;
  on_conflict?: InputMaybe<Trips_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsecasesArgs = {
  objects: Array<Usecases_Insert_Input>;
  on_conflict?: InputMaybe<Usecases_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usecases_OneArgs = {
  object: Usecases_Insert_Input;
  on_conflict?: InputMaybe<Usecases_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsecasetocertificationsArgs = {
  objects: Array<Usecasetocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Usecasetocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usecasetocertifications_OneArgs = {
  object: Usecasetocertifications_Insert_Input;
  on_conflict?: InputMaybe<Usecasetocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsereventlogsArgs = {
  objects: Array<Usereventlogs_Insert_Input>;
  on_conflict?: InputMaybe<Usereventlogs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usereventlogs_OneArgs = {
  object: Usereventlogs_Insert_Input;
  on_conflict?: InputMaybe<Usereventlogs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsertocustomersArgs = {
  objects: Array<Usertocustomers_Insert_Input>;
  on_conflict?: InputMaybe<Usertocustomers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usertocustomers_OneArgs = {
  object: Usertocustomers_Insert_Input;
  on_conflict?: InputMaybe<Usertocustomers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsertofeaturesArgs = {
  objects: Array<Usertofeatures_Insert_Input>;
  on_conflict?: InputMaybe<Usertofeatures_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usertofeatures_OneArgs = {
  object: Usertofeatures_Insert_Input;
  on_conflict?: InputMaybe<Usertofeatures_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsertoregionsArgs = {
  objects: Array<Usertoregions_Insert_Input>;
  on_conflict?: InputMaybe<Usertoregions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usertoregions_OneArgs = {
  object: Usertoregions_Insert_Input;
  on_conflict?: InputMaybe<Usertoregions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsertorolesArgs = {
  objects: Array<Usertoroles_Insert_Input>;
  on_conflict?: InputMaybe<Usertoroles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Usertoroles_OneArgs = {
  object: Usertoroles_Insert_Input;
  on_conflict?: InputMaybe<Usertoroles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VehiclemakesArgs = {
  objects: Array<Vehiclemakes_Insert_Input>;
  on_conflict?: InputMaybe<Vehiclemakes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Vehiclemakes_OneArgs = {
  object: Vehiclemakes_Insert_Input;
  on_conflict?: InputMaybe<Vehiclemakes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VehiclemodelsArgs = {
  objects: Array<Vehiclemodels_Insert_Input>;
  on_conflict?: InputMaybe<Vehiclemodels_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Vehiclemodels_OneArgs = {
  object: Vehiclemodels_Insert_Input;
  on_conflict?: InputMaybe<Vehiclemodels_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VehiclephotosArgs = {
  objects: Array<Vehiclephotos_Insert_Input>;
  on_conflict?: InputMaybe<Vehiclephotos_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Vehiclephotos_OneArgs = {
  object: Vehiclephotos_Insert_Input;
  on_conflict?: InputMaybe<Vehiclephotos_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VehiclesArgs = {
  objects: Array<Vehicles_Insert_Input>;
  on_conflict?: InputMaybe<Vehicles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Vehicles_OneArgs = {
  object: Vehicles_Insert_Input;
  on_conflict?: InputMaybe<Vehicles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Webhook_EventsArgs = {
  objects: Array<Webhook_Events_Insert_Input>;
  on_conflict?: InputMaybe<Webhook_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Webhook_Events_OneArgs = {
  object: Webhook_Events_Insert_Input;
  on_conflict?: InputMaybe<Webhook_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_WorkflowsArgs = {
  objects: Array<Workflows_Insert_Input>;
  on_conflict?: InputMaybe<Workflows_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Workflows_OneArgs = {
  object: Workflows_Insert_Input;
  on_conflict?: InputMaybe<Workflows_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_WorkflowsetsArgs = {
  objects: Array<Workflowsets_Insert_Input>;
  on_conflict?: InputMaybe<Workflowsets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Workflowsets_OneArgs = {
  object: Workflowsets_Insert_Input;
  on_conflict?: InputMaybe<Workflowsets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_WorkflowsettypesArgs = {
  objects: Array<Workflowsettypes_Insert_Input>;
  on_conflict?: InputMaybe<Workflowsettypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Workflowsettypes_OneArgs = {
  object: Workflowsettypes_Insert_Input;
  on_conflict?: InputMaybe<Workflowsettypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_WorkflowsettypestocertificationsArgs = {
  objects: Array<Workflowsettypestocertifications_Insert_Input>;
  on_conflict?: InputMaybe<Workflowsettypestocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Workflowsettypestocertifications_OneArgs = {
  object: Workflowsettypestocertifications_Insert_Input;
  on_conflict?: InputMaybe<Workflowsettypestocertifications_On_Conflict>;
};


/** mutation root */
export type Mutation_RootUpdate_AccessorialsArgs = {
  _inc?: InputMaybe<Accessorials_Inc_Input>;
  _set?: InputMaybe<Accessorials_Set_Input>;
  where: Accessorials_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Accessorials_By_PkArgs = {
  _inc?: InputMaybe<Accessorials_Inc_Input>;
  _set?: InputMaybe<Accessorials_Set_Input>;
  pk_columns: Accessorials_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Accessorials_ManyArgs = {
  updates: Array<Accessorials_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AccessorialstoalgorithmsArgs = {
  _inc?: InputMaybe<Accessorialstoalgorithms_Inc_Input>;
  _set?: InputMaybe<Accessorialstoalgorithms_Set_Input>;
  where: Accessorialstoalgorithms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Accessorialstoalgorithms_By_PkArgs = {
  _inc?: InputMaybe<Accessorialstoalgorithms_Inc_Input>;
  _set?: InputMaybe<Accessorialstoalgorithms_Set_Input>;
  pk_columns: Accessorialstoalgorithms_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Accessorialstoalgorithms_ManyArgs = {
  updates: Array<Accessorialstoalgorithms_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ActiontypesArgs = {
  _append?: InputMaybe<Actiontypes_Append_Input>;
  _delete_at_path?: InputMaybe<Actiontypes_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Actiontypes_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Actiontypes_Delete_Key_Input>;
  _inc?: InputMaybe<Actiontypes_Inc_Input>;
  _prepend?: InputMaybe<Actiontypes_Prepend_Input>;
  _set?: InputMaybe<Actiontypes_Set_Input>;
  where: Actiontypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Actiontypes_By_PkArgs = {
  _append?: InputMaybe<Actiontypes_Append_Input>;
  _delete_at_path?: InputMaybe<Actiontypes_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Actiontypes_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Actiontypes_Delete_Key_Input>;
  _inc?: InputMaybe<Actiontypes_Inc_Input>;
  _prepend?: InputMaybe<Actiontypes_Prepend_Input>;
  _set?: InputMaybe<Actiontypes_Set_Input>;
  pk_columns: Actiontypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Actiontypes_ManyArgs = {
  updates: Array<Actiontypes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ActivetimesArgs = {
  _append?: InputMaybe<Activetimes_Append_Input>;
  _delete_at_path?: InputMaybe<Activetimes_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Activetimes_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Activetimes_Delete_Key_Input>;
  _inc?: InputMaybe<Activetimes_Inc_Input>;
  _prepend?: InputMaybe<Activetimes_Prepend_Input>;
  _set?: InputMaybe<Activetimes_Set_Input>;
  where: Activetimes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Activetimes_By_PkArgs = {
  _append?: InputMaybe<Activetimes_Append_Input>;
  _delete_at_path?: InputMaybe<Activetimes_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Activetimes_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Activetimes_Delete_Key_Input>;
  _inc?: InputMaybe<Activetimes_Inc_Input>;
  _prepend?: InputMaybe<Activetimes_Prepend_Input>;
  _set?: InputMaybe<Activetimes_Set_Input>;
  pk_columns: Activetimes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Activetimes_ManyArgs = {
  updates: Array<Activetimes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AlgorithmsArgs = {
  _append?: InputMaybe<Algorithms_Append_Input>;
  _delete_at_path?: InputMaybe<Algorithms_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Algorithms_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Algorithms_Delete_Key_Input>;
  _inc?: InputMaybe<Algorithms_Inc_Input>;
  _prepend?: InputMaybe<Algorithms_Prepend_Input>;
  _set?: InputMaybe<Algorithms_Set_Input>;
  where: Algorithms_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Algorithms_By_PkArgs = {
  _append?: InputMaybe<Algorithms_Append_Input>;
  _delete_at_path?: InputMaybe<Algorithms_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Algorithms_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Algorithms_Delete_Key_Input>;
  _inc?: InputMaybe<Algorithms_Inc_Input>;
  _prepend?: InputMaybe<Algorithms_Prepend_Input>;
  _set?: InputMaybe<Algorithms_Set_Input>;
  pk_columns: Algorithms_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Algorithms_ManyArgs = {
  updates: Array<Algorithms_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApchargesArgs = {
  _inc?: InputMaybe<Apcharges_Inc_Input>;
  _set?: InputMaybe<Apcharges_Set_Input>;
  where: Apcharges_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Apcharges_By_PkArgs = {
  _inc?: InputMaybe<Apcharges_Inc_Input>;
  _set?: InputMaybe<Apcharges_Set_Input>;
  pk_columns: Apcharges_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Apcharges_ManyArgs = {
  updates: Array<Apcharges_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AppaymentsArgs = {
  _inc?: InputMaybe<Appayments_Inc_Input>;
  _set?: InputMaybe<Appayments_Set_Input>;
  where: Appayments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Appayments_By_PkArgs = {
  _inc?: InputMaybe<Appayments_Inc_Input>;
  _set?: InputMaybe<Appayments_Set_Input>;
  pk_columns: Appayments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Appayments_ManyArgs = {
  updates: Array<Appayments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AppointmentsArgs = {
  _append?: InputMaybe<Appointments_Append_Input>;
  _delete_at_path?: InputMaybe<Appointments_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Appointments_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Appointments_Delete_Key_Input>;
  _inc?: InputMaybe<Appointments_Inc_Input>;
  _prepend?: InputMaybe<Appointments_Prepend_Input>;
  _set?: InputMaybe<Appointments_Set_Input>;
  where: Appointments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Appointments_By_PkArgs = {
  _append?: InputMaybe<Appointments_Append_Input>;
  _delete_at_path?: InputMaybe<Appointments_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Appointments_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Appointments_Delete_Key_Input>;
  _inc?: InputMaybe<Appointments_Inc_Input>;
  _prepend?: InputMaybe<Appointments_Prepend_Input>;
  _set?: InputMaybe<Appointments_Set_Input>;
  pk_columns: Appointments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Appointments_ManyArgs = {
  updates: Array<Appointments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AppraisalsArgs = {
  _append?: InputMaybe<Appraisals_Append_Input>;
  _delete_at_path?: InputMaybe<Appraisals_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Appraisals_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Appraisals_Delete_Key_Input>;
  _inc?: InputMaybe<Appraisals_Inc_Input>;
  _prepend?: InputMaybe<Appraisals_Prepend_Input>;
  _set?: InputMaybe<Appraisals_Set_Input>;
  where: Appraisals_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Appraisals_By_PkArgs = {
  _append?: InputMaybe<Appraisals_Append_Input>;
  _delete_at_path?: InputMaybe<Appraisals_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Appraisals_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Appraisals_Delete_Key_Input>;
  _inc?: InputMaybe<Appraisals_Inc_Input>;
  _prepend?: InputMaybe<Appraisals_Prepend_Input>;
  _set?: InputMaybe<Appraisals_Set_Input>;
  pk_columns: Appraisals_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Appraisals_ManyArgs = {
  updates: Array<Appraisals_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AreventsArgs = {
  _inc?: InputMaybe<Arevents_Inc_Input>;
  _set?: InputMaybe<Arevents_Set_Input>;
  where: Arevents_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arevents_By_PkArgs = {
  _inc?: InputMaybe<Arevents_Inc_Input>;
  _set?: InputMaybe<Arevents_Set_Input>;
  pk_columns: Arevents_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arevents_ManyArgs = {
  updates: Array<Arevents_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArinvoicesArgs = {
  _inc?: InputMaybe<Arinvoices_Inc_Input>;
  _set?: InputMaybe<Arinvoices_Set_Input>;
  where: Arinvoices_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arinvoices_By_PkArgs = {
  _inc?: InputMaybe<Arinvoices_Inc_Input>;
  _set?: InputMaybe<Arinvoices_Set_Input>;
  pk_columns: Arinvoices_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arinvoices_ManyArgs = {
  updates: Array<Arinvoices_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArmovedetailsArgs = {
  _inc?: InputMaybe<Armovedetails_Inc_Input>;
  _set?: InputMaybe<Armovedetails_Set_Input>;
  where: Armovedetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Armovedetails_By_PkArgs = {
  _inc?: InputMaybe<Armovedetails_Inc_Input>;
  _set?: InputMaybe<Armovedetails_Set_Input>;
  pk_columns: Armovedetails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Armovedetails_ManyArgs = {
  updates: Array<Armovedetails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArmovedetailshistoryArgs = {
  _inc?: InputMaybe<Armovedetailshistory_Inc_Input>;
  _set?: InputMaybe<Armovedetailshistory_Set_Input>;
  where: Armovedetailshistory_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Armovedetailshistory_By_PkArgs = {
  _inc?: InputMaybe<Armovedetailshistory_Inc_Input>;
  _set?: InputMaybe<Armovedetailshistory_Set_Input>;
  pk_columns: Armovedetailshistory_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Armovedetailshistory_ManyArgs = {
  updates: Array<Armovedetailshistory_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArmovesArgs = {
  _inc?: InputMaybe<Armoves_Inc_Input>;
  _set?: InputMaybe<Armoves_Set_Input>;
  where: Armoves_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Armoves_By_PkArgs = {
  _inc?: InputMaybe<Armoves_Inc_Input>;
  _set?: InputMaybe<Armoves_Set_Input>;
  pk_columns: Armoves_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Armoves_ManyArgs = {
  updates: Array<Armoves_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArmoveshistoryArgs = {
  _inc?: InputMaybe<Armoveshistory_Inc_Input>;
  _set?: InputMaybe<Armoveshistory_Set_Input>;
  where: Armoveshistory_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Armoveshistory_By_PkArgs = {
  _inc?: InputMaybe<Armoveshistory_Inc_Input>;
  _set?: InputMaybe<Armoveshistory_Set_Input>;
  pk_columns: Armoveshistory_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Armoveshistory_ManyArgs = {
  updates: Array<Armoveshistory_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArpaymentdetailsArgs = {
  _inc?: InputMaybe<Arpaymentdetails_Inc_Input>;
  _set?: InputMaybe<Arpaymentdetails_Set_Input>;
  where: Arpaymentdetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arpaymentdetails_By_PkArgs = {
  _inc?: InputMaybe<Arpaymentdetails_Inc_Input>;
  _set?: InputMaybe<Arpaymentdetails_Set_Input>;
  pk_columns: Arpaymentdetails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arpaymentdetails_ManyArgs = {
  updates: Array<Arpaymentdetails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArpaymentmethodsArgs = {
  _inc?: InputMaybe<Arpaymentmethods_Inc_Input>;
  _set?: InputMaybe<Arpaymentmethods_Set_Input>;
  where: Arpaymentmethods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arpaymentmethods_By_PkArgs = {
  _inc?: InputMaybe<Arpaymentmethods_Inc_Input>;
  _set?: InputMaybe<Arpaymentmethods_Set_Input>;
  pk_columns: Arpaymentmethods_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arpaymentmethods_ManyArgs = {
  updates: Array<Arpaymentmethods_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArpaymentsArgs = {
  _inc?: InputMaybe<Arpayments_Inc_Input>;
  _set?: InputMaybe<Arpayments_Set_Input>;
  where: Arpayments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arpayments_By_PkArgs = {
  _inc?: InputMaybe<Arpayments_Inc_Input>;
  _set?: InputMaybe<Arpayments_Set_Input>;
  pk_columns: Arpayments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arpayments_ManyArgs = {
  updates: Array<Arpayments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ArpriceoverridesArgs = {
  _append?: InputMaybe<Arpriceoverrides_Append_Input>;
  _delete_at_path?: InputMaybe<Arpriceoverrides_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Arpriceoverrides_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Arpriceoverrides_Delete_Key_Input>;
  _inc?: InputMaybe<Arpriceoverrides_Inc_Input>;
  _prepend?: InputMaybe<Arpriceoverrides_Prepend_Input>;
  _set?: InputMaybe<Arpriceoverrides_Set_Input>;
  where: Arpriceoverrides_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arpriceoverrides_By_PkArgs = {
  _append?: InputMaybe<Arpriceoverrides_Append_Input>;
  _delete_at_path?: InputMaybe<Arpriceoverrides_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Arpriceoverrides_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Arpriceoverrides_Delete_Key_Input>;
  _inc?: InputMaybe<Arpriceoverrides_Inc_Input>;
  _prepend?: InputMaybe<Arpriceoverrides_Prepend_Input>;
  _set?: InputMaybe<Arpriceoverrides_Set_Input>;
  pk_columns: Arpriceoverrides_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arpriceoverrides_ManyArgs = {
  updates: Array<Arpriceoverrides_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthkeysArgs = {
  _inc?: InputMaybe<Authkeys_Inc_Input>;
  _set?: InputMaybe<Authkeys_Set_Input>;
  where: Authkeys_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Authkeys_By_PkArgs = {
  _inc?: InputMaybe<Authkeys_Inc_Input>;
  _set?: InputMaybe<Authkeys_Set_Input>;
  pk_columns: Authkeys_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Authkeys_ManyArgs = {
  updates: Array<Authkeys_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthorizationsArgs = {
  _inc?: InputMaybe<Authorizations_Inc_Input>;
  _set?: InputMaybe<Authorizations_Set_Input>;
  where: Authorizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Authorizations_By_PkArgs = {
  _inc?: InputMaybe<Authorizations_Inc_Input>;
  _set?: InputMaybe<Authorizations_Set_Input>;
  pk_columns: Authorizations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Authorizations_ManyArgs = {
  updates: Array<Authorizations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Batch_JobsArgs = {
  _append?: InputMaybe<Batch_Jobs_Append_Input>;
  _delete_at_path?: InputMaybe<Batch_Jobs_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Batch_Jobs_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Batch_Jobs_Delete_Key_Input>;
  _inc?: InputMaybe<Batch_Jobs_Inc_Input>;
  _prepend?: InputMaybe<Batch_Jobs_Prepend_Input>;
  _set?: InputMaybe<Batch_Jobs_Set_Input>;
  where: Batch_Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Batch_Jobs_By_PkArgs = {
  _append?: InputMaybe<Batch_Jobs_Append_Input>;
  _delete_at_path?: InputMaybe<Batch_Jobs_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Batch_Jobs_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Batch_Jobs_Delete_Key_Input>;
  _inc?: InputMaybe<Batch_Jobs_Inc_Input>;
  _prepend?: InputMaybe<Batch_Jobs_Prepend_Input>;
  _set?: InputMaybe<Batch_Jobs_Set_Input>;
  pk_columns: Batch_Jobs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Batch_Jobs_ManyArgs = {
  updates: Array<Batch_Jobs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BundlesArgs = {
  _append?: InputMaybe<Bundles_Append_Input>;
  _delete_at_path?: InputMaybe<Bundles_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bundles_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bundles_Delete_Key_Input>;
  _inc?: InputMaybe<Bundles_Inc_Input>;
  _prepend?: InputMaybe<Bundles_Prepend_Input>;
  _set?: InputMaybe<Bundles_Set_Input>;
  where: Bundles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bundles_By_PkArgs = {
  _append?: InputMaybe<Bundles_Append_Input>;
  _delete_at_path?: InputMaybe<Bundles_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bundles_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bundles_Delete_Key_Input>;
  _inc?: InputMaybe<Bundles_Inc_Input>;
  _prepend?: InputMaybe<Bundles_Prepend_Input>;
  _set?: InputMaybe<Bundles_Set_Input>;
  pk_columns: Bundles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bundles_ManyArgs = {
  updates: Array<Bundles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BundlesetsArgs = {
  _append?: InputMaybe<Bundlesets_Append_Input>;
  _delete_at_path?: InputMaybe<Bundlesets_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bundlesets_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bundlesets_Delete_Key_Input>;
  _inc?: InputMaybe<Bundlesets_Inc_Input>;
  _prepend?: InputMaybe<Bundlesets_Prepend_Input>;
  _set?: InputMaybe<Bundlesets_Set_Input>;
  where: Bundlesets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bundlesets_By_PkArgs = {
  _append?: InputMaybe<Bundlesets_Append_Input>;
  _delete_at_path?: InputMaybe<Bundlesets_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Bundlesets_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Bundlesets_Delete_Key_Input>;
  _inc?: InputMaybe<Bundlesets_Inc_Input>;
  _prepend?: InputMaybe<Bundlesets_Prepend_Input>;
  _set?: InputMaybe<Bundlesets_Set_Input>;
  pk_columns: Bundlesets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bundlesets_ManyArgs = {
  updates: Array<Bundlesets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BundletoscenariosArgs = {
  _inc?: InputMaybe<Bundletoscenarios_Inc_Input>;
  _set?: InputMaybe<Bundletoscenarios_Set_Input>;
  where: Bundletoscenarios_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Bundletoscenarios_By_PkArgs = {
  _inc?: InputMaybe<Bundletoscenarios_Inc_Input>;
  _set?: InputMaybe<Bundletoscenarios_Set_Input>;
  pk_columns: Bundletoscenarios_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Bundletoscenarios_ManyArgs = {
  updates: Array<Bundletoscenarios_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinesshoursArgs = {
  _inc?: InputMaybe<Businesshours_Inc_Input>;
  _set?: InputMaybe<Businesshours_Set_Input>;
  where: Businesshours_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Businesshours_By_PkArgs = {
  _inc?: InputMaybe<Businesshours_Inc_Input>;
  _set?: InputMaybe<Businesshours_Set_Input>;
  pk_columns: Businesshours_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Businesshours_ManyArgs = {
  updates: Array<Businesshours_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessrulesArgs = {
  _append?: InputMaybe<Businessrules_Append_Input>;
  _delete_at_path?: InputMaybe<Businessrules_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Businessrules_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Businessrules_Delete_Key_Input>;
  _inc?: InputMaybe<Businessrules_Inc_Input>;
  _prepend?: InputMaybe<Businessrules_Prepend_Input>;
  _set?: InputMaybe<Businessrules_Set_Input>;
  where: Businessrules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Businessrules_By_PkArgs = {
  _append?: InputMaybe<Businessrules_Append_Input>;
  _delete_at_path?: InputMaybe<Businessrules_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Businessrules_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Businessrules_Delete_Key_Input>;
  _inc?: InputMaybe<Businessrules_Inc_Input>;
  _prepend?: InputMaybe<Businessrules_Prepend_Input>;
  _set?: InputMaybe<Businessrules_Set_Input>;
  pk_columns: Businessrules_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Businessrules_ManyArgs = {
  updates: Array<Businessrules_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessruletypesArgs = {
  _inc?: InputMaybe<Businessruletypes_Inc_Input>;
  _set?: InputMaybe<Businessruletypes_Set_Input>;
  where: Businessruletypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Businessruletypes_By_PkArgs = {
  _inc?: InputMaybe<Businessruletypes_Inc_Input>;
  _set?: InputMaybe<Businessruletypes_Set_Input>;
  pk_columns: Businessruletypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Businessruletypes_ManyArgs = {
  updates: Array<Businessruletypes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CertificationsArgs = {
  _set?: InputMaybe<Certifications_Set_Input>;
  where: Certifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Certifications_By_PkArgs = {
  _set?: InputMaybe<Certifications_Set_Input>;
  pk_columns: Certifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Certifications_ManyArgs = {
  updates: Array<Certifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ChasevehiclesArgs = {
  _inc?: InputMaybe<Chasevehicles_Inc_Input>;
  _set?: InputMaybe<Chasevehicles_Set_Input>;
  where: Chasevehicles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chasevehicles_By_PkArgs = {
  _inc?: InputMaybe<Chasevehicles_Inc_Input>;
  _set?: InputMaybe<Chasevehicles_Set_Input>;
  pk_columns: Chasevehicles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chasevehicles_ManyArgs = {
  updates: Array<Chasevehicles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ChasevehiclesassignedArgs = {
  _append?: InputMaybe<Chasevehiclesassigned_Append_Input>;
  _delete_at_path?: InputMaybe<Chasevehiclesassigned_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Chasevehiclesassigned_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Chasevehiclesassigned_Delete_Key_Input>;
  _inc?: InputMaybe<Chasevehiclesassigned_Inc_Input>;
  _prepend?: InputMaybe<Chasevehiclesassigned_Prepend_Input>;
  _set?: InputMaybe<Chasevehiclesassigned_Set_Input>;
  where: Chasevehiclesassigned_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chasevehiclesassigned_By_PkArgs = {
  _append?: InputMaybe<Chasevehiclesassigned_Append_Input>;
  _delete_at_path?: InputMaybe<Chasevehiclesassigned_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Chasevehiclesassigned_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Chasevehiclesassigned_Delete_Key_Input>;
  _inc?: InputMaybe<Chasevehiclesassigned_Inc_Input>;
  _prepend?: InputMaybe<Chasevehiclesassigned_Prepend_Input>;
  _set?: InputMaybe<Chasevehiclesassigned_Set_Input>;
  pk_columns: Chasevehiclesassigned_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chasevehiclesassigned_ManyArgs = {
  updates: Array<Chasevehiclesassigned_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Consumer_NumbersArgs = {
  _inc?: InputMaybe<Consumer_Numbers_Inc_Input>;
  _set?: InputMaybe<Consumer_Numbers_Set_Input>;
  where: Consumer_Numbers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Consumer_Numbers_By_PkArgs = {
  _inc?: InputMaybe<Consumer_Numbers_Inc_Input>;
  _set?: InputMaybe<Consumer_Numbers_Set_Input>;
  pk_columns: Consumer_Numbers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Consumer_Numbers_ManyArgs = {
  updates: Array<Consumer_Numbers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CoordinatedplansArgs = {
  _append?: InputMaybe<Coordinatedplans_Append_Input>;
  _delete_at_path?: InputMaybe<Coordinatedplans_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Coordinatedplans_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Coordinatedplans_Delete_Key_Input>;
  _inc?: InputMaybe<Coordinatedplans_Inc_Input>;
  _prepend?: InputMaybe<Coordinatedplans_Prepend_Input>;
  _set?: InputMaybe<Coordinatedplans_Set_Input>;
  where: Coordinatedplans_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Coordinatedplans_By_PkArgs = {
  _append?: InputMaybe<Coordinatedplans_Append_Input>;
  _delete_at_path?: InputMaybe<Coordinatedplans_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Coordinatedplans_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Coordinatedplans_Delete_Key_Input>;
  _inc?: InputMaybe<Coordinatedplans_Inc_Input>;
  _prepend?: InputMaybe<Coordinatedplans_Prepend_Input>;
  _set?: InputMaybe<Coordinatedplans_Set_Input>;
  pk_columns: Coordinatedplans_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Coordinatedplans_ManyArgs = {
  updates: Array<Coordinatedplans_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CoordinatedplantoscenariosArgs = {
  _inc?: InputMaybe<Coordinatedplantoscenarios_Inc_Input>;
  _set?: InputMaybe<Coordinatedplantoscenarios_Set_Input>;
  where: Coordinatedplantoscenarios_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Coordinatedplantoscenarios_By_PkArgs = {
  _inc?: InputMaybe<Coordinatedplantoscenarios_Inc_Input>;
  _set?: InputMaybe<Coordinatedplantoscenarios_Set_Input>;
  pk_columns: Coordinatedplantoscenarios_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Coordinatedplantoscenarios_ManyArgs = {
  updates: Array<Coordinatedplantoscenarios_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CustomersArgs = {
  _append?: InputMaybe<Customers_Append_Input>;
  _delete_at_path?: InputMaybe<Customers_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Customers_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Customers_Delete_Key_Input>;
  _inc?: InputMaybe<Customers_Inc_Input>;
  _prepend?: InputMaybe<Customers_Prepend_Input>;
  _set?: InputMaybe<Customers_Set_Input>;
  where: Customers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Customers_By_PkArgs = {
  _append?: InputMaybe<Customers_Append_Input>;
  _delete_at_path?: InputMaybe<Customers_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Customers_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Customers_Delete_Key_Input>;
  _inc?: InputMaybe<Customers_Inc_Input>;
  _prepend?: InputMaybe<Customers_Prepend_Input>;
  _set?: InputMaybe<Customers_Set_Input>;
  pk_columns: Customers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Customers_ManyArgs = {
  updates: Array<Customers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CustomerstocertificationsArgs = {
  _inc?: InputMaybe<Customerstocertifications_Inc_Input>;
  _set?: InputMaybe<Customerstocertifications_Set_Input>;
  where: Customerstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Customerstocertifications_By_PkArgs = {
  _inc?: InputMaybe<Customerstocertifications_Inc_Input>;
  _set?: InputMaybe<Customerstocertifications_Set_Input>;
  pk_columns: Customerstocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Customerstocertifications_ManyArgs = {
  updates: Array<Customerstocertifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DocumentsArgs = {
  _inc?: InputMaybe<Documents_Inc_Input>;
  _set?: InputMaybe<Documents_Set_Input>;
  where: Documents_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Documents_By_PkArgs = {
  _inc?: InputMaybe<Documents_Inc_Input>;
  _set?: InputMaybe<Documents_Set_Input>;
  pk_columns: Documents_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Documents_ManyArgs = {
  updates: Array<Documents_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverappconfigArgs = {
  _append?: InputMaybe<Driverappconfig_Append_Input>;
  _delete_at_path?: InputMaybe<Driverappconfig_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Driverappconfig_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Driverappconfig_Delete_Key_Input>;
  _inc?: InputMaybe<Driverappconfig_Inc_Input>;
  _prepend?: InputMaybe<Driverappconfig_Prepend_Input>;
  _set?: InputMaybe<Driverappconfig_Set_Input>;
  where: Driverappconfig_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverappconfig_By_PkArgs = {
  _append?: InputMaybe<Driverappconfig_Append_Input>;
  _delete_at_path?: InputMaybe<Driverappconfig_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Driverappconfig_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Driverappconfig_Delete_Key_Input>;
  _inc?: InputMaybe<Driverappconfig_Inc_Input>;
  _prepend?: InputMaybe<Driverappconfig_Prepend_Input>;
  _set?: InputMaybe<Driverappconfig_Set_Input>;
  pk_columns: Driverappconfig_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverappconfig_ManyArgs = {
  updates: Array<Driverappconfig_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverblacklistArgs = {
  _inc?: InputMaybe<Driverblacklist_Inc_Input>;
  _set?: InputMaybe<Driverblacklist_Set_Input>;
  where: Driverblacklist_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverblacklist_By_PkArgs = {
  _inc?: InputMaybe<Driverblacklist_Inc_Input>;
  _set?: InputMaybe<Driverblacklist_Set_Input>;
  pk_columns: Driverblacklist_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverblacklist_ManyArgs = {
  updates: Array<Driverblacklist_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverdetailsArgs = {
  _append?: InputMaybe<Driverdetails_Append_Input>;
  _delete_at_path?: InputMaybe<Driverdetails_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Driverdetails_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Driverdetails_Delete_Key_Input>;
  _inc?: InputMaybe<Driverdetails_Inc_Input>;
  _prepend?: InputMaybe<Driverdetails_Prepend_Input>;
  _set?: InputMaybe<Driverdetails_Set_Input>;
  where: Driverdetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverdetails_By_PkArgs = {
  _append?: InputMaybe<Driverdetails_Append_Input>;
  _delete_at_path?: InputMaybe<Driverdetails_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Driverdetails_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Driverdetails_Delete_Key_Input>;
  _inc?: InputMaybe<Driverdetails_Inc_Input>;
  _prepend?: InputMaybe<Driverdetails_Prepend_Input>;
  _set?: InputMaybe<Driverdetails_Set_Input>;
  pk_columns: Driverdetails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverdetails_ManyArgs = {
  updates: Array<Driverdetails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverequipmentArgs = {
  _inc?: InputMaybe<Driverequipment_Inc_Input>;
  _set?: InputMaybe<Driverequipment_Set_Input>;
  where: Driverequipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverequipment_By_PkArgs = {
  _inc?: InputMaybe<Driverequipment_Inc_Input>;
  _set?: InputMaybe<Driverequipment_Set_Input>;
  pk_columns: Driverequipment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverequipment_ManyArgs = {
  updates: Array<Driverequipment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverlocationsArgs = {
  _inc?: InputMaybe<Driverlocations_Inc_Input>;
  _set?: InputMaybe<Driverlocations_Set_Input>;
  where: Driverlocations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverlocations_ManyArgs = {
  updates: Array<Driverlocations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverpayoutsArgs = {
  _inc?: InputMaybe<Driverpayouts_Inc_Input>;
  _set?: InputMaybe<Driverpayouts_Set_Input>;
  where: Driverpayouts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverpayouts_By_PkArgs = {
  _inc?: InputMaybe<Driverpayouts_Inc_Input>;
  _set?: InputMaybe<Driverpayouts_Set_Input>;
  pk_columns: Driverpayouts_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverpayouts_ManyArgs = {
  updates: Array<Driverpayouts_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverpaysArgs = {
  _inc?: InputMaybe<Driverpays_Inc_Input>;
  _set?: InputMaybe<Driverpays_Set_Input>;
  where: Driverpays_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverpays_By_PkArgs = {
  _inc?: InputMaybe<Driverpays_Inc_Input>;
  _set?: InputMaybe<Driverpays_Set_Input>;
  pk_columns: Driverpays_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverpays_ManyArgs = {
  updates: Array<Driverpays_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriversArgs = {
  _append?: InputMaybe<Drivers_Append_Input>;
  _delete_at_path?: InputMaybe<Drivers_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Drivers_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Drivers_Delete_Key_Input>;
  _inc?: InputMaybe<Drivers_Inc_Input>;
  _prepend?: InputMaybe<Drivers_Prepend_Input>;
  _set?: InputMaybe<Drivers_Set_Input>;
  where: Drivers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Drivers_By_PkArgs = {
  _append?: InputMaybe<Drivers_Append_Input>;
  _delete_at_path?: InputMaybe<Drivers_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Drivers_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Drivers_Delete_Key_Input>;
  _inc?: InputMaybe<Drivers_Inc_Input>;
  _prepend?: InputMaybe<Drivers_Prepend_Input>;
  _set?: InputMaybe<Drivers_Set_Input>;
  pk_columns: Drivers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Drivers_ManyArgs = {
  updates: Array<Drivers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverscheduledetailsArgs = {
  _inc?: InputMaybe<Driverscheduledetails_Inc_Input>;
  _set?: InputMaybe<Driverscheduledetails_Set_Input>;
  where: Driverscheduledetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverscheduledetails_By_PkArgs = {
  _inc?: InputMaybe<Driverscheduledetails_Inc_Input>;
  _set?: InputMaybe<Driverscheduledetails_Set_Input>;
  pk_columns: Driverscheduledetails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverscheduledetails_ManyArgs = {
  updates: Array<Driverscheduledetails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverschedulesArgs = {
  _inc?: InputMaybe<Driverschedules_Inc_Input>;
  _set?: InputMaybe<Driverschedules_Set_Input>;
  where: Driverschedules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverschedules_By_PkArgs = {
  _inc?: InputMaybe<Driverschedules_Inc_Input>;
  _set?: InputMaybe<Driverschedules_Set_Input>;
  pk_columns: Driverschedules_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverschedules_ManyArgs = {
  updates: Array<Driverschedules_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverstocertificationsArgs = {
  _inc?: InputMaybe<Driverstocertifications_Inc_Input>;
  _set?: InputMaybe<Driverstocertifications_Set_Input>;
  where: Driverstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverstocertifications_By_PkArgs = {
  _inc?: InputMaybe<Driverstocertifications_Inc_Input>;
  _set?: InputMaybe<Driverstocertifications_Set_Input>;
  pk_columns: Driverstocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverstocertifications_ManyArgs = {
  updates: Array<Driverstocertifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DriverstousecasesoptoutArgs = {
  _inc?: InputMaybe<Driverstousecasesoptout_Inc_Input>;
  _set?: InputMaybe<Driverstousecasesoptout_Set_Input>;
  where: Driverstousecasesoptout_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Driverstousecasesoptout_By_PkArgs = {
  _inc?: InputMaybe<Driverstousecasesoptout_Inc_Input>;
  _set?: InputMaybe<Driverstousecasesoptout_Set_Input>;
  pk_columns: Driverstousecasesoptout_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Driverstousecasesoptout_ManyArgs = {
  updates: Array<Driverstousecasesoptout_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Email_EventsArgs = {
  _inc?: InputMaybe<Email_Events_Inc_Input>;
  _set?: InputMaybe<Email_Events_Set_Input>;
  where: Email_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Email_Events_By_PkArgs = {
  _inc?: InputMaybe<Email_Events_Inc_Input>;
  _set?: InputMaybe<Email_Events_Set_Input>;
  pk_columns: Email_Events_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Email_Events_ManyArgs = {
  updates: Array<Email_Events_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_EquipmentArgs = {
  _inc?: InputMaybe<Equipment_Inc_Input>;
  _set?: InputMaybe<Equipment_Set_Input>;
  where: Equipment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Equipment_By_PkArgs = {
  _inc?: InputMaybe<Equipment_Inc_Input>;
  _set?: InputMaybe<Equipment_Set_Input>;
  pk_columns: Equipment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Equipment_ManyArgs = {
  updates: Array<Equipment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Event_ExecutionsArgs = {
  _inc?: InputMaybe<Event_Executions_Inc_Input>;
  _set?: InputMaybe<Event_Executions_Set_Input>;
  where: Event_Executions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Executions_By_PkArgs = {
  _inc?: InputMaybe<Event_Executions_Inc_Input>;
  _set?: InputMaybe<Event_Executions_Set_Input>;
  pk_columns: Event_Executions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Event_Executions_ManyArgs = {
  updates: Array<Event_Executions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_EventlogsArgs = {
  _append?: InputMaybe<Eventlogs_Append_Input>;
  _delete_at_path?: InputMaybe<Eventlogs_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Eventlogs_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Eventlogs_Delete_Key_Input>;
  _inc?: InputMaybe<Eventlogs_Inc_Input>;
  _prepend?: InputMaybe<Eventlogs_Prepend_Input>;
  _set?: InputMaybe<Eventlogs_Set_Input>;
  where: Eventlogs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Eventlogs_By_PkArgs = {
  _append?: InputMaybe<Eventlogs_Append_Input>;
  _delete_at_path?: InputMaybe<Eventlogs_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Eventlogs_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Eventlogs_Delete_Key_Input>;
  _inc?: InputMaybe<Eventlogs_Inc_Input>;
  _prepend?: InputMaybe<Eventlogs_Prepend_Input>;
  _set?: InputMaybe<Eventlogs_Set_Input>;
  pk_columns: Eventlogs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Eventlogs_ManyArgs = {
  updates: Array<Eventlogs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_EventsArgs = {
  _set?: InputMaybe<Events_Set_Input>;
  where: Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Events_By_PkArgs = {
  _set?: InputMaybe<Events_Set_Input>;
  pk_columns: Events_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Events_ManyArgs = {
  updates: Array<Events_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FaqsArgs = {
  _inc?: InputMaybe<Faqs_Inc_Input>;
  _set?: InputMaybe<Faqs_Set_Input>;
  where: Faqs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faqs_By_PkArgs = {
  _inc?: InputMaybe<Faqs_Inc_Input>;
  _set?: InputMaybe<Faqs_Set_Input>;
  pk_columns: Faqs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faqs_ManyArgs = {
  updates: Array<Faqs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FavoritelanesArgs = {
  _inc?: InputMaybe<Favoritelanes_Inc_Input>;
  _set?: InputMaybe<Favoritelanes_Set_Input>;
  where: Favoritelanes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Favoritelanes_By_PkArgs = {
  _inc?: InputMaybe<Favoritelanes_Inc_Input>;
  _set?: InputMaybe<Favoritelanes_Set_Input>;
  pk_columns: Favoritelanes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Favoritelanes_ManyArgs = {
  updates: Array<Favoritelanes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FavoritelocationsArgs = {
  _inc?: InputMaybe<Favoritelocations_Inc_Input>;
  _set?: InputMaybe<Favoritelocations_Set_Input>;
  where: Favoritelocations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Favoritelocations_By_PkArgs = {
  _inc?: InputMaybe<Favoritelocations_Inc_Input>;
  _set?: InputMaybe<Favoritelocations_Set_Input>;
  pk_columns: Favoritelocations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Favoritelocations_ManyArgs = {
  updates: Array<Favoritelocations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FeaturesArgs = {
  _inc?: InputMaybe<Features_Inc_Input>;
  _set?: InputMaybe<Features_Set_Input>;
  where: Features_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Features_By_PkArgs = {
  _inc?: InputMaybe<Features_Inc_Input>;
  _set?: InputMaybe<Features_Set_Input>;
  pk_columns: Features_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Features_ManyArgs = {
  updates: Array<Features_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FuelpricesArgs = {
  _inc?: InputMaybe<Fuelprices_Inc_Input>;
  _set?: InputMaybe<Fuelprices_Set_Input>;
  where: Fuelprices_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Fuelprices_By_PkArgs = {
  _inc?: InputMaybe<Fuelprices_Inc_Input>;
  _set?: InputMaybe<Fuelprices_Set_Input>;
  pk_columns: Fuelprices_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Fuelprices_ManyArgs = {
  updates: Array<Fuelprices_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_HangtagsArgs = {
  _append?: InputMaybe<Hangtags_Append_Input>;
  _delete_at_path?: InputMaybe<Hangtags_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Hangtags_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Hangtags_Delete_Key_Input>;
  _inc?: InputMaybe<Hangtags_Inc_Input>;
  _prepend?: InputMaybe<Hangtags_Prepend_Input>;
  _set?: InputMaybe<Hangtags_Set_Input>;
  where: Hangtags_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Hangtags_By_PkArgs = {
  _append?: InputMaybe<Hangtags_Append_Input>;
  _delete_at_path?: InputMaybe<Hangtags_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Hangtags_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Hangtags_Delete_Key_Input>;
  _inc?: InputMaybe<Hangtags_Inc_Input>;
  _prepend?: InputMaybe<Hangtags_Prepend_Input>;
  _set?: InputMaybe<Hangtags_Set_Input>;
  pk_columns: Hangtags_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Hangtags_ManyArgs = {
  updates: Array<Hangtags_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_InsuranceratesArgs = {
  _inc?: InputMaybe<Insurancerates_Inc_Input>;
  _set?: InputMaybe<Insurancerates_Set_Input>;
  where: Insurancerates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Insurancerates_By_PkArgs = {
  _inc?: InputMaybe<Insurancerates_Inc_Input>;
  _set?: InputMaybe<Insurancerates_Set_Input>;
  pk_columns: Insurancerates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Insurancerates_ManyArgs = {
  updates: Array<Insurancerates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_InvocationsArgs = {
  _append?: InputMaybe<Invocations_Append_Input>;
  _delete_at_path?: InputMaybe<Invocations_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Invocations_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Invocations_Delete_Key_Input>;
  _inc?: InputMaybe<Invocations_Inc_Input>;
  _prepend?: InputMaybe<Invocations_Prepend_Input>;
  _set?: InputMaybe<Invocations_Set_Input>;
  where: Invocations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Invocations_By_PkArgs = {
  _append?: InputMaybe<Invocations_Append_Input>;
  _delete_at_path?: InputMaybe<Invocations_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Invocations_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Invocations_Delete_Key_Input>;
  _inc?: InputMaybe<Invocations_Inc_Input>;
  _prepend?: InputMaybe<Invocations_Prepend_Input>;
  _set?: InputMaybe<Invocations_Set_Input>;
  pk_columns: Invocations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Invocations_ManyArgs = {
  updates: Array<Invocations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Job_ExecutionsArgs = {
  _append?: InputMaybe<Job_Executions_Append_Input>;
  _delete_at_path?: InputMaybe<Job_Executions_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Job_Executions_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Job_Executions_Delete_Key_Input>;
  _inc?: InputMaybe<Job_Executions_Inc_Input>;
  _prepend?: InputMaybe<Job_Executions_Prepend_Input>;
  _set?: InputMaybe<Job_Executions_Set_Input>;
  where: Job_Executions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Executions_By_PkArgs = {
  _append?: InputMaybe<Job_Executions_Append_Input>;
  _delete_at_path?: InputMaybe<Job_Executions_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Job_Executions_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Job_Executions_Delete_Key_Input>;
  _inc?: InputMaybe<Job_Executions_Inc_Input>;
  _prepend?: InputMaybe<Job_Executions_Prepend_Input>;
  _set?: InputMaybe<Job_Executions_Set_Input>;
  pk_columns: Job_Executions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Executions_ManyArgs = {
  updates: Array<Job_Executions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LanemodifiersArgs = {
  _inc?: InputMaybe<Lanemodifiers_Inc_Input>;
  _set?: InputMaybe<Lanemodifiers_Set_Input>;
  where: Lanemodifiers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Lanemodifiers_By_PkArgs = {
  _inc?: InputMaybe<Lanemodifiers_Inc_Input>;
  _set?: InputMaybe<Lanemodifiers_Set_Input>;
  pk_columns: Lanemodifiers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Lanemodifiers_ManyArgs = {
  updates: Array<Lanemodifiers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LanesArgs = {
  _inc?: InputMaybe<Lanes_Inc_Input>;
  _set?: InputMaybe<Lanes_Set_Input>;
  where: Lanes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Lanes_By_PkArgs = {
  _inc?: InputMaybe<Lanes_Inc_Input>;
  _set?: InputMaybe<Lanes_Set_Input>;
  pk_columns: Lanes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Lanes_ManyArgs = {
  updates: Array<Lanes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LocationsArgs = {
  _inc?: InputMaybe<Locations_Inc_Input>;
  _set?: InputMaybe<Locations_Set_Input>;
  where: Locations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Locations_By_PkArgs = {
  _inc?: InputMaybe<Locations_Inc_Input>;
  _set?: InputMaybe<Locations_Set_Input>;
  pk_columns: Locations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Locations_ManyArgs = {
  updates: Array<Locations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LocationstocertificationsArgs = {
  _inc?: InputMaybe<Locationstocertifications_Inc_Input>;
  _set?: InputMaybe<Locationstocertifications_Set_Input>;
  where: Locationstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Locationstocertifications_By_PkArgs = {
  _inc?: InputMaybe<Locationstocertifications_Inc_Input>;
  _set?: InputMaybe<Locationstocertifications_Set_Input>;
  pk_columns: Locationstocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Locationstocertifications_ManyArgs = {
  updates: Array<Locationstocertifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LyftrideattemptsArgs = {
  _inc?: InputMaybe<Lyftrideattempts_Inc_Input>;
  _set?: InputMaybe<Lyftrideattempts_Set_Input>;
  where: Lyftrideattempts_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Lyftrideattempts_By_PkArgs = {
  _inc?: InputMaybe<Lyftrideattempts_Inc_Input>;
  _set?: InputMaybe<Lyftrideattempts_Set_Input>;
  pk_columns: Lyftrideattempts_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Lyftrideattempts_ManyArgs = {
  updates: Array<Lyftrideattempts_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_LyftridesArgs = {
  _inc?: InputMaybe<Lyftrides_Inc_Input>;
  _set?: InputMaybe<Lyftrides_Set_Input>;
  where: Lyftrides_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Lyftrides_By_PkArgs = {
  _inc?: InputMaybe<Lyftrides_Inc_Input>;
  _set?: InputMaybe<Lyftrides_Set_Input>;
  pk_columns: Lyftrides_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Lyftrides_ManyArgs = {
  updates: Array<Lyftrides_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Metrics_HourlyArgs = {
  _append?: InputMaybe<Metrics_Hourly_Append_Input>;
  _delete_at_path?: InputMaybe<Metrics_Hourly_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Metrics_Hourly_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Metrics_Hourly_Delete_Key_Input>;
  _inc?: InputMaybe<Metrics_Hourly_Inc_Input>;
  _prepend?: InputMaybe<Metrics_Hourly_Prepend_Input>;
  _set?: InputMaybe<Metrics_Hourly_Set_Input>;
  where: Metrics_Hourly_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Metrics_Hourly_By_PkArgs = {
  _append?: InputMaybe<Metrics_Hourly_Append_Input>;
  _delete_at_path?: InputMaybe<Metrics_Hourly_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Metrics_Hourly_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Metrics_Hourly_Delete_Key_Input>;
  _inc?: InputMaybe<Metrics_Hourly_Inc_Input>;
  _prepend?: InputMaybe<Metrics_Hourly_Prepend_Input>;
  _set?: InputMaybe<Metrics_Hourly_Set_Input>;
  pk_columns: Metrics_Hourly_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Metrics_Hourly_ManyArgs = {
  updates: Array<Metrics_Hourly_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MoveauditArgs = {
  _append?: InputMaybe<Moveaudit_Append_Input>;
  _delete_at_path?: InputMaybe<Moveaudit_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Moveaudit_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Moveaudit_Delete_Key_Input>;
  _inc?: InputMaybe<Moveaudit_Inc_Input>;
  _prepend?: InputMaybe<Moveaudit_Prepend_Input>;
  _set?: InputMaybe<Moveaudit_Set_Input>;
  where: Moveaudit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Moveaudit_By_PkArgs = {
  _append?: InputMaybe<Moveaudit_Append_Input>;
  _delete_at_path?: InputMaybe<Moveaudit_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Moveaudit_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Moveaudit_Delete_Key_Input>;
  _inc?: InputMaybe<Moveaudit_Inc_Input>;
  _prepend?: InputMaybe<Moveaudit_Prepend_Input>;
  _set?: InputMaybe<Moveaudit_Set_Input>;
  pk_columns: Moveaudit_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Moveaudit_ManyArgs = {
  updates: Array<Moveaudit_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MovesArgs = {
  _append?: InputMaybe<Moves_Append_Input>;
  _delete_at_path?: InputMaybe<Moves_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Moves_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Moves_Delete_Key_Input>;
  _inc?: InputMaybe<Moves_Inc_Input>;
  _prepend?: InputMaybe<Moves_Prepend_Input>;
  _set?: InputMaybe<Moves_Set_Input>;
  where: Moves_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Moves_By_PkArgs = {
  _append?: InputMaybe<Moves_Append_Input>;
  _delete_at_path?: InputMaybe<Moves_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Moves_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Moves_Delete_Key_Input>;
  _inc?: InputMaybe<Moves_Inc_Input>;
  _prepend?: InputMaybe<Moves_Prepend_Input>;
  _set?: InputMaybe<Moves_Set_Input>;
  pk_columns: Moves_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Moves_ManyArgs = {
  updates: Array<Moves_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_NotificationsArgs = {
  _append?: InputMaybe<Notifications_Append_Input>;
  _delete_at_path?: InputMaybe<Notifications_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Notifications_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Notifications_Delete_Key_Input>;
  _inc?: InputMaybe<Notifications_Inc_Input>;
  _prepend?: InputMaybe<Notifications_Prepend_Input>;
  _set?: InputMaybe<Notifications_Set_Input>;
  where: Notifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Notifications_By_PkArgs = {
  _append?: InputMaybe<Notifications_Append_Input>;
  _delete_at_path?: InputMaybe<Notifications_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Notifications_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Notifications_Delete_Key_Input>;
  _inc?: InputMaybe<Notifications_Inc_Input>;
  _prepend?: InputMaybe<Notifications_Prepend_Input>;
  _set?: InputMaybe<Notifications_Set_Input>;
  pk_columns: Notifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Notifications_ManyArgs = {
  updates: Array<Notifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_OffersArgs = {
  _inc?: InputMaybe<Offers_Inc_Input>;
  _set?: InputMaybe<Offers_Set_Input>;
  where: Offers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Offers_By_PkArgs = {
  _inc?: InputMaybe<Offers_Inc_Input>;
  _set?: InputMaybe<Offers_Set_Input>;
  pk_columns: Offers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Offers_ManyArgs = {
  updates: Array<Offers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_OrganizationsArgs = {
  _append?: InputMaybe<Organizations_Append_Input>;
  _delete_at_path?: InputMaybe<Organizations_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Organizations_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Organizations_Delete_Key_Input>;
  _inc?: InputMaybe<Organizations_Inc_Input>;
  _prepend?: InputMaybe<Organizations_Prepend_Input>;
  _set?: InputMaybe<Organizations_Set_Input>;
  where: Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organizations_By_PkArgs = {
  _append?: InputMaybe<Organizations_Append_Input>;
  _delete_at_path?: InputMaybe<Organizations_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Organizations_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Organizations_Delete_Key_Input>;
  _inc?: InputMaybe<Organizations_Inc_Input>;
  _prepend?: InputMaybe<Organizations_Prepend_Input>;
  _set?: InputMaybe<Organizations_Set_Input>;
  pk_columns: Organizations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organizations_ManyArgs = {
  updates: Array<Organizations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_OrganizationstocertificationsArgs = {
  _inc?: InputMaybe<Organizationstocertifications_Inc_Input>;
  _set?: InputMaybe<Organizationstocertifications_Set_Input>;
  where: Organizationstocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organizationstocertifications_By_PkArgs = {
  _inc?: InputMaybe<Organizationstocertifications_Inc_Input>;
  _set?: InputMaybe<Organizationstocertifications_Set_Input>;
  pk_columns: Organizationstocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organizationstocertifications_ManyArgs = {
  updates: Array<Organizationstocertifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PaycyclesArgs = {
  _inc?: InputMaybe<Paycycles_Inc_Input>;
  _set?: InputMaybe<Paycycles_Set_Input>;
  where: Paycycles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Paycycles_By_PkArgs = {
  _inc?: InputMaybe<Paycycles_Inc_Input>;
  _set?: InputMaybe<Paycycles_Set_Input>;
  pk_columns: Paycycles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Paycycles_ManyArgs = {
  updates: Array<Paycycles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PaycycletodrivertodocumentsArgs = {
  _inc?: InputMaybe<Paycycletodrivertodocuments_Inc_Input>;
  _set?: InputMaybe<Paycycletodrivertodocuments_Set_Input>;
  where: Paycycletodrivertodocuments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Paycycletodrivertodocuments_By_PkArgs = {
  _inc?: InputMaybe<Paycycletodrivertodocuments_Inc_Input>;
  _set?: InputMaybe<Paycycletodrivertodocuments_Set_Input>;
  pk_columns: Paycycletodrivertodocuments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Paycycletodrivertodocuments_ManyArgs = {
  updates: Array<Paycycletodrivertodocuments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PayertocustomerArgs = {
  _inc?: InputMaybe<Payertocustomer_Inc_Input>;
  _set?: InputMaybe<Payertocustomer_Set_Input>;
  where: Payertocustomer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Payertocustomer_By_PkArgs = {
  _inc?: InputMaybe<Payertocustomer_Inc_Input>;
  _set?: InputMaybe<Payertocustomer_Set_Input>;
  pk_columns: Payertocustomer_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Payertocustomer_ManyArgs = {
  updates: Array<Payertocustomer_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PayrategroupsArgs = {
  _append?: InputMaybe<Payrategroups_Append_Input>;
  _delete_at_path?: InputMaybe<Payrategroups_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Payrategroups_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Payrategroups_Delete_Key_Input>;
  _inc?: InputMaybe<Payrategroups_Inc_Input>;
  _prepend?: InputMaybe<Payrategroups_Prepend_Input>;
  _set?: InputMaybe<Payrategroups_Set_Input>;
  where: Payrategroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Payrategroups_By_PkArgs = {
  _append?: InputMaybe<Payrategroups_Append_Input>;
  _delete_at_path?: InputMaybe<Payrategroups_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Payrategroups_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Payrategroups_Delete_Key_Input>;
  _inc?: InputMaybe<Payrategroups_Inc_Input>;
  _prepend?: InputMaybe<Payrategroups_Prepend_Input>;
  _set?: InputMaybe<Payrategroups_Set_Input>;
  pk_columns: Payrategroups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Payrategroups_ManyArgs = {
  updates: Array<Payrategroups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PayraterulesArgs = {
  _inc?: InputMaybe<Payraterules_Inc_Input>;
  _set?: InputMaybe<Payraterules_Set_Input>;
  where: Payraterules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Payraterules_By_PkArgs = {
  _inc?: InputMaybe<Payraterules_Inc_Input>;
  _set?: InputMaybe<Payraterules_Set_Input>;
  pk_columns: Payraterules_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Payraterules_ManyArgs = {
  updates: Array<Payraterules_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PlansArgs = {
  _inc?: InputMaybe<Plans_Inc_Input>;
  _set?: InputMaybe<Plans_Set_Input>;
  where: Plans_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Plans_By_PkArgs = {
  _inc?: InputMaybe<Plans_Inc_Input>;
  _set?: InputMaybe<Plans_Set_Input>;
  pk_columns: Plans_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Plans_ManyArgs = {
  updates: Array<Plans_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PlatedetailsArgs = {
  _inc?: InputMaybe<Platedetails_Inc_Input>;
  _set?: InputMaybe<Platedetails_Set_Input>;
  where: Platedetails_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Platedetails_By_PkArgs = {
  _inc?: InputMaybe<Platedetails_Inc_Input>;
  _set?: InputMaybe<Platedetails_Set_Input>;
  pk_columns: Platedetails_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Platedetails_ManyArgs = {
  updates: Array<Platedetails_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PlatesArgs = {
  _inc?: InputMaybe<Plates_Inc_Input>;
  _set?: InputMaybe<Plates_Set_Input>;
  where: Plates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Plates_By_PkArgs = {
  _inc?: InputMaybe<Plates_Inc_Input>;
  _set?: InputMaybe<Plates_Set_Input>;
  pk_columns: Plates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Plates_ManyArgs = {
  updates: Array<Plates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ProductfeesArgs = {
  _inc?: InputMaybe<Productfees_Inc_Input>;
  _set?: InputMaybe<Productfees_Set_Input>;
  where: Productfees_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Productfees_By_PkArgs = {
  _inc?: InputMaybe<Productfees_Inc_Input>;
  _set?: InputMaybe<Productfees_Set_Input>;
  pk_columns: Productfees_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Productfees_ManyArgs = {
  updates: Array<Productfees_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ProductsArgs = {
  _inc?: InputMaybe<Products_Inc_Input>;
  _set?: InputMaybe<Products_Set_Input>;
  where: Products_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Products_By_PkArgs = {
  _inc?: InputMaybe<Products_Inc_Input>;
  _set?: InputMaybe<Products_Set_Input>;
  pk_columns: Products_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Products_ManyArgs = {
  updates: Array<Products_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PromosArgs = {
  _append?: InputMaybe<Promos_Append_Input>;
  _delete_at_path?: InputMaybe<Promos_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Promos_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Promos_Delete_Key_Input>;
  _inc?: InputMaybe<Promos_Inc_Input>;
  _prepend?: InputMaybe<Promos_Prepend_Input>;
  _set?: InputMaybe<Promos_Set_Input>;
  where: Promos_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Promos_By_PkArgs = {
  _append?: InputMaybe<Promos_Append_Input>;
  _delete_at_path?: InputMaybe<Promos_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Promos_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Promos_Delete_Key_Input>;
  _inc?: InputMaybe<Promos_Inc_Input>;
  _prepend?: InputMaybe<Promos_Prepend_Input>;
  _set?: InputMaybe<Promos_Set_Input>;
  pk_columns: Promos_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Promos_ManyArgs = {
  updates: Array<Promos_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RaterulegroupsArgs = {
  _inc?: InputMaybe<Raterulegroups_Inc_Input>;
  _set?: InputMaybe<Raterulegroups_Set_Input>;
  where: Raterulegroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Raterulegroups_By_PkArgs = {
  _inc?: InputMaybe<Raterulegroups_Inc_Input>;
  _set?: InputMaybe<Raterulegroups_Set_Input>;
  pk_columns: Raterulegroups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Raterulegroups_ManyArgs = {
  updates: Array<Raterulegroups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RaterulesArgs = {
  _inc?: InputMaybe<Raterules_Inc_Input>;
  _set?: InputMaybe<Raterules_Set_Input>;
  where: Raterules_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Raterules_By_PkArgs = {
  _inc?: InputMaybe<Raterules_Inc_Input>;
  _set?: InputMaybe<Raterules_Set_Input>;
  pk_columns: Raterules_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Raterules_ManyArgs = {
  updates: Array<Raterules_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RegionsArgs = {
  _inc?: InputMaybe<Regions_Inc_Input>;
  _set?: InputMaybe<Regions_Set_Input>;
  where: Regions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Regions_By_PkArgs = {
  _inc?: InputMaybe<Regions_Inc_Input>;
  _set?: InputMaybe<Regions_Set_Input>;
  pk_columns: Regions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Regions_ManyArgs = {
  updates: Array<Regions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RidegroupsArgs = {
  _inc?: InputMaybe<Ridegroups_Inc_Input>;
  _set?: InputMaybe<Ridegroups_Set_Input>;
  where: Ridegroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Ridegroups_By_PkArgs = {
  _inc?: InputMaybe<Ridegroups_Inc_Input>;
  _set?: InputMaybe<Ridegroups_Set_Input>;
  pk_columns: Ridegroups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Ridegroups_ManyArgs = {
  updates: Array<Ridegroups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RidesharefaresArgs = {
  _inc?: InputMaybe<Ridesharefares_Inc_Input>;
  _set?: InputMaybe<Ridesharefares_Set_Input>;
  where: Ridesharefares_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Ridesharefares_By_PkArgs = {
  _inc?: InputMaybe<Ridesharefares_Inc_Input>;
  _set?: InputMaybe<Ridesharefares_Set_Input>;
  pk_columns: Ridesharefares_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Ridesharefares_ManyArgs = {
  updates: Array<Ridesharefares_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RideshareratesArgs = {
  _inc?: InputMaybe<Ridesharerates_Inc_Input>;
  _set?: InputMaybe<Ridesharerates_Set_Input>;
  where: Ridesharerates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Ridesharerates_By_PkArgs = {
  _inc?: InputMaybe<Ridesharerates_Inc_Input>;
  _set?: InputMaybe<Ridesharerates_Set_Input>;
  pk_columns: Ridesharerates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Ridesharerates_ManyArgs = {
  updates: Array<Ridesharerates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RideshareratetoridesharefaresArgs = {
  _inc?: InputMaybe<Rideshareratetoridesharefares_Inc_Input>;
  _set?: InputMaybe<Rideshareratetoridesharefares_Set_Input>;
  where: Rideshareratetoridesharefares_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rideshareratetoridesharefares_By_PkArgs = {
  _inc?: InputMaybe<Rideshareratetoridesharefares_Inc_Input>;
  _set?: InputMaybe<Rideshareratetoridesharefares_Set_Input>;
  pk_columns: Rideshareratetoridesharefares_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rideshareratetoridesharefares_ManyArgs = {
  updates: Array<Rideshareratetoridesharefares_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RoletypesArgs = {
  _inc?: InputMaybe<Roletypes_Inc_Input>;
  _set?: InputMaybe<Roletypes_Set_Input>;
  where: Roletypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Roletypes_By_PkArgs = {
  _inc?: InputMaybe<Roletypes_Inc_Input>;
  _set?: InputMaybe<Roletypes_Set_Input>;
  pk_columns: Roletypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Roletypes_ManyArgs = {
  updates: Array<Roletypes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ScenariosArgs = {
  _append?: InputMaybe<Scenarios_Append_Input>;
  _delete_at_path?: InputMaybe<Scenarios_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Scenarios_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Scenarios_Delete_Key_Input>;
  _inc?: InputMaybe<Scenarios_Inc_Input>;
  _prepend?: InputMaybe<Scenarios_Prepend_Input>;
  _set?: InputMaybe<Scenarios_Set_Input>;
  where: Scenarios_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Scenarios_By_PkArgs = {
  _append?: InputMaybe<Scenarios_Append_Input>;
  _delete_at_path?: InputMaybe<Scenarios_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Scenarios_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Scenarios_Delete_Key_Input>;
  _inc?: InputMaybe<Scenarios_Inc_Input>;
  _prepend?: InputMaybe<Scenarios_Prepend_Input>;
  _set?: InputMaybe<Scenarios_Set_Input>;
  pk_columns: Scenarios_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Scenarios_ManyArgs = {
  updates: Array<Scenarios_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ScenariotomovesArgs = {
  _inc?: InputMaybe<Scenariotomoves_Inc_Input>;
  _set?: InputMaybe<Scenariotomoves_Set_Input>;
  where: Scenariotomoves_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Scenariotomoves_By_PkArgs = {
  _inc?: InputMaybe<Scenariotomoves_Inc_Input>;
  _set?: InputMaybe<Scenariotomoves_Set_Input>;
  pk_columns: Scenariotomoves_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Scenariotomoves_ManyArgs = {
  updates: Array<Scenariotomoves_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ScenariotypesArgs = {
  _append?: InputMaybe<Scenariotypes_Append_Input>;
  _delete_at_path?: InputMaybe<Scenariotypes_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Scenariotypes_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Scenariotypes_Delete_Key_Input>;
  _inc?: InputMaybe<Scenariotypes_Inc_Input>;
  _prepend?: InputMaybe<Scenariotypes_Prepend_Input>;
  _set?: InputMaybe<Scenariotypes_Set_Input>;
  where: Scenariotypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Scenariotypes_By_PkArgs = {
  _append?: InputMaybe<Scenariotypes_Append_Input>;
  _delete_at_path?: InputMaybe<Scenariotypes_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Scenariotypes_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Scenariotypes_Delete_Key_Input>;
  _inc?: InputMaybe<Scenariotypes_Inc_Input>;
  _prepend?: InputMaybe<Scenariotypes_Prepend_Input>;
  _set?: InputMaybe<Scenariotypes_Set_Input>;
  pk_columns: Scenariotypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Scenariotypes_ManyArgs = {
  updates: Array<Scenariotypes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ScenariotypestocertificationsArgs = {
  _set?: InputMaybe<Scenariotypestocertifications_Set_Input>;
  where: Scenariotypestocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Scenariotypestocertifications_By_PkArgs = {
  _set?: InputMaybe<Scenariotypestocertifications_Set_Input>;
  pk_columns: Scenariotypestocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Scenariotypestocertifications_ManyArgs = {
  updates: Array<Scenariotypestocertifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SequelizemetaArgs = {
  _set?: InputMaybe<Sequelizemeta_Set_Input>;
  where: Sequelizemeta_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Sequelizemeta_By_PkArgs = {
  _set?: InputMaybe<Sequelizemeta_Set_Input>;
  pk_columns: Sequelizemeta_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Sequelizemeta_ManyArgs = {
  updates: Array<Sequelizemeta_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SlasArgs = {
  _inc?: InputMaybe<Slas_Inc_Input>;
  _set?: InputMaybe<Slas_Set_Input>;
  where: Slas_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Slas_By_PkArgs = {
  _inc?: InputMaybe<Slas_Inc_Input>;
  _set?: InputMaybe<Slas_Set_Input>;
  pk_columns: Slas_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Slas_ManyArgs = {
  updates: Array<Slas_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Slas_To_RaterulegroupsArgs = {
  _inc?: InputMaybe<Slas_To_Raterulegroups_Inc_Input>;
  _set?: InputMaybe<Slas_To_Raterulegroups_Set_Input>;
  where: Slas_To_Raterulegroups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Slas_To_Raterulegroups_By_PkArgs = {
  _inc?: InputMaybe<Slas_To_Raterulegroups_Inc_Input>;
  _set?: InputMaybe<Slas_To_Raterulegroups_Set_Input>;
  pk_columns: Slas_To_Raterulegroups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Slas_To_Raterulegroups_ManyArgs = {
  updates: Array<Slas_To_Raterulegroups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SmsmediaArgs = {
  _inc?: InputMaybe<Smsmedia_Inc_Input>;
  _set?: InputMaybe<Smsmedia_Set_Input>;
  where: Smsmedia_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Smsmedia_By_PkArgs = {
  _inc?: InputMaybe<Smsmedia_Inc_Input>;
  _set?: InputMaybe<Smsmedia_Set_Input>;
  pk_columns: Smsmedia_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Smsmedia_ManyArgs = {
  updates: Array<Smsmedia_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SmsmessagesArgs = {
  _append?: InputMaybe<Smsmessages_Append_Input>;
  _delete_at_path?: InputMaybe<Smsmessages_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Smsmessages_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Smsmessages_Delete_Key_Input>;
  _inc?: InputMaybe<Smsmessages_Inc_Input>;
  _prepend?: InputMaybe<Smsmessages_Prepend_Input>;
  _set?: InputMaybe<Smsmessages_Set_Input>;
  where: Smsmessages_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Smsmessages_By_PkArgs = {
  _append?: InputMaybe<Smsmessages_Append_Input>;
  _delete_at_path?: InputMaybe<Smsmessages_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Smsmessages_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Smsmessages_Delete_Key_Input>;
  _inc?: InputMaybe<Smsmessages_Inc_Input>;
  _prepend?: InputMaybe<Smsmessages_Prepend_Input>;
  _set?: InputMaybe<Smsmessages_Set_Input>;
  pk_columns: Smsmessages_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Smsmessages_ManyArgs = {
  updates: Array<Smsmessages_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SmstemplatesArgs = {
  _append?: InputMaybe<Smstemplates_Append_Input>;
  _delete_at_path?: InputMaybe<Smstemplates_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Smstemplates_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Smstemplates_Delete_Key_Input>;
  _inc?: InputMaybe<Smstemplates_Inc_Input>;
  _prepend?: InputMaybe<Smstemplates_Prepend_Input>;
  _set?: InputMaybe<Smstemplates_Set_Input>;
  where: Smstemplates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Smstemplates_By_PkArgs = {
  _append?: InputMaybe<Smstemplates_Append_Input>;
  _delete_at_path?: InputMaybe<Smstemplates_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Smstemplates_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Smstemplates_Delete_Key_Input>;
  _inc?: InputMaybe<Smstemplates_Inc_Input>;
  _prepend?: InputMaybe<Smstemplates_Prepend_Input>;
  _set?: InputMaybe<Smstemplates_Set_Input>;
  pk_columns: Smstemplates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Smstemplates_ManyArgs = {
  updates: Array<Smstemplates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SubscriptionsArgs = {
  _append?: InputMaybe<Subscriptions_Append_Input>;
  _delete_at_path?: InputMaybe<Subscriptions_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Subscriptions_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Subscriptions_Delete_Key_Input>;
  _inc?: InputMaybe<Subscriptions_Inc_Input>;
  _prepend?: InputMaybe<Subscriptions_Prepend_Input>;
  _set?: InputMaybe<Subscriptions_Set_Input>;
  where: Subscriptions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Subscriptions_By_PkArgs = {
  _append?: InputMaybe<Subscriptions_Append_Input>;
  _delete_at_path?: InputMaybe<Subscriptions_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Subscriptions_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Subscriptions_Delete_Key_Input>;
  _inc?: InputMaybe<Subscriptions_Inc_Input>;
  _prepend?: InputMaybe<Subscriptions_Prepend_Input>;
  _set?: InputMaybe<Subscriptions_Set_Input>;
  pk_columns: Subscriptions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Subscriptions_ManyArgs = {
  updates: Array<Subscriptions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TemplatesArgs = {
  _inc?: InputMaybe<Templates_Inc_Input>;
  _set?: InputMaybe<Templates_Set_Input>;
  where: Templates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Templates_By_PkArgs = {
  _inc?: InputMaybe<Templates_Inc_Input>;
  _set?: InputMaybe<Templates_Set_Input>;
  pk_columns: Templates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Templates_ManyArgs = {
  updates: Array<Templates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TripsArgs = {
  _inc?: InputMaybe<Trips_Inc_Input>;
  _set?: InputMaybe<Trips_Set_Input>;
  where: Trips_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Trips_By_PkArgs = {
  _inc?: InputMaybe<Trips_Inc_Input>;
  _set?: InputMaybe<Trips_Set_Input>;
  pk_columns: Trips_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Trips_ManyArgs = {
  updates: Array<Trips_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsecasesArgs = {
  _set?: InputMaybe<Usecases_Set_Input>;
  where: Usecases_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usecases_By_PkArgs = {
  _set?: InputMaybe<Usecases_Set_Input>;
  pk_columns: Usecases_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usecases_ManyArgs = {
  updates: Array<Usecases_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsecasetocertificationsArgs = {
  _set?: InputMaybe<Usecasetocertifications_Set_Input>;
  where: Usecasetocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usecasetocertifications_By_PkArgs = {
  _set?: InputMaybe<Usecasetocertifications_Set_Input>;
  pk_columns: Usecasetocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usecasetocertifications_ManyArgs = {
  updates: Array<Usecasetocertifications_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsereventlogsArgs = {
  _append?: InputMaybe<Usereventlogs_Append_Input>;
  _delete_at_path?: InputMaybe<Usereventlogs_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Usereventlogs_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Usereventlogs_Delete_Key_Input>;
  _inc?: InputMaybe<Usereventlogs_Inc_Input>;
  _prepend?: InputMaybe<Usereventlogs_Prepend_Input>;
  _set?: InputMaybe<Usereventlogs_Set_Input>;
  where: Usereventlogs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usereventlogs_By_PkArgs = {
  _append?: InputMaybe<Usereventlogs_Append_Input>;
  _delete_at_path?: InputMaybe<Usereventlogs_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Usereventlogs_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Usereventlogs_Delete_Key_Input>;
  _inc?: InputMaybe<Usereventlogs_Inc_Input>;
  _prepend?: InputMaybe<Usereventlogs_Prepend_Input>;
  _set?: InputMaybe<Usereventlogs_Set_Input>;
  pk_columns: Usereventlogs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usereventlogs_ManyArgs = {
  updates: Array<Usereventlogs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _inc?: InputMaybe<Users_Inc_Input>;
  _set?: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _inc?: InputMaybe<Users_Inc_Input>;
  _set?: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsertocustomersArgs = {
  _inc?: InputMaybe<Usertocustomers_Inc_Input>;
  _set?: InputMaybe<Usertocustomers_Set_Input>;
  where: Usertocustomers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usertocustomers_By_PkArgs = {
  _inc?: InputMaybe<Usertocustomers_Inc_Input>;
  _set?: InputMaybe<Usertocustomers_Set_Input>;
  pk_columns: Usertocustomers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usertocustomers_ManyArgs = {
  updates: Array<Usertocustomers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsertofeaturesArgs = {
  _inc?: InputMaybe<Usertofeatures_Inc_Input>;
  _set?: InputMaybe<Usertofeatures_Set_Input>;
  where: Usertofeatures_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usertofeatures_By_PkArgs = {
  _inc?: InputMaybe<Usertofeatures_Inc_Input>;
  _set?: InputMaybe<Usertofeatures_Set_Input>;
  pk_columns: Usertofeatures_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usertofeatures_ManyArgs = {
  updates: Array<Usertofeatures_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsertoregionsArgs = {
  _inc?: InputMaybe<Usertoregions_Inc_Input>;
  _set?: InputMaybe<Usertoregions_Set_Input>;
  where: Usertoregions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usertoregions_By_PkArgs = {
  _inc?: InputMaybe<Usertoregions_Inc_Input>;
  _set?: InputMaybe<Usertoregions_Set_Input>;
  pk_columns: Usertoregions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usertoregions_ManyArgs = {
  updates: Array<Usertoregions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsertorolesArgs = {
  _inc?: InputMaybe<Usertoroles_Inc_Input>;
  _set?: InputMaybe<Usertoroles_Set_Input>;
  where: Usertoroles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Usertoroles_By_PkArgs = {
  _inc?: InputMaybe<Usertoroles_Inc_Input>;
  _set?: InputMaybe<Usertoroles_Set_Input>;
  pk_columns: Usertoroles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Usertoroles_ManyArgs = {
  updates: Array<Usertoroles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_VehiclemakesArgs = {
  _inc?: InputMaybe<Vehiclemakes_Inc_Input>;
  _set?: InputMaybe<Vehiclemakes_Set_Input>;
  where: Vehiclemakes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vehiclemakes_By_PkArgs = {
  _inc?: InputMaybe<Vehiclemakes_Inc_Input>;
  _set?: InputMaybe<Vehiclemakes_Set_Input>;
  pk_columns: Vehiclemakes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Vehiclemakes_ManyArgs = {
  updates: Array<Vehiclemakes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_VehiclemodelsArgs = {
  _inc?: InputMaybe<Vehiclemodels_Inc_Input>;
  _set?: InputMaybe<Vehiclemodels_Set_Input>;
  where: Vehiclemodels_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vehiclemodels_By_PkArgs = {
  _inc?: InputMaybe<Vehiclemodels_Inc_Input>;
  _set?: InputMaybe<Vehiclemodels_Set_Input>;
  pk_columns: Vehiclemodels_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Vehiclemodels_ManyArgs = {
  updates: Array<Vehiclemodels_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_VehiclephotosArgs = {
  _inc?: InputMaybe<Vehiclephotos_Inc_Input>;
  _set?: InputMaybe<Vehiclephotos_Set_Input>;
  where: Vehiclephotos_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vehiclephotos_By_PkArgs = {
  _inc?: InputMaybe<Vehiclephotos_Inc_Input>;
  _set?: InputMaybe<Vehiclephotos_Set_Input>;
  pk_columns: Vehiclephotos_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Vehiclephotos_ManyArgs = {
  updates: Array<Vehiclephotos_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_VehiclesArgs = {
  _inc?: InputMaybe<Vehicles_Inc_Input>;
  _set?: InputMaybe<Vehicles_Set_Input>;
  where: Vehicles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Vehicles_By_PkArgs = {
  _inc?: InputMaybe<Vehicles_Inc_Input>;
  _set?: InputMaybe<Vehicles_Set_Input>;
  pk_columns: Vehicles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Vehicles_ManyArgs = {
  updates: Array<Vehicles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Webhook_EventsArgs = {
  _append?: InputMaybe<Webhook_Events_Append_Input>;
  _delete_at_path?: InputMaybe<Webhook_Events_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Webhook_Events_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Webhook_Events_Delete_Key_Input>;
  _inc?: InputMaybe<Webhook_Events_Inc_Input>;
  _prepend?: InputMaybe<Webhook_Events_Prepend_Input>;
  _set?: InputMaybe<Webhook_Events_Set_Input>;
  where: Webhook_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Webhook_Events_By_PkArgs = {
  _append?: InputMaybe<Webhook_Events_Append_Input>;
  _delete_at_path?: InputMaybe<Webhook_Events_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Webhook_Events_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Webhook_Events_Delete_Key_Input>;
  _inc?: InputMaybe<Webhook_Events_Inc_Input>;
  _prepend?: InputMaybe<Webhook_Events_Prepend_Input>;
  _set?: InputMaybe<Webhook_Events_Set_Input>;
  pk_columns: Webhook_Events_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Webhook_Events_ManyArgs = {
  updates: Array<Webhook_Events_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_WorkflowsArgs = {
  _append?: InputMaybe<Workflows_Append_Input>;
  _delete_at_path?: InputMaybe<Workflows_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Workflows_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Workflows_Delete_Key_Input>;
  _inc?: InputMaybe<Workflows_Inc_Input>;
  _prepend?: InputMaybe<Workflows_Prepend_Input>;
  _set?: InputMaybe<Workflows_Set_Input>;
  where: Workflows_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Workflows_By_PkArgs = {
  _append?: InputMaybe<Workflows_Append_Input>;
  _delete_at_path?: InputMaybe<Workflows_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Workflows_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Workflows_Delete_Key_Input>;
  _inc?: InputMaybe<Workflows_Inc_Input>;
  _prepend?: InputMaybe<Workflows_Prepend_Input>;
  _set?: InputMaybe<Workflows_Set_Input>;
  pk_columns: Workflows_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Workflows_ManyArgs = {
  updates: Array<Workflows_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_WorkflowsetsArgs = {
  _inc?: InputMaybe<Workflowsets_Inc_Input>;
  _set?: InputMaybe<Workflowsets_Set_Input>;
  where: Workflowsets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Workflowsets_By_PkArgs = {
  _inc?: InputMaybe<Workflowsets_Inc_Input>;
  _set?: InputMaybe<Workflowsets_Set_Input>;
  pk_columns: Workflowsets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Workflowsets_ManyArgs = {
  updates: Array<Workflowsets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_WorkflowsettypesArgs = {
  _inc?: InputMaybe<Workflowsettypes_Inc_Input>;
  _set?: InputMaybe<Workflowsettypes_Set_Input>;
  where: Workflowsettypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Workflowsettypes_By_PkArgs = {
  _inc?: InputMaybe<Workflowsettypes_Inc_Input>;
  _set?: InputMaybe<Workflowsettypes_Set_Input>;
  pk_columns: Workflowsettypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Workflowsettypes_ManyArgs = {
  updates: Array<Workflowsettypes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_WorkflowsettypestocertificationsArgs = {
  _set?: InputMaybe<Workflowsettypestocertifications_Set_Input>;
  where: Workflowsettypestocertifications_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Workflowsettypestocertifications_By_PkArgs = {
  _set?: InputMaybe<Workflowsettypestocertifications_Set_Input>;
  pk_columns: Workflowsettypestocertifications_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Workflowsettypestocertifications_ManyArgs = {
  updates: Array<Workflowsettypestocertifications_Updates>;
};

/** The notifications table is the core system of record for any notifications shown to admins. Type can be either inform or action. Assignment fields are for action types only and will be null for the inform. */
export type Notifications = {
  __typename?: 'notifications';
  assignedat?: Maybe<Scalars['timestamptz']['output']>;
  assignedby?: Maybe<Scalars['String']['output']>;
  assignedto?: Maybe<Scalars['String']['output']>;
  body?: Maybe<Scalars['String']['output']>;
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  duedate?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['bigint']['output'];
  json?: Maybe<Scalars['jsonb']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  resolvedat?: Maybe<Scalars['timestamptz']['output']>;
  resolvedby?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  type: Scalars['String']['output'];
};


/** The notifications table is the core system of record for any notifications shown to admins. Type can be either inform or action. Assignment fields are for action types only and will be null for the inform. */
export type NotificationsJsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "notifications" */
export type Notifications_Aggregate = {
  __typename?: 'notifications_aggregate';
  aggregate?: Maybe<Notifications_Aggregate_Fields>;
  nodes: Array<Notifications>;
};

/** aggregate fields of "notifications" */
export type Notifications_Aggregate_Fields = {
  __typename?: 'notifications_aggregate_fields';
  avg?: Maybe<Notifications_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Notifications_Max_Fields>;
  min?: Maybe<Notifications_Min_Fields>;
  stddev?: Maybe<Notifications_Stddev_Fields>;
  stddev_pop?: Maybe<Notifications_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Notifications_Stddev_Samp_Fields>;
  sum?: Maybe<Notifications_Sum_Fields>;
  var_pop?: Maybe<Notifications_Var_Pop_Fields>;
  var_samp?: Maybe<Notifications_Var_Samp_Fields>;
  variance?: Maybe<Notifications_Variance_Fields>;
};


/** aggregate fields of "notifications" */
export type Notifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Notifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Notifications_Append_Input = {
  json?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Notifications_Avg_Fields = {
  __typename?: 'notifications_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'. */
export type Notifications_Bool_Exp = {
  _and?: InputMaybe<Array<Notifications_Bool_Exp>>;
  _not?: InputMaybe<Notifications_Bool_Exp>;
  _or?: InputMaybe<Array<Notifications_Bool_Exp>>;
  assignedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  assignedby?: InputMaybe<String_Comparison_Exp>;
  assignedto?: InputMaybe<String_Comparison_Exp>;
  body?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  duedate?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  json?: InputMaybe<Jsonb_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  resolvedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  resolvedby?: InputMaybe<String_Comparison_Exp>;
  title?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "notifications" */
export enum Notifications_Constraint {
  /** unique or primary key constraint on columns "id" */
  NotificationsPkey = 'notifications_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Notifications_Delete_At_Path_Input = {
  json?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Notifications_Delete_Elem_Input = {
  json?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Notifications_Delete_Key_Input = {
  json?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "notifications" */
export type Notifications_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "notifications" */
export type Notifications_Insert_Input = {
  assignedat?: InputMaybe<Scalars['timestamptz']['input']>;
  assignedby?: InputMaybe<Scalars['String']['input']>;
  assignedto?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  duedate?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  json?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  resolvedat?: InputMaybe<Scalars['timestamptz']['input']>;
  resolvedby?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Notifications_Max_Fields = {
  __typename?: 'notifications_max_fields';
  assignedat?: Maybe<Scalars['timestamptz']['output']>;
  assignedby?: Maybe<Scalars['String']['output']>;
  assignedto?: Maybe<Scalars['String']['output']>;
  body?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  duedate?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  resolvedat?: Maybe<Scalars['timestamptz']['output']>;
  resolvedby?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Notifications_Min_Fields = {
  __typename?: 'notifications_min_fields';
  assignedat?: Maybe<Scalars['timestamptz']['output']>;
  assignedby?: Maybe<Scalars['String']['output']>;
  assignedto?: Maybe<Scalars['String']['output']>;
  body?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  duedate?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  resolvedat?: Maybe<Scalars['timestamptz']['output']>;
  resolvedby?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "notifications" */
export type Notifications_Mutation_Response = {
  __typename?: 'notifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Notifications>;
};

/** on_conflict condition type for table "notifications" */
export type Notifications_On_Conflict = {
  constraint: Notifications_Constraint;
  update_columns?: Array<Notifications_Update_Column>;
  where?: InputMaybe<Notifications_Bool_Exp>;
};

/** Ordering options when selecting data from "notifications". */
export type Notifications_Order_By = {
  assignedat?: InputMaybe<Order_By>;
  assignedby?: InputMaybe<Order_By>;
  assignedto?: InputMaybe<Order_By>;
  body?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  duedate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  json?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  resolvedat?: InputMaybe<Order_By>;
  resolvedby?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: notifications */
export type Notifications_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Notifications_Prepend_Input = {
  json?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "notifications" */
export enum Notifications_Select_Column {
  /** column name */
  Assignedat = 'assignedat',
  /** column name */
  Assignedby = 'assignedby',
  /** column name */
  Assignedto = 'assignedto',
  /** column name */
  Body = 'body',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Duedate = 'duedate',
  /** column name */
  Id = 'id',
  /** column name */
  Json = 'json',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolvedat = 'resolvedat',
  /** column name */
  Resolvedby = 'resolvedby',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "notifications" */
export type Notifications_Set_Input = {
  assignedat?: InputMaybe<Scalars['timestamptz']['input']>;
  assignedby?: InputMaybe<Scalars['String']['input']>;
  assignedto?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  duedate?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  json?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  resolvedat?: InputMaybe<Scalars['timestamptz']['input']>;
  resolvedby?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Notifications_Stddev_Fields = {
  __typename?: 'notifications_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Notifications_Stddev_Pop_Fields = {
  __typename?: 'notifications_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Notifications_Stddev_Samp_Fields = {
  __typename?: 'notifications_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "notifications" */
export type Notifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notifications_Stream_Cursor_Value_Input = {
  assignedat?: InputMaybe<Scalars['timestamptz']['input']>;
  assignedby?: InputMaybe<Scalars['String']['input']>;
  assignedto?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  duedate?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  json?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  resolvedat?: InputMaybe<Scalars['timestamptz']['input']>;
  resolvedby?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Notifications_Sum_Fields = {
  __typename?: 'notifications_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "notifications" */
export enum Notifications_Update_Column {
  /** column name */
  Assignedat = 'assignedat',
  /** column name */
  Assignedby = 'assignedby',
  /** column name */
  Assignedto = 'assignedto',
  /** column name */
  Body = 'body',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Duedate = 'duedate',
  /** column name */
  Id = 'id',
  /** column name */
  Json = 'json',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolvedat = 'resolvedat',
  /** column name */
  Resolvedby = 'resolvedby',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type'
}

export type Notifications_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Notifications_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Notifications_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Notifications_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Notifications_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Notifications_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Notifications_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Notifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Notifications_Var_Pop_Fields = {
  __typename?: 'notifications_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Notifications_Var_Samp_Fields = {
  __typename?: 'notifications_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Notifications_Variance_Fields = {
  __typename?: 'notifications_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['numeric']['input']>;
  _gt?: InputMaybe<Scalars['numeric']['input']>;
  _gte?: InputMaybe<Scalars['numeric']['input']>;
  _in?: InputMaybe<Array<Scalars['numeric']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['numeric']['input']>;
  _lte?: InputMaybe<Scalars['numeric']['input']>;
  _neq?: InputMaybe<Scalars['numeric']['input']>;
  _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;
};

/** An offer will be a representation of making an offer to a driver and storing its lifecycle which may or may not result in the offer being accepted by a driver. An offer can have one of 3 outcomes: accepted, declined, or expired. */
export type Offers = {
  __typename?: 'offers';
  /** An object relationship */
  bundle?: Maybe<Bundles>;
  /** id for the related bundle record */
  bundle_id: Scalars['bigint']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  driver: Drivers;
  /** id for the related scenario record */
  driver_id: Scalars['bigint']['output'];
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "offers" */
export type Offers_Aggregate = {
  __typename?: 'offers_aggregate';
  aggregate?: Maybe<Offers_Aggregate_Fields>;
  nodes: Array<Offers>;
};

export type Offers_Aggregate_Bool_Exp = {
  count?: InputMaybe<Offers_Aggregate_Bool_Exp_Count>;
};

export type Offers_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Offers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Offers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "offers" */
export type Offers_Aggregate_Fields = {
  __typename?: 'offers_aggregate_fields';
  avg?: Maybe<Offers_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Offers_Max_Fields>;
  min?: Maybe<Offers_Min_Fields>;
  stddev?: Maybe<Offers_Stddev_Fields>;
  stddev_pop?: Maybe<Offers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Offers_Stddev_Samp_Fields>;
  sum?: Maybe<Offers_Sum_Fields>;
  var_pop?: Maybe<Offers_Var_Pop_Fields>;
  var_samp?: Maybe<Offers_Var_Samp_Fields>;
  variance?: Maybe<Offers_Variance_Fields>;
};


/** aggregate fields of "offers" */
export type Offers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Offers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "offers" */
export type Offers_Aggregate_Order_By = {
  avg?: InputMaybe<Offers_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Offers_Max_Order_By>;
  min?: InputMaybe<Offers_Min_Order_By>;
  stddev?: InputMaybe<Offers_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Offers_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Offers_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Offers_Sum_Order_By>;
  var_pop?: InputMaybe<Offers_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Offers_Var_Samp_Order_By>;
  variance?: InputMaybe<Offers_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "offers" */
export type Offers_Arr_Rel_Insert_Input = {
  data: Array<Offers_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Offers_On_Conflict>;
};

/** aggregate avg on columns */
export type Offers_Avg_Fields = {
  __typename?: 'offers_avg_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "offers" */
export type Offers_Avg_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "offers". All fields are combined with a logical 'AND'. */
export type Offers_Bool_Exp = {
  _and?: InputMaybe<Array<Offers_Bool_Exp>>;
  _not?: InputMaybe<Offers_Bool_Exp>;
  _or?: InputMaybe<Array<Offers_Bool_Exp>>;
  bundle?: InputMaybe<Bundles_Bool_Exp>;
  bundle_id?: InputMaybe<Bigint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  expiration_timestamp?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "offers" */
export enum Offers_Constraint {
  /** unique or primary key constraint on columns "id" */
  OffersPkey = 'offers_pkey'
}

/** input type for incrementing numeric columns in table "offers" */
export type Offers_Inc_Input = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "offers" */
export type Offers_Insert_Input = {
  bundle?: InputMaybe<Bundles_Obj_Rel_Insert_Input>;
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Offers_Max_Fields = {
  __typename?: 'offers_max_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "offers" */
export type Offers_Max_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Offers_Min_Fields = {
  __typename?: 'offers_min_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "offers" */
export type Offers_Min_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "offers" */
export type Offers_Mutation_Response = {
  __typename?: 'offers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Offers>;
};

/** input type for inserting object relation for remote table "offers" */
export type Offers_Obj_Rel_Insert_Input = {
  data: Offers_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Offers_On_Conflict>;
};

/** on_conflict condition type for table "offers" */
export type Offers_On_Conflict = {
  constraint: Offers_Constraint;
  update_columns?: Array<Offers_Update_Column>;
  where?: InputMaybe<Offers_Bool_Exp>;
};

/** Ordering options when selecting data from "offers". */
export type Offers_Order_By = {
  bundle?: InputMaybe<Bundles_Order_By>;
  bundle_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  expiration_timestamp?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: offers */
export type Offers_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "offers" */
export enum Offers_Select_Column {
  /** column name */
  BundleId = 'bundle_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  ExpirationTimestamp = 'expiration_timestamp',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "offers" */
export type Offers_Set_Input = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Offers_Stddev_Fields = {
  __typename?: 'offers_stddev_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "offers" */
export type Offers_Stddev_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Offers_Stddev_Pop_Fields = {
  __typename?: 'offers_stddev_pop_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "offers" */
export type Offers_Stddev_Pop_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Offers_Stddev_Samp_Fields = {
  __typename?: 'offers_stddev_samp_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "offers" */
export type Offers_Stddev_Samp_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "offers" */
export type Offers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Offers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Offers_Stream_Cursor_Value_Input = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a full timezone aware timestamp representing when the offer should expire and the status change to expired. */
  expiration_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** a status of the record indicating its current state within its lifecycle. Possible values are: new - the initial status the record is written in. Typically it will instantly be updated to change from new to offered. offered - the bundle has been offered to the driver but it has not yet been resolved (expired, declined, or accepted). accepted - the driver has accepted the offer. assigned - the driver accepted the offer, then the offer has been fully assigned to that driver by the backend. This two step acceptance process allows the driver app to simply perform a mutation on the offer to set the status to accepted without having to handle multiple people trying to accept at the exact same time. They will all set their offer status to accepted, then each of those individual mutations will fire the Accepted Event which will try to be the first to assign the assigned_offer_id column on the parent Bundle record (which has a constraint to only allow the first to assign it) and the one that is successful in setting that column will trigger the Dispatched Event which in turn sets the status of the offer to assigned. Resulting behavior is that only the first offer to be accepted by a driver gets to assigned status.  declined - the driver has declined the offer. expired - the offer timed out before getting a response from the driver. rescinded - the offer has been rescinded. This can be caused by a number of things: The driver accepted, but another driver beat them to it after they both accepted at the same time (only one can get the assigned_offer_id set). The driver never responded but another driver accepted the offer. The driver never responded but the offer system shut down the offer to try again with another method or batch of drivers (if doing broadcast offers to multiple drivers at once) */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Offers_Sum_Fields = {
  __typename?: 'offers_sum_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "offers" */
export type Offers_Sum_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "offers" */
export enum Offers_Update_Column {
  /** column name */
  BundleId = 'bundle_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  ExpirationTimestamp = 'expiration_timestamp',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Offers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Offers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Offers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Offers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Offers_Var_Pop_Fields = {
  __typename?: 'offers_var_pop_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "offers" */
export type Offers_Var_Pop_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Offers_Var_Samp_Fields = {
  __typename?: 'offers_var_samp_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "offers" */
export type Offers_Var_Samp_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Offers_Variance_Fields = {
  __typename?: 'offers_variance_fields';
  /** id for the related bundle record */
  bundle_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario record */
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "offers" */
export type Offers_Variance_Order_By = {
  /** id for the related bundle record */
  bundle_id?: InputMaybe<Order_By>;
  /** id for the related scenario record */
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** Parent to many customer records as a way to group them together under a single organization. Each customer might be a single dealership rooftop, while the organization may be the overarching company that owns all of those rooftop locations. */
export type Organizations = {
  __typename?: 'organizations';
  /** Is the organization active or inactive? Used as a soft delete. */
  active: Scalars['Boolean']['output'];
  /** Organizations can be categorized as either "operational" or "concierge" */
  category?: Maybe<Scalars['String']['output']>;
  config?: Maybe<Scalars['jsonb']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  customers: Array<Customers>;
  /** An aggregate relationship */
  customers_aggregate: Customers_Aggregate;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  organizationstocertifications: Array<Organizationstocertifications>;
  /** An aggregate relationship */
  organizationstocertifications_aggregate: Organizationstocertifications_Aggregate;
  /** Status of the organization. Used to determine what stage of the organization life-cycle this particular organization is in. */
  status?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** Parent to many customer records as a way to group them together under a single organization. Each customer might be a single dealership rooftop, while the organization may be the overarching company that owns all of those rooftop locations. */
export type OrganizationsConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Parent to many customer records as a way to group them together under a single organization. Each customer might be a single dealership rooftop, while the organization may be the overarching company that owns all of those rooftop locations. */
export type OrganizationsCustomersArgs = {
  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customers_Order_By>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


/** Parent to many customer records as a way to group them together under a single organization. Each customer might be a single dealership rooftop, while the organization may be the overarching company that owns all of those rooftop locations. */
export type OrganizationsCustomers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customers_Order_By>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


/** Parent to many customer records as a way to group them together under a single organization. Each customer might be a single dealership rooftop, while the organization may be the overarching company that owns all of those rooftop locations. */
export type OrganizationsOrganizationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


/** Parent to many customer records as a way to group them together under a single organization. Each customer might be a single dealership rooftop, while the organization may be the overarching company that owns all of those rooftop locations. */
export type OrganizationsOrganizationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};

/** aggregated selection of "organizations" */
export type Organizations_Aggregate = {
  __typename?: 'organizations_aggregate';
  aggregate?: Maybe<Organizations_Aggregate_Fields>;
  nodes: Array<Organizations>;
};

/** aggregate fields of "organizations" */
export type Organizations_Aggregate_Fields = {
  __typename?: 'organizations_aggregate_fields';
  avg?: Maybe<Organizations_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Organizations_Max_Fields>;
  min?: Maybe<Organizations_Min_Fields>;
  stddev?: Maybe<Organizations_Stddev_Fields>;
  stddev_pop?: Maybe<Organizations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Organizations_Stddev_Samp_Fields>;
  sum?: Maybe<Organizations_Sum_Fields>;
  var_pop?: Maybe<Organizations_Var_Pop_Fields>;
  var_samp?: Maybe<Organizations_Var_Samp_Fields>;
  variance?: Maybe<Organizations_Variance_Fields>;
};


/** aggregate fields of "organizations" */
export type Organizations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organizations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Organizations_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Organizations_Avg_Fields = {
  __typename?: 'organizations_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'. */
export type Organizations_Bool_Exp = {
  _and?: InputMaybe<Array<Organizations_Bool_Exp>>;
  _not?: InputMaybe<Organizations_Bool_Exp>;
  _or?: InputMaybe<Array<Organizations_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  category?: InputMaybe<String_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  customers?: InputMaybe<Customers_Bool_Exp>;
  customers_aggregate?: InputMaybe<Customers_Aggregate_Bool_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  organizationstocertifications?: InputMaybe<Organizationstocertifications_Bool_Exp>;
  organizationstocertifications_aggregate?: InputMaybe<Organizationstocertifications_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "organizations" */
export enum Organizations_Constraint {
  /** unique or primary key constraint on columns "id" */
  OrganizationsPkey = 'organizations_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Organizations_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Organizations_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Organizations_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "organizations" */
export type Organizations_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "organizations" */
export type Organizations_Insert_Input = {
  /** Is the organization active or inactive? Used as a soft delete. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Organizations can be categorized as either "operational" or "concierge" */
  category?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  customers?: InputMaybe<Customers_Arr_Rel_Insert_Input>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationstocertifications?: InputMaybe<Organizationstocertifications_Arr_Rel_Insert_Input>;
  /** Status of the organization. Used to determine what stage of the organization life-cycle this particular organization is in. */
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Organizations_Max_Fields = {
  __typename?: 'organizations_max_fields';
  /** Organizations can be categorized as either "operational" or "concierge" */
  category?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** Status of the organization. Used to determine what stage of the organization life-cycle this particular organization is in. */
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Organizations_Min_Fields = {
  __typename?: 'organizations_min_fields';
  /** Organizations can be categorized as either "operational" or "concierge" */
  category?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** Status of the organization. Used to determine what stage of the organization life-cycle this particular organization is in. */
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "organizations" */
export type Organizations_Mutation_Response = {
  __typename?: 'organizations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Organizations>;
};

/** input type for inserting object relation for remote table "organizations" */
export type Organizations_Obj_Rel_Insert_Input = {
  data: Organizations_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};

/** on_conflict condition type for table "organizations" */
export type Organizations_On_Conflict = {
  constraint: Organizations_Constraint;
  update_columns?: Array<Organizations_Update_Column>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};

/** Ordering options when selecting data from "organizations". */
export type Organizations_Order_By = {
  active?: InputMaybe<Order_By>;
  category?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  customers_aggregate?: InputMaybe<Customers_Aggregate_Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  organizationstocertifications_aggregate?: InputMaybe<Organizationstocertifications_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organizations */
export type Organizations_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Organizations_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "organizations" */
export enum Organizations_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Category = 'category',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "organizations" */
export type Organizations_Set_Input = {
  /** Is the organization active or inactive? Used as a soft delete. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Organizations can be categorized as either "operational" or "concierge" */
  category?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the organization. Used to determine what stage of the organization life-cycle this particular organization is in. */
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Organizations_Stddev_Fields = {
  __typename?: 'organizations_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Organizations_Stddev_Pop_Fields = {
  __typename?: 'organizations_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Organizations_Stddev_Samp_Fields = {
  __typename?: 'organizations_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "organizations" */
export type Organizations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organizations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organizations_Stream_Cursor_Value_Input = {
  /** Is the organization active or inactive? Used as a soft delete. */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Organizations can be categorized as either "operational" or "concierge" */
  category?: InputMaybe<Scalars['String']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the organization. Used to determine what stage of the organization life-cycle this particular organization is in. */
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Organizations_Sum_Fields = {
  __typename?: 'organizations_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "organizations" */
export enum Organizations_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Category = 'category',
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Organizations_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Organizations_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Organizations_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Organizations_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Organizations_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Organizations_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Organizations_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organizations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organizations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Organizations_Var_Pop_Fields = {
  __typename?: 'organizations_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Organizations_Var_Samp_Fields = {
  __typename?: 'organizations_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Organizations_Variance_Fields = {
  __typename?: 'organizations_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Many to Many relationships. This could be used if an org has a specific requirement for a specific certification before any cars can be moved at any of their customer rooftop locations */
export type Organizationstocertifications = {
  __typename?: 'organizationstocertifications';
  /** An object relationship */
  certification: Certifications;
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** An object relationship */
  organization: Organizations;
  organization_id: Scalars['bigint']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "organizationstocertifications" */
export type Organizationstocertifications_Aggregate = {
  __typename?: 'organizationstocertifications_aggregate';
  aggregate?: Maybe<Organizationstocertifications_Aggregate_Fields>;
  nodes: Array<Organizationstocertifications>;
};

export type Organizationstocertifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Organizationstocertifications_Aggregate_Bool_Exp_Count>;
};

export type Organizationstocertifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Organizationstocertifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "organizationstocertifications" */
export type Organizationstocertifications_Aggregate_Fields = {
  __typename?: 'organizationstocertifications_aggregate_fields';
  avg?: Maybe<Organizationstocertifications_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Organizationstocertifications_Max_Fields>;
  min?: Maybe<Organizationstocertifications_Min_Fields>;
  stddev?: Maybe<Organizationstocertifications_Stddev_Fields>;
  stddev_pop?: Maybe<Organizationstocertifications_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Organizationstocertifications_Stddev_Samp_Fields>;
  sum?: Maybe<Organizationstocertifications_Sum_Fields>;
  var_pop?: Maybe<Organizationstocertifications_Var_Pop_Fields>;
  var_samp?: Maybe<Organizationstocertifications_Var_Samp_Fields>;
  variance?: Maybe<Organizationstocertifications_Variance_Fields>;
};


/** aggregate fields of "organizationstocertifications" */
export type Organizationstocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "organizationstocertifications" */
export type Organizationstocertifications_Aggregate_Order_By = {
  avg?: InputMaybe<Organizationstocertifications_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Organizationstocertifications_Max_Order_By>;
  min?: InputMaybe<Organizationstocertifications_Min_Order_By>;
  stddev?: InputMaybe<Organizationstocertifications_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Organizationstocertifications_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Organizationstocertifications_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Organizationstocertifications_Sum_Order_By>;
  var_pop?: InputMaybe<Organizationstocertifications_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Organizationstocertifications_Var_Samp_Order_By>;
  variance?: InputMaybe<Organizationstocertifications_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "organizationstocertifications" */
export type Organizationstocertifications_Arr_Rel_Insert_Input = {
  data: Array<Organizationstocertifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Organizationstocertifications_On_Conflict>;
};

/** aggregate avg on columns */
export type Organizationstocertifications_Avg_Fields = {
  __typename?: 'organizationstocertifications_avg_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Avg_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "organizationstocertifications". All fields are combined with a logical 'AND'. */
export type Organizationstocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Organizationstocertifications_Bool_Exp>>;
  _not?: InputMaybe<Organizationstocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Organizationstocertifications_Bool_Exp>>;
  certification?: InputMaybe<Certifications_Bool_Exp>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "organizationstocertifications" */
export enum Organizationstocertifications_Constraint {
  /** unique or primary key constraint on columns "organization_id", "certification_key" */
  OrganizationstocertificationsPkey = 'organizationstocertifications_pkey'
}

/** input type for incrementing numeric columns in table "organizationstocertifications" */
export type Organizationstocertifications_Inc_Input = {
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "organizationstocertifications" */
export type Organizationstocertifications_Insert_Input = {
  certification?: InputMaybe<Certifications_Obj_Rel_Insert_Input>;
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Organizationstocertifications_Max_Fields = {
  __typename?: 'organizationstocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Max_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Organizationstocertifications_Min_Fields = {
  __typename?: 'organizationstocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Min_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "organizationstocertifications" */
export type Organizationstocertifications_Mutation_Response = {
  __typename?: 'organizationstocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Organizationstocertifications>;
};

/** on_conflict condition type for table "organizationstocertifications" */
export type Organizationstocertifications_On_Conflict = {
  constraint: Organizationstocertifications_Constraint;
  update_columns?: Array<Organizationstocertifications_Update_Column>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "organizationstocertifications". */
export type Organizationstocertifications_Order_By = {
  certification?: InputMaybe<Certifications_Order_By>;
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organizationstocertifications */
export type Organizationstocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  organization_id: Scalars['bigint']['input'];
};

/** select columns of table "organizationstocertifications" */
export enum Organizationstocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "organizationstocertifications" */
export type Organizationstocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Organizationstocertifications_Stddev_Fields = {
  __typename?: 'organizationstocertifications_stddev_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Stddev_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Organizationstocertifications_Stddev_Pop_Fields = {
  __typename?: 'organizationstocertifications_stddev_pop_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Stddev_Pop_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Organizationstocertifications_Stddev_Samp_Fields = {
  __typename?: 'organizationstocertifications_stddev_samp_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Stddev_Samp_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "organizationstocertifications" */
export type Organizationstocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organizationstocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organizationstocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Organizationstocertifications_Sum_Fields = {
  __typename?: 'organizationstocertifications_sum_fields';
  organization_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Sum_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** update columns of table "organizationstocertifications" */
export enum Organizationstocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

export type Organizationstocertifications_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Organizationstocertifications_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organizationstocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organizationstocertifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Organizationstocertifications_Var_Pop_Fields = {
  __typename?: 'organizationstocertifications_var_pop_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Var_Pop_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Organizationstocertifications_Var_Samp_Fields = {
  __typename?: 'organizationstocertifications_var_samp_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Var_Samp_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Organizationstocertifications_Variance_Fields = {
  __typename?: 'organizationstocertifications_variance_fields';
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "organizationstocertifications" */
export type Organizationstocertifications_Variance_Order_By = {
  organization_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "pay_periods_by_driver" */
export type Pay_Periods_By_Driver = {
  __typename?: 'pay_periods_by_driver';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
  pay_period?: Maybe<Scalars['String']['output']>;
  pickup_time_end?: Maybe<Scalars['timestamp']['output']>;
  pickup_time_start?: Maybe<Scalars['timestamp']['output']>;
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  total_pay_amount?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "pay_periods_by_driver" */
export type Pay_Periods_By_Driver_Aggregate = {
  __typename?: 'pay_periods_by_driver_aggregate';
  aggregate?: Maybe<Pay_Periods_By_Driver_Aggregate_Fields>;
  nodes: Array<Pay_Periods_By_Driver>;
};

/** aggregate fields of "pay_periods_by_driver" */
export type Pay_Periods_By_Driver_Aggregate_Fields = {
  __typename?: 'pay_periods_by_driver_aggregate_fields';
  avg?: Maybe<Pay_Periods_By_Driver_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Pay_Periods_By_Driver_Max_Fields>;
  min?: Maybe<Pay_Periods_By_Driver_Min_Fields>;
  stddev?: Maybe<Pay_Periods_By_Driver_Stddev_Fields>;
  stddev_pop?: Maybe<Pay_Periods_By_Driver_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pay_Periods_By_Driver_Stddev_Samp_Fields>;
  sum?: Maybe<Pay_Periods_By_Driver_Sum_Fields>;
  var_pop?: Maybe<Pay_Periods_By_Driver_Var_Pop_Fields>;
  var_samp?: Maybe<Pay_Periods_By_Driver_Var_Samp_Fields>;
  variance?: Maybe<Pay_Periods_By_Driver_Variance_Fields>;
};


/** aggregate fields of "pay_periods_by_driver" */
export type Pay_Periods_By_Driver_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Pay_Periods_By_Driver_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Pay_Periods_By_Driver_Avg_Fields = {
  __typename?: 'pay_periods_by_driver_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "pay_periods_by_driver". All fields are combined with a logical 'AND'. */
export type Pay_Periods_By_Driver_Bool_Exp = {
  _and?: InputMaybe<Array<Pay_Periods_By_Driver_Bool_Exp>>;
  _not?: InputMaybe<Pay_Periods_By_Driver_Bool_Exp>;
  _or?: InputMaybe<Array<Pay_Periods_By_Driver_Bool_Exp>>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_name?: InputMaybe<String_Comparison_Exp>;
  move_count?: InputMaybe<Bigint_Comparison_Exp>;
  pay_period?: InputMaybe<String_Comparison_Exp>;
  pickup_time_end?: InputMaybe<Timestamp_Comparison_Exp>;
  pickup_time_start?: InputMaybe<Timestamp_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  total_pay_amount?: InputMaybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Pay_Periods_By_Driver_Max_Fields = {
  __typename?: 'pay_periods_by_driver_max_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
  pay_period?: Maybe<Scalars['String']['output']>;
  pickup_time_end?: Maybe<Scalars['timestamp']['output']>;
  pickup_time_start?: Maybe<Scalars['timestamp']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  total_pay_amount?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type Pay_Periods_By_Driver_Min_Fields = {
  __typename?: 'pay_periods_by_driver_min_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
  pay_period?: Maybe<Scalars['String']['output']>;
  pickup_time_end?: Maybe<Scalars['timestamp']['output']>;
  pickup_time_start?: Maybe<Scalars['timestamp']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  total_pay_amount?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "pay_periods_by_driver". */
export type Pay_Periods_By_Driver_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  move_count?: InputMaybe<Order_By>;
  pay_period?: InputMaybe<Order_By>;
  pickup_time_end?: InputMaybe<Order_By>;
  pickup_time_start?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  total_pay_amount?: InputMaybe<Order_By>;
};

/** select columns of table "pay_periods_by_driver" */
export enum Pay_Periods_By_Driver_Select_Column {
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  MoveCount = 'move_count',
  /** column name */
  PayPeriod = 'pay_period',
  /** column name */
  PickupTimeEnd = 'pickup_time_end',
  /** column name */
  PickupTimeStart = 'pickup_time_start',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  TotalPayAmount = 'total_pay_amount'
}

/** aggregate stddev on columns */
export type Pay_Periods_By_Driver_Stddev_Fields = {
  __typename?: 'pay_periods_by_driver_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Pay_Periods_By_Driver_Stddev_Pop_Fields = {
  __typename?: 'pay_periods_by_driver_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Pay_Periods_By_Driver_Stddev_Samp_Fields = {
  __typename?: 'pay_periods_by_driver_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "pay_periods_by_driver" */
export type Pay_Periods_By_Driver_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pay_Periods_By_Driver_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pay_Periods_By_Driver_Stream_Cursor_Value_Input = {
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  move_count?: InputMaybe<Scalars['bigint']['input']>;
  pay_period?: InputMaybe<Scalars['String']['input']>;
  pickup_time_end?: InputMaybe<Scalars['timestamp']['input']>;
  pickup_time_start?: InputMaybe<Scalars['timestamp']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  total_pay_amount?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type Pay_Periods_By_Driver_Sum_Fields = {
  __typename?: 'pay_periods_by_driver_sum_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  move_count?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  total_pay_amount?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate var_pop on columns */
export type Pay_Periods_By_Driver_Var_Pop_Fields = {
  __typename?: 'pay_periods_by_driver_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Pay_Periods_By_Driver_Var_Samp_Fields = {
  __typename?: 'pay_periods_by_driver_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Pay_Periods_By_Driver_Variance_Fields = {
  __typename?: 'pay_periods_by_driver_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  move_count?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  total_pay_amount?: Maybe<Scalars['Float']['output']>;
};

/** Period of time in which appayments and apcharges are gathered together to make up a pay cycle. */
export type Paycycles = {
  __typename?: 'paycycles';
  /** An array relationship */
  apcharges: Array<Apcharges>;
  /** An aggregate relationship */
  apcharges_aggregate: Apcharges_Aggregate;
  /** An array relationship */
  appayments: Array<Appayments>;
  /** An aggregate relationship */
  appayments_aggregate: Appayments_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** End date of the pay cycle. */
  end_date: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** Start date of the pay cycle. */
  start_date: Scalars['timestamptz']['output'];
  /** "accruing" - Pay cycle is currently collecting AP. | "preparing" - Pay cycle is prepping for compliance and driver pay readiness. | "prepared" - Pay cycle has been prepped for drivers to be paid. | "failed" - Pay cycle failed to run compliance jobs and is not ready for driver payouts. */
  status: Scalars['String']['output'];
  /** "1099" - Pay cycle for 1099 drivers. | "W-2" - Pay cycle for W-2 drivers. */
  tax_class?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
};


/** Period of time in which appayments and apcharges are gathered together to make up a pay cycle. */
export type PaycyclesApchargesArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


/** Period of time in which appayments and apcharges are gathered together to make up a pay cycle. */
export type PaycyclesApcharges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


/** Period of time in which appayments and apcharges are gathered together to make up a pay cycle. */
export type PaycyclesAppaymentsArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


/** Period of time in which appayments and apcharges are gathered together to make up a pay cycle. */
export type PaycyclesAppayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};

/** aggregated selection of "paycycles" */
export type Paycycles_Aggregate = {
  __typename?: 'paycycles_aggregate';
  aggregate?: Maybe<Paycycles_Aggregate_Fields>;
  nodes: Array<Paycycles>;
};

/** aggregate fields of "paycycles" */
export type Paycycles_Aggregate_Fields = {
  __typename?: 'paycycles_aggregate_fields';
  avg?: Maybe<Paycycles_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Paycycles_Max_Fields>;
  min?: Maybe<Paycycles_Min_Fields>;
  stddev?: Maybe<Paycycles_Stddev_Fields>;
  stddev_pop?: Maybe<Paycycles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Paycycles_Stddev_Samp_Fields>;
  sum?: Maybe<Paycycles_Sum_Fields>;
  var_pop?: Maybe<Paycycles_Var_Pop_Fields>;
  var_samp?: Maybe<Paycycles_Var_Samp_Fields>;
  variance?: Maybe<Paycycles_Variance_Fields>;
};


/** aggregate fields of "paycycles" */
export type Paycycles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Paycycles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Paycycles_Avg_Fields = {
  __typename?: 'paycycles_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "paycycles". All fields are combined with a logical 'AND'. */
export type Paycycles_Bool_Exp = {
  _and?: InputMaybe<Array<Paycycles_Bool_Exp>>;
  _not?: InputMaybe<Paycycles_Bool_Exp>;
  _or?: InputMaybe<Array<Paycycles_Bool_Exp>>;
  apcharges?: InputMaybe<Apcharges_Bool_Exp>;
  apcharges_aggregate?: InputMaybe<Apcharges_Aggregate_Bool_Exp>;
  appayments?: InputMaybe<Appayments_Bool_Exp>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  end_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  start_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  tax_class?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "paycycles" */
export enum Paycycles_Constraint {
  /** unique or primary key constraint on columns "id" */
  PaycyclesPkey = 'paycycles_pkey',
  /** unique or primary key constraint on columns "tax_class", "end_date", "start_date" */
  PaycyclesStartDateEndDateTaxClassKey = 'paycycles_start_date_end_date_tax_class_key'
}

/** input type for incrementing numeric columns in table "paycycles" */
export type Paycycles_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "paycycles" */
export type Paycycles_Insert_Input = {
  apcharges?: InputMaybe<Apcharges_Arr_Rel_Insert_Input>;
  appayments?: InputMaybe<Appayments_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** End date of the pay cycle. */
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Start date of the pay cycle. */
  start_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** "accruing" - Pay cycle is currently collecting AP. | "preparing" - Pay cycle is prepping for compliance and driver pay readiness. | "prepared" - Pay cycle has been prepped for drivers to be paid. | "failed" - Pay cycle failed to run compliance jobs and is not ready for driver payouts. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** "1099" - Pay cycle for 1099 drivers. | "W-2" - Pay cycle for W-2 drivers. */
  tax_class?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Paycycles_Max_Fields = {
  __typename?: 'paycycles_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** End date of the pay cycle. */
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Start date of the pay cycle. */
  start_date?: Maybe<Scalars['timestamptz']['output']>;
  /** "accruing" - Pay cycle is currently collecting AP. | "preparing" - Pay cycle is prepping for compliance and driver pay readiness. | "prepared" - Pay cycle has been prepped for drivers to be paid. | "failed" - Pay cycle failed to run compliance jobs and is not ready for driver payouts. */
  status?: Maybe<Scalars['String']['output']>;
  /** "1099" - Pay cycle for 1099 drivers. | "W-2" - Pay cycle for W-2 drivers. */
  tax_class?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Paycycles_Min_Fields = {
  __typename?: 'paycycles_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** End date of the pay cycle. */
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Start date of the pay cycle. */
  start_date?: Maybe<Scalars['timestamptz']['output']>;
  /** "accruing" - Pay cycle is currently collecting AP. | "preparing" - Pay cycle is prepping for compliance and driver pay readiness. | "prepared" - Pay cycle has been prepped for drivers to be paid. | "failed" - Pay cycle failed to run compliance jobs and is not ready for driver payouts. */
  status?: Maybe<Scalars['String']['output']>;
  /** "1099" - Pay cycle for 1099 drivers. | "W-2" - Pay cycle for W-2 drivers. */
  tax_class?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "paycycles" */
export type Paycycles_Mutation_Response = {
  __typename?: 'paycycles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Paycycles>;
};

/** input type for inserting object relation for remote table "paycycles" */
export type Paycycles_Obj_Rel_Insert_Input = {
  data: Paycycles_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Paycycles_On_Conflict>;
};

/** on_conflict condition type for table "paycycles" */
export type Paycycles_On_Conflict = {
  constraint: Paycycles_Constraint;
  update_columns?: Array<Paycycles_Update_Column>;
  where?: InputMaybe<Paycycles_Bool_Exp>;
};

/** Ordering options when selecting data from "paycycles". */
export type Paycycles_Order_By = {
  apcharges_aggregate?: InputMaybe<Apcharges_Aggregate_Order_By>;
  appayments_aggregate?: InputMaybe<Appayments_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  start_date?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  tax_class?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: paycycles */
export type Paycycles_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "paycycles" */
export enum Paycycles_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Status = 'status',
  /** column name */
  TaxClass = 'tax_class',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "paycycles" */
export type Paycycles_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** End date of the pay cycle. */
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Start date of the pay cycle. */
  start_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** "accruing" - Pay cycle is currently collecting AP. | "preparing" - Pay cycle is prepping for compliance and driver pay readiness. | "prepared" - Pay cycle has been prepped for drivers to be paid. | "failed" - Pay cycle failed to run compliance jobs and is not ready for driver payouts. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** "1099" - Pay cycle for 1099 drivers. | "W-2" - Pay cycle for W-2 drivers. */
  tax_class?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Paycycles_Stddev_Fields = {
  __typename?: 'paycycles_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Paycycles_Stddev_Pop_Fields = {
  __typename?: 'paycycles_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Paycycles_Stddev_Samp_Fields = {
  __typename?: 'paycycles_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "paycycles" */
export type Paycycles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Paycycles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Paycycles_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** End date of the pay cycle. */
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Start date of the pay cycle. */
  start_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** "accruing" - Pay cycle is currently collecting AP. | "preparing" - Pay cycle is prepping for compliance and driver pay readiness. | "prepared" - Pay cycle has been prepped for drivers to be paid. | "failed" - Pay cycle failed to run compliance jobs and is not ready for driver payouts. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** "1099" - Pay cycle for 1099 drivers. | "W-2" - Pay cycle for W-2 drivers. */
  tax_class?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Paycycles_Sum_Fields = {
  __typename?: 'paycycles_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "paycycles" */
export enum Paycycles_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Status = 'status',
  /** column name */
  TaxClass = 'tax_class',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Paycycles_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Paycycles_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Paycycles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Paycycles_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Paycycles_Var_Pop_Fields = {
  __typename?: 'paycycles_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Paycycles_Var_Samp_Fields = {
  __typename?: 'paycycles_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Paycycles_Variance_Fields = {
  __typename?: 'paycycles_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments = {
  __typename?: 'paycycletodrivertodocuments';
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['String']['output'];
  document_reference_id: Scalars['uuid']['output'];
  /** An object relationship */
  driver?: Maybe<Drivers>;
  driver_id: Scalars['bigint']['output'];
  id: Scalars['Int']['output'];
  modified_at: Scalars['timestamptz']['output'];
  modified_by: Scalars['String']['output'];
  /** An object relationship */
  paycycle?: Maybe<Paycycles>;
  paycycle_id: Scalars['bigint']['output'];
  /** An object relationship */
  paycycle_to_driver_to_documents?: Maybe<Documents>;
};

/** aggregated selection of "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Aggregate = {
  __typename?: 'paycycletodrivertodocuments_aggregate';
  aggregate?: Maybe<Paycycletodrivertodocuments_Aggregate_Fields>;
  nodes: Array<Paycycletodrivertodocuments>;
};

/** aggregate fields of "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Aggregate_Fields = {
  __typename?: 'paycycletodrivertodocuments_aggregate_fields';
  avg?: Maybe<Paycycletodrivertodocuments_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Paycycletodrivertodocuments_Max_Fields>;
  min?: Maybe<Paycycletodrivertodocuments_Min_Fields>;
  stddev?: Maybe<Paycycletodrivertodocuments_Stddev_Fields>;
  stddev_pop?: Maybe<Paycycletodrivertodocuments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Paycycletodrivertodocuments_Stddev_Samp_Fields>;
  sum?: Maybe<Paycycletodrivertodocuments_Sum_Fields>;
  var_pop?: Maybe<Paycycletodrivertodocuments_Var_Pop_Fields>;
  var_samp?: Maybe<Paycycletodrivertodocuments_Var_Samp_Fields>;
  variance?: Maybe<Paycycletodrivertodocuments_Variance_Fields>;
};


/** aggregate fields of "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Paycycletodrivertodocuments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Paycycletodrivertodocuments_Avg_Fields = {
  __typename?: 'paycycletodrivertodocuments_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "paycycletodrivertodocuments". All fields are combined with a logical 'AND'. */
export type Paycycletodrivertodocuments_Bool_Exp = {
  _and?: InputMaybe<Array<Paycycletodrivertodocuments_Bool_Exp>>;
  _not?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
  _or?: InputMaybe<Array<Paycycletodrivertodocuments_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  document_reference_id?: InputMaybe<Uuid_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  modified_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  modified_by?: InputMaybe<String_Comparison_Exp>;
  paycycle?: InputMaybe<Paycycles_Bool_Exp>;
  paycycle_id?: InputMaybe<Bigint_Comparison_Exp>;
  paycycle_to_driver_to_documents?: InputMaybe<Documents_Bool_Exp>;
};

/** unique or primary key constraints on table "paycycletodrivertodocuments" */
export enum Paycycletodrivertodocuments_Constraint {
  /** unique or primary key constraint on columns "document_reference_id" */
  PaycycletodrivertodocumentsDocumentReferenceIdKey = 'paycycletodrivertodocuments_document_reference_id_key',
  /** unique or primary key constraint on columns "id" */
  PaycycletodrivertodocumentsPkey = 'paycycletodrivertodocuments_pkey'
}

/** input type for incrementing numeric columns in table "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Inc_Input = {
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified_at?: InputMaybe<Scalars['timestamptz']['input']>;
  modified_by?: InputMaybe<Scalars['String']['input']>;
  paycycle?: InputMaybe<Paycycles_Obj_Rel_Insert_Input>;
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
  paycycle_to_driver_to_documents?: InputMaybe<Documents_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Paycycletodrivertodocuments_Max_Fields = {
  __typename?: 'paycycletodrivertodocuments_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  modified_at?: Maybe<Scalars['timestamptz']['output']>;
  modified_by?: Maybe<Scalars['String']['output']>;
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Paycycletodrivertodocuments_Min_Fields = {
  __typename?: 'paycycletodrivertodocuments_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  document_reference_id?: Maybe<Scalars['uuid']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  modified_at?: Maybe<Scalars['timestamptz']['output']>;
  modified_by?: Maybe<Scalars['String']['output']>;
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Mutation_Response = {
  __typename?: 'paycycletodrivertodocuments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Paycycletodrivertodocuments>;
};

/** on_conflict condition type for table "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_On_Conflict = {
  constraint: Paycycletodrivertodocuments_Constraint;
  update_columns?: Array<Paycycletodrivertodocuments_Update_Column>;
  where?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
};

/** Ordering options when selecting data from "paycycletodrivertodocuments". */
export type Paycycletodrivertodocuments_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  document_reference_id?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  modified_at?: InputMaybe<Order_By>;
  modified_by?: InputMaybe<Order_By>;
  paycycle?: InputMaybe<Paycycles_Order_By>;
  paycycle_id?: InputMaybe<Order_By>;
  paycycle_to_driver_to_documents?: InputMaybe<Documents_Order_By>;
};

/** primary key columns input for table: paycycletodrivertodocuments */
export type Paycycletodrivertodocuments_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "paycycletodrivertodocuments" */
export enum Paycycletodrivertodocuments_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Id = 'id',
  /** column name */
  ModifiedAt = 'modified_at',
  /** column name */
  ModifiedBy = 'modified_by',
  /** column name */
  PaycycleId = 'paycycle_id'
}

/** input type for updating data in table "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified_at?: InputMaybe<Scalars['timestamptz']['input']>;
  modified_by?: InputMaybe<Scalars['String']['input']>;
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Paycycletodrivertodocuments_Stddev_Fields = {
  __typename?: 'paycycletodrivertodocuments_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Paycycletodrivertodocuments_Stddev_Pop_Fields = {
  __typename?: 'paycycletodrivertodocuments_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Paycycletodrivertodocuments_Stddev_Samp_Fields = {
  __typename?: 'paycycletodrivertodocuments_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "paycycletodrivertodocuments" */
export type Paycycletodrivertodocuments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Paycycletodrivertodocuments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Paycycletodrivertodocuments_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  document_reference_id?: InputMaybe<Scalars['uuid']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified_at?: InputMaybe<Scalars['timestamptz']['input']>;
  modified_by?: InputMaybe<Scalars['String']['input']>;
  paycycle_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Paycycletodrivertodocuments_Sum_Fields = {
  __typename?: 'paycycletodrivertodocuments_sum_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  paycycle_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "paycycletodrivertodocuments" */
export enum Paycycletodrivertodocuments_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DocumentReferenceId = 'document_reference_id',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  Id = 'id',
  /** column name */
  ModifiedAt = 'modified_at',
  /** column name */
  ModifiedBy = 'modified_by',
  /** column name */
  PaycycleId = 'paycycle_id'
}

export type Paycycletodrivertodocuments_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Paycycletodrivertodocuments_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Paycycletodrivertodocuments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Paycycletodrivertodocuments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Paycycletodrivertodocuments_Var_Pop_Fields = {
  __typename?: 'paycycletodrivertodocuments_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Paycycletodrivertodocuments_Var_Samp_Fields = {
  __typename?: 'paycycletodrivertodocuments_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Paycycletodrivertodocuments_Variance_Fields = {
  __typename?: 'paycycletodrivertodocuments_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  paycycle_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payertocustomer" */
export type Payertocustomer = {
  __typename?: 'payertocustomer';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  /** An object relationship */
  payee?: Maybe<Customers>;
  payee_id: Scalars['bigint']['output'];
  /** An object relationship */
  payer?: Maybe<Customers>;
  payer_id: Scalars['bigint']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by: Scalars['String']['output'];
};

/** aggregated selection of "payertocustomer" */
export type Payertocustomer_Aggregate = {
  __typename?: 'payertocustomer_aggregate';
  aggregate?: Maybe<Payertocustomer_Aggregate_Fields>;
  nodes: Array<Payertocustomer>;
};

/** aggregate fields of "payertocustomer" */
export type Payertocustomer_Aggregate_Fields = {
  __typename?: 'payertocustomer_aggregate_fields';
  avg?: Maybe<Payertocustomer_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Payertocustomer_Max_Fields>;
  min?: Maybe<Payertocustomer_Min_Fields>;
  stddev?: Maybe<Payertocustomer_Stddev_Fields>;
  stddev_pop?: Maybe<Payertocustomer_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Payertocustomer_Stddev_Samp_Fields>;
  sum?: Maybe<Payertocustomer_Sum_Fields>;
  var_pop?: Maybe<Payertocustomer_Var_Pop_Fields>;
  var_samp?: Maybe<Payertocustomer_Var_Samp_Fields>;
  variance?: Maybe<Payertocustomer_Variance_Fields>;
};


/** aggregate fields of "payertocustomer" */
export type Payertocustomer_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Payertocustomer_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Payertocustomer_Avg_Fields = {
  __typename?: 'payertocustomer_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payertocustomer". All fields are combined with a logical 'AND'. */
export type Payertocustomer_Bool_Exp = {
  _and?: InputMaybe<Array<Payertocustomer_Bool_Exp>>;
  _not?: InputMaybe<Payertocustomer_Bool_Exp>;
  _or?: InputMaybe<Array<Payertocustomer_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  payee?: InputMaybe<Customers_Bool_Exp>;
  payee_id?: InputMaybe<Bigint_Comparison_Exp>;
  payer?: InputMaybe<Customers_Bool_Exp>;
  payer_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "payertocustomer" */
export enum Payertocustomer_Constraint {
  /** unique or primary key constraint on columns "payer_id", "payee_id" */
  PayertocustomerPayerIdPayeeIdKey = 'payertocustomer_payer_id_payee_id_key',
  /** unique or primary key constraint on columns "id" */
  PayertocustomerPkey = 'payertocustomer_pkey'
}

/** input type for incrementing numeric columns in table "payertocustomer" */
export type Payertocustomer_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  payee_id?: InputMaybe<Scalars['bigint']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "payertocustomer" */
export type Payertocustomer_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  payee?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  payee_id?: InputMaybe<Scalars['bigint']['input']>;
  payer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Payertocustomer_Max_Fields = {
  __typename?: 'payertocustomer_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  payee_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Payertocustomer_Min_Fields = {
  __typename?: 'payertocustomer_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  payee_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "payertocustomer" */
export type Payertocustomer_Mutation_Response = {
  __typename?: 'payertocustomer_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Payertocustomer>;
};

/** on_conflict condition type for table "payertocustomer" */
export type Payertocustomer_On_Conflict = {
  constraint: Payertocustomer_Constraint;
  update_columns?: Array<Payertocustomer_Update_Column>;
  where?: InputMaybe<Payertocustomer_Bool_Exp>;
};

/** Ordering options when selecting data from "payertocustomer". */
export type Payertocustomer_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payee?: InputMaybe<Customers_Order_By>;
  payee_id?: InputMaybe<Order_By>;
  payer?: InputMaybe<Customers_Order_By>;
  payer_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
};

/** primary key columns input for table: payertocustomer */
export type Payertocustomer_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "payertocustomer" */
export enum Payertocustomer_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  PayeeId = 'payee_id',
  /** column name */
  PayerId = 'payer_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "payertocustomer" */
export type Payertocustomer_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  payee_id?: InputMaybe<Scalars['bigint']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Payertocustomer_Stddev_Fields = {
  __typename?: 'payertocustomer_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Payertocustomer_Stddev_Pop_Fields = {
  __typename?: 'payertocustomer_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Payertocustomer_Stddev_Samp_Fields = {
  __typename?: 'payertocustomer_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payertocustomer" */
export type Payertocustomer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payertocustomer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payertocustomer_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  payee_id?: InputMaybe<Scalars['bigint']['input']>;
  payer_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Payertocustomer_Sum_Fields = {
  __typename?: 'payertocustomer_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  payee_id?: Maybe<Scalars['bigint']['output']>;
  payer_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "payertocustomer" */
export enum Payertocustomer_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  PayeeId = 'payee_id',
  /** column name */
  PayerId = 'payer_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Payertocustomer_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Payertocustomer_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Payertocustomer_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payertocustomer_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Payertocustomer_Var_Pop_Fields = {
  __typename?: 'payertocustomer_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Payertocustomer_Var_Samp_Fields = {
  __typename?: 'payertocustomer_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Payertocustomer_Variance_Fields = {
  __typename?: 'payertocustomer_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  payee_id?: Maybe<Scalars['Float']['output']>;
  payer_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payrategroups" */
export type Payrategroups = {
  __typename?: 'payrategroups';
  active: Scalars['Boolean']['output'];
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  config?: Maybe<Scalars['jsonb']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['bigint']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  payraterules: Array<Payraterules>;
  /** An aggregate relationship */
  payraterules_aggregate: Payraterules_Aggregate;
  /** An array relationship */
  raterules: Array<Raterules>;
  /** An aggregate relationship */
  raterules_aggregate: Raterules_Aggregate;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "payrategroups" */
export type PayrategroupsConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "payrategroups" */
export type PayrategroupsPayraterulesArgs = {
  distinct_on?: InputMaybe<Array<Payraterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payraterules_Order_By>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


/** columns and relationships of "payrategroups" */
export type PayrategroupsPayraterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payraterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payraterules_Order_By>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


/** columns and relationships of "payrategroups" */
export type PayrategroupsRaterulesArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


/** columns and relationships of "payrategroups" */
export type PayrategroupsRaterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};

/** aggregated selection of "payrategroups" */
export type Payrategroups_Aggregate = {
  __typename?: 'payrategroups_aggregate';
  aggregate?: Maybe<Payrategroups_Aggregate_Fields>;
  nodes: Array<Payrategroups>;
};

/** aggregate fields of "payrategroups" */
export type Payrategroups_Aggregate_Fields = {
  __typename?: 'payrategroups_aggregate_fields';
  avg?: Maybe<Payrategroups_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Payrategroups_Max_Fields>;
  min?: Maybe<Payrategroups_Min_Fields>;
  stddev?: Maybe<Payrategroups_Stddev_Fields>;
  stddev_pop?: Maybe<Payrategroups_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Payrategroups_Stddev_Samp_Fields>;
  sum?: Maybe<Payrategroups_Sum_Fields>;
  var_pop?: Maybe<Payrategroups_Var_Pop_Fields>;
  var_samp?: Maybe<Payrategroups_Var_Samp_Fields>;
  variance?: Maybe<Payrategroups_Variance_Fields>;
};


/** aggregate fields of "payrategroups" */
export type Payrategroups_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Payrategroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Payrategroups_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Payrategroups_Avg_Fields = {
  __typename?: 'payrategroups_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payrategroups". All fields are combined with a logical 'AND'. */
export type Payrategroups_Bool_Exp = {
  _and?: InputMaybe<Array<Payrategroups_Bool_Exp>>;
  _not?: InputMaybe<Payrategroups_Bool_Exp>;
  _or?: InputMaybe<Array<Payrategroups_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  begin_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  end_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  payraterules?: InputMaybe<Payraterules_Bool_Exp>;
  payraterules_aggregate?: InputMaybe<Payraterules_Aggregate_Bool_Exp>;
  raterules?: InputMaybe<Raterules_Bool_Exp>;
  raterules_aggregate?: InputMaybe<Raterules_Aggregate_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "payrategroups" */
export enum Payrategroups_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25738Primary = 'idx_25738_primary'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Payrategroups_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Payrategroups_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Payrategroups_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "payrategroups" */
export type Payrategroups_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "payrategroups" */
export type Payrategroups_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payraterules?: InputMaybe<Payraterules_Arr_Rel_Insert_Input>;
  raterules?: InputMaybe<Raterules_Arr_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Payrategroups_Max_Fields = {
  __typename?: 'payrategroups_max_fields';
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Payrategroups_Min_Fields = {
  __typename?: 'payrategroups_min_fields';
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "payrategroups" */
export type Payrategroups_Mutation_Response = {
  __typename?: 'payrategroups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Payrategroups>;
};

/** input type for inserting object relation for remote table "payrategroups" */
export type Payrategroups_Obj_Rel_Insert_Input = {
  data: Payrategroups_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Payrategroups_On_Conflict>;
};

/** on_conflict condition type for table "payrategroups" */
export type Payrategroups_On_Conflict = {
  constraint: Payrategroups_Constraint;
  update_columns?: Array<Payrategroups_Update_Column>;
  where?: InputMaybe<Payrategroups_Bool_Exp>;
};

/** Ordering options when selecting data from "payrategroups". */
export type Payrategroups_Order_By = {
  active?: InputMaybe<Order_By>;
  begin_date?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  payraterules_aggregate?: InputMaybe<Payraterules_Aggregate_Order_By>;
  raterules_aggregate?: InputMaybe<Raterules_Aggregate_Order_By>;
  region_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: payrategroups */
export type Payrategroups_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Payrategroups_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "payrategroups" */
export enum Payrategroups_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  BeginDate = 'begin_date',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "payrategroups" */
export type Payrategroups_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Payrategroups_Stddev_Fields = {
  __typename?: 'payrategroups_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Payrategroups_Stddev_Pop_Fields = {
  __typename?: 'payrategroups_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Payrategroups_Stddev_Samp_Fields = {
  __typename?: 'payrategroups_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payrategroups" */
export type Payrategroups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payrategroups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payrategroups_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Payrategroups_Sum_Fields = {
  __typename?: 'payrategroups_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "payrategroups" */
export enum Payrategroups_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  BeginDate = 'begin_date',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Payrategroups_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Payrategroups_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Payrategroups_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Payrategroups_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Payrategroups_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Payrategroups_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Payrategroups_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Payrategroups_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payrategroups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Payrategroups_Var_Pop_Fields = {
  __typename?: 'payrategroups_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Payrategroups_Var_Samp_Fields = {
  __typename?: 'payrategroups_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Payrategroups_Variance_Fields = {
  __typename?: 'payrategroups_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payraterules" */
export type Payraterules = {
  __typename?: 'payraterules';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['bigint']['output'];
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  payrategroup?: Maybe<Payrategroups>;
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "payraterules" */
export type Payraterules_Aggregate = {
  __typename?: 'payraterules_aggregate';
  aggregate?: Maybe<Payraterules_Aggregate_Fields>;
  nodes: Array<Payraterules>;
};

export type Payraterules_Aggregate_Bool_Exp = {
  count?: InputMaybe<Payraterules_Aggregate_Bool_Exp_Count>;
};

export type Payraterules_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Payraterules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Payraterules_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "payraterules" */
export type Payraterules_Aggregate_Fields = {
  __typename?: 'payraterules_aggregate_fields';
  avg?: Maybe<Payraterules_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Payraterules_Max_Fields>;
  min?: Maybe<Payraterules_Min_Fields>;
  stddev?: Maybe<Payraterules_Stddev_Fields>;
  stddev_pop?: Maybe<Payraterules_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Payraterules_Stddev_Samp_Fields>;
  sum?: Maybe<Payraterules_Sum_Fields>;
  var_pop?: Maybe<Payraterules_Var_Pop_Fields>;
  var_samp?: Maybe<Payraterules_Var_Samp_Fields>;
  variance?: Maybe<Payraterules_Variance_Fields>;
};


/** aggregate fields of "payraterules" */
export type Payraterules_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Payraterules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payraterules" */
export type Payraterules_Aggregate_Order_By = {
  avg?: InputMaybe<Payraterules_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Payraterules_Max_Order_By>;
  min?: InputMaybe<Payraterules_Min_Order_By>;
  stddev?: InputMaybe<Payraterules_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Payraterules_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Payraterules_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Payraterules_Sum_Order_By>;
  var_pop?: InputMaybe<Payraterules_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Payraterules_Var_Samp_Order_By>;
  variance?: InputMaybe<Payraterules_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "payraterules" */
export type Payraterules_Arr_Rel_Insert_Input = {
  data: Array<Payraterules_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Payraterules_On_Conflict>;
};

/** aggregate avg on columns */
export type Payraterules_Avg_Fields = {
  __typename?: 'payraterules_avg_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "payraterules" */
export type Payraterules_Avg_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "payraterules". All fields are combined with a logical 'AND'. */
export type Payraterules_Bool_Exp = {
  _and?: InputMaybe<Array<Payraterules_Bool_Exp>>;
  _not?: InputMaybe<Payraterules_Bool_Exp>;
  _or?: InputMaybe<Array<Payraterules_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  distance_end?: InputMaybe<Numeric_Comparison_Exp>;
  distance_start?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  pay_rate_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  payrategroup?: InputMaybe<Payrategroups_Bool_Exp>;
  per_mile_rate?: InputMaybe<Numeric_Comparison_Exp>;
  per_minute_rate?: InputMaybe<Numeric_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "payraterules" */
export enum Payraterules_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25747Primary = 'idx_25747_primary'
}

/** input type for incrementing numeric columns in table "payraterules" */
export type Payraterules_Inc_Input = {
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "payraterules" */
export type Payraterules_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  payrategroup?: InputMaybe<Payrategroups_Obj_Rel_Insert_Input>;
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Payraterules_Max_Fields = {
  __typename?: 'payraterules_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "payraterules" */
export type Payraterules_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Payraterules_Min_Fields = {
  __typename?: 'payraterules_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "payraterules" */
export type Payraterules_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "payraterules" */
export type Payraterules_Mutation_Response = {
  __typename?: 'payraterules_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Payraterules>;
};

/** input type for inserting object relation for remote table "payraterules" */
export type Payraterules_Obj_Rel_Insert_Input = {
  data: Payraterules_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Payraterules_On_Conflict>;
};

/** on_conflict condition type for table "payraterules" */
export type Payraterules_On_Conflict = {
  constraint: Payraterules_Constraint;
  update_columns?: Array<Payraterules_Update_Column>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};

/** Ordering options when selecting data from "payraterules". */
export type Payraterules_Order_By = {
  createdat?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  payrategroup?: InputMaybe<Payrategroups_Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: payraterules */
export type Payraterules_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "payraterules" */
export enum Payraterules_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DistanceEnd = 'distance_end',
  /** column name */
  DistanceStart = 'distance_start',
  /** column name */
  Id = 'id',
  /** column name */
  PayRateGroupId = 'pay_rate_group_id',
  /** column name */
  PerMileRate = 'per_mile_rate',
  /** column name */
  PerMinuteRate = 'per_minute_rate',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "payraterules" */
export type Payraterules_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Payraterules_Stddev_Fields = {
  __typename?: 'payraterules_stddev_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "payraterules" */
export type Payraterules_Stddev_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Payraterules_Stddev_Pop_Fields = {
  __typename?: 'payraterules_stddev_pop_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "payraterules" */
export type Payraterules_Stddev_Pop_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Payraterules_Stddev_Samp_Fields = {
  __typename?: 'payraterules_stddev_samp_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "payraterules" */
export type Payraterules_Stddev_Samp_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "payraterules" */
export type Payraterules_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payraterules_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payraterules_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Payraterules_Sum_Fields = {
  __typename?: 'payraterules_sum_fields';
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "payraterules" */
export type Payraterules_Sum_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** update columns of table "payraterules" */
export enum Payraterules_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DistanceEnd = 'distance_end',
  /** column name */
  DistanceStart = 'distance_start',
  /** column name */
  Id = 'id',
  /** column name */
  PayRateGroupId = 'pay_rate_group_id',
  /** column name */
  PerMileRate = 'per_mile_rate',
  /** column name */
  PerMinuteRate = 'per_minute_rate',
  /** column name */
  Updatedat = 'updatedat'
}

export type Payraterules_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Payraterules_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Payraterules_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payraterules_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Payraterules_Var_Pop_Fields = {
  __typename?: 'payraterules_var_pop_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "payraterules" */
export type Payraterules_Var_Pop_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Payraterules_Var_Samp_Fields = {
  __typename?: 'payraterules_var_samp_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "payraterules" */
export type Payraterules_Var_Samp_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Payraterules_Variance_Fields = {
  __typename?: 'payraterules_variance_fields';
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "payraterules" */
export type Payraterules_Variance_Order_By = {
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
};

/** columns and relationships of "plans" */
export type Plans = {
  __typename?: 'plans';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  driver?: Maybe<Drivers>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** An object relationship */
  parked_car_location?: Maybe<Locations>;
  parked_location?: Maybe<Scalars['bigint']['output']>;
  plan_date?: Maybe<Scalars['date']['output']>;
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  trip?: Maybe<Trips>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "plans" */
export type PlansMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "plans" */
export type PlansMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};

/** aggregated selection of "plans" */
export type Plans_Aggregate = {
  __typename?: 'plans_aggregate';
  aggregate?: Maybe<Plans_Aggregate_Fields>;
  nodes: Array<Plans>;
};

export type Plans_Aggregate_Bool_Exp = {
  count?: InputMaybe<Plans_Aggregate_Bool_Exp_Count>;
};

export type Plans_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Plans_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Plans_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "plans" */
export type Plans_Aggregate_Fields = {
  __typename?: 'plans_aggregate_fields';
  avg?: Maybe<Plans_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Plans_Max_Fields>;
  min?: Maybe<Plans_Min_Fields>;
  stddev?: Maybe<Plans_Stddev_Fields>;
  stddev_pop?: Maybe<Plans_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Plans_Stddev_Samp_Fields>;
  sum?: Maybe<Plans_Sum_Fields>;
  var_pop?: Maybe<Plans_Var_Pop_Fields>;
  var_samp?: Maybe<Plans_Var_Samp_Fields>;
  variance?: Maybe<Plans_Variance_Fields>;
};


/** aggregate fields of "plans" */
export type Plans_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Plans_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "plans" */
export type Plans_Aggregate_Order_By = {
  avg?: InputMaybe<Plans_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Plans_Max_Order_By>;
  min?: InputMaybe<Plans_Min_Order_By>;
  stddev?: InputMaybe<Plans_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Plans_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Plans_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Plans_Sum_Order_By>;
  var_pop?: InputMaybe<Plans_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Plans_Var_Samp_Order_By>;
  variance?: InputMaybe<Plans_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "plans" */
export type Plans_Arr_Rel_Insert_Input = {
  data: Array<Plans_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};

/** aggregate avg on columns */
export type Plans_Avg_Fields = {
  __typename?: 'plans_avg_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "plans" */
export type Plans_Avg_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "plans". All fields are combined with a logical 'AND'. */
export type Plans_Bool_Exp = {
  _and?: InputMaybe<Array<Plans_Bool_Exp>>;
  _not?: InputMaybe<Plans_Bool_Exp>;
  _or?: InputMaybe<Array<Plans_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  driver_id?: InputMaybe<Bigint_Comparison_Exp>;
  driver_name?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  parked_car_location?: InputMaybe<Locations_Bool_Exp>;
  parked_location?: InputMaybe<Bigint_Comparison_Exp>;
  plan_date?: InputMaybe<Date_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  trip?: InputMaybe<Trips_Bool_Exp>;
  trip_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "plans" */
export enum Plans_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25753Primary = 'idx_25753_primary'
}

/** input type for incrementing numeric columns in table "plans" */
export type Plans_Inc_Input = {
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  parked_location?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "plans" */
export type Plans_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  parked_car_location?: InputMaybe<Locations_Obj_Rel_Insert_Input>;
  parked_location?: InputMaybe<Scalars['bigint']['input']>;
  plan_date?: InputMaybe<Scalars['date']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  trip?: InputMaybe<Trips_Obj_Rel_Insert_Input>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Plans_Max_Fields = {
  __typename?: 'plans_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  parked_location?: Maybe<Scalars['bigint']['output']>;
  plan_date?: Maybe<Scalars['date']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "plans" */
export type Plans_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  plan_date?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Plans_Min_Fields = {
  __typename?: 'plans_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  driver_id?: Maybe<Scalars['bigint']['output']>;
  driver_name?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  parked_location?: Maybe<Scalars['bigint']['output']>;
  plan_date?: Maybe<Scalars['date']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "plans" */
export type Plans_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  plan_date?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "plans" */
export type Plans_Mutation_Response = {
  __typename?: 'plans_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Plans>;
};

/** input type for inserting object relation for remote table "plans" */
export type Plans_Obj_Rel_Insert_Input = {
  data: Plans_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};

/** on_conflict condition type for table "plans" */
export type Plans_On_Conflict = {
  constraint: Plans_Constraint;
  update_columns?: Array<Plans_Update_Column>;
  where?: InputMaybe<Plans_Bool_Exp>;
};

/** Ordering options when selecting data from "plans". */
export type Plans_Order_By = {
  createdat?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  driver_id?: InputMaybe<Order_By>;
  driver_name?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  parked_car_location?: InputMaybe<Locations_Order_By>;
  parked_location?: InputMaybe<Order_By>;
  plan_date?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip?: InputMaybe<Trips_Order_By>;
  trip_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: plans */
export type Plans_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "plans" */
export enum Plans_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  Id = 'id',
  /** column name */
  ParkedLocation = 'parked_location',
  /** column name */
  PlanDate = 'plan_date',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "plans" */
export type Plans_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  parked_location?: InputMaybe<Scalars['bigint']['input']>;
  plan_date?: InputMaybe<Scalars['date']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Plans_Stddev_Fields = {
  __typename?: 'plans_stddev_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "plans" */
export type Plans_Stddev_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Plans_Stddev_Pop_Fields = {
  __typename?: 'plans_stddev_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "plans" */
export type Plans_Stddev_Pop_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Plans_Stddev_Samp_Fields = {
  __typename?: 'plans_stddev_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "plans" */
export type Plans_Stddev_Samp_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "plans" */
export type Plans_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Plans_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Plans_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  driver_id?: InputMaybe<Scalars['bigint']['input']>;
  driver_name?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  parked_location?: InputMaybe<Scalars['bigint']['input']>;
  plan_date?: InputMaybe<Scalars['date']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  trip_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Plans_Sum_Fields = {
  __typename?: 'plans_sum_fields';
  driver_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  parked_location?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  trip_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "plans" */
export type Plans_Sum_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** update columns of table "plans" */
export enum Plans_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  DriverId = 'driver_id',
  /** column name */
  DriverName = 'driver_name',
  /** column name */
  Id = 'id',
  /** column name */
  ParkedLocation = 'parked_location',
  /** column name */
  PlanDate = 'plan_date',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  TripId = 'trip_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Plans_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Plans_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Plans_Set_Input>;
  /** filter the rows which have to be updated */
  where: Plans_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Plans_Var_Pop_Fields = {
  __typename?: 'plans_var_pop_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "plans" */
export type Plans_Var_Pop_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Plans_Var_Samp_Fields = {
  __typename?: 'plans_var_samp_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "plans" */
export type Plans_Var_Samp_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Plans_Variance_Fields = {
  __typename?: 'plans_variance_fields';
  driver_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  parked_location?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  trip_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "plans" */
export type Plans_Variance_Order_By = {
  driver_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parked_location?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  trip_id?: InputMaybe<Order_By>;
};

/** This table is an audit trail for where a plate has been. It is a direct child to a plate record and shares many siblings. */
export type Platedetails = {
  __typename?: 'platedetails';
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** Notes on the plate at the time. */
  notes?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  plate: Plates;
  /** Relationship ID to plates. */
  plate_id: Scalars['bigint']['output'];
  /** The status of the plate during this time period. */
  status: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "platedetails" */
export type Platedetails_Aggregate = {
  __typename?: 'platedetails_aggregate';
  aggregate?: Maybe<Platedetails_Aggregate_Fields>;
  nodes: Array<Platedetails>;
};

export type Platedetails_Aggregate_Bool_Exp = {
  count?: InputMaybe<Platedetails_Aggregate_Bool_Exp_Count>;
};

export type Platedetails_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Platedetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Platedetails_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "platedetails" */
export type Platedetails_Aggregate_Fields = {
  __typename?: 'platedetails_aggregate_fields';
  avg?: Maybe<Platedetails_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Platedetails_Max_Fields>;
  min?: Maybe<Platedetails_Min_Fields>;
  stddev?: Maybe<Platedetails_Stddev_Fields>;
  stddev_pop?: Maybe<Platedetails_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Platedetails_Stddev_Samp_Fields>;
  sum?: Maybe<Platedetails_Sum_Fields>;
  var_pop?: Maybe<Platedetails_Var_Pop_Fields>;
  var_samp?: Maybe<Platedetails_Var_Samp_Fields>;
  variance?: Maybe<Platedetails_Variance_Fields>;
};


/** aggregate fields of "platedetails" */
export type Platedetails_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Platedetails_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "platedetails" */
export type Platedetails_Aggregate_Order_By = {
  avg?: InputMaybe<Platedetails_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Platedetails_Max_Order_By>;
  min?: InputMaybe<Platedetails_Min_Order_By>;
  stddev?: InputMaybe<Platedetails_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Platedetails_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Platedetails_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Platedetails_Sum_Order_By>;
  var_pop?: InputMaybe<Platedetails_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Platedetails_Var_Samp_Order_By>;
  variance?: InputMaybe<Platedetails_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "platedetails" */
export type Platedetails_Arr_Rel_Insert_Input = {
  data: Array<Platedetails_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Platedetails_On_Conflict>;
};

/** aggregate avg on columns */
export type Platedetails_Avg_Fields = {
  __typename?: 'platedetails_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "platedetails" */
export type Platedetails_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "platedetails". All fields are combined with a logical 'AND'. */
export type Platedetails_Bool_Exp = {
  _and?: InputMaybe<Array<Platedetails_Bool_Exp>>;
  _not?: InputMaybe<Platedetails_Bool_Exp>;
  _or?: InputMaybe<Array<Platedetails_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  plate?: InputMaybe<Plates_Bool_Exp>;
  plate_id?: InputMaybe<Bigint_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "platedetails" */
export enum Platedetails_Constraint {
  /** unique or primary key constraint on columns "id" */
  PlatedetailsPkey = 'platedetails_pkey'
}

/** input type for incrementing numeric columns in table "platedetails" */
export type Platedetails_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "platedetails" */
export type Platedetails_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes on the plate at the time. */
  notes?: InputMaybe<Scalars['String']['input']>;
  plate?: InputMaybe<Plates_Obj_Rel_Insert_Input>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The status of the plate during this time period. */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Platedetails_Max_Fields = {
  __typename?: 'platedetails_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Notes on the plate at the time. */
  notes?: Maybe<Scalars['String']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['bigint']['output']>;
  /** The status of the plate during this time period. */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "platedetails" */
export type Platedetails_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Notes on the plate at the time. */
  notes?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
  /** The status of the plate during this time period. */
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Platedetails_Min_Fields = {
  __typename?: 'platedetails_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Notes on the plate at the time. */
  notes?: Maybe<Scalars['String']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['bigint']['output']>;
  /** The status of the plate during this time period. */
  status?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "platedetails" */
export type Platedetails_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Notes on the plate at the time. */
  notes?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
  /** The status of the plate during this time period. */
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "platedetails" */
export type Platedetails_Mutation_Response = {
  __typename?: 'platedetails_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Platedetails>;
};

/** on_conflict condition type for table "platedetails" */
export type Platedetails_On_Conflict = {
  constraint: Platedetails_Constraint;
  update_columns?: Array<Platedetails_Update_Column>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};

/** Ordering options when selecting data from "platedetails". */
export type Platedetails_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  plate?: InputMaybe<Plates_Order_By>;
  plate_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: platedetails */
export type Platedetails_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "platedetails" */
export enum Platedetails_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PlateId = 'plate_id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "platedetails" */
export type Platedetails_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes on the plate at the time. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The status of the plate during this time period. */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Platedetails_Stddev_Fields = {
  __typename?: 'platedetails_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "platedetails" */
export type Platedetails_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Platedetails_Stddev_Pop_Fields = {
  __typename?: 'platedetails_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "platedetails" */
export type Platedetails_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Platedetails_Stddev_Samp_Fields = {
  __typename?: 'platedetails_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "platedetails" */
export type Platedetails_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "platedetails" */
export type Platedetails_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Platedetails_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Platedetails_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes on the plate at the time. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The status of the plate during this time period. */
  status?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Platedetails_Sum_Fields = {
  __typename?: 'platedetails_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "platedetails" */
export type Platedetails_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** update columns of table "platedetails" */
export enum Platedetails_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PlateId = 'plate_id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Platedetails_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Platedetails_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Platedetails_Set_Input>;
  /** filter the rows which have to be updated */
  where: Platedetails_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Platedetails_Var_Pop_Fields = {
  __typename?: 'platedetails_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "platedetails" */
export type Platedetails_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Platedetails_Var_Samp_Fields = {
  __typename?: 'platedetails_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "platedetails" */
export type Platedetails_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Platedetails_Variance_Fields = {
  __typename?: 'platedetails_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship ID to plates. */
  plate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "platedetails" */
export type Platedetails_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship ID to plates. */
  plate_id?: InputMaybe<Order_By>;
};

/** This table stores transporter license plate (drive-away plate) information and relates directly to a driver record. */
export type Plates = {
  __typename?: 'plates';
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** Notes on the status (Reason why it was lost?) */
  notes?: Maybe<Scalars['String']['output']>;
  /** License plate number. */
  plate_number: Scalars['String']['output'];
  /** License plate state. */
  plate_state: Scalars['String']['output'];
  /** An array relationship */
  platedetails: Array<Platedetails>;
  /** An aggregate relationship */
  platedetails_aggregate: Platedetails_Aggregate;
  /** Current status of the plate (unassigned | assigned | lost | destroyed). */
  status: Scalars['String']['output'];
  /** 3rd party toll management system token. */
  toll_management_id?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** This table stores transporter license plate (drive-away plate) information and relates directly to a driver record. */
export type PlatesPlatedetailsArgs = {
  distinct_on?: InputMaybe<Array<Platedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Platedetails_Order_By>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};


/** This table stores transporter license plate (drive-away plate) information and relates directly to a driver record. */
export type PlatesPlatedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Platedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Platedetails_Order_By>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};

/** aggregated selection of "plates" */
export type Plates_Aggregate = {
  __typename?: 'plates_aggregate';
  aggregate?: Maybe<Plates_Aggregate_Fields>;
  nodes: Array<Plates>;
};

/** aggregate fields of "plates" */
export type Plates_Aggregate_Fields = {
  __typename?: 'plates_aggregate_fields';
  avg?: Maybe<Plates_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Plates_Max_Fields>;
  min?: Maybe<Plates_Min_Fields>;
  stddev?: Maybe<Plates_Stddev_Fields>;
  stddev_pop?: Maybe<Plates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Plates_Stddev_Samp_Fields>;
  sum?: Maybe<Plates_Sum_Fields>;
  var_pop?: Maybe<Plates_Var_Pop_Fields>;
  var_samp?: Maybe<Plates_Var_Samp_Fields>;
  variance?: Maybe<Plates_Variance_Fields>;
};


/** aggregate fields of "plates" */
export type Plates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Plates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Plates_Avg_Fields = {
  __typename?: 'plates_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "plates". All fields are combined with a logical 'AND'. */
export type Plates_Bool_Exp = {
  _and?: InputMaybe<Array<Plates_Bool_Exp>>;
  _not?: InputMaybe<Plates_Bool_Exp>;
  _or?: InputMaybe<Array<Plates_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  plate_number?: InputMaybe<String_Comparison_Exp>;
  plate_state?: InputMaybe<String_Comparison_Exp>;
  platedetails?: InputMaybe<Platedetails_Bool_Exp>;
  platedetails_aggregate?: InputMaybe<Platedetails_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  toll_management_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "plates" */
export enum Plates_Constraint {
  /** unique or primary key constraint on columns "id" */
  PlatesPkey = 'plates_pkey',
  /** unique or primary key constraint on columns "plate_number" */
  PlatesPlateNumberKey = 'plates_plate_number_key'
}

/** input type for incrementing numeric columns in table "plates" */
export type Plates_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "plates" */
export type Plates_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes on the status (Reason why it was lost?) */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** License plate number. */
  plate_number?: InputMaybe<Scalars['String']['input']>;
  /** License plate state. */
  plate_state?: InputMaybe<Scalars['String']['input']>;
  platedetails?: InputMaybe<Platedetails_Arr_Rel_Insert_Input>;
  /** Current status of the plate (unassigned | assigned | lost | destroyed). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** 3rd party toll management system token. */
  toll_management_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Plates_Max_Fields = {
  __typename?: 'plates_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Notes on the status (Reason why it was lost?) */
  notes?: Maybe<Scalars['String']['output']>;
  /** License plate number. */
  plate_number?: Maybe<Scalars['String']['output']>;
  /** License plate state. */
  plate_state?: Maybe<Scalars['String']['output']>;
  /** Current status of the plate (unassigned | assigned | lost | destroyed). */
  status?: Maybe<Scalars['String']['output']>;
  /** 3rd party toll management system token. */
  toll_management_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Plates_Min_Fields = {
  __typename?: 'plates_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Notes on the status (Reason why it was lost?) */
  notes?: Maybe<Scalars['String']['output']>;
  /** License plate number. */
  plate_number?: Maybe<Scalars['String']['output']>;
  /** License plate state. */
  plate_state?: Maybe<Scalars['String']['output']>;
  /** Current status of the plate (unassigned | assigned | lost | destroyed). */
  status?: Maybe<Scalars['String']['output']>;
  /** 3rd party toll management system token. */
  toll_management_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "plates" */
export type Plates_Mutation_Response = {
  __typename?: 'plates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Plates>;
};

/** input type for inserting object relation for remote table "plates" */
export type Plates_Obj_Rel_Insert_Input = {
  data: Plates_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Plates_On_Conflict>;
};

/** on_conflict condition type for table "plates" */
export type Plates_On_Conflict = {
  constraint: Plates_Constraint;
  update_columns?: Array<Plates_Update_Column>;
  where?: InputMaybe<Plates_Bool_Exp>;
};

/** Ordering options when selecting data from "plates". */
export type Plates_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  plate_number?: InputMaybe<Order_By>;
  plate_state?: InputMaybe<Order_By>;
  platedetails_aggregate?: InputMaybe<Platedetails_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  toll_management_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: plates */
export type Plates_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "plates" */
export enum Plates_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PlateNumber = 'plate_number',
  /** column name */
  PlateState = 'plate_state',
  /** column name */
  Status = 'status',
  /** column name */
  TollManagementId = 'toll_management_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "plates" */
export type Plates_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes on the status (Reason why it was lost?) */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** License plate number. */
  plate_number?: InputMaybe<Scalars['String']['input']>;
  /** License plate state. */
  plate_state?: InputMaybe<Scalars['String']['input']>;
  /** Current status of the plate (unassigned | assigned | lost | destroyed). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** 3rd party toll management system token. */
  toll_management_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Plates_Stddev_Fields = {
  __typename?: 'plates_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Plates_Stddev_Pop_Fields = {
  __typename?: 'plates_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Plates_Stddev_Samp_Fields = {
  __typename?: 'plates_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "plates" */
export type Plates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Plates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Plates_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Notes on the status (Reason why it was lost?) */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** License plate number. */
  plate_number?: InputMaybe<Scalars['String']['input']>;
  /** License plate state. */
  plate_state?: InputMaybe<Scalars['String']['input']>;
  /** Current status of the plate (unassigned | assigned | lost | destroyed). */
  status?: InputMaybe<Scalars['String']['input']>;
  /** 3rd party toll management system token. */
  toll_management_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Plates_Sum_Fields = {
  __typename?: 'plates_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "plates" */
export enum Plates_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  PlateNumber = 'plate_number',
  /** column name */
  PlateState = 'plate_state',
  /** column name */
  Status = 'status',
  /** column name */
  TollManagementId = 'toll_management_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Plates_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Plates_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Plates_Set_Input>;
  /** filter the rows which have to be updated */
  where: Plates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Plates_Var_Pop_Fields = {
  __typename?: 'plates_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Plates_Var_Samp_Fields = {
  __typename?: 'plates_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Plates_Variance_Fields = {
  __typename?: 'plates_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Products on a specified customer contract. The contract is represented by an entry in the raterulesgroup table.. Only covers the time period that the raterulegroup is active. */
export type Productfees = {
  __typename?: 'productfees';
  active: Scalars['Boolean']['output'];
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: Maybe<Scalars['timestamp']['output']>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge: Scalars['numeric']['output'];
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost: Scalars['numeric']['output'];
  createdBy: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  product: Products;
  product_id: Scalars['bigint']['output'];
  rate_rule_group_id: Scalars['bigint']['output'];
  /** An object relationship */
  raterulegroup: Raterulegroups;
  updatedBy: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "productfees" */
export type Productfees_Aggregate = {
  __typename?: 'productfees_aggregate';
  aggregate?: Maybe<Productfees_Aggregate_Fields>;
  nodes: Array<Productfees>;
};

export type Productfees_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Productfees_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Productfees_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Productfees_Aggregate_Bool_Exp_Count>;
};

export type Productfees_Aggregate_Bool_Exp_Bool_And = {
  arguments: Productfees_Select_Column_Productfees_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Productfees_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Productfees_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Productfees_Select_Column_Productfees_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Productfees_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Productfees_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Productfees_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Productfees_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "productfees" */
export type Productfees_Aggregate_Fields = {
  __typename?: 'productfees_aggregate_fields';
  avg?: Maybe<Productfees_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Productfees_Max_Fields>;
  min?: Maybe<Productfees_Min_Fields>;
  stddev?: Maybe<Productfees_Stddev_Fields>;
  stddev_pop?: Maybe<Productfees_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Productfees_Stddev_Samp_Fields>;
  sum?: Maybe<Productfees_Sum_Fields>;
  var_pop?: Maybe<Productfees_Var_Pop_Fields>;
  var_samp?: Maybe<Productfees_Var_Samp_Fields>;
  variance?: Maybe<Productfees_Variance_Fields>;
};


/** aggregate fields of "productfees" */
export type Productfees_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Productfees_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "productfees" */
export type Productfees_Aggregate_Order_By = {
  avg?: InputMaybe<Productfees_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Productfees_Max_Order_By>;
  min?: InputMaybe<Productfees_Min_Order_By>;
  stddev?: InputMaybe<Productfees_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Productfees_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Productfees_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Productfees_Sum_Order_By>;
  var_pop?: InputMaybe<Productfees_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Productfees_Var_Samp_Order_By>;
  variance?: InputMaybe<Productfees_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "productfees" */
export type Productfees_Arr_Rel_Insert_Input = {
  data: Array<Productfees_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Productfees_On_Conflict>;
};

/** aggregate avg on columns */
export type Productfees_Avg_Fields = {
  __typename?: 'productfees_avg_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "productfees" */
export type Productfees_Avg_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "productfees". All fields are combined with a logical 'AND'. */
export type Productfees_Bool_Exp = {
  _and?: InputMaybe<Array<Productfees_Bool_Exp>>;
  _not?: InputMaybe<Productfees_Bool_Exp>;
  _or?: InputMaybe<Array<Productfees_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  billable_date?: InputMaybe<Timestamp_Comparison_Exp>;
  charge?: InputMaybe<Numeric_Comparison_Exp>;
  cost?: InputMaybe<Numeric_Comparison_Exp>;
  createdBy?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  product?: InputMaybe<Products_Bool_Exp>;
  product_id?: InputMaybe<Bigint_Comparison_Exp>;
  rate_rule_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  raterulegroup?: InputMaybe<Raterulegroups_Bool_Exp>;
  updatedBy?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "productfees" */
export enum Productfees_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProductFeesPkey = 'product_fees_pkey'
}

/** input type for incrementing numeric columns in table "productfees" */
export type Productfees_Inc_Input = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Scalars['numeric']['input']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  product_id?: InputMaybe<Scalars['bigint']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "productfees" */
export type Productfees_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Scalars['numeric']['input']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: InputMaybe<Scalars['String']['input']>;
  product?: InputMaybe<Products_Obj_Rel_Insert_Input>;
  product_id?: InputMaybe<Scalars['bigint']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  raterulegroup?: InputMaybe<Raterulegroups_Obj_Rel_Insert_Input>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Productfees_Max_Fields = {
  __typename?: 'productfees_max_fields';
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: Maybe<Scalars['timestamp']['output']>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['numeric']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['numeric']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: Maybe<Scalars['String']['output']>;
  product_id?: Maybe<Scalars['bigint']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "productfees" */
export type Productfees_Max_Order_By = {
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: InputMaybe<Order_By>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Productfees_Min_Fields = {
  __typename?: 'productfees_min_fields';
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: Maybe<Scalars['timestamp']['output']>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['numeric']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['numeric']['output']>;
  createdBy?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: Maybe<Scalars['String']['output']>;
  product_id?: Maybe<Scalars['bigint']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  updatedBy?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "productfees" */
export type Productfees_Min_Order_By = {
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: InputMaybe<Order_By>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "productfees" */
export type Productfees_Mutation_Response = {
  __typename?: 'productfees_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Productfees>;
};

/** on_conflict condition type for table "productfees" */
export type Productfees_On_Conflict = {
  constraint: Productfees_Constraint;
  update_columns?: Array<Productfees_Update_Column>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};

/** Ordering options when selecting data from "productfees". */
export type Productfees_Order_By = {
  active?: InputMaybe<Order_By>;
  billable_date?: InputMaybe<Order_By>;
  charge?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  product?: InputMaybe<Products_Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  raterulegroup?: InputMaybe<Raterulegroups_Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: productfees */
export type Productfees_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "productfees" */
export enum Productfees_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  BillableDate = 'billable_date',
  /** column name */
  Charge = 'charge',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  RateRuleGroupId = 'rate_rule_group_id',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "productfees_aggregate_bool_exp_bool_and_arguments_columns" columns of table "productfees" */
export enum Productfees_Select_Column_Productfees_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** select "productfees_aggregate_bool_exp_bool_or_arguments_columns" columns of table "productfees" */
export enum Productfees_Select_Column_Productfees_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** input type for updating data in table "productfees" */
export type Productfees_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Scalars['numeric']['input']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: InputMaybe<Scalars['String']['input']>;
  product_id?: InputMaybe<Scalars['bigint']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Productfees_Stddev_Fields = {
  __typename?: 'productfees_stddev_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "productfees" */
export type Productfees_Stddev_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Productfees_Stddev_Pop_Fields = {
  __typename?: 'productfees_stddev_pop_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "productfees" */
export type Productfees_Stddev_Pop_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Productfees_Stddev_Samp_Fields = {
  __typename?: 'productfees_stddev_samp_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "productfees" */
export type Productfees_Stddev_Samp_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "productfees" */
export type Productfees_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Productfees_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Productfees_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the customer will be charged for the product. Is used for products with a term of "once" */
  billable_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Scalars['numeric']['input']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Any additional information specific to this instance of the product. Will be entered by a user */
  notes?: InputMaybe<Scalars['String']['input']>;
  product_id?: InputMaybe<Scalars['bigint']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Productfees_Sum_Fields = {
  __typename?: 'productfees_sum_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['numeric']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  product_id?: Maybe<Scalars['bigint']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "productfees" */
export type Productfees_Sum_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** update columns of table "productfees" */
export enum Productfees_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  BillableDate = 'billable_date',
  /** column name */
  Charge = 'charge',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Notes = 'notes',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  RateRuleGroupId = 'rate_rule_group_id',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Productfees_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Productfees_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Productfees_Set_Input>;
  /** filter the rows which have to be updated */
  where: Productfees_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Productfees_Var_Pop_Fields = {
  __typename?: 'productfees_var_pop_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "productfees" */
export type Productfees_Var_Pop_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Productfees_Var_Samp_Fields = {
  __typename?: 'productfees_var_samp_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "productfees" */
export type Productfees_Var_Samp_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Productfees_Variance_Fields = {
  __typename?: 'productfees_variance_fields';
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: Maybe<Scalars['Float']['output']>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  product_id?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "productfees" */
export type Productfees_Variance_Order_By = {
  /** Amount charged to the customer. Setting this lower than the cost is equivalent to discounting the product */
  charge?: InputMaybe<Order_By>;
  /** Amount product is worth. A prepaid package with a cost of $1000 will cover $1000 worth of moves */
  cost?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** Products sold by HopDrive. Include moves, fees, prepaid packages, and one time fees. Each record also contains an accounting_id that matches with a product in quickbooks. */
export type Products = {
  __typename?: 'products';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Int']['output']>;
  active: Scalars['Boolean']['output'];
  /** The amount the product is worth */
  cost: Scalars['numeric']['output'];
  /** Who or what created this product */
  createdBy: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** Brief description of the product */
  description: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  name: Scalars['String']['output'];
  /** Prepaid products are charges that are paid up front and cover the costs of later purchases. Prepaid move packages are charged at the first of the month, and then offset the cost of a certain dollar amount of moves. Any product that covers the cost of another item purchased by the customer will be "prepaid: true"" */
  prepaid: Scalars['Boolean']['output'];
  /** An array relationship */
  productfees: Array<Productfees>;
  /** An aggregate relationship */
  productfees_aggregate: Productfees_Aggregate;
  /** Salable products are sold to the customer as part of their contract with Hopdrive and charged automatically to the customer.  Examples include prepaid packages, on-boarding fees, and services such as whitelabeling. Non-salable products inculde moves, processing fees, and accessorial charges; these are not sold up front to the customer but are applied as needed. */
  salable: Scalars['Boolean']['output'];
  /** How often the customer will be charged for the product. Options are: none, once, weekly, monthly. "None" means the product is not sold on a scheduled term but is instead purchased whenever needed */
  term: Scalars['String']['output'];
  /** Who or what updated this product */
  updatedBy: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** Products sold by HopDrive. Include moves, fees, prepaid packages, and one time fees. Each record also contains an accounting_id that matches with a product in quickbooks. */
export type ProductsProductfeesArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


/** Products sold by HopDrive. Include moves, fees, prepaid packages, and one time fees. Each record also contains an accounting_id that matches with a product in quickbooks. */
export type ProductsProductfees_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};

/** aggregated selection of "products" */
export type Products_Aggregate = {
  __typename?: 'products_aggregate';
  aggregate?: Maybe<Products_Aggregate_Fields>;
  nodes: Array<Products>;
};

/** aggregate fields of "products" */
export type Products_Aggregate_Fields = {
  __typename?: 'products_aggregate_fields';
  avg?: Maybe<Products_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Products_Max_Fields>;
  min?: Maybe<Products_Min_Fields>;
  stddev?: Maybe<Products_Stddev_Fields>;
  stddev_pop?: Maybe<Products_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Products_Stddev_Samp_Fields>;
  sum?: Maybe<Products_Sum_Fields>;
  var_pop?: Maybe<Products_Var_Pop_Fields>;
  var_samp?: Maybe<Products_Var_Samp_Fields>;
  variance?: Maybe<Products_Variance_Fields>;
};


/** aggregate fields of "products" */
export type Products_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Products_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Products_Avg_Fields = {
  __typename?: 'products_avg_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'. */
export type Products_Bool_Exp = {
  _and?: InputMaybe<Array<Products_Bool_Exp>>;
  _not?: InputMaybe<Products_Bool_Exp>;
  _or?: InputMaybe<Array<Products_Bool_Exp>>;
  accounting_id?: InputMaybe<Int_Comparison_Exp>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  cost?: InputMaybe<Numeric_Comparison_Exp>;
  createdBy?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  prepaid?: InputMaybe<Boolean_Comparison_Exp>;
  productfees?: InputMaybe<Productfees_Bool_Exp>;
  productfees_aggregate?: InputMaybe<Productfees_Aggregate_Bool_Exp>;
  salable?: InputMaybe<Boolean_Comparison_Exp>;
  term?: InputMaybe<String_Comparison_Exp>;
  updatedBy?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "products" */
export enum Products_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProductsPkey = 'Products_pkey'
}

/** input type for incrementing numeric columns in table "products" */
export type Products_Inc_Input = {
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: InputMaybe<Scalars['Int']['input']>;
  /** The amount the product is worth */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "products" */
export type Products_Insert_Input = {
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: InputMaybe<Scalars['Int']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The amount the product is worth */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Who or what created this product */
  createdBy?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Brief description of the product */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Prepaid products are charges that are paid up front and cover the costs of later purchases. Prepaid move packages are charged at the first of the month, and then offset the cost of a certain dollar amount of moves. Any product that covers the cost of another item purchased by the customer will be "prepaid: true"" */
  prepaid?: InputMaybe<Scalars['Boolean']['input']>;
  productfees?: InputMaybe<Productfees_Arr_Rel_Insert_Input>;
  /** Salable products are sold to the customer as part of their contract with Hopdrive and charged automatically to the customer.  Examples include prepaid packages, on-boarding fees, and services such as whitelabeling. Non-salable products inculde moves, processing fees, and accessorial charges; these are not sold up front to the customer but are applied as needed. */
  salable?: InputMaybe<Scalars['Boolean']['input']>;
  /** How often the customer will be charged for the product. Options are: none, once, weekly, monthly. "None" means the product is not sold on a scheduled term but is instead purchased whenever needed */
  term?: InputMaybe<Scalars['String']['input']>;
  /** Who or what updated this product */
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Products_Max_Fields = {
  __typename?: 'products_max_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Int']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['numeric']['output']>;
  /** Who or what created this product */
  createdBy?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Brief description of the product */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** How often the customer will be charged for the product. Options are: none, once, weekly, monthly. "None" means the product is not sold on a scheduled term but is instead purchased whenever needed */
  term?: Maybe<Scalars['String']['output']>;
  /** Who or what updated this product */
  updatedBy?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Products_Min_Fields = {
  __typename?: 'products_min_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Int']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['numeric']['output']>;
  /** Who or what created this product */
  createdBy?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Brief description of the product */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** How often the customer will be charged for the product. Options are: none, once, weekly, monthly. "None" means the product is not sold on a scheduled term but is instead purchased whenever needed */
  term?: Maybe<Scalars['String']['output']>;
  /** Who or what updated this product */
  updatedBy?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "products" */
export type Products_Mutation_Response = {
  __typename?: 'products_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Products>;
};

/** input type for inserting object relation for remote table "products" */
export type Products_Obj_Rel_Insert_Input = {
  data: Products_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Products_On_Conflict>;
};

/** on_conflict condition type for table "products" */
export type Products_On_Conflict = {
  constraint: Products_Constraint;
  update_columns?: Array<Products_Update_Column>;
  where?: InputMaybe<Products_Bool_Exp>;
};

/** Ordering options when selecting data from "products". */
export type Products_Order_By = {
  accounting_id?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  prepaid?: InputMaybe<Order_By>;
  productfees_aggregate?: InputMaybe<Productfees_Aggregate_Order_By>;
  salable?: InputMaybe<Order_By>;
  term?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: products */
export type Products_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "products" */
export enum Products_Select_Column {
  /** column name */
  AccountingId = 'accounting_id',
  /** column name */
  Active = 'active',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Prepaid = 'prepaid',
  /** column name */
  Salable = 'salable',
  /** column name */
  Term = 'term',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "products" */
export type Products_Set_Input = {
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: InputMaybe<Scalars['Int']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The amount the product is worth */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Who or what created this product */
  createdBy?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Brief description of the product */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Prepaid products are charges that are paid up front and cover the costs of later purchases. Prepaid move packages are charged at the first of the month, and then offset the cost of a certain dollar amount of moves. Any product that covers the cost of another item purchased by the customer will be "prepaid: true"" */
  prepaid?: InputMaybe<Scalars['Boolean']['input']>;
  /** Salable products are sold to the customer as part of their contract with Hopdrive and charged automatically to the customer.  Examples include prepaid packages, on-boarding fees, and services such as whitelabeling. Non-salable products inculde moves, processing fees, and accessorial charges; these are not sold up front to the customer but are applied as needed. */
  salable?: InputMaybe<Scalars['Boolean']['input']>;
  /** How often the customer will be charged for the product. Options are: none, once, weekly, monthly. "None" means the product is not sold on a scheduled term but is instead purchased whenever needed */
  term?: InputMaybe<Scalars['String']['input']>;
  /** Who or what updated this product */
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Products_Stddev_Fields = {
  __typename?: 'products_stddev_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Products_Stddev_Pop_Fields = {
  __typename?: 'products_stddev_pop_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Products_Stddev_Samp_Fields = {
  __typename?: 'products_stddev_samp_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "products" */
export type Products_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Products_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Products_Stream_Cursor_Value_Input = {
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: InputMaybe<Scalars['Int']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** The amount the product is worth */
  cost?: InputMaybe<Scalars['numeric']['input']>;
  /** Who or what created this product */
  createdBy?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Brief description of the product */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Prepaid products are charges that are paid up front and cover the costs of later purchases. Prepaid move packages are charged at the first of the month, and then offset the cost of a certain dollar amount of moves. Any product that covers the cost of another item purchased by the customer will be "prepaid: true"" */
  prepaid?: InputMaybe<Scalars['Boolean']['input']>;
  /** Salable products are sold to the customer as part of their contract with Hopdrive and charged automatically to the customer.  Examples include prepaid packages, on-boarding fees, and services such as whitelabeling. Non-salable products inculde moves, processing fees, and accessorial charges; these are not sold up front to the customer but are applied as needed. */
  salable?: InputMaybe<Scalars['Boolean']['input']>;
  /** How often the customer will be charged for the product. Options are: none, once, weekly, monthly. "None" means the product is not sold on a scheduled term but is instead purchased whenever needed */
  term?: InputMaybe<Scalars['String']['input']>;
  /** Who or what updated this product */
  updatedBy?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Products_Sum_Fields = {
  __typename?: 'products_sum_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Int']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "products" */
export enum Products_Update_Column {
  /** column name */
  AccountingId = 'accounting_id',
  /** column name */
  Active = 'active',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Prepaid = 'prepaid',
  /** column name */
  Salable = 'salable',
  /** column name */
  Term = 'term',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Products_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Products_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Products_Set_Input>;
  /** filter the rows which have to be updated */
  where: Products_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Products_Var_Pop_Fields = {
  __typename?: 'products_var_pop_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Products_Var_Samp_Fields = {
  __typename?: 'products_var_samp_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Products_Variance_Fields = {
  __typename?: 'products_variance_fields';
  /** Accounting id number (Quickbooks '"item_id") */
  accounting_id?: Maybe<Scalars['Float']['output']>;
  /** The amount the product is worth */
  cost?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "promos" */
export type Promos = {
  __typename?: 'promos';
  activation_date?: Maybe<Scalars['timestamptz']['output']>;
  active: Scalars['Boolean']['output'];
  config?: Maybe<Scalars['jsonb']['output']>;
  createdat: Scalars['timestamptz']['output'];
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['bigint']['output'];
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  rule: Businessrules;
  rule_id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
};


/** columns and relationships of "promos" */
export type PromosConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "promos" */
export type Promos_Aggregate = {
  __typename?: 'promos_aggregate';
  aggregate?: Maybe<Promos_Aggregate_Fields>;
  nodes: Array<Promos>;
};

/** aggregate fields of "promos" */
export type Promos_Aggregate_Fields = {
  __typename?: 'promos_aggregate_fields';
  avg?: Maybe<Promos_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Promos_Max_Fields>;
  min?: Maybe<Promos_Min_Fields>;
  stddev?: Maybe<Promos_Stddev_Fields>;
  stddev_pop?: Maybe<Promos_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Promos_Stddev_Samp_Fields>;
  sum?: Maybe<Promos_Sum_Fields>;
  var_pop?: Maybe<Promos_Var_Pop_Fields>;
  var_samp?: Maybe<Promos_Var_Samp_Fields>;
  variance?: Maybe<Promos_Variance_Fields>;
};


/** aggregate fields of "promos" */
export type Promos_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Promos_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Promos_Append_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Promos_Avg_Fields = {
  __typename?: 'promos_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "promos". All fields are combined with a logical 'AND'. */
export type Promos_Bool_Exp = {
  _and?: InputMaybe<Array<Promos_Bool_Exp>>;
  _not?: InputMaybe<Promos_Bool_Exp>;
  _or?: InputMaybe<Array<Promos_Bool_Exp>>;
  activation_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  expiration_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  rule?: InputMaybe<Businessrules_Bool_Exp>;
  rule_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "promos" */
export enum Promos_Constraint {
  /** unique or primary key constraint on columns "id" */
  PromosPkey = 'promos_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Promos_Delete_At_Path_Input = {
  config?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Promos_Delete_Elem_Input = {
  config?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Promos_Delete_Key_Input = {
  config?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "promos" */
export type Promos_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  rule_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "promos" */
export type Promos_Insert_Input = {
  activation_date?: InputMaybe<Scalars['timestamptz']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  rule?: InputMaybe<Businessrules_Obj_Rel_Insert_Input>;
  rule_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Promos_Max_Fields = {
  __typename?: 'promos_max_fields';
  activation_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  rule_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Promos_Min_Fields = {
  __typename?: 'promos_min_fields';
  activation_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  rule_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "promos" */
export type Promos_Mutation_Response = {
  __typename?: 'promos_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Promos>;
};

/** on_conflict condition type for table "promos" */
export type Promos_On_Conflict = {
  constraint: Promos_Constraint;
  update_columns?: Array<Promos_Update_Column>;
  where?: InputMaybe<Promos_Bool_Exp>;
};

/** Ordering options when selecting data from "promos". */
export type Promos_Order_By = {
  activation_date?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  expiration_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  rule?: InputMaybe<Businessrules_Order_By>;
  rule_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: promos */
export type Promos_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Promos_Prepend_Input = {
  config?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "promos" */
export enum Promos_Select_Column {
  /** column name */
  ActivationDate = 'activation_date',
  /** column name */
  Active = 'active',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  RuleId = 'rule_id',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "promos" */
export type Promos_Set_Input = {
  activation_date?: InputMaybe<Scalars['timestamptz']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  rule_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Promos_Stddev_Fields = {
  __typename?: 'promos_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Promos_Stddev_Pop_Fields = {
  __typename?: 'promos_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Promos_Stddev_Samp_Fields = {
  __typename?: 'promos_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "promos" */
export type Promos_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Promos_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Promos_Stream_Cursor_Value_Input = {
  activation_date?: InputMaybe<Scalars['timestamptz']['input']>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  rule_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Promos_Sum_Fields = {
  __typename?: 'promos_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  rule_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "promos" */
export enum Promos_Update_Column {
  /** column name */
  ActivationDate = 'activation_date',
  /** column name */
  Active = 'active',
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  RuleId = 'rule_id',
  /** column name */
  Updatedat = 'updatedat'
}

export type Promos_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Promos_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Promos_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Promos_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Promos_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Promos_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Promos_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Promos_Set_Input>;
  /** filter the rows which have to be updated */
  where: Promos_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Promos_Var_Pop_Fields = {
  __typename?: 'promos_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Promos_Var_Samp_Fields = {
  __typename?: 'promos_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Promos_Variance_Fields = {
  __typename?: 'promos_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  rule_id?: Maybe<Scalars['Float']['output']>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** An array relationship */
  accessorials: Array<Accessorials>;
  /** An aggregate relationship */
  accessorials_aggregate: Accessorials_Aggregate;
  /** fetch data from the table: "accessorials" using primary key columns */
  accessorials_by_pk?: Maybe<Accessorials>;
  /** fetch data from the table: "accessorialstoalgorithms" */
  accessorialstoalgorithms: Array<Accessorialstoalgorithms>;
  /** fetch aggregated fields from the table: "accessorialstoalgorithms" */
  accessorialstoalgorithms_aggregate: Accessorialstoalgorithms_Aggregate;
  /** fetch data from the table: "accessorialstoalgorithms" using primary key columns */
  accessorialstoalgorithms_by_pk?: Maybe<Accessorialstoalgorithms>;
  /** fetch data from the table: "actiontypes" */
  actiontypes: Array<Actiontypes>;
  /** fetch aggregated fields from the table: "actiontypes" */
  actiontypes_aggregate: Actiontypes_Aggregate;
  /** fetch data from the table: "actiontypes" using primary key columns */
  actiontypes_by_pk?: Maybe<Actiontypes>;
  /** fetch data from the table: "activetimes" */
  activetimes: Array<Activetimes>;
  /** fetch aggregated fields from the table: "activetimes" */
  activetimes_aggregate: Activetimes_Aggregate;
  /** fetch data from the table: "activetimes" using primary key columns */
  activetimes_by_pk?: Maybe<Activetimes>;
  /** fetch data from the table: "algorithms" */
  algorithms: Array<Algorithms>;
  /** fetch aggregated fields from the table: "algorithms" */
  algorithms_aggregate: Algorithms_Aggregate;
  /** fetch data from the table: "algorithms" using primary key columns */
  algorithms_by_pk?: Maybe<Algorithms>;
  /** An array relationship */
  apcharges: Array<Apcharges>;
  /** An aggregate relationship */
  apcharges_aggregate: Apcharges_Aggregate;
  /** fetch data from the table: "apcharges" using primary key columns */
  apcharges_by_pk?: Maybe<Apcharges>;
  /** An array relationship */
  appayments: Array<Appayments>;
  /** An aggregate relationship */
  appayments_aggregate: Appayments_Aggregate;
  /** fetch data from the table: "appayments" using primary key columns */
  appayments_by_pk?: Maybe<Appayments>;
  /** fetch data from the table: "appointments" */
  appointments: Array<Appointments>;
  /** fetch aggregated fields from the table: "appointments" */
  appointments_aggregate: Appointments_Aggregate;
  /** fetch data from the table: "appointments" using primary key columns */
  appointments_by_pk?: Maybe<Appointments>;
  /** fetch data from the table: "appraisal_vehicles" */
  appraisal_vehicles: Array<Appraisal_Vehicles>;
  /** fetch aggregated fields from the table: "appraisal_vehicles" */
  appraisal_vehicles_aggregate: Appraisal_Vehicles_Aggregate;
  /** fetch data from the table: "appraisals" */
  appraisals: Array<Appraisals>;
  /** fetch aggregated fields from the table: "appraisals" */
  appraisals_aggregate: Appraisals_Aggregate;
  /** fetch data from the table: "appraisals" using primary key columns */
  appraisals_by_pk?: Maybe<Appraisals>;
  /** fetch data from the table: "arevents" */
  arevents: Array<Arevents>;
  /** fetch aggregated fields from the table: "arevents" */
  arevents_aggregate: Arevents_Aggregate;
  /** fetch data from the table: "arevents" using primary key columns */
  arevents_by_pk?: Maybe<Arevents>;
  /** fetch data from the table: "arinvoices" */
  arinvoices: Array<Arinvoices>;
  /** fetch aggregated fields from the table: "arinvoices" */
  arinvoices_aggregate: Arinvoices_Aggregate;
  /** fetch data from the table: "arinvoices" using primary key columns */
  arinvoices_by_pk?: Maybe<Arinvoices>;
  /** An array relationship */
  armovedetails: Array<Armovedetails>;
  /** An aggregate relationship */
  armovedetails_aggregate: Armovedetails_Aggregate;
  /** fetch data from the table: "armovedetails" using primary key columns */
  armovedetails_by_pk?: Maybe<Armovedetails>;
  /** An array relationship */
  armovedetailshistory: Array<Armovedetailshistory>;
  /** An aggregate relationship */
  armovedetailshistory_aggregate: Armovedetailshistory_Aggregate;
  /** fetch data from the table: "armovedetailshistory" using primary key columns */
  armovedetailshistory_by_pk?: Maybe<Armovedetailshistory>;
  /** An array relationship */
  armoves: Array<Armoves>;
  /** An aggregate relationship */
  armoves_aggregate: Armoves_Aggregate;
  /** fetch data from the table: "armoves" using primary key columns */
  armoves_by_pk?: Maybe<Armoves>;
  /** fetch data from the table: "armoveshistory" */
  armoveshistory: Array<Armoveshistory>;
  /** fetch aggregated fields from the table: "armoveshistory" */
  armoveshistory_aggregate: Armoveshistory_Aggregate;
  /** fetch data from the table: "armoveshistory" using primary key columns */
  armoveshistory_by_pk?: Maybe<Armoveshistory>;
  /** fetch data from the table: "arpaymentdetails" */
  arpaymentdetails: Array<Arpaymentdetails>;
  /** fetch aggregated fields from the table: "arpaymentdetails" */
  arpaymentdetails_aggregate: Arpaymentdetails_Aggregate;
  /** fetch data from the table: "arpaymentdetails" using primary key columns */
  arpaymentdetails_by_pk?: Maybe<Arpaymentdetails>;
  /** fetch data from the table: "arpaymentmethods" */
  arpaymentmethods: Array<Arpaymentmethods>;
  /** fetch aggregated fields from the table: "arpaymentmethods" */
  arpaymentmethods_aggregate: Arpaymentmethods_Aggregate;
  /** fetch data from the table: "arpaymentmethods" using primary key columns */
  arpaymentmethods_by_pk?: Maybe<Arpaymentmethods>;
  /** An array relationship */
  arpayments: Array<Arpayments>;
  /** An aggregate relationship */
  arpayments_aggregate: Arpayments_Aggregate;
  /** fetch data from the table: "arpayments" using primary key columns */
  arpayments_by_pk?: Maybe<Arpayments>;
  /** fetch data from the table: "arpriceoverrides" */
  arpriceoverrides: Array<Arpriceoverrides>;
  /** fetch aggregated fields from the table: "arpriceoverrides" */
  arpriceoverrides_aggregate: Arpriceoverrides_Aggregate;
  /** fetch data from the table: "arpriceoverrides" using primary key columns */
  arpriceoverrides_by_pk?: Maybe<Arpriceoverrides>;
  /** fetch data from the table: "authkeys" */
  authkeys: Array<Authkeys>;
  /** fetch aggregated fields from the table: "authkeys" */
  authkeys_aggregate: Authkeys_Aggregate;
  /** fetch data from the table: "authkeys" using primary key columns */
  authkeys_by_pk?: Maybe<Authkeys>;
  /** fetch data from the table: "authorizations" */
  authorizations: Array<Authorizations>;
  /** fetch aggregated fields from the table: "authorizations" */
  authorizations_aggregate: Authorizations_Aggregate;
  /** fetch data from the table: "authorizations" using primary key columns */
  authorizations_by_pk?: Maybe<Authorizations>;
  /** fetch data from the table: "batch_jobs" */
  batch_jobs: Array<Batch_Jobs>;
  /** fetch aggregated fields from the table: "batch_jobs" */
  batch_jobs_aggregate: Batch_Jobs_Aggregate;
  /** fetch data from the table: "batch_jobs" using primary key columns */
  batch_jobs_by_pk?: Maybe<Batch_Jobs>;
  /** An array relationship */
  bundles: Array<Bundles>;
  /** An aggregate relationship */
  bundles_aggregate: Bundles_Aggregate;
  /** fetch data from the table: "bundles" using primary key columns */
  bundles_by_pk?: Maybe<Bundles>;
  /** fetch data from the table: "bundlesets" */
  bundlesets: Array<Bundlesets>;
  /** fetch aggregated fields from the table: "bundlesets" */
  bundlesets_aggregate: Bundlesets_Aggregate;
  /** fetch data from the table: "bundlesets" using primary key columns */
  bundlesets_by_pk?: Maybe<Bundlesets>;
  /** An array relationship */
  bundletoscenarios: Array<Bundletoscenarios>;
  /** An aggregate relationship */
  bundletoscenarios_aggregate: Bundletoscenarios_Aggregate;
  /** fetch data from the table: "bundletoscenarios" using primary key columns */
  bundletoscenarios_by_pk?: Maybe<Bundletoscenarios>;
  /** An array relationship */
  businesshours: Array<Businesshours>;
  /** An aggregate relationship */
  businesshours_aggregate: Businesshours_Aggregate;
  /** fetch data from the table: "businesshours" using primary key columns */
  businesshours_by_pk?: Maybe<Businesshours>;
  /** An array relationship */
  businessrules: Array<Businessrules>;
  /** An aggregate relationship */
  businessrules_aggregate: Businessrules_Aggregate;
  /** fetch data from the table: "businessrules" using primary key columns */
  businessrules_by_pk?: Maybe<Businessrules>;
  /** fetch data from the table: "businessruletypes" */
  businessruletypes: Array<Businessruletypes>;
  /** fetch aggregated fields from the table: "businessruletypes" */
  businessruletypes_aggregate: Businessruletypes_Aggregate;
  /** fetch data from the table: "businessruletypes" using primary key columns */
  businessruletypes_by_pk?: Maybe<Businessruletypes>;
  /** fetch data from the table: "certifications" */
  certifications: Array<Certifications>;
  /** fetch aggregated fields from the table: "certifications" */
  certifications_aggregate: Certifications_Aggregate;
  /** fetch data from the table: "certifications" using primary key columns */
  certifications_by_pk?: Maybe<Certifications>;
  /** fetch data from the table: "chasevehicles" */
  chasevehicles: Array<Chasevehicles>;
  /** fetch aggregated fields from the table: "chasevehicles" */
  chasevehicles_aggregate: Chasevehicles_Aggregate;
  /** fetch data from the table: "chasevehicles" using primary key columns */
  chasevehicles_by_pk?: Maybe<Chasevehicles>;
  /** fetch data from the table: "chasevehiclesassigned" */
  chasevehiclesassigned: Array<Chasevehiclesassigned>;
  /** fetch aggregated fields from the table: "chasevehiclesassigned" */
  chasevehiclesassigned_aggregate: Chasevehiclesassigned_Aggregate;
  /** fetch data from the table: "chasevehiclesassigned" using primary key columns */
  chasevehiclesassigned_by_pk?: Maybe<Chasevehiclesassigned>;
  /** fetch data from the table: "consumer_numbers" */
  consumer_numbers: Array<Consumer_Numbers>;
  /** fetch aggregated fields from the table: "consumer_numbers" */
  consumer_numbers_aggregate: Consumer_Numbers_Aggregate;
  /** fetch data from the table: "consumer_numbers" using primary key columns */
  consumer_numbers_by_pk?: Maybe<Consumer_Numbers>;
  /** fetch data from the table: "coordinatedplans" */
  coordinatedplans: Array<Coordinatedplans>;
  /** fetch aggregated fields from the table: "coordinatedplans" */
  coordinatedplans_aggregate: Coordinatedplans_Aggregate;
  /** fetch data from the table: "coordinatedplans" using primary key columns */
  coordinatedplans_by_pk?: Maybe<Coordinatedplans>;
  /** fetch data from the table: "coordinatedplantoscenarios" */
  coordinatedplantoscenarios: Array<Coordinatedplantoscenarios>;
  /** fetch aggregated fields from the table: "coordinatedplantoscenarios" */
  coordinatedplantoscenarios_aggregate: Coordinatedplantoscenarios_Aggregate;
  /** fetch data from the table: "coordinatedplantoscenarios" using primary key columns */
  coordinatedplantoscenarios_by_pk?: Maybe<Coordinatedplantoscenarios>;
  /** An array relationship */
  customers: Array<Customers>;
  /** An aggregate relationship */
  customers_aggregate: Customers_Aggregate;
  /** fetch data from the table: "customers" using primary key columns */
  customers_by_pk?: Maybe<Customers>;
  /** fetch data from the table: "customerstocertifications" */
  customerstocertifications: Array<Customerstocertifications>;
  /** fetch aggregated fields from the table: "customerstocertifications" */
  customerstocertifications_aggregate: Customerstocertifications_Aggregate;
  /** fetch data from the table: "customerstocertifications" using primary key columns */
  customerstocertifications_by_pk?: Maybe<Customerstocertifications>;
  /** fetch data from the table: "dealer_viewable_admin_info" */
  dealer_viewable_admin_info: Array<Dealer_Viewable_Admin_Info>;
  /** fetch aggregated fields from the table: "dealer_viewable_admin_info" */
  dealer_viewable_admin_info_aggregate: Dealer_Viewable_Admin_Info_Aggregate;
  /** fetch data from the table: "dealer_viewable_driver_info" */
  dealer_viewable_driver_info: Array<Dealer_Viewable_Driver_Info>;
  /** fetch aggregated fields from the table: "dealer_viewable_driver_info" */
  dealer_viewable_driver_info_aggregate: Dealer_Viewable_Driver_Info_Aggregate;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documents_aggregate: Documents_Aggregate;
  /** fetch data from the table: "documents" using primary key columns */
  documents_by_pk?: Maybe<Documents>;
  /** fetch data from the table: "driver_pay_by_move" */
  driver_pay_by_move: Array<Driver_Pay_By_Move>;
  /** fetch aggregated fields from the table: "driver_pay_by_move" */
  driver_pay_by_move_aggregate: Driver_Pay_By_Move_Aggregate;
  /** fetch data from the table: "driverappconfig" */
  driverappconfig: Array<Driverappconfig>;
  /** fetch aggregated fields from the table: "driverappconfig" */
  driverappconfig_aggregate: Driverappconfig_Aggregate;
  /** fetch data from the table: "driverappconfig" using primary key columns */
  driverappconfig_by_pk?: Maybe<Driverappconfig>;
  /** fetch data from the table: "driverblacklist" */
  driverblacklist: Array<Driverblacklist>;
  /** fetch aggregated fields from the table: "driverblacklist" */
  driverblacklist_aggregate: Driverblacklist_Aggregate;
  /** fetch data from the table: "driverblacklist" using primary key columns */
  driverblacklist_by_pk?: Maybe<Driverblacklist>;
  /** fetch data from the table: "driverdetails" */
  driverdetails: Array<Driverdetails>;
  /** fetch aggregated fields from the table: "driverdetails" */
  driverdetails_aggregate: Driverdetails_Aggregate;
  /** fetch data from the table: "driverdetails" using primary key columns */
  driverdetails_by_pk?: Maybe<Driverdetails>;
  /** An array relationship */
  driverequipment: Array<Driverequipment>;
  /** An aggregate relationship */
  driverequipment_aggregate: Driverequipment_Aggregate;
  /** fetch data from the table: "driverequipment" using primary key columns */
  driverequipment_by_pk?: Maybe<Driverequipment>;
  /** fetch data from the table: "driverlocations" */
  driverlocations: Array<Driverlocations>;
  /** fetch aggregated fields from the table: "driverlocations" */
  driverlocations_aggregate: Driverlocations_Aggregate;
  /** An array relationship */
  driverpayouts: Array<Driverpayouts>;
  /** An aggregate relationship */
  driverpayouts_aggregate: Driverpayouts_Aggregate;
  /** fetch data from the table: "driverpayouts" using primary key columns */
  driverpayouts_by_pk?: Maybe<Driverpayouts>;
  /** fetch data from the table: "driverpays" */
  driverpays: Array<Driverpays>;
  /** fetch aggregated fields from the table: "driverpays" */
  driverpays_aggregate: Driverpays_Aggregate;
  /** fetch data from the table: "driverpays" using primary key columns */
  driverpays_by_pk?: Maybe<Driverpays>;
  /** fetch data from the table: "drivers" */
  drivers: Array<Drivers>;
  /** fetch aggregated fields from the table: "drivers" */
  drivers_aggregate: Drivers_Aggregate;
  /** fetch data from the table: "drivers" using primary key columns */
  drivers_by_pk?: Maybe<Drivers>;
  /** fetch data from the table: "driverscheduledetails" */
  driverscheduledetails: Array<Driverscheduledetails>;
  /** fetch aggregated fields from the table: "driverscheduledetails" */
  driverscheduledetails_aggregate: Driverscheduledetails_Aggregate;
  /** fetch data from the table: "driverscheduledetails" using primary key columns */
  driverscheduledetails_by_pk?: Maybe<Driverscheduledetails>;
  /** fetch data from the table: "driverschedules" */
  driverschedules: Array<Driverschedules>;
  /** fetch aggregated fields from the table: "driverschedules" */
  driverschedules_aggregate: Driverschedules_Aggregate;
  /** fetch data from the table: "driverschedules" using primary key columns */
  driverschedules_by_pk?: Maybe<Driverschedules>;
  /** fetch data from the table: "driversinridegroupbymoveid" */
  driversinridegroupbymoveid: Array<Driversinridegroupbymoveid>;
  /** fetch aggregated fields from the table: "driversinridegroupbymoveid" */
  driversinridegroupbymoveid_aggregate: Driversinridegroupbymoveid_Aggregate;
  /** fetch data from the table: "driverstocertifications" */
  driverstocertifications: Array<Driverstocertifications>;
  /** fetch aggregated fields from the table: "driverstocertifications" */
  driverstocertifications_aggregate: Driverstocertifications_Aggregate;
  /** fetch data from the table: "driverstocertifications" using primary key columns */
  driverstocertifications_by_pk?: Maybe<Driverstocertifications>;
  /** fetch data from the table: "driverstousecasesoptout" */
  driverstousecasesoptout: Array<Driverstousecasesoptout>;
  /** fetch aggregated fields from the table: "driverstousecasesoptout" */
  driverstousecasesoptout_aggregate: Driverstousecasesoptout_Aggregate;
  /** fetch data from the table: "driverstousecasesoptout" using primary key columns */
  driverstousecasesoptout_by_pk?: Maybe<Driverstousecasesoptout>;
  /** fetch data from the table: "email_events" */
  email_events: Array<Email_Events>;
  /** fetch aggregated fields from the table: "email_events" */
  email_events_aggregate: Email_Events_Aggregate;
  /** fetch data from the table: "email_events" using primary key columns */
  email_events_by_pk?: Maybe<Email_Events>;
  /** fetch data from the table: "equipment" */
  equipment: Array<Equipment>;
  /** fetch aggregated fields from the table: "equipment" */
  equipment_aggregate: Equipment_Aggregate;
  /** fetch data from the table: "equipment" using primary key columns */
  equipment_by_pk?: Maybe<Equipment>;
  /** An array relationship */
  event_executions: Array<Event_Executions>;
  /** An aggregate relationship */
  event_executions_aggregate: Event_Executions_Aggregate;
  /** fetch data from the table: "event_executions" using primary key columns */
  event_executions_by_pk?: Maybe<Event_Executions>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  /** fetch data from the table: "eventlogs" using primary key columns */
  eventlogs_by_pk?: Maybe<Eventlogs>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  events_aggregate: Events_Aggregate;
  /** fetch data from the table: "events" using primary key columns */
  events_by_pk?: Maybe<Events>;
  /** fetch data from the table: "faqs" */
  faqs: Array<Faqs>;
  /** fetch aggregated fields from the table: "faqs" */
  faqs_aggregate: Faqs_Aggregate;
  /** fetch data from the table: "faqs" using primary key columns */
  faqs_by_pk?: Maybe<Faqs>;
  /** An array relationship */
  favoritelanes: Array<Favoritelanes>;
  /** An aggregate relationship */
  favoritelanes_aggregate: Favoritelanes_Aggregate;
  /** fetch data from the table: "favoritelanes" using primary key columns */
  favoritelanes_by_pk?: Maybe<Favoritelanes>;
  /** An array relationship */
  favoritelocations: Array<Favoritelocations>;
  /** An aggregate relationship */
  favoritelocations_aggregate: Favoritelocations_Aggregate;
  /** fetch data from the table: "favoritelocations" using primary key columns */
  favoritelocations_by_pk?: Maybe<Favoritelocations>;
  /** fetch data from the table: "features" */
  features: Array<Features>;
  /** fetch aggregated fields from the table: "features" */
  features_aggregate: Features_Aggregate;
  /** fetch data from the table: "features" using primary key columns */
  features_by_pk?: Maybe<Features>;
  /** fetch data from the table: "fuelprices" */
  fuelprices: Array<Fuelprices>;
  /** fetch aggregated fields from the table: "fuelprices" */
  fuelprices_aggregate: Fuelprices_Aggregate;
  /** fetch data from the table: "fuelprices" using primary key columns */
  fuelprices_by_pk?: Maybe<Fuelprices>;
  /** An array relationship */
  groupable_moves: Array<Groupable_Moves>;
  /** An aggregate relationship */
  groupable_moves_aggregate: Groupable_Moves_Aggregate;
  /** An array relationship */
  hangtags: Array<Hangtags>;
  /** An aggregate relationship */
  hangtags_aggregate: Hangtags_Aggregate;
  /** fetch data from the table: "hangtags" using primary key columns */
  hangtags_by_pk?: Maybe<Hangtags>;
  /** fetch data from the table: "insurancerates" */
  insurancerates: Array<Insurancerates>;
  /** fetch aggregated fields from the table: "insurancerates" */
  insurancerates_aggregate: Insurancerates_Aggregate;
  /** fetch data from the table: "insurancerates" using primary key columns */
  insurancerates_by_pk?: Maybe<Insurancerates>;
  /** fetch data from the table: "invocations" */
  invocations: Array<Invocations>;
  /** fetch aggregated fields from the table: "invocations" */
  invocations_aggregate: Invocations_Aggregate;
  /** fetch data from the table: "invocations" using primary key columns */
  invocations_by_pk?: Maybe<Invocations>;
  /** An array relationship */
  job_executions: Array<Job_Executions>;
  /** An aggregate relationship */
  job_executions_aggregate: Job_Executions_Aggregate;
  /** fetch data from the table: "job_executions" using primary key columns */
  job_executions_by_pk?: Maybe<Job_Executions>;
  /** fetch data from the table: "lanemodifiers" */
  lanemodifiers: Array<Lanemodifiers>;
  /** fetch aggregated fields from the table: "lanemodifiers" */
  lanemodifiers_aggregate: Lanemodifiers_Aggregate;
  /** fetch data from the table: "lanemodifiers" using primary key columns */
  lanemodifiers_by_pk?: Maybe<Lanemodifiers>;
  /** An array relationship */
  lanes: Array<Lanes>;
  /** An aggregate relationship */
  lanes_aggregate: Lanes_Aggregate;
  /** fetch data from the table: "lanes" using primary key columns */
  lanes_by_pk?: Maybe<Lanes>;
  /** An array relationship */
  locations: Array<Locations>;
  /** An aggregate relationship */
  locations_aggregate: Locations_Aggregate;
  /** fetch data from the table: "locations" using primary key columns */
  locations_by_pk?: Maybe<Locations>;
  /** An array relationship */
  locationstocertifications: Array<Locationstocertifications>;
  /** An aggregate relationship */
  locationstocertifications_aggregate: Locationstocertifications_Aggregate;
  /** fetch data from the table: "locationstocertifications" using primary key columns */
  locationstocertifications_by_pk?: Maybe<Locationstocertifications>;
  /** fetch data from the table: "lyftrideattempts" */
  lyftrideattempts: Array<Lyftrideattempts>;
  /** fetch aggregated fields from the table: "lyftrideattempts" */
  lyftrideattempts_aggregate: Lyftrideattempts_Aggregate;
  /** fetch data from the table: "lyftrideattempts" using primary key columns */
  lyftrideattempts_by_pk?: Maybe<Lyftrideattempts>;
  /** An array relationship */
  lyftrides: Array<Lyftrides>;
  /** An aggregate relationship */
  lyftrides_aggregate: Lyftrides_Aggregate;
  /** fetch data from the table: "lyftrides" using primary key columns */
  lyftrides_by_pk?: Maybe<Lyftrides>;
  /** fetch data from the table: "metrics_hourly" */
  metrics_hourly: Array<Metrics_Hourly>;
  /** fetch aggregated fields from the table: "metrics_hourly" */
  metrics_hourly_aggregate: Metrics_Hourly_Aggregate;
  /** fetch data from the table: "metrics_hourly" using primary key columns */
  metrics_hourly_by_pk?: Maybe<Metrics_Hourly>;
  /** fetch data from the table: "move_counts_by_customer" */
  move_counts_by_customer: Array<Move_Counts_By_Customer>;
  /** fetch aggregated fields from the table: "move_counts_by_customer" */
  move_counts_by_customer_aggregate: Move_Counts_By_Customer_Aggregate;
  /** fetch data from the table: "move_pricing" */
  move_pricing: Array<Move_Pricing>;
  /** fetch aggregated fields from the table: "move_pricing" */
  move_pricing_aggregate: Move_Pricing_Aggregate;
  /** fetch data from the table: "move_raterule" */
  move_raterule: Array<Move_Raterule>;
  /** fetch aggregated fields from the table: "move_raterule" */
  move_raterule_aggregate: Move_Raterule_Aggregate;
  /** fetch data from the table: "moveaudit" */
  moveaudit: Array<Moveaudit>;
  /** fetch aggregated fields from the table: "moveaudit" */
  moveaudit_aggregate: Moveaudit_Aggregate;
  /** fetch data from the table: "moveaudit" using primary key columns */
  moveaudit_by_pk?: Maybe<Moveaudit>;
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** fetch data from the table: "moves" using primary key columns */
  moves_by_pk?: Maybe<Moves>;
  /** fetch data from the table: "notifications" */
  notifications: Array<Notifications>;
  /** fetch aggregated fields from the table: "notifications" */
  notifications_aggregate: Notifications_Aggregate;
  /** fetch data from the table: "notifications" using primary key columns */
  notifications_by_pk?: Maybe<Notifications>;
  /** An array relationship */
  offers: Array<Offers>;
  /** An aggregate relationship */
  offers_aggregate: Offers_Aggregate;
  /** fetch data from the table: "offers" using primary key columns */
  offers_by_pk?: Maybe<Offers>;
  /** fetch data from the table: "organizations" */
  organizations: Array<Organizations>;
  /** fetch aggregated fields from the table: "organizations" */
  organizations_aggregate: Organizations_Aggregate;
  /** fetch data from the table: "organizations" using primary key columns */
  organizations_by_pk?: Maybe<Organizations>;
  /** An array relationship */
  organizationstocertifications: Array<Organizationstocertifications>;
  /** An aggregate relationship */
  organizationstocertifications_aggregate: Organizationstocertifications_Aggregate;
  /** fetch data from the table: "organizationstocertifications" using primary key columns */
  organizationstocertifications_by_pk?: Maybe<Organizationstocertifications>;
  /** fetch data from the table: "pay_periods_by_driver" */
  pay_periods_by_driver: Array<Pay_Periods_By_Driver>;
  /** fetch aggregated fields from the table: "pay_periods_by_driver" */
  pay_periods_by_driver_aggregate: Pay_Periods_By_Driver_Aggregate;
  /** fetch data from the table: "paycycles" */
  paycycles: Array<Paycycles>;
  /** fetch aggregated fields from the table: "paycycles" */
  paycycles_aggregate: Paycycles_Aggregate;
  /** fetch data from the table: "paycycles" using primary key columns */
  paycycles_by_pk?: Maybe<Paycycles>;
  /** fetch data from the table: "paycycletodrivertodocuments" */
  paycycletodrivertodocuments: Array<Paycycletodrivertodocuments>;
  /** fetch aggregated fields from the table: "paycycletodrivertodocuments" */
  paycycletodrivertodocuments_aggregate: Paycycletodrivertodocuments_Aggregate;
  /** fetch data from the table: "paycycletodrivertodocuments" using primary key columns */
  paycycletodrivertodocuments_by_pk?: Maybe<Paycycletodrivertodocuments>;
  /** fetch data from the table: "payertocustomer" */
  payertocustomer: Array<Payertocustomer>;
  /** fetch aggregated fields from the table: "payertocustomer" */
  payertocustomer_aggregate: Payertocustomer_Aggregate;
  /** fetch data from the table: "payertocustomer" using primary key columns */
  payertocustomer_by_pk?: Maybe<Payertocustomer>;
  /** fetch data from the table: "payrategroups" */
  payrategroups: Array<Payrategroups>;
  /** fetch aggregated fields from the table: "payrategroups" */
  payrategroups_aggregate: Payrategroups_Aggregate;
  /** fetch data from the table: "payrategroups" using primary key columns */
  payrategroups_by_pk?: Maybe<Payrategroups>;
  /** An array relationship */
  payraterules: Array<Payraterules>;
  /** An aggregate relationship */
  payraterules_aggregate: Payraterules_Aggregate;
  /** fetch data from the table: "payraterules" using primary key columns */
  payraterules_by_pk?: Maybe<Payraterules>;
  /** An array relationship */
  plans: Array<Plans>;
  /** An aggregate relationship */
  plans_aggregate: Plans_Aggregate;
  /** fetch data from the table: "plans" using primary key columns */
  plans_by_pk?: Maybe<Plans>;
  /** An array relationship */
  platedetails: Array<Platedetails>;
  /** An aggregate relationship */
  platedetails_aggregate: Platedetails_Aggregate;
  /** fetch data from the table: "platedetails" using primary key columns */
  platedetails_by_pk?: Maybe<Platedetails>;
  /** fetch data from the table: "plates" */
  plates: Array<Plates>;
  /** fetch aggregated fields from the table: "plates" */
  plates_aggregate: Plates_Aggregate;
  /** fetch data from the table: "plates" using primary key columns */
  plates_by_pk?: Maybe<Plates>;
  /** An array relationship */
  productfees: Array<Productfees>;
  /** An aggregate relationship */
  productfees_aggregate: Productfees_Aggregate;
  /** fetch data from the table: "productfees" using primary key columns */
  productfees_by_pk?: Maybe<Productfees>;
  /** fetch data from the table: "products" */
  products: Array<Products>;
  /** fetch aggregated fields from the table: "products" */
  products_aggregate: Products_Aggregate;
  /** fetch data from the table: "products" using primary key columns */
  products_by_pk?: Maybe<Products>;
  /** fetch data from the table: "promos" */
  promos: Array<Promos>;
  /** fetch aggregated fields from the table: "promos" */
  promos_aggregate: Promos_Aggregate;
  /** fetch data from the table: "promos" using primary key columns */
  promos_by_pk?: Maybe<Promos>;
  /** An array relationship */
  raterulegroups: Array<Raterulegroups>;
  /** An aggregate relationship */
  raterulegroups_aggregate: Raterulegroups_Aggregate;
  /** fetch data from the table: "raterulegroups" using primary key columns */
  raterulegroups_by_pk?: Maybe<Raterulegroups>;
  /** An array relationship */
  raterules: Array<Raterules>;
  /** An aggregate relationship */
  raterules_aggregate: Raterules_Aggregate;
  /** fetch data from the table: "raterules" using primary key columns */
  raterules_by_pk?: Maybe<Raterules>;
  /** fetch data from the table: "regions" */
  regions: Array<Regions>;
  /** fetch aggregated fields from the table: "regions" */
  regions_aggregate: Regions_Aggregate;
  /** fetch data from the table: "regions" using primary key columns */
  regions_by_pk?: Maybe<Regions>;
  /** fetch data from the table: "ridegroups" */
  ridegroups: Array<Ridegroups>;
  /** fetch aggregated fields from the table: "ridegroups" */
  ridegroups_aggregate: Ridegroups_Aggregate;
  /** fetch data from the table: "ridegroups" using primary key columns */
  ridegroups_by_pk?: Maybe<Ridegroups>;
  /** fetch data from the table: "ridesharefares" */
  ridesharefares: Array<Ridesharefares>;
  /** fetch aggregated fields from the table: "ridesharefares" */
  ridesharefares_aggregate: Ridesharefares_Aggregate;
  /** fetch data from the table: "ridesharefares" using primary key columns */
  ridesharefares_by_pk?: Maybe<Ridesharefares>;
  /** An array relationship */
  ridesharerates: Array<Ridesharerates>;
  /** An aggregate relationship */
  ridesharerates_aggregate: Ridesharerates_Aggregate;
  /** fetch data from the table: "ridesharerates" using primary key columns */
  ridesharerates_by_pk?: Maybe<Ridesharerates>;
  /** fetch data from the table: "rideshareratetoridesharefares" */
  rideshareratetoridesharefares: Array<Rideshareratetoridesharefares>;
  /** fetch aggregated fields from the table: "rideshareratetoridesharefares" */
  rideshareratetoridesharefares_aggregate: Rideshareratetoridesharefares_Aggregate;
  /** fetch data from the table: "rideshareratetoridesharefares" using primary key columns */
  rideshareratetoridesharefares_by_pk?: Maybe<Rideshareratetoridesharefares>;
  /** fetch data from the table: "roletypes" */
  roletypes: Array<Roletypes>;
  /** fetch aggregated fields from the table: "roletypes" */
  roletypes_aggregate: Roletypes_Aggregate;
  /** fetch data from the table: "roletypes" using primary key columns */
  roletypes_by_pk?: Maybe<Roletypes>;
  /** An array relationship */
  scenarios: Array<Scenarios>;
  /** An aggregate relationship */
  scenarios_aggregate: Scenarios_Aggregate;
  /** fetch data from the table: "scenarios" using primary key columns */
  scenarios_by_pk?: Maybe<Scenarios>;
  /** An array relationship */
  scenariotomoves: Array<Scenariotomoves>;
  /** An aggregate relationship */
  scenariotomoves_aggregate: Scenariotomoves_Aggregate;
  /** fetch data from the table: "scenariotomoves" using primary key columns */
  scenariotomoves_by_pk?: Maybe<Scenariotomoves>;
  /** An array relationship */
  scenariotypes: Array<Scenariotypes>;
  /** An aggregate relationship */
  scenariotypes_aggregate: Scenariotypes_Aggregate;
  /** fetch data from the table: "scenariotypes" using primary key columns */
  scenariotypes_by_pk?: Maybe<Scenariotypes>;
  /** An array relationship */
  scenariotypestocertifications: Array<Scenariotypestocertifications>;
  /** An aggregate relationship */
  scenariotypestocertifications_aggregate: Scenariotypestocertifications_Aggregate;
  /** fetch data from the table: "scenariotypestocertifications" using primary key columns */
  scenariotypestocertifications_by_pk?: Maybe<Scenariotypestocertifications>;
  /** fetch data from the table: "sequelizemeta" */
  sequelizemeta: Array<Sequelizemeta>;
  /** fetch aggregated fields from the table: "sequelizemeta" */
  sequelizemeta_aggregate: Sequelizemeta_Aggregate;
  /** fetch data from the table: "sequelizemeta" using primary key columns */
  sequelizemeta_by_pk?: Maybe<Sequelizemeta>;
  /** fetch data from the table: "slas" */
  slas: Array<Slas>;
  /** fetch aggregated fields from the table: "slas" */
  slas_aggregate: Slas_Aggregate;
  /** fetch data from the table: "slas" using primary key columns */
  slas_by_pk?: Maybe<Slas>;
  /** fetch data from the table: "slas_to_raterulegroups" */
  slas_to_raterulegroups: Array<Slas_To_Raterulegroups>;
  /** fetch aggregated fields from the table: "slas_to_raterulegroups" */
  slas_to_raterulegroups_aggregate: Slas_To_Raterulegroups_Aggregate;
  /** fetch data from the table: "slas_to_raterulegroups" using primary key columns */
  slas_to_raterulegroups_by_pk?: Maybe<Slas_To_Raterulegroups>;
  /** An array relationship */
  smsmedia: Array<Smsmedia>;
  /** An aggregate relationship */
  smsmedia_aggregate: Smsmedia_Aggregate;
  /** fetch data from the table: "smsmedia" using primary key columns */
  smsmedia_by_pk?: Maybe<Smsmedia>;
  /** An array relationship */
  smsmessages: Array<Smsmessages>;
  /** An aggregate relationship */
  smsmessages_aggregate: Smsmessages_Aggregate;
  /** fetch data from the table: "smsmessages" using primary key columns */
  smsmessages_by_pk?: Maybe<Smsmessages>;
  /** fetch data from the table: "smstemplates" */
  smstemplates: Array<Smstemplates>;
  /** fetch aggregated fields from the table: "smstemplates" */
  smstemplates_aggregate: Smstemplates_Aggregate;
  /** fetch data from the table: "smstemplates" using primary key columns */
  smstemplates_by_pk?: Maybe<Smstemplates>;
  /** An array relationship */
  subscriptions: Array<Subscriptions>;
  /** An aggregate relationship */
  subscriptions_aggregate: Subscriptions_Aggregate;
  /** fetch data from the table: "subscriptions" using primary key columns */
  subscriptions_by_pk?: Maybe<Subscriptions>;
  /** fetch data from the table: "templates" */
  templates: Array<Templates>;
  /** fetch aggregated fields from the table: "templates" */
  templates_aggregate: Templates_Aggregate;
  /** fetch data from the table: "templates" using primary key columns */
  templates_by_pk?: Maybe<Templates>;
  /** An array relationship */
  trips: Array<Trips>;
  /** An aggregate relationship */
  trips_aggregate: Trips_Aggregate;
  /** fetch data from the table: "trips" using primary key columns */
  trips_by_pk?: Maybe<Trips>;
  /** fetch data from the table: "usecases" */
  usecases: Array<Usecases>;
  /** fetch aggregated fields from the table: "usecases" */
  usecases_aggregate: Usecases_Aggregate;
  /** fetch data from the table: "usecases" using primary key columns */
  usecases_by_pk?: Maybe<Usecases>;
  /** An array relationship */
  usecasetocertifications: Array<Usecasetocertifications>;
  /** An aggregate relationship */
  usecasetocertifications_aggregate: Usecasetocertifications_Aggregate;
  /** fetch data from the table: "usecasetocertifications" using primary key columns */
  usecasetocertifications_by_pk?: Maybe<Usecasetocertifications>;
  /** fetch data from the table: "usereventlogs" */
  usereventlogs: Array<Usereventlogs>;
  /** fetch aggregated fields from the table: "usereventlogs" */
  usereventlogs_aggregate: Usereventlogs_Aggregate;
  /** fetch data from the table: "usereventlogs" using primary key columns */
  usereventlogs_by_pk?: Maybe<Usereventlogs>;
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table: "usertocustomers" */
  usertocustomers: Array<Usertocustomers>;
  /** fetch aggregated fields from the table: "usertocustomers" */
  usertocustomers_aggregate: Usertocustomers_Aggregate;
  /** fetch data from the table: "usertocustomers" using primary key columns */
  usertocustomers_by_pk?: Maybe<Usertocustomers>;
  /** fetch data from the table: "usertofeatures" */
  usertofeatures: Array<Usertofeatures>;
  /** fetch aggregated fields from the table: "usertofeatures" */
  usertofeatures_aggregate: Usertofeatures_Aggregate;
  /** fetch data from the table: "usertofeatures" using primary key columns */
  usertofeatures_by_pk?: Maybe<Usertofeatures>;
  /** fetch data from the table: "usertoregions" */
  usertoregions: Array<Usertoregions>;
  /** fetch aggregated fields from the table: "usertoregions" */
  usertoregions_aggregate: Usertoregions_Aggregate;
  /** fetch data from the table: "usertoregions" using primary key columns */
  usertoregions_by_pk?: Maybe<Usertoregions>;
  /** fetch data from the table: "usertoroles" */
  usertoroles: Array<Usertoroles>;
  /** fetch aggregated fields from the table: "usertoroles" */
  usertoroles_aggregate: Usertoroles_Aggregate;
  /** fetch data from the table: "usertoroles" using primary key columns */
  usertoroles_by_pk?: Maybe<Usertoroles>;
  /** fetch data from the table: "vehiclemakes" */
  vehiclemakes: Array<Vehiclemakes>;
  /** fetch aggregated fields from the table: "vehiclemakes" */
  vehiclemakes_aggregate: Vehiclemakes_Aggregate;
  /** fetch data from the table: "vehiclemakes" using primary key columns */
  vehiclemakes_by_pk?: Maybe<Vehiclemakes>;
  /** An array relationship */
  vehiclemodels: Array<Vehiclemodels>;
  /** An aggregate relationship */
  vehiclemodels_aggregate: Vehiclemodels_Aggregate;
  /** fetch data from the table: "vehiclemodels" using primary key columns */
  vehiclemodels_by_pk?: Maybe<Vehiclemodels>;
  /** An array relationship */
  vehiclephotos: Array<Vehiclephotos>;
  /** An aggregate relationship */
  vehiclephotos_aggregate: Vehiclephotos_Aggregate;
  /** fetch data from the table: "vehiclephotos" using primary key columns */
  vehiclephotos_by_pk?: Maybe<Vehiclephotos>;
  /** fetch data from the table: "vehicles" */
  vehicles: Array<Vehicles>;
  /** fetch aggregated fields from the table: "vehicles" */
  vehicles_aggregate: Vehicles_Aggregate;
  /** fetch data from the table: "vehicles" using primary key columns */
  vehicles_by_pk?: Maybe<Vehicles>;
  /** An array relationship */
  webhook_events: Array<Webhook_Events>;
  /** An aggregate relationship */
  webhook_events_aggregate: Webhook_Events_Aggregate;
  /** fetch data from the table: "webhook_events" using primary key columns */
  webhook_events_by_pk?: Maybe<Webhook_Events>;
  /** fetch data from the table: "workflows" */
  workflows: Array<Workflows>;
  /** fetch aggregated fields from the table: "workflows" */
  workflows_aggregate: Workflows_Aggregate;
  /** fetch data from the table: "workflows" using primary key columns */
  workflows_by_pk?: Maybe<Workflows>;
  /** An array relationship */
  workflowsets: Array<Workflowsets>;
  /** An aggregate relationship */
  workflowsets_aggregate: Workflowsets_Aggregate;
  /** fetch data from the table: "workflowsets" using primary key columns */
  workflowsets_by_pk?: Maybe<Workflowsets>;
  /** An array relationship */
  workflowsettypes: Array<Workflowsettypes>;
  /** An aggregate relationship */
  workflowsettypes_aggregate: Workflowsettypes_Aggregate;
  /** fetch data from the table: "workflowsettypes" using primary key columns */
  workflowsettypes_by_pk?: Maybe<Workflowsettypes>;
  /** fetch data from the table: "workflowsettypestocertifications" */
  workflowsettypestocertifications: Array<Workflowsettypestocertifications>;
  /** fetch aggregated fields from the table: "workflowsettypestocertifications" */
  workflowsettypestocertifications_aggregate: Workflowsettypestocertifications_Aggregate;
  /** fetch data from the table: "workflowsettypestocertifications" using primary key columns */
  workflowsettypestocertifications_by_pk?: Maybe<Workflowsettypestocertifications>;
};


export type Query_RootAccessorialsArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


export type Query_RootAccessorials_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


export type Query_RootAccessorials_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAccessorialstoalgorithmsArgs = {
  distinct_on?: InputMaybe<Array<Accessorialstoalgorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorialstoalgorithms_Order_By>>;
  where?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
};


export type Query_RootAccessorialstoalgorithms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorialstoalgorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorialstoalgorithms_Order_By>>;
  where?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
};


export type Query_RootAccessorialstoalgorithms_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootActiontypesArgs = {
  distinct_on?: InputMaybe<Array<Actiontypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Actiontypes_Order_By>>;
  where?: InputMaybe<Actiontypes_Bool_Exp>;
};


export type Query_RootActiontypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Actiontypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Actiontypes_Order_By>>;
  where?: InputMaybe<Actiontypes_Bool_Exp>;
};


export type Query_RootActiontypes_By_PkArgs = {
  id: Scalars['smallint']['input'];
};


export type Query_RootActivetimesArgs = {
  distinct_on?: InputMaybe<Array<Activetimes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Activetimes_Order_By>>;
  where?: InputMaybe<Activetimes_Bool_Exp>;
};


export type Query_RootActivetimes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Activetimes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Activetimes_Order_By>>;
  where?: InputMaybe<Activetimes_Bool_Exp>;
};


export type Query_RootActivetimes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAlgorithmsArgs = {
  distinct_on?: InputMaybe<Array<Algorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Algorithms_Order_By>>;
  where?: InputMaybe<Algorithms_Bool_Exp>;
};


export type Query_RootAlgorithms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Algorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Algorithms_Order_By>>;
  where?: InputMaybe<Algorithms_Bool_Exp>;
};


export type Query_RootAlgorithms_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootApchargesArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


export type Query_RootApcharges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


export type Query_RootApcharges_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAppaymentsArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


export type Query_RootAppayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


export type Query_RootAppayments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAppointmentsArgs = {
  distinct_on?: InputMaybe<Array<Appointments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appointments_Order_By>>;
  where?: InputMaybe<Appointments_Bool_Exp>;
};


export type Query_RootAppointments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appointments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appointments_Order_By>>;
  where?: InputMaybe<Appointments_Bool_Exp>;
};


export type Query_RootAppointments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAppraisal_VehiclesArgs = {
  distinct_on?: InputMaybe<Array<Appraisal_Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisal_Vehicles_Order_By>>;
  where?: InputMaybe<Appraisal_Vehicles_Bool_Exp>;
};


export type Query_RootAppraisal_Vehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appraisal_Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisal_Vehicles_Order_By>>;
  where?: InputMaybe<Appraisal_Vehicles_Bool_Exp>;
};


export type Query_RootAppraisalsArgs = {
  distinct_on?: InputMaybe<Array<Appraisals_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisals_Order_By>>;
  where?: InputMaybe<Appraisals_Bool_Exp>;
};


export type Query_RootAppraisals_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appraisals_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisals_Order_By>>;
  where?: InputMaybe<Appraisals_Bool_Exp>;
};


export type Query_RootAppraisals_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAreventsArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


export type Query_RootArevents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


export type Query_RootArevents_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArinvoicesArgs = {
  distinct_on?: InputMaybe<Array<Arinvoices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arinvoices_Order_By>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


export type Query_RootArinvoices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arinvoices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arinvoices_Order_By>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


export type Query_RootArinvoices_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArmovedetailsArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


export type Query_RootArmovedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


export type Query_RootArmovedetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArmovedetailshistoryArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


export type Query_RootArmovedetailshistory_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


export type Query_RootArmovedetailshistory_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArmovesArgs = {
  distinct_on?: InputMaybe<Array<Armoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoves_Order_By>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


export type Query_RootArmoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoves_Order_By>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


export type Query_RootArmoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArmoveshistoryArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


export type Query_RootArmoveshistory_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


export type Query_RootArmoveshistory_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArpaymentdetailsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


export type Query_RootArpaymentdetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


export type Query_RootArpaymentdetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArpaymentmethodsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentmethods_Order_By>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


export type Query_RootArpaymentmethods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentmethods_Order_By>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


export type Query_RootArpaymentmethods_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArpaymentsArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


export type Query_RootArpayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


export type Query_RootArpayments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootArpriceoverridesArgs = {
  distinct_on?: InputMaybe<Array<Arpriceoverrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpriceoverrides_Order_By>>;
  where?: InputMaybe<Arpriceoverrides_Bool_Exp>;
};


export type Query_RootArpriceoverrides_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpriceoverrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpriceoverrides_Order_By>>;
  where?: InputMaybe<Arpriceoverrides_Bool_Exp>;
};


export type Query_RootArpriceoverrides_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAuthkeysArgs = {
  distinct_on?: InputMaybe<Array<Authkeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authkeys_Order_By>>;
  where?: InputMaybe<Authkeys_Bool_Exp>;
};


export type Query_RootAuthkeys_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Authkeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authkeys_Order_By>>;
  where?: InputMaybe<Authkeys_Bool_Exp>;
};


export type Query_RootAuthkeys_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootAuthorizationsArgs = {
  distinct_on?: InputMaybe<Array<Authorizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authorizations_Order_By>>;
  where?: InputMaybe<Authorizations_Bool_Exp>;
};


export type Query_RootAuthorizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Authorizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authorizations_Order_By>>;
  where?: InputMaybe<Authorizations_Bool_Exp>;
};


export type Query_RootAuthorizations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBatch_JobsArgs = {
  distinct_on?: InputMaybe<Array<Batch_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Batch_Jobs_Order_By>>;
  where?: InputMaybe<Batch_Jobs_Bool_Exp>;
};


export type Query_RootBatch_Jobs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Batch_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Batch_Jobs_Order_By>>;
  where?: InputMaybe<Batch_Jobs_Bool_Exp>;
};


export type Query_RootBatch_Jobs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBundlesArgs = {
  distinct_on?: InputMaybe<Array<Bundles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundles_Order_By>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


export type Query_RootBundles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundles_Order_By>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


export type Query_RootBundles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBundlesetsArgs = {
  distinct_on?: InputMaybe<Array<Bundlesets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundlesets_Order_By>>;
  where?: InputMaybe<Bundlesets_Bool_Exp>;
};


export type Query_RootBundlesets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundlesets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundlesets_Order_By>>;
  where?: InputMaybe<Bundlesets_Bool_Exp>;
};


export type Query_RootBundlesets_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBundletoscenariosArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


export type Query_RootBundletoscenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


export type Query_RootBundletoscenarios_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBusinesshoursArgs = {
  distinct_on?: InputMaybe<Array<Businesshours_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businesshours_Order_By>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


export type Query_RootBusinesshours_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businesshours_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businesshours_Order_By>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


export type Query_RootBusinesshours_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBusinessrulesArgs = {
  distinct_on?: InputMaybe<Array<Businessrules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessrules_Order_By>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};


export type Query_RootBusinessrules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businessrules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessrules_Order_By>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};


export type Query_RootBusinessrules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootBusinessruletypesArgs = {
  distinct_on?: InputMaybe<Array<Businessruletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessruletypes_Order_By>>;
  where?: InputMaybe<Businessruletypes_Bool_Exp>;
};


export type Query_RootBusinessruletypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businessruletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessruletypes_Order_By>>;
  where?: InputMaybe<Businessruletypes_Bool_Exp>;
};


export type Query_RootBusinessruletypes_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCertificationsArgs = {
  distinct_on?: InputMaybe<Array<Certifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Certifications_Order_By>>;
  where?: InputMaybe<Certifications_Bool_Exp>;
};


export type Query_RootCertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Certifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Certifications_Order_By>>;
  where?: InputMaybe<Certifications_Bool_Exp>;
};


export type Query_RootCertifications_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Query_RootChasevehiclesArgs = {
  distinct_on?: InputMaybe<Array<Chasevehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehicles_Order_By>>;
  where?: InputMaybe<Chasevehicles_Bool_Exp>;
};


export type Query_RootChasevehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chasevehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehicles_Order_By>>;
  where?: InputMaybe<Chasevehicles_Bool_Exp>;
};


export type Query_RootChasevehicles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootChasevehiclesassignedArgs = {
  distinct_on?: InputMaybe<Array<Chasevehiclesassigned_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehiclesassigned_Order_By>>;
  where?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
};


export type Query_RootChasevehiclesassigned_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chasevehiclesassigned_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehiclesassigned_Order_By>>;
  where?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
};


export type Query_RootChasevehiclesassigned_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootConsumer_NumbersArgs = {
  distinct_on?: InputMaybe<Array<Consumer_Numbers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Consumer_Numbers_Order_By>>;
  where?: InputMaybe<Consumer_Numbers_Bool_Exp>;
};


export type Query_RootConsumer_Numbers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Consumer_Numbers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Consumer_Numbers_Order_By>>;
  where?: InputMaybe<Consumer_Numbers_Bool_Exp>;
};


export type Query_RootConsumer_Numbers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootCoordinatedplansArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplans_Order_By>>;
  where?: InputMaybe<Coordinatedplans_Bool_Exp>;
};


export type Query_RootCoordinatedplans_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplans_Order_By>>;
  where?: InputMaybe<Coordinatedplans_Bool_Exp>;
};


export type Query_RootCoordinatedplans_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootCoordinatedplantoscenariosArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


export type Query_RootCoordinatedplantoscenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


export type Query_RootCoordinatedplantoscenarios_By_PkArgs = {
  coordinatedplan_id: Scalars['bigint']['input'];
  scenario_id: Scalars['bigint']['input'];
};


export type Query_RootCustomersArgs = {
  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customers_Order_By>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


export type Query_RootCustomers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customers_Order_By>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


export type Query_RootCustomers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootCustomerstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customerstocertifications_Order_By>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


export type Query_RootCustomerstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customerstocertifications_Order_By>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


export type Query_RootCustomerstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  customer_id: Scalars['bigint']['input'];
};


export type Query_RootDealer_Viewable_Admin_InfoArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Admin_Info_Bool_Exp>;
};


export type Query_RootDealer_Viewable_Admin_Info_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Admin_Info_Bool_Exp>;
};


export type Query_RootDealer_Viewable_Driver_InfoArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Driver_Info_Bool_Exp>;
};


export type Query_RootDealer_Viewable_Driver_Info_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Driver_Info_Bool_Exp>;
};


export type Query_RootDocumentsArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


export type Query_RootDocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


export type Query_RootDocuments_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootDriver_Pay_By_MoveArgs = {
  distinct_on?: InputMaybe<Array<Driver_Pay_By_Move_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Pay_By_Move_Order_By>>;
  where?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
};


export type Query_RootDriver_Pay_By_Move_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Pay_By_Move_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Pay_By_Move_Order_By>>;
  where?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
};


export type Query_RootDriverappconfigArgs = {
  distinct_on?: InputMaybe<Array<Driverappconfig_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverappconfig_Order_By>>;
  where?: InputMaybe<Driverappconfig_Bool_Exp>;
};


export type Query_RootDriverappconfig_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverappconfig_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverappconfig_Order_By>>;
  where?: InputMaybe<Driverappconfig_Bool_Exp>;
};


export type Query_RootDriverappconfig_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootDriverblacklistArgs = {
  distinct_on?: InputMaybe<Array<Driverblacklist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverblacklist_Order_By>>;
  where?: InputMaybe<Driverblacklist_Bool_Exp>;
};


export type Query_RootDriverblacklist_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverblacklist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverblacklist_Order_By>>;
  where?: InputMaybe<Driverblacklist_Bool_Exp>;
};


export type Query_RootDriverblacklist_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriverdetailsArgs = {
  distinct_on?: InputMaybe<Array<Driverdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverdetails_Order_By>>;
  where?: InputMaybe<Driverdetails_Bool_Exp>;
};


export type Query_RootDriverdetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverdetails_Order_By>>;
  where?: InputMaybe<Driverdetails_Bool_Exp>;
};


export type Query_RootDriverdetails_By_PkArgs = {
  driver_id: Scalars['bigint']['input'];
};


export type Query_RootDriverequipmentArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


export type Query_RootDriverequipment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


export type Query_RootDriverequipment_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriverlocationsArgs = {
  distinct_on?: InputMaybe<Array<Driverlocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverlocations_Order_By>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


export type Query_RootDriverlocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverlocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverlocations_Order_By>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


export type Query_RootDriverpayoutsArgs = {
  distinct_on?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpayouts_Order_By>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


export type Query_RootDriverpayouts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpayouts_Order_By>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


export type Query_RootDriverpayouts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriverpaysArgs = {
  distinct_on?: InputMaybe<Array<Driverpays_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpays_Order_By>>;
  where?: InputMaybe<Driverpays_Bool_Exp>;
};


export type Query_RootDriverpays_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverpays_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpays_Order_By>>;
  where?: InputMaybe<Driverpays_Bool_Exp>;
};


export type Query_RootDriverpays_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriversArgs = {
  distinct_on?: InputMaybe<Array<Drivers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Drivers_Order_By>>;
  where?: InputMaybe<Drivers_Bool_Exp>;
};


export type Query_RootDrivers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Drivers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Drivers_Order_By>>;
  where?: InputMaybe<Drivers_Bool_Exp>;
};


export type Query_RootDrivers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriverscheduledetailsArgs = {
  distinct_on?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverscheduledetails_Order_By>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};


export type Query_RootDriverscheduledetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverscheduledetails_Order_By>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};


export type Query_RootDriverscheduledetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriverschedulesArgs = {
  distinct_on?: InputMaybe<Array<Driverschedules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverschedules_Order_By>>;
  where?: InputMaybe<Driverschedules_Bool_Exp>;
};


export type Query_RootDriverschedules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverschedules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverschedules_Order_By>>;
  where?: InputMaybe<Driverschedules_Bool_Exp>;
};


export type Query_RootDriverschedules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootDriversinridegroupbymoveidArgs = {
  distinct_on?: InputMaybe<Array<Driversinridegroupbymoveid_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driversinridegroupbymoveid_Order_By>>;
  where?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
};


export type Query_RootDriversinridegroupbymoveid_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driversinridegroupbymoveid_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driversinridegroupbymoveid_Order_By>>;
  where?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
};


export type Query_RootDriverstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


export type Query_RootDriverstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


export type Query_RootDriverstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  driver_id: Scalars['bigint']['input'];
  effective_date: Scalars['timestamptz']['input'];
};


export type Query_RootDriverstousecasesoptoutArgs = {
  distinct_on?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstousecasesoptout_Order_By>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


export type Query_RootDriverstousecasesoptout_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstousecasesoptout_Order_By>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


export type Query_RootDriverstousecasesoptout_By_PkArgs = {
  driver_id: Scalars['bigint']['input'];
  usecase_key: Scalars['String']['input'];
};


export type Query_RootEmail_EventsArgs = {
  distinct_on?: InputMaybe<Array<Email_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Email_Events_Order_By>>;
  where?: InputMaybe<Email_Events_Bool_Exp>;
};


export type Query_RootEmail_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Email_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Email_Events_Order_By>>;
  where?: InputMaybe<Email_Events_Bool_Exp>;
};


export type Query_RootEmail_Events_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootEquipmentArgs = {
  distinct_on?: InputMaybe<Array<Equipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Equipment_Order_By>>;
  where?: InputMaybe<Equipment_Bool_Exp>;
};


export type Query_RootEquipment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Equipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Equipment_Order_By>>;
  where?: InputMaybe<Equipment_Bool_Exp>;
};


export type Query_RootEquipment_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootEvent_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Event_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Event_Executions_Order_By>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


export type Query_RootEvent_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Event_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Event_Executions_Order_By>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


export type Query_RootEvent_Executions_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


export type Query_RootEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


export type Query_RootEventlogs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootEventsArgs = {
  distinct_on?: InputMaybe<Array<Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Events_Order_By>>;
  where?: InputMaybe<Events_Bool_Exp>;
};


export type Query_RootEvents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Events_Order_By>>;
  where?: InputMaybe<Events_Bool_Exp>;
};


export type Query_RootEvents_By_PkArgs = {
  eventid: Scalars['String']['input'];
};


export type Query_RootFaqsArgs = {
  distinct_on?: InputMaybe<Array<Faqs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faqs_Order_By>>;
  where?: InputMaybe<Faqs_Bool_Exp>;
};


export type Query_RootFaqs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faqs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faqs_Order_By>>;
  where?: InputMaybe<Faqs_Bool_Exp>;
};


export type Query_RootFaqs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootFavoritelanesArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


export type Query_RootFavoritelanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


export type Query_RootFavoritelanes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootFavoritelocationsArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


export type Query_RootFavoritelocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


export type Query_RootFavoritelocations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootFeaturesArgs = {
  distinct_on?: InputMaybe<Array<Features_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Features_Order_By>>;
  where?: InputMaybe<Features_Bool_Exp>;
};


export type Query_RootFeatures_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Features_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Features_Order_By>>;
  where?: InputMaybe<Features_Bool_Exp>;
};


export type Query_RootFeatures_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootFuelpricesArgs = {
  distinct_on?: InputMaybe<Array<Fuelprices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fuelprices_Order_By>>;
  where?: InputMaybe<Fuelprices_Bool_Exp>;
};


export type Query_RootFuelprices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fuelprices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fuelprices_Order_By>>;
  where?: InputMaybe<Fuelprices_Bool_Exp>;
};


export type Query_RootFuelprices_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootGroupable_MovesArgs = {
  distinct_on?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Groupable_Moves_Order_By>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


export type Query_RootGroupable_Moves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Groupable_Moves_Order_By>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


export type Query_RootHangtagsArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


export type Query_RootHangtags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


export type Query_RootHangtags_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootInsuranceratesArgs = {
  distinct_on?: InputMaybe<Array<Insurancerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Insurancerates_Order_By>>;
  where?: InputMaybe<Insurancerates_Bool_Exp>;
};


export type Query_RootInsurancerates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Insurancerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Insurancerates_Order_By>>;
  where?: InputMaybe<Insurancerates_Bool_Exp>;
};


export type Query_RootInsurancerates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootInvocationsArgs = {
  distinct_on?: InputMaybe<Array<Invocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Invocations_Order_By>>;
  where?: InputMaybe<Invocations_Bool_Exp>;
};


export type Query_RootInvocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Invocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Invocations_Order_By>>;
  where?: InputMaybe<Invocations_Bool_Exp>;
};


export type Query_RootInvocations_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootJob_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


export type Query_RootJob_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


export type Query_RootJob_Executions_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootLanemodifiersArgs = {
  distinct_on?: InputMaybe<Array<Lanemodifiers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanemodifiers_Order_By>>;
  where?: InputMaybe<Lanemodifiers_Bool_Exp>;
};


export type Query_RootLanemodifiers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanemodifiers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanemodifiers_Order_By>>;
  where?: InputMaybe<Lanemodifiers_Bool_Exp>;
};


export type Query_RootLanemodifiers_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootLanesArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


export type Query_RootLanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


export type Query_RootLanes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootLocationsArgs = {
  distinct_on?: InputMaybe<Array<Locations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locations_Order_By>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


export type Query_RootLocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locations_Order_By>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


export type Query_RootLocations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootLocationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


export type Query_RootLocationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


export type Query_RootLocationstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  location_id: Scalars['bigint']['input'];
};


export type Query_RootLyftrideattemptsArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


export type Query_RootLyftrideattempts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


export type Query_RootLyftrideattempts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootLyftridesArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


export type Query_RootLyftrides_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


export type Query_RootLyftrides_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootMetrics_HourlyArgs = {
  distinct_on?: InputMaybe<Array<Metrics_Hourly_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Metrics_Hourly_Order_By>>;
  where?: InputMaybe<Metrics_Hourly_Bool_Exp>;
};


export type Query_RootMetrics_Hourly_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Metrics_Hourly_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Metrics_Hourly_Order_By>>;
  where?: InputMaybe<Metrics_Hourly_Bool_Exp>;
};


export type Query_RootMetrics_Hourly_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMove_Counts_By_CustomerArgs = {
  distinct_on?: InputMaybe<Array<Move_Counts_By_Customer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Counts_By_Customer_Order_By>>;
  where?: InputMaybe<Move_Counts_By_Customer_Bool_Exp>;
};


export type Query_RootMove_Counts_By_Customer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Move_Counts_By_Customer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Counts_By_Customer_Order_By>>;
  where?: InputMaybe<Move_Counts_By_Customer_Bool_Exp>;
};


export type Query_RootMove_PricingArgs = {
  distinct_on?: InputMaybe<Array<Move_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Pricing_Order_By>>;
  where?: InputMaybe<Move_Pricing_Bool_Exp>;
};


export type Query_RootMove_Pricing_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Move_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Pricing_Order_By>>;
  where?: InputMaybe<Move_Pricing_Bool_Exp>;
};


export type Query_RootMove_RateruleArgs = {
  distinct_on?: InputMaybe<Array<Move_Raterule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Raterule_Order_By>>;
  where?: InputMaybe<Move_Raterule_Bool_Exp>;
};


export type Query_RootMove_Raterule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Move_Raterule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Raterule_Order_By>>;
  where?: InputMaybe<Move_Raterule_Bool_Exp>;
};


export type Query_RootMoveauditArgs = {
  distinct_on?: InputMaybe<Array<Moveaudit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moveaudit_Order_By>>;
  where?: InputMaybe<Moveaudit_Bool_Exp>;
};


export type Query_RootMoveaudit_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moveaudit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moveaudit_Order_By>>;
  where?: InputMaybe<Moveaudit_Bool_Exp>;
};


export type Query_RootMoveaudit_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


export type Query_RootMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


export type Query_RootMoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootNotificationsArgs = {
  distinct_on?: InputMaybe<Array<Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notifications_Order_By>>;
  where?: InputMaybe<Notifications_Bool_Exp>;
};


export type Query_RootNotifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notifications_Order_By>>;
  where?: InputMaybe<Notifications_Bool_Exp>;
};


export type Query_RootNotifications_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootOffersArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


export type Query_RootOffers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


export type Query_RootOffers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Query_RootOrganizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Query_RootOrganizations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootOrganizationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


export type Query_RootOrganizationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


export type Query_RootOrganizationstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  organization_id: Scalars['bigint']['input'];
};


export type Query_RootPay_Periods_By_DriverArgs = {
  distinct_on?: InputMaybe<Array<Pay_Periods_By_Driver_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pay_Periods_By_Driver_Order_By>>;
  where?: InputMaybe<Pay_Periods_By_Driver_Bool_Exp>;
};


export type Query_RootPay_Periods_By_Driver_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pay_Periods_By_Driver_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pay_Periods_By_Driver_Order_By>>;
  where?: InputMaybe<Pay_Periods_By_Driver_Bool_Exp>;
};


export type Query_RootPaycyclesArgs = {
  distinct_on?: InputMaybe<Array<Paycycles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycles_Order_By>>;
  where?: InputMaybe<Paycycles_Bool_Exp>;
};


export type Query_RootPaycycles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Paycycles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycles_Order_By>>;
  where?: InputMaybe<Paycycles_Bool_Exp>;
};


export type Query_RootPaycycles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPaycycletodrivertodocumentsArgs = {
  distinct_on?: InputMaybe<Array<Paycycletodrivertodocuments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycletodrivertodocuments_Order_By>>;
  where?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
};


export type Query_RootPaycycletodrivertodocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Paycycletodrivertodocuments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycletodrivertodocuments_Order_By>>;
  where?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
};


export type Query_RootPaycycletodrivertodocuments_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootPayertocustomerArgs = {
  distinct_on?: InputMaybe<Array<Payertocustomer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payertocustomer_Order_By>>;
  where?: InputMaybe<Payertocustomer_Bool_Exp>;
};


export type Query_RootPayertocustomer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payertocustomer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payertocustomer_Order_By>>;
  where?: InputMaybe<Payertocustomer_Bool_Exp>;
};


export type Query_RootPayertocustomer_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPayrategroupsArgs = {
  distinct_on?: InputMaybe<Array<Payrategroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payrategroups_Order_By>>;
  where?: InputMaybe<Payrategroups_Bool_Exp>;
};


export type Query_RootPayrategroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payrategroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payrategroups_Order_By>>;
  where?: InputMaybe<Payrategroups_Bool_Exp>;
};


export type Query_RootPayrategroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPayraterulesArgs = {
  distinct_on?: InputMaybe<Array<Payraterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payraterules_Order_By>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


export type Query_RootPayraterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payraterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payraterules_Order_By>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


export type Query_RootPayraterules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPlansArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Query_RootPlans_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Query_RootPlans_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPlatedetailsArgs = {
  distinct_on?: InputMaybe<Array<Platedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Platedetails_Order_By>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};


export type Query_RootPlatedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Platedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Platedetails_Order_By>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};


export type Query_RootPlatedetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPlatesArgs = {
  distinct_on?: InputMaybe<Array<Plates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plates_Order_By>>;
  where?: InputMaybe<Plates_Bool_Exp>;
};


export type Query_RootPlates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Plates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plates_Order_By>>;
  where?: InputMaybe<Plates_Bool_Exp>;
};


export type Query_RootPlates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootProductfeesArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


export type Query_RootProductfees_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


export type Query_RootProductfees_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootProductsArgs = {
  distinct_on?: InputMaybe<Array<Products_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Products_Order_By>>;
  where?: InputMaybe<Products_Bool_Exp>;
};


export type Query_RootProducts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Products_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Products_Order_By>>;
  where?: InputMaybe<Products_Bool_Exp>;
};


export type Query_RootProducts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootPromosArgs = {
  distinct_on?: InputMaybe<Array<Promos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Promos_Order_By>>;
  where?: InputMaybe<Promos_Bool_Exp>;
};


export type Query_RootPromos_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Promos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Promos_Order_By>>;
  where?: InputMaybe<Promos_Bool_Exp>;
};


export type Query_RootPromos_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


export type Query_RootRaterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


export type Query_RootRaterulegroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRaterulesArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


export type Query_RootRaterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


export type Query_RootRaterules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRegionsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Query_RootRegions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Query_RootRegions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRidegroupsArgs = {
  distinct_on?: InputMaybe<Array<Ridegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridegroups_Order_By>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};


export type Query_RootRidegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridegroups_Order_By>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};


export type Query_RootRidegroups_By_PkArgs = {
  drive_move_id: Scalars['bigint']['input'];
  group_id: Scalars['uuid']['input'];
};


export type Query_RootRidesharefaresArgs = {
  distinct_on?: InputMaybe<Array<Ridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharefares_Order_By>>;
  where?: InputMaybe<Ridesharefares_Bool_Exp>;
};


export type Query_RootRidesharefares_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharefares_Order_By>>;
  where?: InputMaybe<Ridesharefares_Bool_Exp>;
};


export type Query_RootRidesharefares_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRideshareratesArgs = {
  distinct_on?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharerates_Order_By>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};


export type Query_RootRidesharerates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharerates_Order_By>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};


export type Query_RootRidesharerates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRideshareratetoridesharefaresArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


export type Query_RootRideshareratetoridesharefares_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


export type Query_RootRideshareratetoridesharefares_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootRoletypesArgs = {
  distinct_on?: InputMaybe<Array<Roletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Roletypes_Order_By>>;
  where?: InputMaybe<Roletypes_Bool_Exp>;
};


export type Query_RootRoletypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Roletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Roletypes_Order_By>>;
  where?: InputMaybe<Roletypes_Bool_Exp>;
};


export type Query_RootRoletypes_By_PkArgs = {
  id: Scalars['smallint']['input'];
};


export type Query_RootScenariosArgs = {
  distinct_on?: InputMaybe<Array<Scenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenarios_Order_By>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


export type Query_RootScenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenarios_Order_By>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


export type Query_RootScenarios_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootScenariotomovesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


export type Query_RootScenariotomoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


export type Query_RootScenariotomoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootScenariotypesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypes_Order_By>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


export type Query_RootScenariotypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypes_Order_By>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


export type Query_RootScenariotypes_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Query_RootScenariotypestocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


export type Query_RootScenariotypestocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


export type Query_RootScenariotypestocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  scenario_key: Scalars['String']['input'];
};


export type Query_RootSequelizemetaArgs = {
  distinct_on?: InputMaybe<Array<Sequelizemeta_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Sequelizemeta_Order_By>>;
  where?: InputMaybe<Sequelizemeta_Bool_Exp>;
};


export type Query_RootSequelizemeta_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Sequelizemeta_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Sequelizemeta_Order_By>>;
  where?: InputMaybe<Sequelizemeta_Bool_Exp>;
};


export type Query_RootSequelizemeta_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Query_RootSlasArgs = {
  distinct_on?: InputMaybe<Array<Slas_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_Order_By>>;
  where?: InputMaybe<Slas_Bool_Exp>;
};


export type Query_RootSlas_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Slas_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_Order_By>>;
  where?: InputMaybe<Slas_Bool_Exp>;
};


export type Query_RootSlas_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootSlas_To_RaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


export type Query_RootSlas_To_Raterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


export type Query_RootSlas_To_Raterulegroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootSmsmediaArgs = {
  distinct_on?: InputMaybe<Array<Smsmedia_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmedia_Order_By>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};


export type Query_RootSmsmedia_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smsmedia_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmedia_Order_By>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};


export type Query_RootSmsmedia_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootSmsmessagesArgs = {
  distinct_on?: InputMaybe<Array<Smsmessages_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmessages_Order_By>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};


export type Query_RootSmsmessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smsmessages_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmessages_Order_By>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};


export type Query_RootSmsmessages_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootSmstemplatesArgs = {
  distinct_on?: InputMaybe<Array<Smstemplates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smstemplates_Order_By>>;
  where?: InputMaybe<Smstemplates_Bool_Exp>;
};


export type Query_RootSmstemplates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smstemplates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smstemplates_Order_By>>;
  where?: InputMaybe<Smstemplates_Bool_Exp>;
};


export type Query_RootSmstemplates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Subscriptions_Order_By>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


export type Query_RootSubscriptions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Subscriptions_Order_By>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


export type Query_RootSubscriptions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootTemplatesArgs = {
  distinct_on?: InputMaybe<Array<Templates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Templates_Order_By>>;
  where?: InputMaybe<Templates_Bool_Exp>;
};


export type Query_RootTemplates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Templates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Templates_Order_By>>;
  where?: InputMaybe<Templates_Bool_Exp>;
};


export type Query_RootTemplates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootTripsArgs = {
  distinct_on?: InputMaybe<Array<Trips_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Trips_Order_By>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


export type Query_RootTrips_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trips_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Trips_Order_By>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


export type Query_RootTrips_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootUsecasesArgs = {
  distinct_on?: InputMaybe<Array<Usecases_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecases_Order_By>>;
  where?: InputMaybe<Usecases_Bool_Exp>;
};


export type Query_RootUsecases_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usecases_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecases_Order_By>>;
  where?: InputMaybe<Usecases_Bool_Exp>;
};


export type Query_RootUsecases_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Query_RootUsecasetocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


export type Query_RootUsecasetocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


export type Query_RootUsecasetocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  usecase_key: Scalars['String']['input'];
};


export type Query_RootUsereventlogsArgs = {
  distinct_on?: InputMaybe<Array<Usereventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usereventlogs_Order_By>>;
  where?: InputMaybe<Usereventlogs_Bool_Exp>;
};


export type Query_RootUsereventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usereventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usereventlogs_Order_By>>;
  where?: InputMaybe<Usereventlogs_Bool_Exp>;
};


export type Query_RootUsereventlogs_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootUsertocustomersArgs = {
  distinct_on?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertocustomers_Order_By>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


export type Query_RootUsertocustomers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertocustomers_Order_By>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


export type Query_RootUsertocustomers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootUsertofeaturesArgs = {
  distinct_on?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertofeatures_Order_By>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


export type Query_RootUsertofeatures_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertofeatures_Order_By>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


export type Query_RootUsertofeatures_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootUsertoregionsArgs = {
  distinct_on?: InputMaybe<Array<Usertoregions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoregions_Order_By>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


export type Query_RootUsertoregions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertoregions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoregions_Order_By>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


export type Query_RootUsertoregions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootUsertorolesArgs = {
  distinct_on?: InputMaybe<Array<Usertoroles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoroles_Order_By>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};


export type Query_RootUsertoroles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertoroles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoroles_Order_By>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};


export type Query_RootUsertoroles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootVehiclemakesArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemakes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemakes_Order_By>>;
  where?: InputMaybe<Vehiclemakes_Bool_Exp>;
};


export type Query_RootVehiclemakes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemakes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemakes_Order_By>>;
  where?: InputMaybe<Vehiclemakes_Bool_Exp>;
};


export type Query_RootVehiclemakes_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootVehiclemodelsArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemodels_Order_By>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};


export type Query_RootVehiclemodels_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemodels_Order_By>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};


export type Query_RootVehiclemodels_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootVehiclephotosArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


export type Query_RootVehiclephotos_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


export type Query_RootVehiclephotos_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootVehiclesArgs = {
  distinct_on?: InputMaybe<Array<Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicles_Order_By>>;
  where?: InputMaybe<Vehicles_Bool_Exp>;
};


export type Query_RootVehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicles_Order_By>>;
  where?: InputMaybe<Vehicles_Bool_Exp>;
};


export type Query_RootVehicles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootWebhook_EventsArgs = {
  distinct_on?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Webhook_Events_Order_By>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};


export type Query_RootWebhook_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Webhook_Events_Order_By>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};


export type Query_RootWebhook_Events_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootWorkflowsArgs = {
  distinct_on?: InputMaybe<Array<Workflows_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflows_Order_By>>;
  where?: InputMaybe<Workflows_Bool_Exp>;
};


export type Query_RootWorkflows_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflows_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflows_Order_By>>;
  where?: InputMaybe<Workflows_Bool_Exp>;
};


export type Query_RootWorkflows_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootWorkflowsetsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


export type Query_RootWorkflowsets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


export type Query_RootWorkflowsets_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootWorkflowsettypesArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


export type Query_RootWorkflowsettypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


export type Query_RootWorkflowsettypes_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Query_RootWorkflowsettypestocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypestocertifications_Order_By>>;
  where?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
};


export type Query_RootWorkflowsettypestocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypestocertifications_Order_By>>;
  where?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
};


export type Query_RootWorkflowsettypestocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  workflow_set_type_key: Scalars['String']['input'];
};

/** columns and relationships of "raterulegroups" */
export type Raterulegroups = {
  __typename?: 'raterulegroups';
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['bigint']['output'];
  insurance_rate_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  insurancerate?: Maybe<Insurancerates>;
  name?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  productfees: Array<Productfees>;
  /** An aggregate relationship */
  productfees_aggregate: Productfees_Aggregate;
  /** An array relationship */
  raterules: Array<Raterules>;
  /** An aggregate relationship */
  raterules_aggregate: Raterules_Aggregate;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  ridesharerate?: Maybe<Ridesharerates>;
  /** An object relationship */
  sla: Slas;
  sla_id: Scalars['bigint']['output'];
  /** An array relationship */
  slas_to_raterulegroup: Array<Slas_To_Raterulegroups>;
  /** An aggregate relationship */
  slas_to_raterulegroup_aggregate: Slas_To_Raterulegroups_Aggregate;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  workflowsets?: Maybe<Workflowsets>;
};


/** columns and relationships of "raterulegroups" */
export type RaterulegroupsProductfeesArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


/** columns and relationships of "raterulegroups" */
export type RaterulegroupsProductfees_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


/** columns and relationships of "raterulegroups" */
export type RaterulegroupsRaterulesArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


/** columns and relationships of "raterulegroups" */
export type RaterulegroupsRaterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


/** columns and relationships of "raterulegroups" */
export type RaterulegroupsSlas_To_RaterulegroupArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


/** columns and relationships of "raterulegroups" */
export type RaterulegroupsSlas_To_Raterulegroup_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};

/** aggregated selection of "raterulegroups" */
export type Raterulegroups_Aggregate = {
  __typename?: 'raterulegroups_aggregate';
  aggregate?: Maybe<Raterulegroups_Aggregate_Fields>;
  nodes: Array<Raterulegroups>;
};

export type Raterulegroups_Aggregate_Bool_Exp = {
  count?: InputMaybe<Raterulegroups_Aggregate_Bool_Exp_Count>;
};

export type Raterulegroups_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Raterulegroups_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "raterulegroups" */
export type Raterulegroups_Aggregate_Fields = {
  __typename?: 'raterulegroups_aggregate_fields';
  avg?: Maybe<Raterulegroups_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Raterulegroups_Max_Fields>;
  min?: Maybe<Raterulegroups_Min_Fields>;
  stddev?: Maybe<Raterulegroups_Stddev_Fields>;
  stddev_pop?: Maybe<Raterulegroups_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Raterulegroups_Stddev_Samp_Fields>;
  sum?: Maybe<Raterulegroups_Sum_Fields>;
  var_pop?: Maybe<Raterulegroups_Var_Pop_Fields>;
  var_samp?: Maybe<Raterulegroups_Var_Samp_Fields>;
  variance?: Maybe<Raterulegroups_Variance_Fields>;
};


/** aggregate fields of "raterulegroups" */
export type Raterulegroups_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "raterulegroups" */
export type Raterulegroups_Aggregate_Order_By = {
  avg?: InputMaybe<Raterulegroups_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Raterulegroups_Max_Order_By>;
  min?: InputMaybe<Raterulegroups_Min_Order_By>;
  stddev?: InputMaybe<Raterulegroups_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Raterulegroups_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Raterulegroups_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Raterulegroups_Sum_Order_By>;
  var_pop?: InputMaybe<Raterulegroups_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Raterulegroups_Var_Samp_Order_By>;
  variance?: InputMaybe<Raterulegroups_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "raterulegroups" */
export type Raterulegroups_Arr_Rel_Insert_Input = {
  data: Array<Raterulegroups_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Raterulegroups_On_Conflict>;
};

/** aggregate avg on columns */
export type Raterulegroups_Avg_Fields = {
  __typename?: 'raterulegroups_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "raterulegroups" */
export type Raterulegroups_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "raterulegroups". All fields are combined with a logical 'AND'. */
export type Raterulegroups_Bool_Exp = {
  _and?: InputMaybe<Array<Raterulegroups_Bool_Exp>>;
  _not?: InputMaybe<Raterulegroups_Bool_Exp>;
  _or?: InputMaybe<Array<Raterulegroups_Bool_Exp>>;
  begin_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  end_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  insurance_rate_id?: InputMaybe<Bigint_Comparison_Exp>;
  insurancerate?: InputMaybe<Insurancerates_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  productfees?: InputMaybe<Productfees_Bool_Exp>;
  productfees_aggregate?: InputMaybe<Productfees_Aggregate_Bool_Exp>;
  raterules?: InputMaybe<Raterules_Bool_Exp>;
  raterules_aggregate?: InputMaybe<Raterules_Aggregate_Bool_Exp>;
  rideshare_rate_id?: InputMaybe<Bigint_Comparison_Exp>;
  ridesharerate?: InputMaybe<Ridesharerates_Bool_Exp>;
  sla?: InputMaybe<Slas_Bool_Exp>;
  sla_id?: InputMaybe<Bigint_Comparison_Exp>;
  slas_to_raterulegroup?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
  slas_to_raterulegroup_aggregate?: InputMaybe<Slas_To_Raterulegroups_Aggregate_Bool_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  workflowset_id?: InputMaybe<Bigint_Comparison_Exp>;
  workflowsets?: InputMaybe<Workflowsets_Bool_Exp>;
};

/** unique or primary key constraints on table "raterulegroups" */
export enum Raterulegroups_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25769Primary = 'idx_25769_primary'
}

/** input type for incrementing numeric columns in table "raterulegroups" */
export type Raterulegroups_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "raterulegroups" */
export type Raterulegroups_Insert_Input = {
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  insurancerate?: InputMaybe<Insurancerates_Obj_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  productfees?: InputMaybe<Productfees_Arr_Rel_Insert_Input>;
  raterules?: InputMaybe<Raterules_Arr_Rel_Insert_Input>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  ridesharerate?: InputMaybe<Ridesharerates_Obj_Rel_Insert_Input>;
  sla?: InputMaybe<Slas_Obj_Rel_Insert_Input>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  slas_to_raterulegroup?: InputMaybe<Slas_To_Raterulegroups_Arr_Rel_Insert_Input>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
  workflowsets?: InputMaybe<Workflowsets_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Raterulegroups_Max_Fields = {
  __typename?: 'raterulegroups_max_fields';
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  insurance_rate_id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "raterulegroups" */
export type Raterulegroups_Max_Order_By = {
  begin_date?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Raterulegroups_Min_Fields = {
  __typename?: 'raterulegroups_min_fields';
  begin_date?: Maybe<Scalars['timestamptz']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  end_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  insurance_rate_id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "raterulegroups" */
export type Raterulegroups_Min_Order_By = {
  begin_date?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "raterulegroups" */
export type Raterulegroups_Mutation_Response = {
  __typename?: 'raterulegroups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Raterulegroups>;
};

/** input type for inserting object relation for remote table "raterulegroups" */
export type Raterulegroups_Obj_Rel_Insert_Input = {
  data: Raterulegroups_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Raterulegroups_On_Conflict>;
};

/** on_conflict condition type for table "raterulegroups" */
export type Raterulegroups_On_Conflict = {
  constraint: Raterulegroups_Constraint;
  update_columns?: Array<Raterulegroups_Update_Column>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};

/** Ordering options when selecting data from "raterulegroups". */
export type Raterulegroups_Order_By = {
  begin_date?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  insurancerate?: InputMaybe<Insurancerates_Order_By>;
  name?: InputMaybe<Order_By>;
  productfees_aggregate?: InputMaybe<Productfees_Aggregate_Order_By>;
  raterules_aggregate?: InputMaybe<Raterules_Aggregate_Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  ridesharerate?: InputMaybe<Ridesharerates_Order_By>;
  sla?: InputMaybe<Slas_Order_By>;
  sla_id?: InputMaybe<Order_By>;
  slas_to_raterulegroup_aggregate?: InputMaybe<Slas_To_Raterulegroups_Aggregate_Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
  workflowsets?: InputMaybe<Workflowsets_Order_By>;
};

/** primary key columns input for table: raterulegroups */
export type Raterulegroups_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "raterulegroups" */
export enum Raterulegroups_Select_Column {
  /** column name */
  BeginDate = 'begin_date',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  InsuranceRateId = 'insurance_rate_id',
  /** column name */
  Name = 'name',
  /** column name */
  RideshareRateId = 'rideshare_rate_id',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowsetId = 'workflowset_id'
}

/** input type for updating data in table "raterulegroups" */
export type Raterulegroups_Set_Input = {
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Raterulegroups_Stddev_Fields = {
  __typename?: 'raterulegroups_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "raterulegroups" */
export type Raterulegroups_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Raterulegroups_Stddev_Pop_Fields = {
  __typename?: 'raterulegroups_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "raterulegroups" */
export type Raterulegroups_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Raterulegroups_Stddev_Samp_Fields = {
  __typename?: 'raterulegroups_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "raterulegroups" */
export type Raterulegroups_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "raterulegroups" */
export type Raterulegroups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Raterulegroups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Raterulegroups_Stream_Cursor_Value_Input = {
  begin_date?: InputMaybe<Scalars['timestamptz']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  end_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  insurance_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflowset_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Raterulegroups_Sum_Fields = {
  __typename?: 'raterulegroups_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  insurance_rate_id?: Maybe<Scalars['bigint']['output']>;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  workflowset_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "raterulegroups" */
export type Raterulegroups_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** update columns of table "raterulegroups" */
export enum Raterulegroups_Update_Column {
  /** column name */
  BeginDate = 'begin_date',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Id = 'id',
  /** column name */
  InsuranceRateId = 'insurance_rate_id',
  /** column name */
  Name = 'name',
  /** column name */
  RideshareRateId = 'rideshare_rate_id',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowsetId = 'workflowset_id'
}

export type Raterulegroups_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Raterulegroups_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Raterulegroups_Set_Input>;
  /** filter the rows which have to be updated */
  where: Raterulegroups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Raterulegroups_Var_Pop_Fields = {
  __typename?: 'raterulegroups_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "raterulegroups" */
export type Raterulegroups_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Raterulegroups_Var_Samp_Fields = {
  __typename?: 'raterulegroups_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "raterulegroups" */
export type Raterulegroups_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Raterulegroups_Variance_Fields = {
  __typename?: 'raterulegroups_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  insurance_rate_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
  workflowset_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "raterulegroups" */
export type Raterulegroups_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  insurance_rate_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  workflowset_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "raterules" */
export type Raterules = {
  __typename?: 'raterules';
  active?: Maybe<Scalars['smallint']['output']>;
  /** An array relationship */
  armovedetails: Array<Armovedetails>;
  /** An aggregate relationship */
  armovedetails_aggregate: Armovedetails_Aggregate;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: Maybe<Scalars['String']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['bigint']['output'];
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  payrategroup?: Maybe<Payrategroups>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  raterulegroup?: Maybe<Raterulegroups>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "raterules" */
export type RaterulesArmovedetailsArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


/** columns and relationships of "raterules" */
export type RaterulesArmovedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};

/** aggregated selection of "raterules" */
export type Raterules_Aggregate = {
  __typename?: 'raterules_aggregate';
  aggregate?: Maybe<Raterules_Aggregate_Fields>;
  nodes: Array<Raterules>;
};

export type Raterules_Aggregate_Bool_Exp = {
  count?: InputMaybe<Raterules_Aggregate_Bool_Exp_Count>;
};

export type Raterules_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Raterules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Raterules_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "raterules" */
export type Raterules_Aggregate_Fields = {
  __typename?: 'raterules_aggregate_fields';
  avg?: Maybe<Raterules_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Raterules_Max_Fields>;
  min?: Maybe<Raterules_Min_Fields>;
  stddev?: Maybe<Raterules_Stddev_Fields>;
  stddev_pop?: Maybe<Raterules_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Raterules_Stddev_Samp_Fields>;
  sum?: Maybe<Raterules_Sum_Fields>;
  var_pop?: Maybe<Raterules_Var_Pop_Fields>;
  var_samp?: Maybe<Raterules_Var_Samp_Fields>;
  variance?: Maybe<Raterules_Variance_Fields>;
};


/** aggregate fields of "raterules" */
export type Raterules_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Raterules_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "raterules" */
export type Raterules_Aggregate_Order_By = {
  avg?: InputMaybe<Raterules_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Raterules_Max_Order_By>;
  min?: InputMaybe<Raterules_Min_Order_By>;
  stddev?: InputMaybe<Raterules_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Raterules_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Raterules_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Raterules_Sum_Order_By>;
  var_pop?: InputMaybe<Raterules_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Raterules_Var_Samp_Order_By>;
  variance?: InputMaybe<Raterules_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "raterules" */
export type Raterules_Arr_Rel_Insert_Input = {
  data: Array<Raterules_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Raterules_On_Conflict>;
};

/** aggregate avg on columns */
export type Raterules_Avg_Fields = {
  __typename?: 'raterules_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "raterules" */
export type Raterules_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "raterules". All fields are combined with a logical 'AND'. */
export type Raterules_Bool_Exp = {
  _and?: InputMaybe<Array<Raterules_Bool_Exp>>;
  _not?: InputMaybe<Raterules_Bool_Exp>;
  _or?: InputMaybe<Array<Raterules_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  armovedetails?: InputMaybe<Armovedetails_Bool_Exp>;
  armovedetails_aggregate?: InputMaybe<Armovedetails_Aggregate_Bool_Exp>;
  class?: InputMaybe<String_Comparison_Exp>;
  class_3_flat_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_3_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_4_flat_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_4_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_5_flat_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_5_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_6_flat_rate?: InputMaybe<Numeric_Comparison_Exp>;
  class_6_rate?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  distance_end?: InputMaybe<Numeric_Comparison_Exp>;
  distance_start?: InputMaybe<Numeric_Comparison_Exp>;
  flat_rate?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  pay_rate_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  payrategroup?: InputMaybe<Payrategroups_Bool_Exp>;
  rate?: InputMaybe<Numeric_Comparison_Exp>;
  rate_rule_group_id?: InputMaybe<Bigint_Comparison_Exp>;
  raterulegroup?: InputMaybe<Raterulegroups_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "raterules" */
export enum Raterules_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_21717Primary = 'idx_21717_primary'
}

/** input type for incrementing numeric columns in table "raterules" */
export type Raterules_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "raterules" */
export type Raterules_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  armovedetails?: InputMaybe<Armovedetails_Arr_Rel_Insert_Input>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: InputMaybe<Scalars['String']['input']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  payrategroup?: InputMaybe<Payrategroups_Obj_Rel_Insert_Input>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  raterulegroup?: InputMaybe<Raterulegroups_Obj_Rel_Insert_Input>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Raterules_Max_Fields = {
  __typename?: 'raterules_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: Maybe<Scalars['String']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "raterules" */
export type Raterules_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Raterules_Min_Fields = {
  __typename?: 'raterules_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: Maybe<Scalars['String']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "raterules" */
export type Raterules_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "raterules" */
export type Raterules_Mutation_Response = {
  __typename?: 'raterules_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Raterules>;
};

/** input type for inserting object relation for remote table "raterules" */
export type Raterules_Obj_Rel_Insert_Input = {
  data: Raterules_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Raterules_On_Conflict>;
};

/** on_conflict condition type for table "raterules" */
export type Raterules_On_Conflict = {
  constraint: Raterules_Constraint;
  update_columns?: Array<Raterules_Update_Column>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};

/** Ordering options when selecting data from "raterules". */
export type Raterules_Order_By = {
  active?: InputMaybe<Order_By>;
  armovedetails_aggregate?: InputMaybe<Armovedetails_Aggregate_Order_By>;
  class?: InputMaybe<Order_By>;
  class_3_flat_rate?: InputMaybe<Order_By>;
  class_3_rate?: InputMaybe<Order_By>;
  class_4_flat_rate?: InputMaybe<Order_By>;
  class_4_rate?: InputMaybe<Order_By>;
  class_5_flat_rate?: InputMaybe<Order_By>;
  class_5_rate?: InputMaybe<Order_By>;
  class_6_flat_rate?: InputMaybe<Order_By>;
  class_6_rate?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  payrategroup?: InputMaybe<Payrategroups_Order_By>;
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
  raterulegroup?: InputMaybe<Raterulegroups_Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: raterules */
export type Raterules_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "raterules" */
export enum Raterules_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Class = 'class',
  /** column name */
  Class_3FlatRate = 'class_3_flat_rate',
  /** column name */
  Class_3Rate = 'class_3_rate',
  /** column name */
  Class_4FlatRate = 'class_4_flat_rate',
  /** column name */
  Class_4Rate = 'class_4_rate',
  /** column name */
  Class_5FlatRate = 'class_5_flat_rate',
  /** column name */
  Class_5Rate = 'class_5_rate',
  /** column name */
  Class_6FlatRate = 'class_6_flat_rate',
  /** column name */
  Class_6Rate = 'class_6_rate',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DistanceEnd = 'distance_end',
  /** column name */
  DistanceStart = 'distance_start',
  /** column name */
  FlatRate = 'flat_rate',
  /** column name */
  Id = 'id',
  /** column name */
  PayRateGroupId = 'pay_rate_group_id',
  /** column name */
  Rate = 'rate',
  /** column name */
  RateRuleGroupId = 'rate_rule_group_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "raterules" */
export type Raterules_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: InputMaybe<Scalars['String']['input']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Raterules_Stddev_Fields = {
  __typename?: 'raterules_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "raterules" */
export type Raterules_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Raterules_Stddev_Pop_Fields = {
  __typename?: 'raterules_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "raterules" */
export type Raterules_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Raterules_Stddev_Samp_Fields = {
  __typename?: 'raterules_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "raterules" */
export type Raterules_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "raterules" */
export type Raterules_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Raterules_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Raterules_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** Determines which class of move the rate will apply to: "stranded" or "base" */
  class?: InputMaybe<Scalars['String']['input']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  distance_end?: InputMaybe<Scalars['numeric']['input']>;
  distance_start?: InputMaybe<Scalars['numeric']['input']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  pay_rate_group_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Scalars['numeric']['input']>;
  rate_rule_group_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Determines which type of rate will be applied: "flat", price is the rate; "per", price is the rate multiplied by the mileage; "flatPlusPer", the price is the flat rate plus the per rate multiplied by the mileage. */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Raterules_Sum_Fields = {
  __typename?: 'raterules_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['numeric']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['numeric']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  distance_end?: Maybe<Scalars['numeric']['output']>;
  distance_start?: Maybe<Scalars['numeric']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  pay_rate_group_id?: Maybe<Scalars['bigint']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['numeric']['output']>;
  rate_rule_group_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "raterules" */
export type Raterules_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** update columns of table "raterules" */
export enum Raterules_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Class = 'class',
  /** column name */
  Class_3FlatRate = 'class_3_flat_rate',
  /** column name */
  Class_3Rate = 'class_3_rate',
  /** column name */
  Class_4FlatRate = 'class_4_flat_rate',
  /** column name */
  Class_4Rate = 'class_4_rate',
  /** column name */
  Class_5FlatRate = 'class_5_flat_rate',
  /** column name */
  Class_5Rate = 'class_5_rate',
  /** column name */
  Class_6FlatRate = 'class_6_flat_rate',
  /** column name */
  Class_6Rate = 'class_6_rate',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DistanceEnd = 'distance_end',
  /** column name */
  DistanceStart = 'distance_start',
  /** column name */
  FlatRate = 'flat_rate',
  /** column name */
  Id = 'id',
  /** column name */
  PayRateGroupId = 'pay_rate_group_id',
  /** column name */
  Rate = 'rate',
  /** column name */
  RateRuleGroupId = 'rate_rule_group_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat'
}

export type Raterules_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Raterules_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Raterules_Set_Input>;
  /** filter the rows which have to be updated */
  where: Raterules_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Raterules_Var_Pop_Fields = {
  __typename?: 'raterules_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "raterules" */
export type Raterules_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Raterules_Var_Samp_Fields = {
  __typename?: 'raterules_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "raterules" */
export type Raterules_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Raterules_Variance_Fields = {
  __typename?: 'raterules_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: Maybe<Scalars['Float']['output']>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  distance_end?: Maybe<Scalars['Float']['output']>;
  distance_start?: Maybe<Scalars['Float']['output']>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  pay_rate_group_id?: Maybe<Scalars['Float']['output']>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: Maybe<Scalars['Float']['output']>;
  rate_rule_group_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "raterules" */
export type Raterules_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 3 weight; between 10,001 and 14,000 lbs. */
  class_3_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 4 weight; between 14,001 and 16,000 lbs. */
  class_4_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 5 weight; between 16,001 and 19,500 lbs. */
  class_5_rate?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_flat_rate?: InputMaybe<Order_By>;
  /** Per mile pricing for vehicles with class 6 weight; between 19,501 and 26,000 lbs. */
  class_6_rate?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  distance_end?: InputMaybe<Order_By>;
  distance_start?: InputMaybe<Order_By>;
  /** Flat pricing for vehicles with class 1 or 2 weight; up to 10,000 lbs */
  flat_rate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pay_rate_group_id?: InputMaybe<Order_By>;
  /** Per mile rate that covers moves for vehicles with Gross Weight Rating of Class 1 and Class 2 up to 10,000 lbs */
  rate?: InputMaybe<Order_By>;
  rate_rule_group_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "regions" */
export type Regions = {
  __typename?: 'regions';
  accounting_class_num?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  geofence?: Maybe<Scalars['geometry']['output']>;
  id: Scalars['bigint']['output'];
  last_synced?: Maybe<Scalars['timestamptz']['output']>;
  name: Scalars['String']['output'];
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  ridesharerates: Array<Ridesharerates>;
  /** An aggregate relationship */
  ridesharerates_aggregate: Ridesharerates_Aggregate;
  /** Lifecycle for regions starting with "upcoming" when regions are still being staffed, "live" when they are ready to accept moves, and "deactivated" when decommissioned */
  status: Scalars['String']['output'];
  team_id?: Maybe<Scalars['bigint']['output']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "regions" */
export type RegionsRideshareratesArgs = {
  distinct_on?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharerates_Order_By>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};


/** columns and relationships of "regions" */
export type RegionsRidesharerates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharerates_Order_By>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};

/** aggregated selection of "regions" */
export type Regions_Aggregate = {
  __typename?: 'regions_aggregate';
  aggregate?: Maybe<Regions_Aggregate_Fields>;
  nodes: Array<Regions>;
};

/** aggregate fields of "regions" */
export type Regions_Aggregate_Fields = {
  __typename?: 'regions_aggregate_fields';
  avg?: Maybe<Regions_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Regions_Max_Fields>;
  min?: Maybe<Regions_Min_Fields>;
  stddev?: Maybe<Regions_Stddev_Fields>;
  stddev_pop?: Maybe<Regions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Regions_Stddev_Samp_Fields>;
  sum?: Maybe<Regions_Sum_Fields>;
  var_pop?: Maybe<Regions_Var_Pop_Fields>;
  var_samp?: Maybe<Regions_Var_Samp_Fields>;
  variance?: Maybe<Regions_Variance_Fields>;
};


/** aggregate fields of "regions" */
export type Regions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Regions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Regions_Avg_Fields = {
  __typename?: 'regions_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "regions". All fields are combined with a logical 'AND'. */
export type Regions_Bool_Exp = {
  _and?: InputMaybe<Array<Regions_Bool_Exp>>;
  _not?: InputMaybe<Regions_Bool_Exp>;
  _or?: InputMaybe<Array<Regions_Bool_Exp>>;
  accounting_class_num?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  geofence?: InputMaybe<Geometry_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  last_synced?: InputMaybe<Timestamptz_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  ridesharerates?: InputMaybe<Ridesharerates_Bool_Exp>;
  ridesharerates_aggregate?: InputMaybe<Ridesharerates_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  team_id?: InputMaybe<Bigint_Comparison_Exp>;
  timezone?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "regions" */
export enum Regions_Constraint {
  /** unique or primary key constraint on columns "id" */
  RegionsPkey = 'regions_pkey',
  /** unique or primary key constraint on columns "region_id" */
  RegionsRegionIdKey = 'regions_region_id_key',
  /** unique or primary key constraint on columns "team_id" */
  RegionsTeamIdKey = 'regions_team_id_key'
}

/** input type for incrementing numeric columns in table "regions" */
export type Regions_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  team_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "regions" */
export type Regions_Insert_Input = {
  accounting_class_num?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  geofence?: InputMaybe<Scalars['geometry']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_synced?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  ridesharerates?: InputMaybe<Ridesharerates_Arr_Rel_Insert_Input>;
  /** Lifecycle for regions starting with "upcoming" when regions are still being staffed, "live" when they are ready to accept moves, and "deactivated" when decommissioned */
  status?: InputMaybe<Scalars['String']['input']>;
  team_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Regions_Max_Fields = {
  __typename?: 'regions_max_fields';
  accounting_class_num?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_synced?: Maybe<Scalars['timestamptz']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Lifecycle for regions starting with "upcoming" when regions are still being staffed, "live" when they are ready to accept moves, and "deactivated" when decommissioned */
  status?: Maybe<Scalars['String']['output']>;
  team_id?: Maybe<Scalars['bigint']['output']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Regions_Min_Fields = {
  __typename?: 'regions_min_fields';
  accounting_class_num?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  last_synced?: Maybe<Scalars['timestamptz']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** Lifecycle for regions starting with "upcoming" when regions are still being staffed, "live" when they are ready to accept moves, and "deactivated" when decommissioned */
  status?: Maybe<Scalars['String']['output']>;
  team_id?: Maybe<Scalars['bigint']['output']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "regions" */
export type Regions_Mutation_Response = {
  __typename?: 'regions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Regions>;
};

/** input type for inserting object relation for remote table "regions" */
export type Regions_Obj_Rel_Insert_Input = {
  data: Regions_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};

/** on_conflict condition type for table "regions" */
export type Regions_On_Conflict = {
  constraint: Regions_Constraint;
  update_columns?: Array<Regions_Update_Column>;
  where?: InputMaybe<Regions_Bool_Exp>;
};

/** Ordering options when selecting data from "regions". */
export type Regions_Order_By = {
  accounting_class_num?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  geofence?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  last_synced?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  ridesharerates_aggregate?: InputMaybe<Ridesharerates_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  team_id?: InputMaybe<Order_By>;
  timezone?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: regions */
export type Regions_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "regions" */
export enum Regions_Select_Column {
  /** column name */
  AccountingClassNum = 'accounting_class_num',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Description = 'description',
  /** column name */
  Email = 'email',
  /** column name */
  Geofence = 'geofence',
  /** column name */
  Id = 'id',
  /** column name */
  LastSynced = 'last_synced',
  /** column name */
  Name = 'name',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "regions" */
export type Regions_Set_Input = {
  accounting_class_num?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  geofence?: InputMaybe<Scalars['geometry']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_synced?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Lifecycle for regions starting with "upcoming" when regions are still being staffed, "live" when they are ready to accept moves, and "deactivated" when decommissioned */
  status?: InputMaybe<Scalars['String']['input']>;
  team_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Regions_Stddev_Fields = {
  __typename?: 'regions_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Regions_Stddev_Pop_Fields = {
  __typename?: 'regions_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Regions_Stddev_Samp_Fields = {
  __typename?: 'regions_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "regions" */
export type Regions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Regions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Regions_Stream_Cursor_Value_Input = {
  accounting_class_num?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  geofence?: InputMaybe<Scalars['geometry']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  last_synced?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Lifecycle for regions starting with "upcoming" when regions are still being staffed, "live" when they are ready to accept moves, and "deactivated" when decommissioned */
  status?: InputMaybe<Scalars['String']['input']>;
  team_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Standard timezone ID/database name used to determine timezone location. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Regions_Sum_Fields = {
  __typename?: 'regions_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  team_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "regions" */
export enum Regions_Update_Column {
  /** column name */
  AccountingClassNum = 'accounting_class_num',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Description = 'description',
  /** column name */
  Email = 'email',
  /** column name */
  Geofence = 'geofence',
  /** column name */
  Id = 'id',
  /** column name */
  LastSynced = 'last_synced',
  /** column name */
  Name = 'name',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  Updatedat = 'updatedat'
}

export type Regions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Regions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Regions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Regions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Regions_Var_Pop_Fields = {
  __typename?: 'regions_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Regions_Var_Samp_Fields = {
  __typename?: 'regions_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Regions_Variance_Fields = {
  __typename?: 'regions_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  team_id?: Maybe<Scalars['Float']['output']>;
};

/** Link table to relate shared rides to moves. */
export type Ridegroups = {
  __typename?: 'ridegroups';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  drive_move_id: Scalars['bigint']['output'];
  group_id: Scalars['uuid']['output'];
  id: Scalars['bigint']['output'];
  /** An object relationship */
  move: Moves;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status: Scalars['String']['output'];
};

/** aggregated selection of "ridegroups" */
export type Ridegroups_Aggregate = {
  __typename?: 'ridegroups_aggregate';
  aggregate?: Maybe<Ridegroups_Aggregate_Fields>;
  nodes: Array<Ridegroups>;
};

export type Ridegroups_Aggregate_Bool_Exp = {
  count?: InputMaybe<Ridegroups_Aggregate_Bool_Exp_Count>;
};

export type Ridegroups_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Ridegroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Ridegroups_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ridegroups" */
export type Ridegroups_Aggregate_Fields = {
  __typename?: 'ridegroups_aggregate_fields';
  avg?: Maybe<Ridegroups_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Ridegroups_Max_Fields>;
  min?: Maybe<Ridegroups_Min_Fields>;
  stddev?: Maybe<Ridegroups_Stddev_Fields>;
  stddev_pop?: Maybe<Ridegroups_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ridegroups_Stddev_Samp_Fields>;
  sum?: Maybe<Ridegroups_Sum_Fields>;
  var_pop?: Maybe<Ridegroups_Var_Pop_Fields>;
  var_samp?: Maybe<Ridegroups_Var_Samp_Fields>;
  variance?: Maybe<Ridegroups_Variance_Fields>;
};


/** aggregate fields of "ridegroups" */
export type Ridegroups_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Ridegroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "ridegroups" */
export type Ridegroups_Aggregate_Order_By = {
  avg?: InputMaybe<Ridegroups_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Ridegroups_Max_Order_By>;
  min?: InputMaybe<Ridegroups_Min_Order_By>;
  stddev?: InputMaybe<Ridegroups_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Ridegroups_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Ridegroups_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Ridegroups_Sum_Order_By>;
  var_pop?: InputMaybe<Ridegroups_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Ridegroups_Var_Samp_Order_By>;
  variance?: InputMaybe<Ridegroups_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ridegroups" */
export type Ridegroups_Arr_Rel_Insert_Input = {
  data: Array<Ridegroups_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Ridegroups_On_Conflict>;
};

/** aggregate avg on columns */
export type Ridegroups_Avg_Fields = {
  __typename?: 'ridegroups_avg_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "ridegroups" */
export type Ridegroups_Avg_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ridegroups". All fields are combined with a logical 'AND'. */
export type Ridegroups_Bool_Exp = {
  _and?: InputMaybe<Array<Ridegroups_Bool_Exp>>;
  _not?: InputMaybe<Ridegroups_Bool_Exp>;
  _or?: InputMaybe<Array<Ridegroups_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  drive_move_id?: InputMaybe<Bigint_Comparison_Exp>;
  group_id?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  ready_at_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ridegroups" */
export enum Ridegroups_Constraint {
  /** unique or primary key constraint on columns "drive_move_id" */
  RidegroupsDriveMoveIdKey = 'ridegroups_drive_move_id_key',
  /** unique or primary key constraint on columns "group_id", "drive_move_id" */
  RidegroupsPkey = 'ridegroups_pkey'
}

/** input type for incrementing numeric columns in table "ridegroups" */
export type Ridegroups_Inc_Input = {
  drive_move_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "ridegroups" */
export type Ridegroups_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  drive_move_id?: InputMaybe<Scalars['bigint']['input']>;
  group_id?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Ridegroups_Max_Fields = {
  __typename?: 'ridegroups_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  drive_move_id?: Maybe<Scalars['bigint']['output']>;
  group_id?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "ridegroups" */
export type Ridegroups_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  drive_move_id?: InputMaybe<Order_By>;
  group_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: InputMaybe<Order_By>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Ridegroups_Min_Fields = {
  __typename?: 'ridegroups_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  drive_move_id?: Maybe<Scalars['bigint']['output']>;
  group_id?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: Maybe<Scalars['timestamptz']['output']>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "ridegroups" */
export type Ridegroups_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  drive_move_id?: InputMaybe<Order_By>;
  group_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: InputMaybe<Order_By>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "ridegroups" */
export type Ridegroups_Mutation_Response = {
  __typename?: 'ridegroups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Ridegroups>;
};

/** input type for inserting object relation for remote table "ridegroups" */
export type Ridegroups_Obj_Rel_Insert_Input = {
  data: Ridegroups_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Ridegroups_On_Conflict>;
};

/** on_conflict condition type for table "ridegroups" */
export type Ridegroups_On_Conflict = {
  constraint: Ridegroups_Constraint;
  update_columns?: Array<Ridegroups_Update_Column>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};

/** Ordering options when selecting data from "ridegroups". */
export type Ridegroups_Order_By = {
  created_at?: InputMaybe<Order_By>;
  drive_move_id?: InputMaybe<Order_By>;
  group_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  ready_at_time?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
};

/** primary key columns input for table: ridegroups */
export type Ridegroups_Pk_Columns_Input = {
  drive_move_id: Scalars['bigint']['input'];
  group_id: Scalars['uuid']['input'];
};

/** select columns of table "ridegroups" */
export enum Ridegroups_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriveMoveId = 'drive_move_id',
  /** column name */
  GroupId = 'group_id',
  /** column name */
  Id = 'id',
  /** column name */
  ReadyAtTime = 'ready_at_time',
  /** column name */
  Status = 'status'
}

/** input type for updating data in table "ridegroups" */
export type Ridegroups_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  drive_move_id?: InputMaybe<Scalars['bigint']['input']>;
  group_id?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Ridegroups_Stddev_Fields = {
  __typename?: 'ridegroups_stddev_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "ridegroups" */
export type Ridegroups_Stddev_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Ridegroups_Stddev_Pop_Fields = {
  __typename?: 'ridegroups_stddev_pop_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "ridegroups" */
export type Ridegroups_Stddev_Pop_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Ridegroups_Stddev_Samp_Fields = {
  __typename?: 'ridegroups_stddev_samp_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "ridegroups" */
export type Ridegroups_Stddev_Samp_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "ridegroups" */
export type Ridegroups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ridegroups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ridegroups_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  drive_move_id?: InputMaybe<Scalars['bigint']['input']>;
  group_id?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Time that is set when the status changes to "ready". Used to detect who calls the ride first in the group. */
  ready_at_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Current status of the member of the ride group. [not ready | ready] */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Ridegroups_Sum_Fields = {
  __typename?: 'ridegroups_sum_fields';
  drive_move_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "ridegroups" */
export type Ridegroups_Sum_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "ridegroups" */
export enum Ridegroups_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DriveMoveId = 'drive_move_id',
  /** column name */
  GroupId = 'group_id',
  /** column name */
  Id = 'id',
  /** column name */
  ReadyAtTime = 'ready_at_time',
  /** column name */
  Status = 'status'
}

export type Ridegroups_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Ridegroups_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Ridegroups_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ridegroups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Ridegroups_Var_Pop_Fields = {
  __typename?: 'ridegroups_var_pop_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "ridegroups" */
export type Ridegroups_Var_Pop_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Ridegroups_Var_Samp_Fields = {
  __typename?: 'ridegroups_var_samp_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "ridegroups" */
export type Ridegroups_Var_Samp_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Ridegroups_Variance_Fields = {
  __typename?: 'ridegroups_variance_fields';
  drive_move_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "ridegroups" */
export type Ridegroups_Variance_Order_By = {
  drive_move_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Table of fare data sourced from rideshare providers organized by market */
export type Ridesharefares = {
  __typename?: 'ridesharefares';
  /** fee charged for canceling */
  cancelation_fee: Scalars['numeric']['output'];
  /** Central latitude/longitude of market, expressed as a "point" type geometry object */
  center_geopoint: Scalars['geometry']['output'];
  /** latitude of center location of providers market */
  center_lat: Scalars['numeric']['output'];
  /** longitude center location of providers market */
  center_lon: Scalars['numeric']['output'];
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax: Scalars['numeric']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** start date of when rate should be used to make contract prices */
  effective_date: Scalars['timestamptz']['output'];
  /** end date of when rate should be used to make contract prices */
  expiration_date: Scalars['timestamptz']['output'];
  /** geofence of providers region */
  geofence: Scalars['geometry']['output'];
  id: Scalars['bigint']['output'];
  /** base cost that is applied to all fares */
  initial_cost: Scalars['numeric']['output'];
  /** the name of the city or area for these rates (e.g. Atlanta, Bronx NYC, etc) */
  market: Scalars['String']['output'];
  /** highest possible fare */
  maximum_fare: Scalars['numeric']['output'];
  /** lowest possible fare */
  minimum_fare: Scalars['numeric']['output'];
  /** charge per mile */
  per_mile: Scalars['numeric']['output'];
  /** charge per minute */
  per_minute: Scalars['numeric']['output'];
  /** name of rideshare provider (e.g Lyft, Uber, Yellow Taxi) */
  provider: Scalars['String']['output'];
  /** An array relationship */
  ridesharefare_to_ridesharerates: Array<Rideshareratetoridesharefares>;
  /** An aggregate relationship */
  ridesharefare_to_ridesharerates_aggregate: Rideshareratetoridesharefares_Aggregate;
  /** additional fee applied to all fares */
  service_fee: Scalars['numeric']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** Table of fare data sourced from rideshare providers organized by market */
export type RidesharefaresRidesharefare_To_RideshareratesArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


/** Table of fare data sourced from rideshare providers organized by market */
export type RidesharefaresRidesharefare_To_Ridesharerates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};

/** aggregated selection of "ridesharefares" */
export type Ridesharefares_Aggregate = {
  __typename?: 'ridesharefares_aggregate';
  aggregate?: Maybe<Ridesharefares_Aggregate_Fields>;
  nodes: Array<Ridesharefares>;
};

/** aggregate fields of "ridesharefares" */
export type Ridesharefares_Aggregate_Fields = {
  __typename?: 'ridesharefares_aggregate_fields';
  avg?: Maybe<Ridesharefares_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Ridesharefares_Max_Fields>;
  min?: Maybe<Ridesharefares_Min_Fields>;
  stddev?: Maybe<Ridesharefares_Stddev_Fields>;
  stddev_pop?: Maybe<Ridesharefares_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ridesharefares_Stddev_Samp_Fields>;
  sum?: Maybe<Ridesharefares_Sum_Fields>;
  var_pop?: Maybe<Ridesharefares_Var_Pop_Fields>;
  var_samp?: Maybe<Ridesharefares_Var_Samp_Fields>;
  variance?: Maybe<Ridesharefares_Variance_Fields>;
};


/** aggregate fields of "ridesharefares" */
export type Ridesharefares_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Ridesharefares_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Ridesharefares_Avg_Fields = {
  __typename?: 'ridesharefares_avg_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "ridesharefares". All fields are combined with a logical 'AND'. */
export type Ridesharefares_Bool_Exp = {
  _and?: InputMaybe<Array<Ridesharefares_Bool_Exp>>;
  _not?: InputMaybe<Ridesharefares_Bool_Exp>;
  _or?: InputMaybe<Array<Ridesharefares_Bool_Exp>>;
  cancelation_fee?: InputMaybe<Numeric_Comparison_Exp>;
  center_geopoint?: InputMaybe<Geometry_Comparison_Exp>;
  center_lat?: InputMaybe<Numeric_Comparison_Exp>;
  center_lon?: InputMaybe<Numeric_Comparison_Exp>;
  city_tax?: InputMaybe<Numeric_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  effective_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiration_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  geofence?: InputMaybe<Geometry_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  initial_cost?: InputMaybe<Numeric_Comparison_Exp>;
  market?: InputMaybe<String_Comparison_Exp>;
  maximum_fare?: InputMaybe<Numeric_Comparison_Exp>;
  minimum_fare?: InputMaybe<Numeric_Comparison_Exp>;
  per_mile?: InputMaybe<Numeric_Comparison_Exp>;
  per_minute?: InputMaybe<Numeric_Comparison_Exp>;
  provider?: InputMaybe<String_Comparison_Exp>;
  ridesharefare_to_ridesharerates?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
  ridesharefare_to_ridesharerates_aggregate?: InputMaybe<Rideshareratetoridesharefares_Aggregate_Bool_Exp>;
  service_fee?: InputMaybe<Numeric_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ridesharefares" */
export enum Ridesharefares_Constraint {
  /** unique or primary key constraint on columns "id" */
  RidesharefaresPkey = 'ridesharefares_pkey',
  /** unique or primary key constraint on columns "effective_date", "provider", "market" */
  RidesharefaresProviderMarketEffectiveDateKey = 'ridesharefares_provider_market_effective_date_key'
}

/** input type for incrementing numeric columns in table "ridesharefares" */
export type Ridesharefares_Inc_Input = {
  /** fee charged for canceling */
  cancelation_fee?: InputMaybe<Scalars['numeric']['input']>;
  /** latitude of center location of providers market */
  center_lat?: InputMaybe<Scalars['numeric']['input']>;
  /** longitude center location of providers market */
  center_lon?: InputMaybe<Scalars['numeric']['input']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost that is applied to all fares */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** highest possible fare */
  maximum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** lowest possible fare */
  minimum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per mile */
  per_mile?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per minute */
  per_minute?: InputMaybe<Scalars['numeric']['input']>;
  /** additional fee applied to all fares */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "ridesharefares" */
export type Ridesharefares_Insert_Input = {
  /** fee charged for canceling */
  cancelation_fee?: InputMaybe<Scalars['numeric']['input']>;
  /** Central latitude/longitude of market, expressed as a "point" type geometry object */
  center_geopoint?: InputMaybe<Scalars['geometry']['input']>;
  /** latitude of center location of providers market */
  center_lat?: InputMaybe<Scalars['numeric']['input']>;
  /** longitude center location of providers market */
  center_lon?: InputMaybe<Scalars['numeric']['input']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** start date of when rate should be used to make contract prices */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** end date of when rate should be used to make contract prices */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** geofence of providers region */
  geofence?: InputMaybe<Scalars['geometry']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost that is applied to all fares */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** the name of the city or area for these rates (e.g. Atlanta, Bronx NYC, etc) */
  market?: InputMaybe<Scalars['String']['input']>;
  /** highest possible fare */
  maximum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** lowest possible fare */
  minimum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per mile */
  per_mile?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per minute */
  per_minute?: InputMaybe<Scalars['numeric']['input']>;
  /** name of rideshare provider (e.g Lyft, Uber, Yellow Taxi) */
  provider?: InputMaybe<Scalars['String']['input']>;
  ridesharefare_to_ridesharerates?: InputMaybe<Rideshareratetoridesharefares_Arr_Rel_Insert_Input>;
  /** additional fee applied to all fares */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Ridesharefares_Max_Fields = {
  __typename?: 'ridesharefares_max_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['numeric']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['numeric']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['numeric']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** start date of when rate should be used to make contract prices */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** end date of when rate should be used to make contract prices */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['numeric']['output']>;
  /** the name of the city or area for these rates (e.g. Atlanta, Bronx NYC, etc) */
  market?: Maybe<Scalars['String']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['numeric']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['numeric']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['numeric']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['numeric']['output']>;
  /** name of rideshare provider (e.g Lyft, Uber, Yellow Taxi) */
  provider?: Maybe<Scalars['String']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Ridesharefares_Min_Fields = {
  __typename?: 'ridesharefares_min_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['numeric']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['numeric']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['numeric']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['numeric']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** start date of when rate should be used to make contract prices */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** end date of when rate should be used to make contract prices */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['numeric']['output']>;
  /** the name of the city or area for these rates (e.g. Atlanta, Bronx NYC, etc) */
  market?: Maybe<Scalars['String']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['numeric']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['numeric']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['numeric']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['numeric']['output']>;
  /** name of rideshare provider (e.g Lyft, Uber, Yellow Taxi) */
  provider?: Maybe<Scalars['String']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "ridesharefares" */
export type Ridesharefares_Mutation_Response = {
  __typename?: 'ridesharefares_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Ridesharefares>;
};

/** input type for inserting object relation for remote table "ridesharefares" */
export type Ridesharefares_Obj_Rel_Insert_Input = {
  data: Ridesharefares_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Ridesharefares_On_Conflict>;
};

/** on_conflict condition type for table "ridesharefares" */
export type Ridesharefares_On_Conflict = {
  constraint: Ridesharefares_Constraint;
  update_columns?: Array<Ridesharefares_Update_Column>;
  where?: InputMaybe<Ridesharefares_Bool_Exp>;
};

/** Ordering options when selecting data from "ridesharefares". */
export type Ridesharefares_Order_By = {
  cancelation_fee?: InputMaybe<Order_By>;
  center_geopoint?: InputMaybe<Order_By>;
  center_lat?: InputMaybe<Order_By>;
  center_lon?: InputMaybe<Order_By>;
  city_tax?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  effective_date?: InputMaybe<Order_By>;
  expiration_date?: InputMaybe<Order_By>;
  geofence?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  initial_cost?: InputMaybe<Order_By>;
  market?: InputMaybe<Order_By>;
  maximum_fare?: InputMaybe<Order_By>;
  minimum_fare?: InputMaybe<Order_By>;
  per_mile?: InputMaybe<Order_By>;
  per_minute?: InputMaybe<Order_By>;
  provider?: InputMaybe<Order_By>;
  ridesharefare_to_ridesharerates_aggregate?: InputMaybe<Rideshareratetoridesharefares_Aggregate_Order_By>;
  service_fee?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: ridesharefares */
export type Ridesharefares_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "ridesharefares" */
export enum Ridesharefares_Select_Column {
  /** column name */
  CancelationFee = 'cancelation_fee',
  /** column name */
  CenterGeopoint = 'center_geopoint',
  /** column name */
  CenterLat = 'center_lat',
  /** column name */
  CenterLon = 'center_lon',
  /** column name */
  CityTax = 'city_tax',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Geofence = 'geofence',
  /** column name */
  Id = 'id',
  /** column name */
  InitialCost = 'initial_cost',
  /** column name */
  Market = 'market',
  /** column name */
  MaximumFare = 'maximum_fare',
  /** column name */
  MinimumFare = 'minimum_fare',
  /** column name */
  PerMile = 'per_mile',
  /** column name */
  PerMinute = 'per_minute',
  /** column name */
  Provider = 'provider',
  /** column name */
  ServiceFee = 'service_fee',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "ridesharefares" */
export type Ridesharefares_Set_Input = {
  /** fee charged for canceling */
  cancelation_fee?: InputMaybe<Scalars['numeric']['input']>;
  /** Central latitude/longitude of market, expressed as a "point" type geometry object */
  center_geopoint?: InputMaybe<Scalars['geometry']['input']>;
  /** latitude of center location of providers market */
  center_lat?: InputMaybe<Scalars['numeric']['input']>;
  /** longitude center location of providers market */
  center_lon?: InputMaybe<Scalars['numeric']['input']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** start date of when rate should be used to make contract prices */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** end date of when rate should be used to make contract prices */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** geofence of providers region */
  geofence?: InputMaybe<Scalars['geometry']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost that is applied to all fares */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** the name of the city or area for these rates (e.g. Atlanta, Bronx NYC, etc) */
  market?: InputMaybe<Scalars['String']['input']>;
  /** highest possible fare */
  maximum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** lowest possible fare */
  minimum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per mile */
  per_mile?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per minute */
  per_minute?: InputMaybe<Scalars['numeric']['input']>;
  /** name of rideshare provider (e.g Lyft, Uber, Yellow Taxi) */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** additional fee applied to all fares */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Ridesharefares_Stddev_Fields = {
  __typename?: 'ridesharefares_stddev_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Ridesharefares_Stddev_Pop_Fields = {
  __typename?: 'ridesharefares_stddev_pop_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Ridesharefares_Stddev_Samp_Fields = {
  __typename?: 'ridesharefares_stddev_samp_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "ridesharefares" */
export type Ridesharefares_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ridesharefares_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ridesharefares_Stream_Cursor_Value_Input = {
  /** fee charged for canceling */
  cancelation_fee?: InputMaybe<Scalars['numeric']['input']>;
  /** Central latitude/longitude of market, expressed as a "point" type geometry object */
  center_geopoint?: InputMaybe<Scalars['geometry']['input']>;
  /** latitude of center location of providers market */
  center_lat?: InputMaybe<Scalars['numeric']['input']>;
  /** longitude center location of providers market */
  center_lon?: InputMaybe<Scalars['numeric']['input']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: InputMaybe<Scalars['numeric']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** start date of when rate should be used to make contract prices */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** end date of when rate should be used to make contract prices */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** geofence of providers region */
  geofence?: InputMaybe<Scalars['geometry']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost that is applied to all fares */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** the name of the city or area for these rates (e.g. Atlanta, Bronx NYC, etc) */
  market?: InputMaybe<Scalars['String']['input']>;
  /** highest possible fare */
  maximum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** lowest possible fare */
  minimum_fare?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per mile */
  per_mile?: InputMaybe<Scalars['numeric']['input']>;
  /** charge per minute */
  per_minute?: InputMaybe<Scalars['numeric']['input']>;
  /** name of rideshare provider (e.g Lyft, Uber, Yellow Taxi) */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** additional fee applied to all fares */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Ridesharefares_Sum_Fields = {
  __typename?: 'ridesharefares_sum_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['numeric']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['numeric']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['numeric']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['numeric']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['numeric']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['numeric']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['numeric']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['numeric']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "ridesharefares" */
export enum Ridesharefares_Update_Column {
  /** column name */
  CancelationFee = 'cancelation_fee',
  /** column name */
  CenterGeopoint = 'center_geopoint',
  /** column name */
  CenterLat = 'center_lat',
  /** column name */
  CenterLon = 'center_lon',
  /** column name */
  CityTax = 'city_tax',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Geofence = 'geofence',
  /** column name */
  Id = 'id',
  /** column name */
  InitialCost = 'initial_cost',
  /** column name */
  Market = 'market',
  /** column name */
  MaximumFare = 'maximum_fare',
  /** column name */
  MinimumFare = 'minimum_fare',
  /** column name */
  PerMile = 'per_mile',
  /** column name */
  PerMinute = 'per_minute',
  /** column name */
  Provider = 'provider',
  /** column name */
  ServiceFee = 'service_fee',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Ridesharefares_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Ridesharefares_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Ridesharefares_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ridesharefares_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Ridesharefares_Var_Pop_Fields = {
  __typename?: 'ridesharefares_var_pop_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Ridesharefares_Var_Samp_Fields = {
  __typename?: 'ridesharefares_var_samp_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Ridesharefares_Variance_Fields = {
  __typename?: 'ridesharefares_variance_fields';
  /** fee charged for canceling */
  cancelation_fee?: Maybe<Scalars['Float']['output']>;
  /** latitude of center location of providers market */
  center_lat?: Maybe<Scalars['Float']['output']>;
  /** longitude center location of providers market */
  center_lon?: Maybe<Scalars['Float']['output']>;
  /** certain cities charge tax to rideshares, and these are added to the fare */
  city_tax?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost that is applied to all fares */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** highest possible fare */
  maximum_fare?: Maybe<Scalars['Float']['output']>;
  /** lowest possible fare */
  minimum_fare?: Maybe<Scalars['Float']['output']>;
  /** charge per mile */
  per_mile?: Maybe<Scalars['Float']['output']>;
  /** charge per minute */
  per_minute?: Maybe<Scalars['Float']['output']>;
  /** additional fee applied to all fares */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** Table of rideshare rates used to calculate a customer's stranded rates. Assigned to a customer's raterulegroup */
export type Ridesharerates = {
  __typename?: 'ridesharerates';
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** Longer description of the rideshare rate */
  description: Scalars['String']['output'];
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date: Scalars['timestamptz']['output'];
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date: Scalars['timestamptz']['output'];
  id: Scalars['bigint']['output'];
  /** base cost for all estimated ride rates */
  initial_cost: Scalars['numeric']['output'];
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost: Scalars['numeric']['output'];
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost: Scalars['numeric']['output'];
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name: Scalars['String']['output'];
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate: Scalars['numeric']['output'];
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate: Scalars['numeric']['output'];
  /** An array relationship */
  raterulegroups: Array<Raterulegroups>;
  /** An aggregate relationship */
  raterulegroups_aggregate: Raterulegroups_Aggregate;
  /** An object relationship */
  region?: Maybe<Regions>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  ridesharerate_to_ridesharefares: Array<Rideshareratetoridesharefares>;
  /** An aggregate relationship */
  ridesharerate_to_ridesharefares_aggregate: Rideshareratetoridesharefares_Aggregate;
  /** additional fee added to all estimated ride costs */
  service_fee: Scalars['numeric']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};


/** Table of rideshare rates used to calculate a customer's stranded rates. Assigned to a customer's raterulegroup */
export type RideshareratesRaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


/** Table of rideshare rates used to calculate a customer's stranded rates. Assigned to a customer's raterulegroup */
export type RideshareratesRaterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


/** Table of rideshare rates used to calculate a customer's stranded rates. Assigned to a customer's raterulegroup */
export type RideshareratesRidesharerate_To_RidesharefaresArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


/** Table of rideshare rates used to calculate a customer's stranded rates. Assigned to a customer's raterulegroup */
export type RideshareratesRidesharerate_To_Ridesharefares_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};

/** aggregated selection of "ridesharerates" */
export type Ridesharerates_Aggregate = {
  __typename?: 'ridesharerates_aggregate';
  aggregate?: Maybe<Ridesharerates_Aggregate_Fields>;
  nodes: Array<Ridesharerates>;
};

export type Ridesharerates_Aggregate_Bool_Exp = {
  count?: InputMaybe<Ridesharerates_Aggregate_Bool_Exp_Count>;
};

export type Ridesharerates_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Ridesharerates_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ridesharerates" */
export type Ridesharerates_Aggregate_Fields = {
  __typename?: 'ridesharerates_aggregate_fields';
  avg?: Maybe<Ridesharerates_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Ridesharerates_Max_Fields>;
  min?: Maybe<Ridesharerates_Min_Fields>;
  stddev?: Maybe<Ridesharerates_Stddev_Fields>;
  stddev_pop?: Maybe<Ridesharerates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ridesharerates_Stddev_Samp_Fields>;
  sum?: Maybe<Ridesharerates_Sum_Fields>;
  var_pop?: Maybe<Ridesharerates_Var_Pop_Fields>;
  var_samp?: Maybe<Ridesharerates_Var_Samp_Fields>;
  variance?: Maybe<Ridesharerates_Variance_Fields>;
};


/** aggregate fields of "ridesharerates" */
export type Ridesharerates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "ridesharerates" */
export type Ridesharerates_Aggregate_Order_By = {
  avg?: InputMaybe<Ridesharerates_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Ridesharerates_Max_Order_By>;
  min?: InputMaybe<Ridesharerates_Min_Order_By>;
  stddev?: InputMaybe<Ridesharerates_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Ridesharerates_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Ridesharerates_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Ridesharerates_Sum_Order_By>;
  var_pop?: InputMaybe<Ridesharerates_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Ridesharerates_Var_Samp_Order_By>;
  variance?: InputMaybe<Ridesharerates_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ridesharerates" */
export type Ridesharerates_Arr_Rel_Insert_Input = {
  data: Array<Ridesharerates_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Ridesharerates_On_Conflict>;
};

/** aggregate avg on columns */
export type Ridesharerates_Avg_Fields = {
  __typename?: 'ridesharerates_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "ridesharerates" */
export type Ridesharerates_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ridesharerates". All fields are combined with a logical 'AND'. */
export type Ridesharerates_Bool_Exp = {
  _and?: InputMaybe<Array<Ridesharerates_Bool_Exp>>;
  _not?: InputMaybe<Ridesharerates_Bool_Exp>;
  _or?: InputMaybe<Array<Ridesharerates_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  effective_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiration_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  initial_cost?: InputMaybe<Numeric_Comparison_Exp>;
  maximum_ride_cost?: InputMaybe<Numeric_Comparison_Exp>;
  minimum_ride_cost?: InputMaybe<Numeric_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  per_mile_rate?: InputMaybe<Numeric_Comparison_Exp>;
  per_minute_rate?: InputMaybe<Numeric_Comparison_Exp>;
  raterulegroups?: InputMaybe<Raterulegroups_Bool_Exp>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Bool_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  ridesharerate_to_ridesharefares?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
  ridesharerate_to_ridesharefares_aggregate?: InputMaybe<Rideshareratetoridesharefares_Aggregate_Bool_Exp>;
  service_fee?: InputMaybe<Numeric_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ridesharerates" */
export enum Ridesharerates_Constraint {
  /** unique or primary key constraint on columns "name" */
  RideshareratesNameKey = 'ridesharerates_name_key',
  /** unique or primary key constraint on columns "id" */
  RideshareratesPkey = 'ridesharerates_pkey'
}

/** input type for incrementing numeric columns in table "ridesharerates" */
export type Ridesharerates_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "ridesharerates" */
export type Ridesharerates_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Longer description of the rideshare rate */
  description?: InputMaybe<Scalars['String']['input']>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: InputMaybe<Scalars['String']['input']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  raterulegroups?: InputMaybe<Raterulegroups_Arr_Rel_Insert_Input>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  ridesharerate_to_ridesharefares?: InputMaybe<Rideshareratetoridesharefares_Arr_Rel_Insert_Input>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Ridesharerates_Max_Fields = {
  __typename?: 'ridesharerates_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Longer description of the rideshare rate */
  description?: Maybe<Scalars['String']['output']>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['numeric']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: Maybe<Scalars['String']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "ridesharerates" */
export type Ridesharerates_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** Longer description of the rideshare rate */
  description?: InputMaybe<Order_By>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: InputMaybe<Order_By>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Ridesharerates_Min_Fields = {
  __typename?: 'ridesharerates_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Longer description of the rideshare rate */
  description?: Maybe<Scalars['String']['output']>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: Maybe<Scalars['timestamptz']['output']>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['numeric']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: Maybe<Scalars['String']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['numeric']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "ridesharerates" */
export type Ridesharerates_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** Longer description of the rideshare rate */
  description?: InputMaybe<Order_By>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: InputMaybe<Order_By>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "ridesharerates" */
export type Ridesharerates_Mutation_Response = {
  __typename?: 'ridesharerates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Ridesharerates>;
};

/** input type for inserting object relation for remote table "ridesharerates" */
export type Ridesharerates_Obj_Rel_Insert_Input = {
  data: Ridesharerates_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Ridesharerates_On_Conflict>;
};

/** on_conflict condition type for table "ridesharerates" */
export type Ridesharerates_On_Conflict = {
  constraint: Ridesharerates_Constraint;
  update_columns?: Array<Ridesharerates_Update_Column>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};

/** Ordering options when selecting data from "ridesharerates". */
export type Ridesharerates_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  effective_date?: InputMaybe<Order_By>;
  expiration_date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  initial_cost?: InputMaybe<Order_By>;
  maximum_ride_cost?: InputMaybe<Order_By>;
  minimum_ride_cost?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  per_mile_rate?: InputMaybe<Order_By>;
  per_minute_rate?: InputMaybe<Order_By>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  ridesharerate_to_ridesharefares_aggregate?: InputMaybe<Rideshareratetoridesharefares_Aggregate_Order_By>;
  service_fee?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: ridesharerates */
export type Ridesharerates_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "ridesharerates" */
export enum Ridesharerates_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  InitialCost = 'initial_cost',
  /** column name */
  MaximumRideCost = 'maximum_ride_cost',
  /** column name */
  MinimumRideCost = 'minimum_ride_cost',
  /** column name */
  Name = 'name',
  /** column name */
  PerMileRate = 'per_mile_rate',
  /** column name */
  PerMinuteRate = 'per_minute_rate',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  ServiceFee = 'service_fee',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "ridesharerates" */
export type Ridesharerates_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Longer description of the rideshare rate */
  description?: InputMaybe<Scalars['String']['input']>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: InputMaybe<Scalars['String']['input']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Ridesharerates_Stddev_Fields = {
  __typename?: 'ridesharerates_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "ridesharerates" */
export type Ridesharerates_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Ridesharerates_Stddev_Pop_Fields = {
  __typename?: 'ridesharerates_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "ridesharerates" */
export type Ridesharerates_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Ridesharerates_Stddev_Samp_Fields = {
  __typename?: 'ridesharerates_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "ridesharerates" */
export type Ridesharerates_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "ridesharerates" */
export type Ridesharerates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ridesharerates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ridesharerates_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Longer description of the rideshare rate */
  description?: InputMaybe<Scalars['String']['input']>;
  /** start date when rideshare rate should be used to create rates for a contract */
  effective_date?: InputMaybe<Scalars['timestamptz']['input']>;
  /** end date when rideshare rate should be used to create rates for a contract */
  expiration_date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Scalars['numeric']['input']>;
  /** short description of rate (e.g. Q1 2025 Richmond Rates */
  name?: InputMaybe<Scalars['String']['input']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Scalars['numeric']['input']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Scalars['numeric']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Ridesharerates_Sum_Fields = {
  __typename?: 'ridesharerates_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['numeric']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['numeric']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['numeric']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['numeric']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "ridesharerates" */
export type Ridesharerates_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** update columns of table "ridesharerates" */
export enum Ridesharerates_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  EffectiveDate = 'effective_date',
  /** column name */
  ExpirationDate = 'expiration_date',
  /** column name */
  Id = 'id',
  /** column name */
  InitialCost = 'initial_cost',
  /** column name */
  MaximumRideCost = 'maximum_ride_cost',
  /** column name */
  MinimumRideCost = 'minimum_ride_cost',
  /** column name */
  Name = 'name',
  /** column name */
  PerMileRate = 'per_mile_rate',
  /** column name */
  PerMinuteRate = 'per_minute_rate',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  ServiceFee = 'service_fee',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Ridesharerates_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Ridesharerates_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Ridesharerates_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ridesharerates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Ridesharerates_Var_Pop_Fields = {
  __typename?: 'ridesharerates_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "ridesharerates" */
export type Ridesharerates_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Ridesharerates_Var_Samp_Fields = {
  __typename?: 'ridesharerates_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "ridesharerates" */
export type Ridesharerates_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Ridesharerates_Variance_Fields = {
  __typename?: 'ridesharerates_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** base cost for all estimated ride rates */
  initial_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: Maybe<Scalars['Float']['output']>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: Maybe<Scalars['Float']['output']>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: Maybe<Scalars['Float']['output']>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: Maybe<Scalars['Float']['output']>;
  /** additional fee added to all estimated ride costs */
  service_fee?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "ridesharerates" */
export type Ridesharerates_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  /** base cost for all estimated ride rates */
  initial_cost?: InputMaybe<Order_By>;
  /** provider will not charge more than this amount for a ride */
  maximum_ride_cost?: InputMaybe<Order_By>;
  /** provider will not charge less than this amount for a ride */
  minimum_ride_cost?: InputMaybe<Order_By>;
  /** per mile rate used to estimate rideshare cost */
  per_mile_rate?: InputMaybe<Order_By>;
  /** per minute rate used to estimate rideshare cost */
  per_minute_rate?: InputMaybe<Order_By>;
  /** relates the ridesharerate to a HopDrive region. The rate may or may not cover the entire region */
  region_id?: InputMaybe<Order_By>;
  /** additional fee added to all estimated ride costs */
  service_fee?: InputMaybe<Order_By>;
};

/** Relationship table relating HopDrive ridesharerates used in customer pricing to ridesharefares, which contains provider data */
export type Rideshareratetoridesharefares = {
  __typename?: 'rideshareratetoridesharefares';
  createdat: Scalars['timestamp']['output'];
  createdby?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  rideshare_fare_id: Scalars['bigint']['output'];
  rideshare_rate_id: Scalars['bigint']['output'];
  /** An object relationship */
  ridesharefare: Ridesharefares;
  /** An object relationship */
  ridesharerate: Ridesharerates;
  updatedat: Scalars['timestamptz']['output'];
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Aggregate = {
  __typename?: 'rideshareratetoridesharefares_aggregate';
  aggregate?: Maybe<Rideshareratetoridesharefares_Aggregate_Fields>;
  nodes: Array<Rideshareratetoridesharefares>;
};

export type Rideshareratetoridesharefares_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rideshareratetoridesharefares_Aggregate_Bool_Exp_Count>;
};

export type Rideshareratetoridesharefares_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Aggregate_Fields = {
  __typename?: 'rideshareratetoridesharefares_aggregate_fields';
  avg?: Maybe<Rideshareratetoridesharefares_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rideshareratetoridesharefares_Max_Fields>;
  min?: Maybe<Rideshareratetoridesharefares_Min_Fields>;
  stddev?: Maybe<Rideshareratetoridesharefares_Stddev_Fields>;
  stddev_pop?: Maybe<Rideshareratetoridesharefares_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rideshareratetoridesharefares_Stddev_Samp_Fields>;
  sum?: Maybe<Rideshareratetoridesharefares_Sum_Fields>;
  var_pop?: Maybe<Rideshareratetoridesharefares_Var_Pop_Fields>;
  var_samp?: Maybe<Rideshareratetoridesharefares_Var_Samp_Fields>;
  variance?: Maybe<Rideshareratetoridesharefares_Variance_Fields>;
};


/** aggregate fields of "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Aggregate_Order_By = {
  avg?: InputMaybe<Rideshareratetoridesharefares_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rideshareratetoridesharefares_Max_Order_By>;
  min?: InputMaybe<Rideshareratetoridesharefares_Min_Order_By>;
  stddev?: InputMaybe<Rideshareratetoridesharefares_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rideshareratetoridesharefares_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rideshareratetoridesharefares_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rideshareratetoridesharefares_Sum_Order_By>;
  var_pop?: InputMaybe<Rideshareratetoridesharefares_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rideshareratetoridesharefares_Var_Samp_Order_By>;
  variance?: InputMaybe<Rideshareratetoridesharefares_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Arr_Rel_Insert_Input = {
  data: Array<Rideshareratetoridesharefares_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rideshareratetoridesharefares_On_Conflict>;
};

/** aggregate avg on columns */
export type Rideshareratetoridesharefares_Avg_Fields = {
  __typename?: 'rideshareratetoridesharefares_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rideshareratetoridesharefares". All fields are combined with a logical 'AND'. */
export type Rideshareratetoridesharefares_Bool_Exp = {
  _and?: InputMaybe<Array<Rideshareratetoridesharefares_Bool_Exp>>;
  _not?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
  _or?: InputMaybe<Array<Rideshareratetoridesharefares_Bool_Exp>>;
  createdat?: InputMaybe<Timestamp_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  rideshare_fare_id?: InputMaybe<Bigint_Comparison_Exp>;
  rideshare_rate_id?: InputMaybe<Bigint_Comparison_Exp>;
  ridesharefare?: InputMaybe<Ridesharefares_Bool_Exp>;
  ridesharerate?: InputMaybe<Ridesharerates_Bool_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rideshareratetoridesharefares" */
export enum Rideshareratetoridesharefares_Constraint {
  /** unique or primary key constraint on columns "id" */
  RideshareratetoridesharefaresPkey = 'rideshareratetoridesharefares_pkey'
}

/** input type for incrementing numeric columns in table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_fare_id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamp']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_fare_id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  ridesharefare?: InputMaybe<Ridesharefares_Obj_Rel_Insert_Input>;
  ridesharerate?: InputMaybe<Ridesharerates_Obj_Rel_Insert_Input>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rideshareratetoridesharefares_Max_Fields = {
  __typename?: 'rideshareratetoridesharefares_max_fields';
  createdat?: Maybe<Scalars['timestamp']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  rideshare_fare_id?: Maybe<Scalars['bigint']['output']>;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rideshareratetoridesharefares_Min_Fields = {
  __typename?: 'rideshareratetoridesharefares_min_fields';
  createdat?: Maybe<Scalars['timestamp']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  rideshare_fare_id?: Maybe<Scalars['bigint']['output']>;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Mutation_Response = {
  __typename?: 'rideshareratetoridesharefares_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rideshareratetoridesharefares>;
};

/** on_conflict condition type for table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_On_Conflict = {
  constraint: Rideshareratetoridesharefares_Constraint;
  update_columns?: Array<Rideshareratetoridesharefares_Update_Column>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};

/** Ordering options when selecting data from "rideshareratetoridesharefares". */
export type Rideshareratetoridesharefares_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
  ridesharefare?: InputMaybe<Ridesharefares_Order_By>;
  ridesharerate?: InputMaybe<Ridesharerates_Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rideshareratetoridesharefares */
export type Rideshareratetoridesharefares_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "rideshareratetoridesharefares" */
export enum Rideshareratetoridesharefares_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  RideshareFareId = 'rideshare_fare_id',
  /** column name */
  RideshareRateId = 'rideshare_rate_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamp']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_fare_id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rideshareratetoridesharefares_Stddev_Fields = {
  __typename?: 'rideshareratetoridesharefares_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rideshareratetoridesharefares_Stddev_Pop_Fields = {
  __typename?: 'rideshareratetoridesharefares_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rideshareratetoridesharefares_Stddev_Samp_Fields = {
  __typename?: 'rideshareratetoridesharefares_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rideshareratetoridesharefares_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rideshareratetoridesharefares_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamp']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_fare_id?: InputMaybe<Scalars['bigint']['input']>;
  rideshare_rate_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rideshareratetoridesharefares_Sum_Fields = {
  __typename?: 'rideshareratetoridesharefares_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  rideshare_fare_id?: Maybe<Scalars['bigint']['output']>;
  rideshare_rate_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** update columns of table "rideshareratetoridesharefares" */
export enum Rideshareratetoridesharefares_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  RideshareFareId = 'rideshare_fare_id',
  /** column name */
  RideshareRateId = 'rideshare_rate_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Rideshareratetoridesharefares_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rideshareratetoridesharefares_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rideshareratetoridesharefares_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rideshareratetoridesharefares_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rideshareratetoridesharefares_Var_Pop_Fields = {
  __typename?: 'rideshareratetoridesharefares_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rideshareratetoridesharefares_Var_Samp_Fields = {
  __typename?: 'rideshareratetoridesharefares_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rideshareratetoridesharefares_Variance_Fields = {
  __typename?: 'rideshareratetoridesharefares_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  rideshare_fare_id?: Maybe<Scalars['Float']['output']>;
  rideshare_rate_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rideshareratetoridesharefares" */
export type Rideshareratetoridesharefares_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  rideshare_fare_id?: InputMaybe<Order_By>;
  rideshare_rate_id?: InputMaybe<Order_By>;
};

/** Role type corresponds to the code in the eventlogs table */
export type Roletypes = {
  __typename?: 'roletypes';
  description: Scalars['String']['output'];
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  id: Scalars['smallint']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
};


/** Role type corresponds to the code in the eventlogs table */
export type RoletypesEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** Role type corresponds to the code in the eventlogs table */
export type RoletypesEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


/** Role type corresponds to the code in the eventlogs table */
export type RoletypesUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


/** Role type corresponds to the code in the eventlogs table */
export type RoletypesUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** aggregated selection of "roletypes" */
export type Roletypes_Aggregate = {
  __typename?: 'roletypes_aggregate';
  aggregate?: Maybe<Roletypes_Aggregate_Fields>;
  nodes: Array<Roletypes>;
};

/** aggregate fields of "roletypes" */
export type Roletypes_Aggregate_Fields = {
  __typename?: 'roletypes_aggregate_fields';
  avg?: Maybe<Roletypes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Roletypes_Max_Fields>;
  min?: Maybe<Roletypes_Min_Fields>;
  stddev?: Maybe<Roletypes_Stddev_Fields>;
  stddev_pop?: Maybe<Roletypes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Roletypes_Stddev_Samp_Fields>;
  sum?: Maybe<Roletypes_Sum_Fields>;
  var_pop?: Maybe<Roletypes_Var_Pop_Fields>;
  var_samp?: Maybe<Roletypes_Var_Samp_Fields>;
  variance?: Maybe<Roletypes_Variance_Fields>;
};


/** aggregate fields of "roletypes" */
export type Roletypes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Roletypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Roletypes_Avg_Fields = {
  __typename?: 'roletypes_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "roletypes". All fields are combined with a logical 'AND'. */
export type Roletypes_Bool_Exp = {
  _and?: InputMaybe<Array<Roletypes_Bool_Exp>>;
  _not?: InputMaybe<Roletypes_Bool_Exp>;
  _or?: InputMaybe<Array<Roletypes_Bool_Exp>>;
  description?: InputMaybe<String_Comparison_Exp>;
  eventlogs?: InputMaybe<Eventlogs_Bool_Exp>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Bool_Exp>;
  id?: InputMaybe<Smallint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  users?: InputMaybe<Users_Bool_Exp>;
  users_aggregate?: InputMaybe<Users_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "roletypes" */
export enum Roletypes_Constraint {
  /** unique or primary key constraint on columns "name" */
  RoletypesNameKey = 'roletypes_name_key',
  /** unique or primary key constraint on columns "id" */
  RoletypesPkey = 'roletypes_pkey'
}

/** input type for incrementing numeric columns in table "roletypes" */
export type Roletypes_Inc_Input = {
  id?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "roletypes" */
export type Roletypes_Insert_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  eventlogs?: InputMaybe<Eventlogs_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['smallint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  users?: InputMaybe<Users_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Roletypes_Max_Fields = {
  __typename?: 'roletypes_max_fields';
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['smallint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Roletypes_Min_Fields = {
  __typename?: 'roletypes_min_fields';
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['smallint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "roletypes" */
export type Roletypes_Mutation_Response = {
  __typename?: 'roletypes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Roletypes>;
};

/** input type for inserting object relation for remote table "roletypes" */
export type Roletypes_Obj_Rel_Insert_Input = {
  data: Roletypes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Roletypes_On_Conflict>;
};

/** on_conflict condition type for table "roletypes" */
export type Roletypes_On_Conflict = {
  constraint: Roletypes_Constraint;
  update_columns?: Array<Roletypes_Update_Column>;
  where?: InputMaybe<Roletypes_Bool_Exp>;
};

/** Ordering options when selecting data from "roletypes". */
export type Roletypes_Order_By = {
  description?: InputMaybe<Order_By>;
  eventlogs_aggregate?: InputMaybe<Eventlogs_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  users_aggregate?: InputMaybe<Users_Aggregate_Order_By>;
};

/** primary key columns input for table: roletypes */
export type Roletypes_Pk_Columns_Input = {
  id: Scalars['smallint']['input'];
};

/** select columns of table "roletypes" */
export enum Roletypes_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "roletypes" */
export type Roletypes_Set_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['smallint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Roletypes_Stddev_Fields = {
  __typename?: 'roletypes_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Roletypes_Stddev_Pop_Fields = {
  __typename?: 'roletypes_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Roletypes_Stddev_Samp_Fields = {
  __typename?: 'roletypes_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "roletypes" */
export type Roletypes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Roletypes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Roletypes_Stream_Cursor_Value_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['smallint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Roletypes_Sum_Fields = {
  __typename?: 'roletypes_sum_fields';
  id?: Maybe<Scalars['smallint']['output']>;
};

/** update columns of table "roletypes" */
export enum Roletypes_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Roletypes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Roletypes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Roletypes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Roletypes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Roletypes_Var_Pop_Fields = {
  __typename?: 'roletypes_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Roletypes_Var_Samp_Fields = {
  __typename?: 'roletypes_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Roletypes_Variance_Fields = {
  __typename?: 'roletypes_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type Scenarios = {
  __typename?: 'scenarios';
  /** An array relationship */
  bundletoscenarios: Array<Bundletoscenarios>;
  /** An aggregate relationship */
  bundletoscenarios_aggregate: Bundletoscenarios_Aggregate;
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: Maybe<Scalars['jsonb']['output']>;
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** an auto-incrementing id for the record */
  id: Scalars['bigint']['output'];
  /** An array relationship */
  moves: Array<Scenariotomoves>;
  /** An aggregate relationship */
  moves_aggregate: Scenariotomoves_Aggregate;
  /** id for the parent scenario type this is derived from */
  scenario_key: Scalars['String']['output'];
  /** An array relationship */
  scenarios_coordinatedplantoscenarios: Array<Coordinatedplantoscenarios>;
  /** An aggregate relationship */
  scenarios_coordinatedplantoscenarios_aggregate: Coordinatedplantoscenarios_Aggregate;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status: Scalars['String']['output'];
  /** An object relationship */
  type: Scenariotypes;
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: Maybe<Scalars['jsonb']['output']>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosBundletoscenariosArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosBundletoscenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosConfigArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosMovesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosScenarios_CoordinatedplantoscenariosArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosScenarios_Coordinatedplantoscenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


/** Scenarios created by the bundler to combine drive moves and ride intentions into bundles for making offers to drivers. A scenario will contain 1 or more drive moves as well as a configuration for the implementation of that specific scenario type. While a bundle is transient, a scenario will be permanently created by the bundler. */
export type ScenariosWorkflow_DataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "scenarios" */
export type Scenarios_Aggregate = {
  __typename?: 'scenarios_aggregate';
  aggregate?: Maybe<Scenarios_Aggregate_Fields>;
  nodes: Array<Scenarios>;
};

export type Scenarios_Aggregate_Bool_Exp = {
  count?: InputMaybe<Scenarios_Aggregate_Bool_Exp_Count>;
};

export type Scenarios_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Scenarios_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Scenarios_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "scenarios" */
export type Scenarios_Aggregate_Fields = {
  __typename?: 'scenarios_aggregate_fields';
  avg?: Maybe<Scenarios_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Scenarios_Max_Fields>;
  min?: Maybe<Scenarios_Min_Fields>;
  stddev?: Maybe<Scenarios_Stddev_Fields>;
  stddev_pop?: Maybe<Scenarios_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Scenarios_Stddev_Samp_Fields>;
  sum?: Maybe<Scenarios_Sum_Fields>;
  var_pop?: Maybe<Scenarios_Var_Pop_Fields>;
  var_samp?: Maybe<Scenarios_Var_Samp_Fields>;
  variance?: Maybe<Scenarios_Variance_Fields>;
};


/** aggregate fields of "scenarios" */
export type Scenarios_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Scenarios_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "scenarios" */
export type Scenarios_Aggregate_Order_By = {
  avg?: InputMaybe<Scenarios_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Scenarios_Max_Order_By>;
  min?: InputMaybe<Scenarios_Min_Order_By>;
  stddev?: InputMaybe<Scenarios_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Scenarios_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Scenarios_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Scenarios_Sum_Order_By>;
  var_pop?: InputMaybe<Scenarios_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Scenarios_Var_Samp_Order_By>;
  variance?: InputMaybe<Scenarios_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Scenarios_Append_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "scenarios" */
export type Scenarios_Arr_Rel_Insert_Input = {
  data: Array<Scenarios_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Scenarios_On_Conflict>;
};

/** aggregate avg on columns */
export type Scenarios_Avg_Fields = {
  __typename?: 'scenarios_avg_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "scenarios" */
export type Scenarios_Avg_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "scenarios". All fields are combined with a logical 'AND'. */
export type Scenarios_Bool_Exp = {
  _and?: InputMaybe<Array<Scenarios_Bool_Exp>>;
  _not?: InputMaybe<Scenarios_Bool_Exp>;
  _or?: InputMaybe<Array<Scenarios_Bool_Exp>>;
  bundletoscenarios?: InputMaybe<Bundletoscenarios_Bool_Exp>;
  bundletoscenarios_aggregate?: InputMaybe<Bundletoscenarios_Aggregate_Bool_Exp>;
  config?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  moves?: InputMaybe<Scenariotomoves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Scenariotomoves_Aggregate_Bool_Exp>;
  scenario_key?: InputMaybe<String_Comparison_Exp>;
  scenarios_coordinatedplantoscenarios?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
  scenarios_coordinatedplantoscenarios_aggregate?: InputMaybe<Coordinatedplantoscenarios_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<Scenariotypes_Bool_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  workflow_data?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "scenarios" */
export enum Scenarios_Constraint {
  /** unique or primary key constraint on columns "id" */
  ScenariosPkey = 'scenarios_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Scenarios_Delete_At_Path_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Array<Scalars['String']['input']>>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Scenarios_Delete_Elem_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['Int']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Scenarios_Delete_Key_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['String']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "scenarios" */
export type Scenarios_Inc_Input = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "scenarios" */
export type Scenarios_Insert_Input = {
  bundletoscenarios?: InputMaybe<Bundletoscenarios_Arr_Rel_Insert_Input>;
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  moves?: InputMaybe<Scenariotomoves_Arr_Rel_Insert_Input>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: InputMaybe<Scalars['String']['input']>;
  scenarios_coordinatedplantoscenarios?: InputMaybe<Coordinatedplantoscenarios_Arr_Rel_Insert_Input>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scenariotypes_Obj_Rel_Insert_Input>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type Scenarios_Max_Fields = {
  __typename?: 'scenarios_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: Maybe<Scalars['String']['output']>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "scenarios" */
export type Scenarios_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: InputMaybe<Order_By>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Scenarios_Min_Fields = {
  __typename?: 'scenarios_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: Maybe<Scalars['String']['output']>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "scenarios" */
export type Scenarios_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: InputMaybe<Order_By>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "scenarios" */
export type Scenarios_Mutation_Response = {
  __typename?: 'scenarios_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Scenarios>;
};

/** input type for inserting object relation for remote table "scenarios" */
export type Scenarios_Obj_Rel_Insert_Input = {
  data: Scenarios_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Scenarios_On_Conflict>;
};

/** on_conflict condition type for table "scenarios" */
export type Scenarios_On_Conflict = {
  constraint: Scenarios_Constraint;
  update_columns?: Array<Scenarios_Update_Column>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};

/** Ordering options when selecting data from "scenarios". */
export type Scenarios_Order_By = {
  bundletoscenarios_aggregate?: InputMaybe<Bundletoscenarios_Aggregate_Order_By>;
  config?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Scenariotomoves_Aggregate_Order_By>;
  scenario_key?: InputMaybe<Order_By>;
  scenarios_coordinatedplantoscenarios_aggregate?: InputMaybe<Coordinatedplantoscenarios_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Scenariotypes_Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflow_data?: InputMaybe<Order_By>;
};

/** primary key columns input for table: scenarios */
export type Scenarios_Pk_Columns_Input = {
  /** an auto-incrementing id for the record */
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Scenarios_Prepend_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "scenarios" */
export enum Scenarios_Select_Column {
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  ScenarioKey = 'scenario_key',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowData = 'workflow_data'
}

/** input type for updating data in table "scenarios" */
export type Scenarios_Set_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: InputMaybe<Scalars['String']['input']>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type Scenarios_Stddev_Fields = {
  __typename?: 'scenarios_stddev_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "scenarios" */
export type Scenarios_Stddev_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Scenarios_Stddev_Pop_Fields = {
  __typename?: 'scenarios_stddev_pop_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "scenarios" */
export type Scenarios_Stddev_Pop_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Scenarios_Stddev_Samp_Fields = {
  __typename?: 'scenarios_stddev_samp_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "scenarios" */
export type Scenarios_Stddev_Samp_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "scenarios" */
export type Scenarios_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Scenarios_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Scenarios_Stream_Cursor_Value_Input = {
  /** a dynamic json object which can hold settings for the scenario. The schema of this JSON is dictated by the scenario type. */
  config?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the parent scenario type this is derived from */
  scenario_key?: InputMaybe<Scalars['String']['input']>;
  /** a string which is always lowercase and only alpha characters with words that describe the state of the scenario. Valid values are: new - The scenario has only just been created but is not yet ready for bundling. ready - The scenario building is completed and is now ready for bundling. dispatched - The scenario was placed into a bundle and then offer(s) were made for the bundle to drivers. You might wonder why the scenario has a dispatched status if the parent bundle also has this status. This is because a bundle is a group of scenarios that collectively can be dispatched to a driver, but then one of the collections might need to be treated separately in the event of something unexpected happening in the field. Thus it's important to reflect the status of dispatched directly in the scenario too. Each time the parent bundle is dispatched, the bundler will keep the status of the child scenarios in sync.  declined - The scenario, already part of a bundle, and already dispatched to a specific driver, was then declined after accepting the bundle. We call this a late decline. deprecated - The move(s) under this scenario have been unplanned by manual dispatch. This can cause them to plan them in a different way that this scenario implies. */
  status?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** a dynamic json object that collects data captured by a driver during the execution of the scenario workflow. */
  workflow_data?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type Scenarios_Sum_Fields = {
  __typename?: 'scenarios_sum_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "scenarios" */
export type Scenarios_Sum_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** update columns of table "scenarios" */
export enum Scenarios_Update_Column {
  /** column name */
  Config = 'config',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  ScenarioKey = 'scenario_key',
  /** column name */
  Status = 'status',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowData = 'workflow_data'
}

export type Scenarios_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Scenarios_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Scenarios_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Scenarios_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Scenarios_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Scenarios_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Scenarios_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Scenarios_Set_Input>;
  /** filter the rows which have to be updated */
  where: Scenarios_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Scenarios_Var_Pop_Fields = {
  __typename?: 'scenarios_var_pop_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "scenarios" */
export type Scenarios_Var_Pop_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Scenarios_Var_Samp_Fields = {
  __typename?: 'scenarios_var_samp_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "scenarios" */
export type Scenarios_Var_Samp_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Scenarios_Variance_Fields = {
  __typename?: 'scenarios_variance_fields';
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "scenarios" */
export type Scenarios_Variance_Order_By = {
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
};

/** Contains the relationship between scenarios and moves as well as some extra information. Cardinality for one. */
export type Scenariotomoves = {
  __typename?: 'scenariotomoves';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality: Scalars['smallint']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** an auto-incrementing id for the record */
  id: Scalars['bigint']['output'];
  /** An object relationship */
  move: Moves;
  /** id for the related move record */
  move_id: Scalars['bigint']['output'];
  /** An object relationship */
  scenario: Scenarios;
  /** id for the related scenario */
  scenario_id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "scenariotomoves" */
export type Scenariotomoves_Aggregate = {
  __typename?: 'scenariotomoves_aggregate';
  aggregate?: Maybe<Scenariotomoves_Aggregate_Fields>;
  nodes: Array<Scenariotomoves>;
};

export type Scenariotomoves_Aggregate_Bool_Exp = {
  count?: InputMaybe<Scenariotomoves_Aggregate_Bool_Exp_Count>;
};

export type Scenariotomoves_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Scenariotomoves_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "scenariotomoves" */
export type Scenariotomoves_Aggregate_Fields = {
  __typename?: 'scenariotomoves_aggregate_fields';
  avg?: Maybe<Scenariotomoves_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Scenariotomoves_Max_Fields>;
  min?: Maybe<Scenariotomoves_Min_Fields>;
  stddev?: Maybe<Scenariotomoves_Stddev_Fields>;
  stddev_pop?: Maybe<Scenariotomoves_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Scenariotomoves_Stddev_Samp_Fields>;
  sum?: Maybe<Scenariotomoves_Sum_Fields>;
  var_pop?: Maybe<Scenariotomoves_Var_Pop_Fields>;
  var_samp?: Maybe<Scenariotomoves_Var_Samp_Fields>;
  variance?: Maybe<Scenariotomoves_Variance_Fields>;
};


/** aggregate fields of "scenariotomoves" */
export type Scenariotomoves_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "scenariotomoves" */
export type Scenariotomoves_Aggregate_Order_By = {
  avg?: InputMaybe<Scenariotomoves_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Scenariotomoves_Max_Order_By>;
  min?: InputMaybe<Scenariotomoves_Min_Order_By>;
  stddev?: InputMaybe<Scenariotomoves_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Scenariotomoves_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Scenariotomoves_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Scenariotomoves_Sum_Order_By>;
  var_pop?: InputMaybe<Scenariotomoves_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Scenariotomoves_Var_Samp_Order_By>;
  variance?: InputMaybe<Scenariotomoves_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "scenariotomoves" */
export type Scenariotomoves_Arr_Rel_Insert_Input = {
  data: Array<Scenariotomoves_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Scenariotomoves_On_Conflict>;
};

/** aggregate avg on columns */
export type Scenariotomoves_Avg_Fields = {
  __typename?: 'scenariotomoves_avg_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "scenariotomoves" */
export type Scenariotomoves_Avg_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "scenariotomoves". All fields are combined with a logical 'AND'. */
export type Scenariotomoves_Bool_Exp = {
  _and?: InputMaybe<Array<Scenariotomoves_Bool_Exp>>;
  _not?: InputMaybe<Scenariotomoves_Bool_Exp>;
  _or?: InputMaybe<Array<Scenariotomoves_Bool_Exp>>;
  cardinality?: InputMaybe<Smallint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  scenario?: InputMaybe<Scenarios_Bool_Exp>;
  scenario_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "scenariotomoves" */
export enum Scenariotomoves_Constraint {
  /** unique or primary key constraint on columns "id" */
  ScenariotomovesPkey = 'scenariotomoves_pkey'
}

/** input type for incrementing numeric columns in table "scenariotomoves" */
export type Scenariotomoves_Inc_Input = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related move record */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "scenariotomoves" */
export type Scenariotomoves_Insert_Input = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  /** id for the related move record */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  scenario?: InputMaybe<Scenarios_Obj_Rel_Insert_Input>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Scenariotomoves_Max_Fields = {
  __typename?: 'scenariotomoves_max_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "scenariotomoves" */
export type Scenariotomoves_Max_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Scenariotomoves_Min_Fields = {
  __typename?: 'scenariotomoves_min_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "scenariotomoves" */
export type Scenariotomoves_Min_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "scenariotomoves" */
export type Scenariotomoves_Mutation_Response = {
  __typename?: 'scenariotomoves_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Scenariotomoves>;
};

/** on_conflict condition type for table "scenariotomoves" */
export type Scenariotomoves_On_Conflict = {
  constraint: Scenariotomoves_Constraint;
  update_columns?: Array<Scenariotomoves_Update_Column>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};

/** Ordering options when selecting data from "scenariotomoves". */
export type Scenariotomoves_Order_By = {
  cardinality?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Scenarios_Order_By>;
  scenario_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: scenariotomoves */
export type Scenariotomoves_Pk_Columns_Input = {
  /** an auto-incrementing id for the record */
  id: Scalars['bigint']['input'];
};

/** select columns of table "scenariotomoves" */
export enum Scenariotomoves_Select_Column {
  /** column name */
  Cardinality = 'cardinality',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  ScenarioId = 'scenario_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "scenariotomoves" */
export type Scenariotomoves_Set_Input = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related move record */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Scenariotomoves_Stddev_Fields = {
  __typename?: 'scenariotomoves_stddev_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "scenariotomoves" */
export type Scenariotomoves_Stddev_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Scenariotomoves_Stddev_Pop_Fields = {
  __typename?: 'scenariotomoves_stddev_pop_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "scenariotomoves" */
export type Scenariotomoves_Stddev_Pop_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Scenariotomoves_Stddev_Samp_Fields = {
  __typename?: 'scenariotomoves_stddev_samp_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "scenariotomoves" */
export type Scenariotomoves_Stddev_Samp_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "scenariotomoves" */
export type Scenariotomoves_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Scenariotomoves_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Scenariotomoves_Stream_Cursor_Value_Input = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related move record */
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Scenariotomoves_Sum_Fields = {
  __typename?: 'scenariotomoves_sum_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['smallint']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "scenariotomoves" */
export type Scenariotomoves_Sum_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** update columns of table "scenariotomoves" */
export enum Scenariotomoves_Update_Column {
  /** column name */
  Cardinality = 'cardinality',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  ScenarioId = 'scenario_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Scenariotomoves_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Scenariotomoves_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Scenariotomoves_Set_Input>;
  /** filter the rows which have to be updated */
  where: Scenariotomoves_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Scenariotomoves_Var_Pop_Fields = {
  __typename?: 'scenariotomoves_var_pop_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "scenariotomoves" */
export type Scenariotomoves_Var_Pop_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Scenariotomoves_Var_Samp_Fields = {
  __typename?: 'scenariotomoves_var_samp_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "scenariotomoves" */
export type Scenariotomoves_Var_Samp_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Scenariotomoves_Variance_Fields = {
  __typename?: 'scenariotomoves_variance_fields';
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: Maybe<Scalars['Float']['output']>;
  /** an auto-incrementing id for the record */
  id?: Maybe<Scalars['Float']['output']>;
  /** id for the related move record */
  move_id?: Maybe<Scalars['Float']['output']>;
  /** id for the related scenario */
  scenario_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "scenariotomoves" */
export type Scenariotomoves_Variance_Order_By = {
  /** starting with 0 and counting up by 1 to indicate the sequential order the moves should be in */
  cardinality?: InputMaybe<Order_By>;
  /** an auto-incrementing id for the record */
  id?: InputMaybe<Order_By>;
  /** id for the related move record */
  move_id?: InputMaybe<Order_By>;
  /** id for the related scenario */
  scenario_id?: InputMaybe<Order_By>;
};

/** Contains the master list of scenario types that a bundler will ever generate. There is a mapping that is possible from the UseCases to the ScenarioTypes that can show which Scenarios are possible outputs of the Bundler based on a UseCase input. */
export type Scenariotypes = {
  __typename?: 'scenariotypes';
  config_schema?: Maybe<Scalars['jsonb']['output']>;
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['output'];
  /** name of the scenario type to be used when displaying it on screen */
  name: Scalars['String']['output'];
  /** An array relationship */
  scenarios: Array<Scenarios>;
  /** An aggregate relationship */
  scenarios_aggregate: Scenarios_Aggregate;
  /** An array relationship */
  scenariotypestocertifications: Array<Scenariotypestocertifications>;
  /** An aggregate relationship */
  scenariotypestocertifications_aggregate: Scenariotypestocertifications_Aggregate;
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  /** An object relationship */
  workflow?: Maybe<Workflows>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};


/** Contains the master list of scenario types that a bundler will ever generate. There is a mapping that is possible from the UseCases to the ScenarioTypes that can show which Scenarios are possible outputs of the Bundler based on a UseCase input. */
export type ScenariotypesConfig_SchemaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Contains the master list of scenario types that a bundler will ever generate. There is a mapping that is possible from the UseCases to the ScenarioTypes that can show which Scenarios are possible outputs of the Bundler based on a UseCase input. */
export type ScenariotypesScenariosArgs = {
  distinct_on?: InputMaybe<Array<Scenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenarios_Order_By>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


/** Contains the master list of scenario types that a bundler will ever generate. There is a mapping that is possible from the UseCases to the ScenarioTypes that can show which Scenarios are possible outputs of the Bundler based on a UseCase input. */
export type ScenariotypesScenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenarios_Order_By>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


/** Contains the master list of scenario types that a bundler will ever generate. There is a mapping that is possible from the UseCases to the ScenarioTypes that can show which Scenarios are possible outputs of the Bundler based on a UseCase input. */
export type ScenariotypesScenariotypestocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


/** Contains the master list of scenario types that a bundler will ever generate. There is a mapping that is possible from the UseCases to the ScenarioTypes that can show which Scenarios are possible outputs of the Bundler based on a UseCase input. */
export type ScenariotypesScenariotypestocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};

/** aggregated selection of "scenariotypes" */
export type Scenariotypes_Aggregate = {
  __typename?: 'scenariotypes_aggregate';
  aggregate?: Maybe<Scenariotypes_Aggregate_Fields>;
  nodes: Array<Scenariotypes>;
};

export type Scenariotypes_Aggregate_Bool_Exp = {
  count?: InputMaybe<Scenariotypes_Aggregate_Bool_Exp_Count>;
};

export type Scenariotypes_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Scenariotypes_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "scenariotypes" */
export type Scenariotypes_Aggregate_Fields = {
  __typename?: 'scenariotypes_aggregate_fields';
  avg?: Maybe<Scenariotypes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Scenariotypes_Max_Fields>;
  min?: Maybe<Scenariotypes_Min_Fields>;
  stddev?: Maybe<Scenariotypes_Stddev_Fields>;
  stddev_pop?: Maybe<Scenariotypes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Scenariotypes_Stddev_Samp_Fields>;
  sum?: Maybe<Scenariotypes_Sum_Fields>;
  var_pop?: Maybe<Scenariotypes_Var_Pop_Fields>;
  var_samp?: Maybe<Scenariotypes_Var_Samp_Fields>;
  variance?: Maybe<Scenariotypes_Variance_Fields>;
};


/** aggregate fields of "scenariotypes" */
export type Scenariotypes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "scenariotypes" */
export type Scenariotypes_Aggregate_Order_By = {
  avg?: InputMaybe<Scenariotypes_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Scenariotypes_Max_Order_By>;
  min?: InputMaybe<Scenariotypes_Min_Order_By>;
  stddev?: InputMaybe<Scenariotypes_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Scenariotypes_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Scenariotypes_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Scenariotypes_Sum_Order_By>;
  var_pop?: InputMaybe<Scenariotypes_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Scenariotypes_Var_Samp_Order_By>;
  variance?: InputMaybe<Scenariotypes_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Scenariotypes_Append_Input = {
  config_schema?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "scenariotypes" */
export type Scenariotypes_Arr_Rel_Insert_Input = {
  data: Array<Scenariotypes_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Scenariotypes_On_Conflict>;
};

/** aggregate avg on columns */
export type Scenariotypes_Avg_Fields = {
  __typename?: 'scenariotypes_avg_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "scenariotypes" */
export type Scenariotypes_Avg_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "scenariotypes". All fields are combined with a logical 'AND'. */
export type Scenariotypes_Bool_Exp = {
  _and?: InputMaybe<Array<Scenariotypes_Bool_Exp>>;
  _not?: InputMaybe<Scenariotypes_Bool_Exp>;
  _or?: InputMaybe<Array<Scenariotypes_Bool_Exp>>;
  config_schema?: InputMaybe<Jsonb_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  key?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  scenarios?: InputMaybe<Scenarios_Bool_Exp>;
  scenarios_aggregate?: InputMaybe<Scenarios_Aggregate_Bool_Exp>;
  scenariotypestocertifications?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
  scenariotypestocertifications_aggregate?: InputMaybe<Scenariotypestocertifications_Aggregate_Bool_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  workflow?: InputMaybe<Workflows_Bool_Exp>;
  workflow_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "scenariotypes" */
export enum Scenariotypes_Constraint {
  /** unique or primary key constraint on columns "key" */
  ScenariotypesPkey = 'scenariotypes_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Scenariotypes_Delete_At_Path_Input = {
  config_schema?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Scenariotypes_Delete_Elem_Input = {
  config_schema?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Scenariotypes_Delete_Key_Input = {
  config_schema?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "scenariotypes" */
export type Scenariotypes_Inc_Input = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "scenariotypes" */
export type Scenariotypes_Insert_Input = {
  config_schema?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  scenarios?: InputMaybe<Scenarios_Arr_Rel_Insert_Input>;
  scenariotypestocertifications?: InputMaybe<Scenariotypestocertifications_Arr_Rel_Insert_Input>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Scenariotypes_Max_Fields = {
  __typename?: 'scenariotypes_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "scenariotypes" */
export type Scenariotypes_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: InputMaybe<Order_By>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Order_By>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Scenariotypes_Min_Fields = {
  __typename?: 'scenariotypes_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "scenariotypes" */
export type Scenariotypes_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: InputMaybe<Order_By>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Order_By>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "scenariotypes" */
export type Scenariotypes_Mutation_Response = {
  __typename?: 'scenariotypes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Scenariotypes>;
};

/** input type for inserting object relation for remote table "scenariotypes" */
export type Scenariotypes_Obj_Rel_Insert_Input = {
  data: Scenariotypes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Scenariotypes_On_Conflict>;
};

/** on_conflict condition type for table "scenariotypes" */
export type Scenariotypes_On_Conflict = {
  constraint: Scenariotypes_Constraint;
  update_columns?: Array<Scenariotypes_Update_Column>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};

/** Ordering options when selecting data from "scenariotypes". */
export type Scenariotypes_Order_By = {
  config_schema?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  key?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  scenarios_aggregate?: InputMaybe<Scenarios_Aggregate_Order_By>;
  scenariotypestocertifications_aggregate?: InputMaybe<Scenariotypestocertifications_Aggregate_Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflow?: InputMaybe<Workflows_Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: scenariotypes */
export type Scenariotypes_Pk_Columns_Input = {
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Scenariotypes_Prepend_Input = {
  config_schema?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "scenariotypes" */
export enum Scenariotypes_Select_Column {
  /** column name */
  ConfigSchema = 'config_schema',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowId = 'workflow_id'
}

/** input type for updating data in table "scenariotypes" */
export type Scenariotypes_Set_Input = {
  config_schema?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Scenariotypes_Stddev_Fields = {
  __typename?: 'scenariotypes_stddev_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "scenariotypes" */
export type Scenariotypes_Stddev_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Scenariotypes_Stddev_Pop_Fields = {
  __typename?: 'scenariotypes_stddev_pop_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "scenariotypes" */
export type Scenariotypes_Stddev_Pop_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Scenariotypes_Stddev_Samp_Fields = {
  __typename?: 'scenariotypes_stddev_samp_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "scenariotypes" */
export type Scenariotypes_Stddev_Samp_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "scenariotypes" */
export type Scenariotypes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Scenariotypes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Scenariotypes_Stream_Cursor_Value_Input = {
  config_schema?: InputMaybe<Scalars['jsonb']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a long-form description of the scenario to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name of the scenario type to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Scenariotypes_Sum_Fields = {
  __typename?: 'scenariotypes_sum_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "scenariotypes" */
export type Scenariotypes_Sum_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** update columns of table "scenariotypes" */
export enum Scenariotypes_Update_Column {
  /** column name */
  ConfigSchema = 'config_schema',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowId = 'workflow_id'
}

export type Scenariotypes_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Scenariotypes_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Scenariotypes_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Scenariotypes_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Scenariotypes_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Scenariotypes_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Scenariotypes_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Scenariotypes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Scenariotypes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Scenariotypes_Var_Pop_Fields = {
  __typename?: 'scenariotypes_var_pop_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "scenariotypes" */
export type Scenariotypes_Var_Pop_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Scenariotypes_Var_Samp_Fields = {
  __typename?: 'scenariotypes_var_samp_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "scenariotypes" */
export type Scenariotypes_Var_Samp_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Scenariotypes_Variance_Fields = {
  __typename?: 'scenariotypes_variance_fields';
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "scenariotypes" */
export type Scenariotypes_Variance_Order_By = {
  /** a key that relates to the workflows table to a scenario type of workflow which will dictate the series of screens that are presented to the driver in the driver app */
  workflow_id?: InputMaybe<Order_By>;
};

/** Many to Many relationships - This is the storage of which certifications are required in order for a driver to be qualified to perform a specific scenario. For example a shuttle scenario. */
export type Scenariotypestocertifications = {
  __typename?: 'scenariotypestocertifications';
  /** An object relationship */
  certification: Certifications;
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  scenario_key: Scalars['String']['output'];
  /** An object relationship */
  scenariotype: Scenariotypes;
  updated_at: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
};

/** aggregated selection of "scenariotypestocertifications" */
export type Scenariotypestocertifications_Aggregate = {
  __typename?: 'scenariotypestocertifications_aggregate';
  aggregate?: Maybe<Scenariotypestocertifications_Aggregate_Fields>;
  nodes: Array<Scenariotypestocertifications>;
};

export type Scenariotypestocertifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Scenariotypestocertifications_Aggregate_Bool_Exp_Count>;
};

export type Scenariotypestocertifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "scenariotypestocertifications" */
export type Scenariotypestocertifications_Aggregate_Fields = {
  __typename?: 'scenariotypestocertifications_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Scenariotypestocertifications_Max_Fields>;
  min?: Maybe<Scenariotypestocertifications_Min_Fields>;
};


/** aggregate fields of "scenariotypestocertifications" */
export type Scenariotypestocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Scenariotypestocertifications_Max_Order_By>;
  min?: InputMaybe<Scenariotypestocertifications_Min_Order_By>;
};

/** input type for inserting array relation for remote table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Arr_Rel_Insert_Input = {
  data: Array<Scenariotypestocertifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Scenariotypestocertifications_On_Conflict>;
};

/** Boolean expression to filter rows from the table "scenariotypestocertifications". All fields are combined with a logical 'AND'. */
export type Scenariotypestocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Scenariotypestocertifications_Bool_Exp>>;
  _not?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Scenariotypestocertifications_Bool_Exp>>;
  certification?: InputMaybe<Certifications_Bool_Exp>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  scenario_key?: InputMaybe<String_Comparison_Exp>;
  scenariotype?: InputMaybe<Scenariotypes_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "scenariotypestocertifications" */
export enum Scenariotypestocertifications_Constraint {
  /** unique or primary key constraint on columns "scenario_key", "certification_key" */
  ScenariotypestocertificationsPkey = 'scenariotypestocertifications_pkey'
}

/** input type for inserting data into table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Insert_Input = {
  certification?: InputMaybe<Certifications_Obj_Rel_Insert_Input>;
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  scenario_key?: InputMaybe<Scalars['String']['input']>;
  scenariotype?: InputMaybe<Scenariotypes_Obj_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Scenariotypestocertifications_Max_Fields = {
  __typename?: 'scenariotypestocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  scenario_key?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Max_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  scenario_key?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Scenariotypestocertifications_Min_Fields = {
  __typename?: 'scenariotypestocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  scenario_key?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Min_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  scenario_key?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Mutation_Response = {
  __typename?: 'scenariotypestocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Scenariotypestocertifications>;
};

/** on_conflict condition type for table "scenariotypestocertifications" */
export type Scenariotypestocertifications_On_Conflict = {
  constraint: Scenariotypestocertifications_Constraint;
  update_columns?: Array<Scenariotypestocertifications_Update_Column>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "scenariotypestocertifications". */
export type Scenariotypestocertifications_Order_By = {
  certification?: InputMaybe<Certifications_Order_By>;
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  scenario_key?: InputMaybe<Order_By>;
  scenariotype?: InputMaybe<Scenariotypes_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: scenariotypestocertifications */
export type Scenariotypestocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  scenario_key: Scalars['String']['input'];
};

/** select columns of table "scenariotypestocertifications" */
export enum Scenariotypestocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  ScenarioKey = 'scenario_key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  scenario_key?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "scenariotypestocertifications" */
export type Scenariotypestocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Scenariotypestocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Scenariotypestocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  scenario_key?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "scenariotypestocertifications" */
export enum Scenariotypestocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  ScenarioKey = 'scenario_key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Updatedby = 'updatedby'
}

export type Scenariotypestocertifications_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Scenariotypestocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Scenariotypestocertifications_Bool_Exp;
};

/** columns and relationships of "sequelizemeta" */
export type Sequelizemeta = {
  __typename?: 'sequelizemeta';
  name: Scalars['String']['output'];
};

/** aggregated selection of "sequelizemeta" */
export type Sequelizemeta_Aggregate = {
  __typename?: 'sequelizemeta_aggregate';
  aggregate?: Maybe<Sequelizemeta_Aggregate_Fields>;
  nodes: Array<Sequelizemeta>;
};

/** aggregate fields of "sequelizemeta" */
export type Sequelizemeta_Aggregate_Fields = {
  __typename?: 'sequelizemeta_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Sequelizemeta_Max_Fields>;
  min?: Maybe<Sequelizemeta_Min_Fields>;
};


/** aggregate fields of "sequelizemeta" */
export type Sequelizemeta_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Sequelizemeta_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "sequelizemeta". All fields are combined with a logical 'AND'. */
export type Sequelizemeta_Bool_Exp = {
  _and?: InputMaybe<Array<Sequelizemeta_Bool_Exp>>;
  _not?: InputMaybe<Sequelizemeta_Bool_Exp>;
  _or?: InputMaybe<Array<Sequelizemeta_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "sequelizemeta" */
export enum Sequelizemeta_Constraint {
  /** unique or primary key constraint on columns "name" */
  Idx_25786Name = 'idx_25786_name',
  /** unique or primary key constraint on columns "name" */
  Idx_25786Primary = 'idx_25786_primary'
}

/** input type for inserting data into table "sequelizemeta" */
export type Sequelizemeta_Insert_Input = {
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Sequelizemeta_Max_Fields = {
  __typename?: 'sequelizemeta_max_fields';
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Sequelizemeta_Min_Fields = {
  __typename?: 'sequelizemeta_min_fields';
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "sequelizemeta" */
export type Sequelizemeta_Mutation_Response = {
  __typename?: 'sequelizemeta_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Sequelizemeta>;
};

/** on_conflict condition type for table "sequelizemeta" */
export type Sequelizemeta_On_Conflict = {
  constraint: Sequelizemeta_Constraint;
  update_columns?: Array<Sequelizemeta_Update_Column>;
  where?: InputMaybe<Sequelizemeta_Bool_Exp>;
};

/** Ordering options when selecting data from "sequelizemeta". */
export type Sequelizemeta_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: sequelizemeta */
export type Sequelizemeta_Pk_Columns_Input = {
  name: Scalars['String']['input'];
};

/** select columns of table "sequelizemeta" */
export enum Sequelizemeta_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "sequelizemeta" */
export type Sequelizemeta_Set_Input = {
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "sequelizemeta" */
export type Sequelizemeta_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Sequelizemeta_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Sequelizemeta_Stream_Cursor_Value_Input = {
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "sequelizemeta" */
export enum Sequelizemeta_Update_Column {
  /** column name */
  Name = 'name'
}

export type Sequelizemeta_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Sequelizemeta_Set_Input>;
  /** filter the rows which have to be updated */
  where: Sequelizemeta_Bool_Exp;
};

/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type Slas = {
  __typename?: 'slas';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Description of the SLA. Used to describe the SLA if needed. Should always be paired with the label on the front end. */
  description?: Maybe<Scalars['String']['output']>;
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['smallint']['output']>;
  id: Scalars['bigint']['output'];
  /** Label of the SLA. Used for display when selecting this SLA on the front end. */
  label: Scalars['String']['output'];
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** Name of the SLA. The API and other systems use this value when ID is not enough to identify an SLA. Please use snake case for names. */
  name: Scalars['String']['output'];
  /** Is the SLA publicly available to every customer? */
  public: Scalars['Boolean']['output'];
  /** An array relationship */
  sla_to_raterulegroups: Array<Slas_To_Raterulegroups>;
  /** An aggregate relationship */
  sla_to_raterulegroups_aggregate: Slas_To_Raterulegroups_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  workflowsets: Array<Workflowsets>;
  /** An aggregate relationship */
  workflowsets_aggregate: Workflowsets_Aggregate;
  /** An array relationship */
  workflowsettypes: Array<Workflowsettypes>;
  /** An aggregate relationship */
  workflowsettypes_aggregate: Workflowsettypes_Aggregate;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasSla_To_RaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasSla_To_Raterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasWorkflowsetsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasWorkflowsets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasWorkflowsettypesArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


/** SLAs (Service Level Agreements) are windows of time that HopDrive guarantees the move will be completed within. These SLAs are public or linked to a customer contract through the slas_to_raterulegroups table. */
export type SlasWorkflowsettypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};

/** aggregated selection of "slas" */
export type Slas_Aggregate = {
  __typename?: 'slas_aggregate';
  aggregate?: Maybe<Slas_Aggregate_Fields>;
  nodes: Array<Slas>;
};

/** aggregate fields of "slas" */
export type Slas_Aggregate_Fields = {
  __typename?: 'slas_aggregate_fields';
  avg?: Maybe<Slas_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Slas_Max_Fields>;
  min?: Maybe<Slas_Min_Fields>;
  stddev?: Maybe<Slas_Stddev_Fields>;
  stddev_pop?: Maybe<Slas_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Slas_Stddev_Samp_Fields>;
  sum?: Maybe<Slas_Sum_Fields>;
  var_pop?: Maybe<Slas_Var_Pop_Fields>;
  var_samp?: Maybe<Slas_Var_Samp_Fields>;
  variance?: Maybe<Slas_Variance_Fields>;
};


/** aggregate fields of "slas" */
export type Slas_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Slas_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Slas_Avg_Fields = {
  __typename?: 'slas_avg_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "slas". All fields are combined with a logical 'AND'. */
export type Slas_Bool_Exp = {
  _and?: InputMaybe<Array<Slas_Bool_Exp>>;
  _not?: InputMaybe<Slas_Bool_Exp>;
  _or?: InputMaybe<Array<Slas_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  duration_hrs?: InputMaybe<Smallint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  label?: InputMaybe<String_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  public?: InputMaybe<Boolean_Comparison_Exp>;
  sla_to_raterulegroups?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
  sla_to_raterulegroups_aggregate?: InputMaybe<Slas_To_Raterulegroups_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  workflowsets?: InputMaybe<Workflowsets_Bool_Exp>;
  workflowsets_aggregate?: InputMaybe<Workflowsets_Aggregate_Bool_Exp>;
  workflowsettypes?: InputMaybe<Workflowsettypes_Bool_Exp>;
  workflowsettypes_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "slas" */
export enum Slas_Constraint {
  /** unique or primary key constraint on columns "label" */
  SlasLabelKey = 'slas_label_key',
  /** unique or primary key constraint on columns "name" */
  SlasNameKey = 'slas_name_key',
  /** unique or primary key constraint on columns "id" */
  SlasPkey = 'slas_pkey'
}

/** input type for incrementing numeric columns in table "slas" */
export type Slas_Inc_Input = {
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "slas" */
export type Slas_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Description of the SLA. Used to describe the SLA if needed. Should always be paired with the label on the front end. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Label of the SLA. Used for display when selecting this SLA on the front end. */
  label?: InputMaybe<Scalars['String']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  /** Name of the SLA. The API and other systems use this value when ID is not enough to identify an SLA. Please use snake case for names. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Is the SLA publicly available to every customer? */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  sla_to_raterulegroups?: InputMaybe<Slas_To_Raterulegroups_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  workflowsets?: InputMaybe<Workflowsets_Arr_Rel_Insert_Input>;
  workflowsettypes?: InputMaybe<Workflowsettypes_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Slas_Max_Fields = {
  __typename?: 'slas_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Description of the SLA. Used to describe the SLA if needed. Should always be paired with the label on the front end. */
  description?: Maybe<Scalars['String']['output']>;
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Label of the SLA. Used for display when selecting this SLA on the front end. */
  label?: Maybe<Scalars['String']['output']>;
  /** Name of the SLA. The API and other systems use this value when ID is not enough to identify an SLA. Please use snake case for names. */
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Slas_Min_Fields = {
  __typename?: 'slas_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** Description of the SLA. Used to describe the SLA if needed. Should always be paired with the label on the front end. */
  description?: Maybe<Scalars['String']['output']>;
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Label of the SLA. Used for display when selecting this SLA on the front end. */
  label?: Maybe<Scalars['String']['output']>;
  /** Name of the SLA. The API and other systems use this value when ID is not enough to identify an SLA. Please use snake case for names. */
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "slas" */
export type Slas_Mutation_Response = {
  __typename?: 'slas_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Slas>;
};

/** input type for inserting object relation for remote table "slas" */
export type Slas_Obj_Rel_Insert_Input = {
  data: Slas_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Slas_On_Conflict>;
};

/** on_conflict condition type for table "slas" */
export type Slas_On_Conflict = {
  constraint: Slas_Constraint;
  update_columns?: Array<Slas_Update_Column>;
  where?: InputMaybe<Slas_Bool_Exp>;
};

/** Ordering options when selecting data from "slas". */
export type Slas_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  duration_hrs?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  public?: InputMaybe<Order_By>;
  sla_to_raterulegroups_aggregate?: InputMaybe<Slas_To_Raterulegroups_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  workflowsets_aggregate?: InputMaybe<Workflowsets_Aggregate_Order_By>;
  workflowsettypes_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Order_By>;
};

/** primary key columns input for table: slas */
export type Slas_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "slas" */
export enum Slas_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Description = 'description',
  /** column name */
  DurationHrs = 'duration_hrs',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name',
  /** column name */
  Public = 'public',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

/** input type for updating data in table "slas" */
export type Slas_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Description of the SLA. Used to describe the SLA if needed. Should always be paired with the label on the front end. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Label of the SLA. Used for display when selecting this SLA on the front end. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Name of the SLA. The API and other systems use this value when ID is not enough to identify an SLA. Please use snake case for names. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Is the SLA publicly available to every customer? */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Slas_Stddev_Fields = {
  __typename?: 'slas_stddev_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Slas_Stddev_Pop_Fields = {
  __typename?: 'slas_stddev_pop_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Slas_Stddev_Samp_Fields = {
  __typename?: 'slas_stddev_samp_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "slas" */
export type Slas_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Slas_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Slas_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Description of the SLA. Used to describe the SLA if needed. Should always be paired with the label on the front end. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Label of the SLA. Used for display when selecting this SLA on the front end. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Name of the SLA. The API and other systems use this value when ID is not enough to identify an SLA. Please use snake case for names. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Is the SLA publicly available to every customer? */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Slas_Sum_Fields = {
  __typename?: 'slas_sum_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** Link table to relate SLAs to customer contracts. */
export type Slas_To_Raterulegroups = {
  __typename?: 'slas_to_raterulegroups';
  id: Scalars['bigint']['output'];
  /** An object relationship */
  raterulegroup: Raterulegroups;
  /** Relationship to a customer contract. */
  raterulegroup_id: Scalars['bigint']['output'];
  /** An object relationship */
  sla: Slas;
  /** Relationship to an SLA record. */
  sla_id: Scalars['bigint']['output'];
};

/** aggregated selection of "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Aggregate = {
  __typename?: 'slas_to_raterulegroups_aggregate';
  aggregate?: Maybe<Slas_To_Raterulegroups_Aggregate_Fields>;
  nodes: Array<Slas_To_Raterulegroups>;
};

export type Slas_To_Raterulegroups_Aggregate_Bool_Exp = {
  count?: InputMaybe<Slas_To_Raterulegroups_Aggregate_Bool_Exp_Count>;
};

export type Slas_To_Raterulegroups_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Aggregate_Fields = {
  __typename?: 'slas_to_raterulegroups_aggregate_fields';
  avg?: Maybe<Slas_To_Raterulegroups_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Slas_To_Raterulegroups_Max_Fields>;
  min?: Maybe<Slas_To_Raterulegroups_Min_Fields>;
  stddev?: Maybe<Slas_To_Raterulegroups_Stddev_Fields>;
  stddev_pop?: Maybe<Slas_To_Raterulegroups_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Slas_To_Raterulegroups_Stddev_Samp_Fields>;
  sum?: Maybe<Slas_To_Raterulegroups_Sum_Fields>;
  var_pop?: Maybe<Slas_To_Raterulegroups_Var_Pop_Fields>;
  var_samp?: Maybe<Slas_To_Raterulegroups_Var_Samp_Fields>;
  variance?: Maybe<Slas_To_Raterulegroups_Variance_Fields>;
};


/** aggregate fields of "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Aggregate_Order_By = {
  avg?: InputMaybe<Slas_To_Raterulegroups_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Slas_To_Raterulegroups_Max_Order_By>;
  min?: InputMaybe<Slas_To_Raterulegroups_Min_Order_By>;
  stddev?: InputMaybe<Slas_To_Raterulegroups_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Slas_To_Raterulegroups_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Slas_To_Raterulegroups_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Slas_To_Raterulegroups_Sum_Order_By>;
  var_pop?: InputMaybe<Slas_To_Raterulegroups_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Slas_To_Raterulegroups_Var_Samp_Order_By>;
  variance?: InputMaybe<Slas_To_Raterulegroups_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Arr_Rel_Insert_Input = {
  data: Array<Slas_To_Raterulegroups_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Slas_To_Raterulegroups_On_Conflict>;
};

/** aggregate avg on columns */
export type Slas_To_Raterulegroups_Avg_Fields = {
  __typename?: 'slas_to_raterulegroups_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "slas_to_raterulegroups". All fields are combined with a logical 'AND'. */
export type Slas_To_Raterulegroups_Bool_Exp = {
  _and?: InputMaybe<Array<Slas_To_Raterulegroups_Bool_Exp>>;
  _not?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
  _or?: InputMaybe<Array<Slas_To_Raterulegroups_Bool_Exp>>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  raterulegroup?: InputMaybe<Raterulegroups_Bool_Exp>;
  raterulegroup_id?: InputMaybe<Bigint_Comparison_Exp>;
  sla?: InputMaybe<Slas_Bool_Exp>;
  sla_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "slas_to_raterulegroups" */
export enum Slas_To_Raterulegroups_Constraint {
  /** unique or primary key constraint on columns "id" */
  SlasToRaterulegroupsPkey = 'slas_to_raterulegroups_pkey'
}

/** input type for incrementing numeric columns in table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Insert_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  raterulegroup?: InputMaybe<Raterulegroups_Obj_Rel_Insert_Input>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Scalars['bigint']['input']>;
  sla?: InputMaybe<Slas_Obj_Rel_Insert_Input>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Slas_To_Raterulegroups_Max_Fields = {
  __typename?: 'slas_to_raterulegroups_max_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Slas_To_Raterulegroups_Min_Fields = {
  __typename?: 'slas_to_raterulegroups_min_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Mutation_Response = {
  __typename?: 'slas_to_raterulegroups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Slas_To_Raterulegroups>;
};

/** on_conflict condition type for table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_On_Conflict = {
  constraint: Slas_To_Raterulegroups_Constraint;
  update_columns?: Array<Slas_To_Raterulegroups_Update_Column>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};

/** Ordering options when selecting data from "slas_to_raterulegroups". */
export type Slas_To_Raterulegroups_Order_By = {
  id?: InputMaybe<Order_By>;
  raterulegroup?: InputMaybe<Raterulegroups_Order_By>;
  raterulegroup_id?: InputMaybe<Order_By>;
  sla?: InputMaybe<Slas_Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: slas_to_raterulegroups */
export type Slas_To_Raterulegroups_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "slas_to_raterulegroups" */
export enum Slas_To_Raterulegroups_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  RaterulegroupId = 'raterulegroup_id',
  /** column name */
  SlaId = 'sla_id'
}

/** input type for updating data in table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Set_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Slas_To_Raterulegroups_Stddev_Fields = {
  __typename?: 'slas_to_raterulegroups_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Slas_To_Raterulegroups_Stddev_Pop_Fields = {
  __typename?: 'slas_to_raterulegroups_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Slas_To_Raterulegroups_Stddev_Samp_Fields = {
  __typename?: 'slas_to_raterulegroups_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Slas_To_Raterulegroups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Slas_To_Raterulegroups_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Slas_To_Raterulegroups_Sum_Fields = {
  __typename?: 'slas_to_raterulegroups_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['bigint']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** update columns of table "slas_to_raterulegroups" */
export enum Slas_To_Raterulegroups_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  RaterulegroupId = 'raterulegroup_id',
  /** column name */
  SlaId = 'sla_id'
}

export type Slas_To_Raterulegroups_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Slas_To_Raterulegroups_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Slas_To_Raterulegroups_Set_Input>;
  /** filter the rows which have to be updated */
  where: Slas_To_Raterulegroups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Slas_To_Raterulegroups_Var_Pop_Fields = {
  __typename?: 'slas_to_raterulegroups_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Slas_To_Raterulegroups_Var_Samp_Fields = {
  __typename?: 'slas_to_raterulegroups_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Slas_To_Raterulegroups_Variance_Fields = {
  __typename?: 'slas_to_raterulegroups_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: Maybe<Scalars['Float']['output']>;
  /** Relationship to an SLA record. */
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "slas_to_raterulegroups" */
export type Slas_To_Raterulegroups_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  /** Relationship to a customer contract. */
  raterulegroup_id?: InputMaybe<Order_By>;
  /** Relationship to an SLA record. */
  sla_id?: InputMaybe<Order_By>;
};

/** update columns of table "slas" */
export enum Slas_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Description = 'description',
  /** column name */
  DurationHrs = 'duration_hrs',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name',
  /** column name */
  Public = 'public',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by'
}

export type Slas_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Slas_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Slas_Set_Input>;
  /** filter the rows which have to be updated */
  where: Slas_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Slas_Var_Pop_Fields = {
  __typename?: 'slas_var_pop_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Slas_Var_Samp_Fields = {
  __typename?: 'slas_var_samp_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Slas_Variance_Fields = {
  __typename?: 'slas_variance_fields';
  /** Contractual SLA duration. Number of hours that factors into generating the deliver_by time on the move when the move is created or it's ready_by time adjusted. */
  duration_hrs?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type Smallint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['smallint']['input']>;
  _gt?: InputMaybe<Scalars['smallint']['input']>;
  _gte?: InputMaybe<Scalars['smallint']['input']>;
  _in?: InputMaybe<Array<Scalars['smallint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['smallint']['input']>;
  _lte?: InputMaybe<Scalars['smallint']['input']>;
  _neq?: InputMaybe<Scalars['smallint']['input']>;
  _nin?: InputMaybe<Array<Scalars['smallint']['input']>>;
};

/** Stores the media URLs attached to SMS messages */
export type Smsmedia = {
  __typename?: 'smsmedia';
  id: Scalars['bigint']['output'];
  sms_message_id: Scalars['bigint']['output'];
  /** An object relationship */
  smsmessage: Smsmessages;
  url: Scalars['String']['output'];
};

/** aggregated selection of "smsmedia" */
export type Smsmedia_Aggregate = {
  __typename?: 'smsmedia_aggregate';
  aggregate?: Maybe<Smsmedia_Aggregate_Fields>;
  nodes: Array<Smsmedia>;
};

export type Smsmedia_Aggregate_Bool_Exp = {
  count?: InputMaybe<Smsmedia_Aggregate_Bool_Exp_Count>;
};

export type Smsmedia_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Smsmedia_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Smsmedia_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "smsmedia" */
export type Smsmedia_Aggregate_Fields = {
  __typename?: 'smsmedia_aggregate_fields';
  avg?: Maybe<Smsmedia_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Smsmedia_Max_Fields>;
  min?: Maybe<Smsmedia_Min_Fields>;
  stddev?: Maybe<Smsmedia_Stddev_Fields>;
  stddev_pop?: Maybe<Smsmedia_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Smsmedia_Stddev_Samp_Fields>;
  sum?: Maybe<Smsmedia_Sum_Fields>;
  var_pop?: Maybe<Smsmedia_Var_Pop_Fields>;
  var_samp?: Maybe<Smsmedia_Var_Samp_Fields>;
  variance?: Maybe<Smsmedia_Variance_Fields>;
};


/** aggregate fields of "smsmedia" */
export type Smsmedia_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Smsmedia_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "smsmedia" */
export type Smsmedia_Aggregate_Order_By = {
  avg?: InputMaybe<Smsmedia_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Smsmedia_Max_Order_By>;
  min?: InputMaybe<Smsmedia_Min_Order_By>;
  stddev?: InputMaybe<Smsmedia_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Smsmedia_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Smsmedia_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Smsmedia_Sum_Order_By>;
  var_pop?: InputMaybe<Smsmedia_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Smsmedia_Var_Samp_Order_By>;
  variance?: InputMaybe<Smsmedia_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "smsmedia" */
export type Smsmedia_Arr_Rel_Insert_Input = {
  data: Array<Smsmedia_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Smsmedia_On_Conflict>;
};

/** aggregate avg on columns */
export type Smsmedia_Avg_Fields = {
  __typename?: 'smsmedia_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "smsmedia" */
export type Smsmedia_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "smsmedia". All fields are combined with a logical 'AND'. */
export type Smsmedia_Bool_Exp = {
  _and?: InputMaybe<Array<Smsmedia_Bool_Exp>>;
  _not?: InputMaybe<Smsmedia_Bool_Exp>;
  _or?: InputMaybe<Array<Smsmedia_Bool_Exp>>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  sms_message_id?: InputMaybe<Bigint_Comparison_Exp>;
  smsmessage?: InputMaybe<Smsmessages_Bool_Exp>;
  url?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "smsmedia" */
export enum Smsmedia_Constraint {
  /** unique or primary key constraint on columns "id" */
  SmsmediaPkey = 'smsmedia_pkey'
}

/** input type for incrementing numeric columns in table "smsmedia" */
export type Smsmedia_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  sms_message_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "smsmedia" */
export type Smsmedia_Insert_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  sms_message_id?: InputMaybe<Scalars['bigint']['input']>;
  smsmessage?: InputMaybe<Smsmessages_Obj_Rel_Insert_Input>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Smsmedia_Max_Fields = {
  __typename?: 'smsmedia_max_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  sms_message_id?: Maybe<Scalars['bigint']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "smsmedia" */
export type Smsmedia_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Smsmedia_Min_Fields = {
  __typename?: 'smsmedia_min_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  sms_message_id?: Maybe<Scalars['bigint']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "smsmedia" */
export type Smsmedia_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "smsmedia" */
export type Smsmedia_Mutation_Response = {
  __typename?: 'smsmedia_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Smsmedia>;
};

/** on_conflict condition type for table "smsmedia" */
export type Smsmedia_On_Conflict = {
  constraint: Smsmedia_Constraint;
  update_columns?: Array<Smsmedia_Update_Column>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};

/** Ordering options when selecting data from "smsmedia". */
export type Smsmedia_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
  smsmessage?: InputMaybe<Smsmessages_Order_By>;
  url?: InputMaybe<Order_By>;
};

/** primary key columns input for table: smsmedia */
export type Smsmedia_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "smsmedia" */
export enum Smsmedia_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  SmsMessageId = 'sms_message_id',
  /** column name */
  Url = 'url'
}

/** input type for updating data in table "smsmedia" */
export type Smsmedia_Set_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  sms_message_id?: InputMaybe<Scalars['bigint']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Smsmedia_Stddev_Fields = {
  __typename?: 'smsmedia_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "smsmedia" */
export type Smsmedia_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Smsmedia_Stddev_Pop_Fields = {
  __typename?: 'smsmedia_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "smsmedia" */
export type Smsmedia_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Smsmedia_Stddev_Samp_Fields = {
  __typename?: 'smsmedia_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "smsmedia" */
export type Smsmedia_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "smsmedia" */
export type Smsmedia_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Smsmedia_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Smsmedia_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  sms_message_id?: InputMaybe<Scalars['bigint']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Smsmedia_Sum_Fields = {
  __typename?: 'smsmedia_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  sms_message_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "smsmedia" */
export type Smsmedia_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** update columns of table "smsmedia" */
export enum Smsmedia_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  SmsMessageId = 'sms_message_id',
  /** column name */
  Url = 'url'
}

export type Smsmedia_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Smsmedia_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Smsmedia_Set_Input>;
  /** filter the rows which have to be updated */
  where: Smsmedia_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Smsmedia_Var_Pop_Fields = {
  __typename?: 'smsmedia_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "smsmedia" */
export type Smsmedia_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Smsmedia_Var_Samp_Fields = {
  __typename?: 'smsmedia_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "smsmedia" */
export type Smsmedia_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Smsmedia_Variance_Fields = {
  __typename?: 'smsmedia_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  sms_message_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "smsmedia" */
export type Smsmedia_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  sms_message_id?: InputMaybe<Order_By>;
};

/** Stores the content, status, and data required for sending SMS messages */
export type Smsmessages = {
  __typename?: 'smsmessages';
  /** An object relationship */
  appointment?: Maybe<Appointments>;
  appointment_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction: Scalars['String']['output'];
  /** If sending the SMS fails, the error message string will be saved here */
  error?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  message_body?: Maybe<Scalars['String']['output']>;
  /** For storing any audit related detail */
  metadata?: Maybe<Scalars['jsonb']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  recipient_phone?: Maybe<Scalars['String']['output']>;
  sender_phone?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  smsmedia: Array<Smsmedia>;
  /** An aggregate relationship */
  smsmedia_aggregate: Smsmedia_Aggregate;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: Maybe<Scalars['String']['output']>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: Maybe<Scalars['String']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};


/** Stores the content, status, and data required for sending SMS messages */
export type SmsmessagesMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Stores the content, status, and data required for sending SMS messages */
export type SmsmessagesSmsmediaArgs = {
  distinct_on?: InputMaybe<Array<Smsmedia_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmedia_Order_By>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};


/** Stores the content, status, and data required for sending SMS messages */
export type SmsmessagesSmsmedia_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smsmedia_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmedia_Order_By>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};

/** aggregated selection of "smsmessages" */
export type Smsmessages_Aggregate = {
  __typename?: 'smsmessages_aggregate';
  aggregate?: Maybe<Smsmessages_Aggregate_Fields>;
  nodes: Array<Smsmessages>;
};

export type Smsmessages_Aggregate_Bool_Exp = {
  count?: InputMaybe<Smsmessages_Aggregate_Bool_Exp_Count>;
};

export type Smsmessages_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Smsmessages_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Smsmessages_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "smsmessages" */
export type Smsmessages_Aggregate_Fields = {
  __typename?: 'smsmessages_aggregate_fields';
  avg?: Maybe<Smsmessages_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Smsmessages_Max_Fields>;
  min?: Maybe<Smsmessages_Min_Fields>;
  stddev?: Maybe<Smsmessages_Stddev_Fields>;
  stddev_pop?: Maybe<Smsmessages_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Smsmessages_Stddev_Samp_Fields>;
  sum?: Maybe<Smsmessages_Sum_Fields>;
  var_pop?: Maybe<Smsmessages_Var_Pop_Fields>;
  var_samp?: Maybe<Smsmessages_Var_Samp_Fields>;
  variance?: Maybe<Smsmessages_Variance_Fields>;
};


/** aggregate fields of "smsmessages" */
export type Smsmessages_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Smsmessages_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "smsmessages" */
export type Smsmessages_Aggregate_Order_By = {
  avg?: InputMaybe<Smsmessages_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Smsmessages_Max_Order_By>;
  min?: InputMaybe<Smsmessages_Min_Order_By>;
  stddev?: InputMaybe<Smsmessages_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Smsmessages_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Smsmessages_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Smsmessages_Sum_Order_By>;
  var_pop?: InputMaybe<Smsmessages_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Smsmessages_Var_Samp_Order_By>;
  variance?: InputMaybe<Smsmessages_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Smsmessages_Append_Input = {
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "smsmessages" */
export type Smsmessages_Arr_Rel_Insert_Input = {
  data: Array<Smsmessages_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Smsmessages_On_Conflict>;
};

/** aggregate avg on columns */
export type Smsmessages_Avg_Fields = {
  __typename?: 'smsmessages_avg_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "smsmessages" */
export type Smsmessages_Avg_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "smsmessages". All fields are combined with a logical 'AND'. */
export type Smsmessages_Bool_Exp = {
  _and?: InputMaybe<Array<Smsmessages_Bool_Exp>>;
  _not?: InputMaybe<Smsmessages_Bool_Exp>;
  _or?: InputMaybe<Array<Smsmessages_Bool_Exp>>;
  appointment?: InputMaybe<Appointments_Bool_Exp>;
  appointment_id?: InputMaybe<Bigint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  direction?: InputMaybe<String_Comparison_Exp>;
  error?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  message_body?: InputMaybe<String_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  recipient_phone?: InputMaybe<String_Comparison_Exp>;
  sender_phone?: InputMaybe<String_Comparison_Exp>;
  smsmedia?: InputMaybe<Smsmedia_Bool_Exp>;
  smsmedia_aggregate?: InputMaybe<Smsmedia_Aggregate_Bool_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  string_identifier?: InputMaybe<String_Comparison_Exp>;
  template_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "smsmessages" */
export enum Smsmessages_Constraint {
  /** unique or primary key constraint on columns "id" */
  SmsmessagesPkey = 'smsmessages_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Smsmessages_Delete_At_Path_Input = {
  /** For storing any audit related detail */
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Smsmessages_Delete_Elem_Input = {
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Smsmessages_Delete_Key_Input = {
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "smsmessages" */
export type Smsmessages_Inc_Input = {
  appointment_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "smsmessages" */
export type Smsmessages_Insert_Input = {
  appointment?: InputMaybe<Appointments_Obj_Rel_Insert_Input>;
  appointment_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: InputMaybe<Scalars['String']['input']>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  message_body?: InputMaybe<Scalars['String']['input']>;
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  recipient_phone?: InputMaybe<Scalars['String']['input']>;
  sender_phone?: InputMaybe<Scalars['String']['input']>;
  smsmedia?: InputMaybe<Smsmedia_Arr_Rel_Insert_Input>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: InputMaybe<Scalars['String']['input']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Smsmessages_Max_Fields = {
  __typename?: 'smsmessages_max_fields';
  appointment_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: Maybe<Scalars['String']['output']>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  message_body?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  recipient_phone?: Maybe<Scalars['String']['output']>;
  sender_phone?: Maybe<Scalars['String']['output']>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: Maybe<Scalars['String']['output']>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: Maybe<Scalars['String']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "smsmessages" */
export type Smsmessages_Max_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: InputMaybe<Order_By>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message_body?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  recipient_phone?: InputMaybe<Order_By>;
  sender_phone?: InputMaybe<Order_By>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: InputMaybe<Order_By>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Smsmessages_Min_Fields = {
  __typename?: 'smsmessages_min_fields';
  appointment_id?: Maybe<Scalars['bigint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: Maybe<Scalars['String']['output']>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  message_body?: Maybe<Scalars['String']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  recipient_phone?: Maybe<Scalars['String']['output']>;
  sender_phone?: Maybe<Scalars['String']['output']>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: Maybe<Scalars['String']['output']>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: Maybe<Scalars['String']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "smsmessages" */
export type Smsmessages_Min_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: InputMaybe<Order_By>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message_body?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  recipient_phone?: InputMaybe<Order_By>;
  sender_phone?: InputMaybe<Order_By>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: InputMaybe<Order_By>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "smsmessages" */
export type Smsmessages_Mutation_Response = {
  __typename?: 'smsmessages_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Smsmessages>;
};

/** input type for inserting object relation for remote table "smsmessages" */
export type Smsmessages_Obj_Rel_Insert_Input = {
  data: Smsmessages_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Smsmessages_On_Conflict>;
};

/** on_conflict condition type for table "smsmessages" */
export type Smsmessages_On_Conflict = {
  constraint: Smsmessages_Constraint;
  update_columns?: Array<Smsmessages_Update_Column>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};

/** Ordering options when selecting data from "smsmessages". */
export type Smsmessages_Order_By = {
  appointment?: InputMaybe<Appointments_Order_By>;
  appointment_id?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  direction?: InputMaybe<Order_By>;
  error?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message_body?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  recipient_phone?: InputMaybe<Order_By>;
  sender_phone?: InputMaybe<Order_By>;
  smsmedia_aggregate?: InputMaybe<Smsmedia_Aggregate_Order_By>;
  status?: InputMaybe<Order_By>;
  string_identifier?: InputMaybe<Order_By>;
  template_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: smsmessages */
export type Smsmessages_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Smsmessages_Prepend_Input = {
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "smsmessages" */
export enum Smsmessages_Select_Column {
  /** column name */
  AppointmentId = 'appointment_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Direction = 'direction',
  /** column name */
  Error = 'error',
  /** column name */
  Id = 'id',
  /** column name */
  MessageBody = 'message_body',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  RecipientPhone = 'recipient_phone',
  /** column name */
  SenderPhone = 'sender_phone',
  /** column name */
  Status = 'status',
  /** column name */
  StringIdentifier = 'string_identifier',
  /** column name */
  TemplateId = 'template_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "smsmessages" */
export type Smsmessages_Set_Input = {
  appointment_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: InputMaybe<Scalars['String']['input']>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  message_body?: InputMaybe<Scalars['String']['input']>;
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  recipient_phone?: InputMaybe<Scalars['String']['input']>;
  sender_phone?: InputMaybe<Scalars['String']['input']>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: InputMaybe<Scalars['String']['input']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Smsmessages_Stddev_Fields = {
  __typename?: 'smsmessages_stddev_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "smsmessages" */
export type Smsmessages_Stddev_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Smsmessages_Stddev_Pop_Fields = {
  __typename?: 'smsmessages_stddev_pop_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "smsmessages" */
export type Smsmessages_Stddev_Pop_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Smsmessages_Stddev_Samp_Fields = {
  __typename?: 'smsmessages_stddev_samp_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "smsmessages" */
export type Smsmessages_Stddev_Samp_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "smsmessages" */
export type Smsmessages_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Smsmessages_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Smsmessages_Stream_Cursor_Value_Input = {
  appointment_id?: InputMaybe<Scalars['bigint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** Whether the text was outbound (to a customer) or inbound (from a customer) */
  direction?: InputMaybe<Scalars['String']['input']>;
  /** If sending the SMS fails, the error message string will be saved here */
  error?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  message_body?: InputMaybe<Scalars['String']['input']>;
  /** For storing any audit related detail */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  recipient_phone?: InputMaybe<Scalars['String']['input']>;
  sender_phone?: InputMaybe<Scalars['String']['input']>;
  /** Initiating, sending, sent, or failed. If "initiating," an event trigger will call the messaging API to execute sending the SMS */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier assigned by Twilio upon being called. To be used in the Twilio callback handler to update the SMS message's status accordingly */
  string_identifier?: InputMaybe<Scalars['String']['input']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Smsmessages_Sum_Fields = {
  __typename?: 'smsmessages_sum_fields';
  appointment_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "smsmessages" */
export type Smsmessages_Sum_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** update columns of table "smsmessages" */
export enum Smsmessages_Update_Column {
  /** column name */
  AppointmentId = 'appointment_id',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Direction = 'direction',
  /** column name */
  Error = 'error',
  /** column name */
  Id = 'id',
  /** column name */
  MessageBody = 'message_body',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  RecipientPhone = 'recipient_phone',
  /** column name */
  SenderPhone = 'sender_phone',
  /** column name */
  Status = 'status',
  /** column name */
  StringIdentifier = 'string_identifier',
  /** column name */
  TemplateId = 'template_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Smsmessages_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Smsmessages_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Smsmessages_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Smsmessages_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Smsmessages_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Smsmessages_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Smsmessages_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Smsmessages_Set_Input>;
  /** filter the rows which have to be updated */
  where: Smsmessages_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Smsmessages_Var_Pop_Fields = {
  __typename?: 'smsmessages_var_pop_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "smsmessages" */
export type Smsmessages_Var_Pop_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Smsmessages_Var_Samp_Fields = {
  __typename?: 'smsmessages_var_samp_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "smsmessages" */
export type Smsmessages_Var_Samp_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Smsmessages_Variance_Fields = {
  __typename?: 'smsmessages_variance_fields';
  appointment_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "smsmessages" */
export type Smsmessages_Variance_Order_By = {
  appointment_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  /** Signifies which SMS template was used to build the message body */
  template_id?: InputMaybe<Order_By>;
};

/** Stores templates for SMS messages by type, customer, organization, and region */
export type Smstemplates = {
  __typename?: 'smstemplates';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Describes the scenario to which the template applies (e.g. "House account override for pickup starting on a concierge move with the consumer at the pickup location" */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: Maybe<Scalars['jsonb']['output']>;
  /** Designates the override scope (customer, region, or organization) and the context to which the template applies (e.g. House Account, consumer at pickup, pickup started) */
  name: Scalars['String']['output'];
  organization_id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** The text body of the SMS with template tags in place of variables (e.g. "Our driver, {{driver}} has arrived at {{pickupLocation}}" */
  template: Scalars['String']['output'];
  /** Designates the scenario for sending the SMS (e.g., concierge.consumer.at.pickup.pickup.started) */
  type: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};


/** Stores templates for SMS messages by type, customer, organization, and region */
export type SmstemplatesMedia_AttachmentsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "smstemplates" */
export type Smstemplates_Aggregate = {
  __typename?: 'smstemplates_aggregate';
  aggregate?: Maybe<Smstemplates_Aggregate_Fields>;
  nodes: Array<Smstemplates>;
};

/** aggregate fields of "smstemplates" */
export type Smstemplates_Aggregate_Fields = {
  __typename?: 'smstemplates_aggregate_fields';
  avg?: Maybe<Smstemplates_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Smstemplates_Max_Fields>;
  min?: Maybe<Smstemplates_Min_Fields>;
  stddev?: Maybe<Smstemplates_Stddev_Fields>;
  stddev_pop?: Maybe<Smstemplates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Smstemplates_Stddev_Samp_Fields>;
  sum?: Maybe<Smstemplates_Sum_Fields>;
  var_pop?: Maybe<Smstemplates_Var_Pop_Fields>;
  var_samp?: Maybe<Smstemplates_Var_Samp_Fields>;
  variance?: Maybe<Smstemplates_Variance_Fields>;
};


/** aggregate fields of "smstemplates" */
export type Smstemplates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Smstemplates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Smstemplates_Append_Input = {
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Smstemplates_Avg_Fields = {
  __typename?: 'smstemplates_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "smstemplates". All fields are combined with a logical 'AND'. */
export type Smstemplates_Bool_Exp = {
  _and?: InputMaybe<Array<Smstemplates_Bool_Exp>>;
  _not?: InputMaybe<Smstemplates_Bool_Exp>;
  _or?: InputMaybe<Array<Smstemplates_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  media_attachments?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  template?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "smstemplates" */
export enum Smstemplates_Constraint {
  /** unique or primary key constraint on columns "id" */
  SmstemplatesIdKey = 'smstemplates_id_key',
  /** unique or primary key constraint on columns "id" */
  SmstemplatesPkey = 'smstemplates_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Smstemplates_Delete_At_Path_Input = {
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Smstemplates_Delete_Elem_Input = {
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Smstemplates_Delete_Key_Input = {
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "smstemplates" */
export type Smstemplates_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "smstemplates" */
export type Smstemplates_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Describes the scenario to which the template applies (e.g. "House account override for pickup starting on a concierge move with the consumer at the pickup location" */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['jsonb']['input']>;
  /** Designates the override scope (customer, region, or organization) and the context to which the template applies (e.g. House Account, consumer at pickup, pickup started) */
  name?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The text body of the SMS with template tags in place of variables (e.g. "Our driver, {{driver}} has arrived at {{pickupLocation}}" */
  template?: InputMaybe<Scalars['String']['input']>;
  /** Designates the scenario for sending the SMS (e.g., concierge.consumer.at.pickup.pickup.started) */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Smstemplates_Max_Fields = {
  __typename?: 'smstemplates_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Describes the scenario to which the template applies (e.g. "House account override for pickup starting on a concierge move with the consumer at the pickup location" */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Designates the override scope (customer, region, or organization) and the context to which the template applies (e.g. House Account, consumer at pickup, pickup started) */
  name?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** The text body of the SMS with template tags in place of variables (e.g. "Our driver, {{driver}} has arrived at {{pickupLocation}}" */
  template?: Maybe<Scalars['String']['output']>;
  /** Designates the scenario for sending the SMS (e.g., concierge.consumer.at.pickup.pickup.started) */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Smstemplates_Min_Fields = {
  __typename?: 'smstemplates_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Describes the scenario to which the template applies (e.g. "House account override for pickup starting on a concierge move with the consumer at the pickup location" */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Designates the override scope (customer, region, or organization) and the context to which the template applies (e.g. House Account, consumer at pickup, pickup started) */
  name?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  /** The text body of the SMS with template tags in place of variables (e.g. "Our driver, {{driver}} has arrived at {{pickupLocation}}" */
  template?: Maybe<Scalars['String']['output']>;
  /** Designates the scenario for sending the SMS (e.g., concierge.consumer.at.pickup.pickup.started) */
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "smstemplates" */
export type Smstemplates_Mutation_Response = {
  __typename?: 'smstemplates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Smstemplates>;
};

/** on_conflict condition type for table "smstemplates" */
export type Smstemplates_On_Conflict = {
  constraint: Smstemplates_Constraint;
  update_columns?: Array<Smstemplates_Update_Column>;
  where?: InputMaybe<Smstemplates_Bool_Exp>;
};

/** Ordering options when selecting data from "smstemplates". */
export type Smstemplates_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  media_attachments?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  template?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: smstemplates */
export type Smstemplates_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Smstemplates_Prepend_Input = {
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "smstemplates" */
export enum Smstemplates_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  MediaAttachments = 'media_attachments',
  /** column name */
  Name = 'name',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Template = 'template',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "smstemplates" */
export type Smstemplates_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Describes the scenario to which the template applies (e.g. "House account override for pickup starting on a concierge move with the consumer at the pickup location" */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['jsonb']['input']>;
  /** Designates the override scope (customer, region, or organization) and the context to which the template applies (e.g. House Account, consumer at pickup, pickup started) */
  name?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The text body of the SMS with template tags in place of variables (e.g. "Our driver, {{driver}} has arrived at {{pickupLocation}}" */
  template?: InputMaybe<Scalars['String']['input']>;
  /** Designates the scenario for sending the SMS (e.g., concierge.consumer.at.pickup.pickup.started) */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Smstemplates_Stddev_Fields = {
  __typename?: 'smstemplates_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Smstemplates_Stddev_Pop_Fields = {
  __typename?: 'smstemplates_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Smstemplates_Stddev_Samp_Fields = {
  __typename?: 'smstemplates_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "smstemplates" */
export type Smstemplates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Smstemplates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Smstemplates_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Describes the scenario to which the template applies (e.g. "House account override for pickup starting on a concierge move with the consumer at the pickup location" */
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Important: always format as array of strings. They will be used as arguments in the SMS Template Engine's function to get the media specified by the template */
  media_attachments?: InputMaybe<Scalars['jsonb']['input']>;
  /** Designates the override scope (customer, region, or organization) and the context to which the template applies (e.g. House Account, consumer at pickup, pickup started) */
  name?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The text body of the SMS with template tags in place of variables (e.g. "Our driver, {{driver}} has arrived at {{pickupLocation}}" */
  template?: InputMaybe<Scalars['String']['input']>;
  /** Designates the scenario for sending the SMS (e.g., concierge.consumer.at.pickup.pickup.started) */
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Smstemplates_Sum_Fields = {
  __typename?: 'smstemplates_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "smstemplates" */
export enum Smstemplates_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  MediaAttachments = 'media_attachments',
  /** column name */
  Name = 'name',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  Template = 'template',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Smstemplates_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Smstemplates_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Smstemplates_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Smstemplates_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Smstemplates_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Smstemplates_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Smstemplates_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Smstemplates_Set_Input>;
  /** filter the rows which have to be updated */
  where: Smstemplates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Smstemplates_Var_Pop_Fields = {
  __typename?: 'smstemplates_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Smstemplates_Var_Samp_Fields = {
  __typename?: 'smstemplates_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Smstemplates_Variance_Fields = {
  __typename?: 'smstemplates_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
};

export type St_D_Within_Geography_Input = {
  distance: Scalars['Float']['input'];
  from: Scalars['geography']['input'];
  use_spheroid?: InputMaybe<Scalars['Boolean']['input']>;
};

export type St_D_Within_Input = {
  distance: Scalars['Float']['input'];
  from: Scalars['geometry']['input'];
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** An array relationship */
  accessorials: Array<Accessorials>;
  /** An aggregate relationship */
  accessorials_aggregate: Accessorials_Aggregate;
  /** fetch data from the table: "accessorials" using primary key columns */
  accessorials_by_pk?: Maybe<Accessorials>;
  /** fetch data from the table in a streaming manner: "accessorials" */
  accessorials_stream: Array<Accessorials>;
  /** fetch data from the table: "accessorialstoalgorithms" */
  accessorialstoalgorithms: Array<Accessorialstoalgorithms>;
  /** fetch aggregated fields from the table: "accessorialstoalgorithms" */
  accessorialstoalgorithms_aggregate: Accessorialstoalgorithms_Aggregate;
  /** fetch data from the table: "accessorialstoalgorithms" using primary key columns */
  accessorialstoalgorithms_by_pk?: Maybe<Accessorialstoalgorithms>;
  /** fetch data from the table in a streaming manner: "accessorialstoalgorithms" */
  accessorialstoalgorithms_stream: Array<Accessorialstoalgorithms>;
  /** fetch data from the table: "actiontypes" */
  actiontypes: Array<Actiontypes>;
  /** fetch aggregated fields from the table: "actiontypes" */
  actiontypes_aggregate: Actiontypes_Aggregate;
  /** fetch data from the table: "actiontypes" using primary key columns */
  actiontypes_by_pk?: Maybe<Actiontypes>;
  /** fetch data from the table in a streaming manner: "actiontypes" */
  actiontypes_stream: Array<Actiontypes>;
  /** fetch data from the table: "activetimes" */
  activetimes: Array<Activetimes>;
  /** fetch aggregated fields from the table: "activetimes" */
  activetimes_aggregate: Activetimes_Aggregate;
  /** fetch data from the table: "activetimes" using primary key columns */
  activetimes_by_pk?: Maybe<Activetimes>;
  /** fetch data from the table in a streaming manner: "activetimes" */
  activetimes_stream: Array<Activetimes>;
  /** fetch data from the table: "algorithms" */
  algorithms: Array<Algorithms>;
  /** fetch aggregated fields from the table: "algorithms" */
  algorithms_aggregate: Algorithms_Aggregate;
  /** fetch data from the table: "algorithms" using primary key columns */
  algorithms_by_pk?: Maybe<Algorithms>;
  /** fetch data from the table in a streaming manner: "algorithms" */
  algorithms_stream: Array<Algorithms>;
  /** An array relationship */
  apcharges: Array<Apcharges>;
  /** An aggregate relationship */
  apcharges_aggregate: Apcharges_Aggregate;
  /** fetch data from the table: "apcharges" using primary key columns */
  apcharges_by_pk?: Maybe<Apcharges>;
  /** fetch data from the table in a streaming manner: "apcharges" */
  apcharges_stream: Array<Apcharges>;
  /** An array relationship */
  appayments: Array<Appayments>;
  /** An aggregate relationship */
  appayments_aggregate: Appayments_Aggregate;
  /** fetch data from the table: "appayments" using primary key columns */
  appayments_by_pk?: Maybe<Appayments>;
  /** fetch data from the table in a streaming manner: "appayments" */
  appayments_stream: Array<Appayments>;
  /** fetch data from the table: "appointments" */
  appointments: Array<Appointments>;
  /** fetch aggregated fields from the table: "appointments" */
  appointments_aggregate: Appointments_Aggregate;
  /** fetch data from the table: "appointments" using primary key columns */
  appointments_by_pk?: Maybe<Appointments>;
  /** fetch data from the table in a streaming manner: "appointments" */
  appointments_stream: Array<Appointments>;
  /** fetch data from the table: "appraisal_vehicles" */
  appraisal_vehicles: Array<Appraisal_Vehicles>;
  /** fetch aggregated fields from the table: "appraisal_vehicles" */
  appraisal_vehicles_aggregate: Appraisal_Vehicles_Aggregate;
  /** fetch data from the table in a streaming manner: "appraisal_vehicles" */
  appraisal_vehicles_stream: Array<Appraisal_Vehicles>;
  /** fetch data from the table: "appraisals" */
  appraisals: Array<Appraisals>;
  /** fetch aggregated fields from the table: "appraisals" */
  appraisals_aggregate: Appraisals_Aggregate;
  /** fetch data from the table: "appraisals" using primary key columns */
  appraisals_by_pk?: Maybe<Appraisals>;
  /** fetch data from the table in a streaming manner: "appraisals" */
  appraisals_stream: Array<Appraisals>;
  /** fetch data from the table: "arevents" */
  arevents: Array<Arevents>;
  /** fetch aggregated fields from the table: "arevents" */
  arevents_aggregate: Arevents_Aggregate;
  /** fetch data from the table: "arevents" using primary key columns */
  arevents_by_pk?: Maybe<Arevents>;
  /** fetch data from the table in a streaming manner: "arevents" */
  arevents_stream: Array<Arevents>;
  /** fetch data from the table: "arinvoices" */
  arinvoices: Array<Arinvoices>;
  /** fetch aggregated fields from the table: "arinvoices" */
  arinvoices_aggregate: Arinvoices_Aggregate;
  /** fetch data from the table: "arinvoices" using primary key columns */
  arinvoices_by_pk?: Maybe<Arinvoices>;
  /** fetch data from the table in a streaming manner: "arinvoices" */
  arinvoices_stream: Array<Arinvoices>;
  /** An array relationship */
  armovedetails: Array<Armovedetails>;
  /** An aggregate relationship */
  armovedetails_aggregate: Armovedetails_Aggregate;
  /** fetch data from the table: "armovedetails" using primary key columns */
  armovedetails_by_pk?: Maybe<Armovedetails>;
  /** fetch data from the table in a streaming manner: "armovedetails" */
  armovedetails_stream: Array<Armovedetails>;
  /** An array relationship */
  armovedetailshistory: Array<Armovedetailshistory>;
  /** An aggregate relationship */
  armovedetailshistory_aggregate: Armovedetailshistory_Aggregate;
  /** fetch data from the table: "armovedetailshistory" using primary key columns */
  armovedetailshistory_by_pk?: Maybe<Armovedetailshistory>;
  /** fetch data from the table in a streaming manner: "armovedetailshistory" */
  armovedetailshistory_stream: Array<Armovedetailshistory>;
  /** An array relationship */
  armoves: Array<Armoves>;
  /** An aggregate relationship */
  armoves_aggregate: Armoves_Aggregate;
  /** fetch data from the table: "armoves" using primary key columns */
  armoves_by_pk?: Maybe<Armoves>;
  /** fetch data from the table in a streaming manner: "armoves" */
  armoves_stream: Array<Armoves>;
  /** fetch data from the table: "armoveshistory" */
  armoveshistory: Array<Armoveshistory>;
  /** fetch aggregated fields from the table: "armoveshistory" */
  armoveshistory_aggregate: Armoveshistory_Aggregate;
  /** fetch data from the table: "armoveshistory" using primary key columns */
  armoveshistory_by_pk?: Maybe<Armoveshistory>;
  /** fetch data from the table in a streaming manner: "armoveshistory" */
  armoveshistory_stream: Array<Armoveshistory>;
  /** fetch data from the table: "arpaymentdetails" */
  arpaymentdetails: Array<Arpaymentdetails>;
  /** fetch aggregated fields from the table: "arpaymentdetails" */
  arpaymentdetails_aggregate: Arpaymentdetails_Aggregate;
  /** fetch data from the table: "arpaymentdetails" using primary key columns */
  arpaymentdetails_by_pk?: Maybe<Arpaymentdetails>;
  /** fetch data from the table in a streaming manner: "arpaymentdetails" */
  arpaymentdetails_stream: Array<Arpaymentdetails>;
  /** fetch data from the table: "arpaymentmethods" */
  arpaymentmethods: Array<Arpaymentmethods>;
  /** fetch aggregated fields from the table: "arpaymentmethods" */
  arpaymentmethods_aggregate: Arpaymentmethods_Aggregate;
  /** fetch data from the table: "arpaymentmethods" using primary key columns */
  arpaymentmethods_by_pk?: Maybe<Arpaymentmethods>;
  /** fetch data from the table in a streaming manner: "arpaymentmethods" */
  arpaymentmethods_stream: Array<Arpaymentmethods>;
  /** An array relationship */
  arpayments: Array<Arpayments>;
  /** An aggregate relationship */
  arpayments_aggregate: Arpayments_Aggregate;
  /** fetch data from the table: "arpayments" using primary key columns */
  arpayments_by_pk?: Maybe<Arpayments>;
  /** fetch data from the table in a streaming manner: "arpayments" */
  arpayments_stream: Array<Arpayments>;
  /** fetch data from the table: "arpriceoverrides" */
  arpriceoverrides: Array<Arpriceoverrides>;
  /** fetch aggregated fields from the table: "arpriceoverrides" */
  arpriceoverrides_aggregate: Arpriceoverrides_Aggregate;
  /** fetch data from the table: "arpriceoverrides" using primary key columns */
  arpriceoverrides_by_pk?: Maybe<Arpriceoverrides>;
  /** fetch data from the table in a streaming manner: "arpriceoverrides" */
  arpriceoverrides_stream: Array<Arpriceoverrides>;
  /** fetch data from the table: "authkeys" */
  authkeys: Array<Authkeys>;
  /** fetch aggregated fields from the table: "authkeys" */
  authkeys_aggregate: Authkeys_Aggregate;
  /** fetch data from the table: "authkeys" using primary key columns */
  authkeys_by_pk?: Maybe<Authkeys>;
  /** fetch data from the table in a streaming manner: "authkeys" */
  authkeys_stream: Array<Authkeys>;
  /** fetch data from the table: "authorizations" */
  authorizations: Array<Authorizations>;
  /** fetch aggregated fields from the table: "authorizations" */
  authorizations_aggregate: Authorizations_Aggregate;
  /** fetch data from the table: "authorizations" using primary key columns */
  authorizations_by_pk?: Maybe<Authorizations>;
  /** fetch data from the table in a streaming manner: "authorizations" */
  authorizations_stream: Array<Authorizations>;
  /** fetch data from the table: "batch_jobs" */
  batch_jobs: Array<Batch_Jobs>;
  /** fetch aggregated fields from the table: "batch_jobs" */
  batch_jobs_aggregate: Batch_Jobs_Aggregate;
  /** fetch data from the table: "batch_jobs" using primary key columns */
  batch_jobs_by_pk?: Maybe<Batch_Jobs>;
  /** fetch data from the table in a streaming manner: "batch_jobs" */
  batch_jobs_stream: Array<Batch_Jobs>;
  /** An array relationship */
  bundles: Array<Bundles>;
  /** An aggregate relationship */
  bundles_aggregate: Bundles_Aggregate;
  /** fetch data from the table: "bundles" using primary key columns */
  bundles_by_pk?: Maybe<Bundles>;
  /** fetch data from the table in a streaming manner: "bundles" */
  bundles_stream: Array<Bundles>;
  /** fetch data from the table: "bundlesets" */
  bundlesets: Array<Bundlesets>;
  /** fetch aggregated fields from the table: "bundlesets" */
  bundlesets_aggregate: Bundlesets_Aggregate;
  /** fetch data from the table: "bundlesets" using primary key columns */
  bundlesets_by_pk?: Maybe<Bundlesets>;
  /** fetch data from the table in a streaming manner: "bundlesets" */
  bundlesets_stream: Array<Bundlesets>;
  /** An array relationship */
  bundletoscenarios: Array<Bundletoscenarios>;
  /** An aggregate relationship */
  bundletoscenarios_aggregate: Bundletoscenarios_Aggregate;
  /** fetch data from the table: "bundletoscenarios" using primary key columns */
  bundletoscenarios_by_pk?: Maybe<Bundletoscenarios>;
  /** fetch data from the table in a streaming manner: "bundletoscenarios" */
  bundletoscenarios_stream: Array<Bundletoscenarios>;
  /** An array relationship */
  businesshours: Array<Businesshours>;
  /** An aggregate relationship */
  businesshours_aggregate: Businesshours_Aggregate;
  /** fetch data from the table: "businesshours" using primary key columns */
  businesshours_by_pk?: Maybe<Businesshours>;
  /** fetch data from the table in a streaming manner: "businesshours" */
  businesshours_stream: Array<Businesshours>;
  /** An array relationship */
  businessrules: Array<Businessrules>;
  /** An aggregate relationship */
  businessrules_aggregate: Businessrules_Aggregate;
  /** fetch data from the table: "businessrules" using primary key columns */
  businessrules_by_pk?: Maybe<Businessrules>;
  /** fetch data from the table in a streaming manner: "businessrules" */
  businessrules_stream: Array<Businessrules>;
  /** fetch data from the table: "businessruletypes" */
  businessruletypes: Array<Businessruletypes>;
  /** fetch aggregated fields from the table: "businessruletypes" */
  businessruletypes_aggregate: Businessruletypes_Aggregate;
  /** fetch data from the table: "businessruletypes" using primary key columns */
  businessruletypes_by_pk?: Maybe<Businessruletypes>;
  /** fetch data from the table in a streaming manner: "businessruletypes" */
  businessruletypes_stream: Array<Businessruletypes>;
  /** fetch data from the table: "certifications" */
  certifications: Array<Certifications>;
  /** fetch aggregated fields from the table: "certifications" */
  certifications_aggregate: Certifications_Aggregate;
  /** fetch data from the table: "certifications" using primary key columns */
  certifications_by_pk?: Maybe<Certifications>;
  /** fetch data from the table in a streaming manner: "certifications" */
  certifications_stream: Array<Certifications>;
  /** fetch data from the table: "chasevehicles" */
  chasevehicles: Array<Chasevehicles>;
  /** fetch aggregated fields from the table: "chasevehicles" */
  chasevehicles_aggregate: Chasevehicles_Aggregate;
  /** fetch data from the table: "chasevehicles" using primary key columns */
  chasevehicles_by_pk?: Maybe<Chasevehicles>;
  /** fetch data from the table in a streaming manner: "chasevehicles" */
  chasevehicles_stream: Array<Chasevehicles>;
  /** fetch data from the table: "chasevehiclesassigned" */
  chasevehiclesassigned: Array<Chasevehiclesassigned>;
  /** fetch aggregated fields from the table: "chasevehiclesassigned" */
  chasevehiclesassigned_aggregate: Chasevehiclesassigned_Aggregate;
  /** fetch data from the table: "chasevehiclesassigned" using primary key columns */
  chasevehiclesassigned_by_pk?: Maybe<Chasevehiclesassigned>;
  /** fetch data from the table in a streaming manner: "chasevehiclesassigned" */
  chasevehiclesassigned_stream: Array<Chasevehiclesassigned>;
  /** fetch data from the table: "consumer_numbers" */
  consumer_numbers: Array<Consumer_Numbers>;
  /** fetch aggregated fields from the table: "consumer_numbers" */
  consumer_numbers_aggregate: Consumer_Numbers_Aggregate;
  /** fetch data from the table: "consumer_numbers" using primary key columns */
  consumer_numbers_by_pk?: Maybe<Consumer_Numbers>;
  /** fetch data from the table in a streaming manner: "consumer_numbers" */
  consumer_numbers_stream: Array<Consumer_Numbers>;
  /** fetch data from the table: "coordinatedplans" */
  coordinatedplans: Array<Coordinatedplans>;
  /** fetch aggregated fields from the table: "coordinatedplans" */
  coordinatedplans_aggregate: Coordinatedplans_Aggregate;
  /** fetch data from the table: "coordinatedplans" using primary key columns */
  coordinatedplans_by_pk?: Maybe<Coordinatedplans>;
  /** fetch data from the table in a streaming manner: "coordinatedplans" */
  coordinatedplans_stream: Array<Coordinatedplans>;
  /** fetch data from the table: "coordinatedplantoscenarios" */
  coordinatedplantoscenarios: Array<Coordinatedplantoscenarios>;
  /** fetch aggregated fields from the table: "coordinatedplantoscenarios" */
  coordinatedplantoscenarios_aggregate: Coordinatedplantoscenarios_Aggregate;
  /** fetch data from the table: "coordinatedplantoscenarios" using primary key columns */
  coordinatedplantoscenarios_by_pk?: Maybe<Coordinatedplantoscenarios>;
  /** fetch data from the table in a streaming manner: "coordinatedplantoscenarios" */
  coordinatedplantoscenarios_stream: Array<Coordinatedplantoscenarios>;
  /** An array relationship */
  customers: Array<Customers>;
  /** An aggregate relationship */
  customers_aggregate: Customers_Aggregate;
  /** fetch data from the table: "customers" using primary key columns */
  customers_by_pk?: Maybe<Customers>;
  /** fetch data from the table in a streaming manner: "customers" */
  customers_stream: Array<Customers>;
  /** fetch data from the table: "customerstocertifications" */
  customerstocertifications: Array<Customerstocertifications>;
  /** fetch aggregated fields from the table: "customerstocertifications" */
  customerstocertifications_aggregate: Customerstocertifications_Aggregate;
  /** fetch data from the table: "customerstocertifications" using primary key columns */
  customerstocertifications_by_pk?: Maybe<Customerstocertifications>;
  /** fetch data from the table in a streaming manner: "customerstocertifications" */
  customerstocertifications_stream: Array<Customerstocertifications>;
  /** fetch data from the table: "dealer_viewable_admin_info" */
  dealer_viewable_admin_info: Array<Dealer_Viewable_Admin_Info>;
  /** fetch aggregated fields from the table: "dealer_viewable_admin_info" */
  dealer_viewable_admin_info_aggregate: Dealer_Viewable_Admin_Info_Aggregate;
  /** fetch data from the table in a streaming manner: "dealer_viewable_admin_info" */
  dealer_viewable_admin_info_stream: Array<Dealer_Viewable_Admin_Info>;
  /** fetch data from the table: "dealer_viewable_driver_info" */
  dealer_viewable_driver_info: Array<Dealer_Viewable_Driver_Info>;
  /** fetch aggregated fields from the table: "dealer_viewable_driver_info" */
  dealer_viewable_driver_info_aggregate: Dealer_Viewable_Driver_Info_Aggregate;
  /** fetch data from the table in a streaming manner: "dealer_viewable_driver_info" */
  dealer_viewable_driver_info_stream: Array<Dealer_Viewable_Driver_Info>;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documents_aggregate: Documents_Aggregate;
  /** fetch data from the table: "documents" using primary key columns */
  documents_by_pk?: Maybe<Documents>;
  /** fetch data from the table in a streaming manner: "documents" */
  documents_stream: Array<Documents>;
  /** fetch data from the table: "driver_pay_by_move" */
  driver_pay_by_move: Array<Driver_Pay_By_Move>;
  /** fetch aggregated fields from the table: "driver_pay_by_move" */
  driver_pay_by_move_aggregate: Driver_Pay_By_Move_Aggregate;
  /** fetch data from the table in a streaming manner: "driver_pay_by_move" */
  driver_pay_by_move_stream: Array<Driver_Pay_By_Move>;
  /** fetch data from the table: "driverappconfig" */
  driverappconfig: Array<Driverappconfig>;
  /** fetch aggregated fields from the table: "driverappconfig" */
  driverappconfig_aggregate: Driverappconfig_Aggregate;
  /** fetch data from the table: "driverappconfig" using primary key columns */
  driverappconfig_by_pk?: Maybe<Driverappconfig>;
  /** fetch data from the table in a streaming manner: "driverappconfig" */
  driverappconfig_stream: Array<Driverappconfig>;
  /** fetch data from the table: "driverblacklist" */
  driverblacklist: Array<Driverblacklist>;
  /** fetch aggregated fields from the table: "driverblacklist" */
  driverblacklist_aggregate: Driverblacklist_Aggregate;
  /** fetch data from the table: "driverblacklist" using primary key columns */
  driverblacklist_by_pk?: Maybe<Driverblacklist>;
  /** fetch data from the table in a streaming manner: "driverblacklist" */
  driverblacklist_stream: Array<Driverblacklist>;
  /** fetch data from the table: "driverdetails" */
  driverdetails: Array<Driverdetails>;
  /** fetch aggregated fields from the table: "driverdetails" */
  driverdetails_aggregate: Driverdetails_Aggregate;
  /** fetch data from the table: "driverdetails" using primary key columns */
  driverdetails_by_pk?: Maybe<Driverdetails>;
  /** fetch data from the table in a streaming manner: "driverdetails" */
  driverdetails_stream: Array<Driverdetails>;
  /** An array relationship */
  driverequipment: Array<Driverequipment>;
  /** An aggregate relationship */
  driverequipment_aggregate: Driverequipment_Aggregate;
  /** fetch data from the table: "driverequipment" using primary key columns */
  driverequipment_by_pk?: Maybe<Driverequipment>;
  /** fetch data from the table in a streaming manner: "driverequipment" */
  driverequipment_stream: Array<Driverequipment>;
  /** fetch data from the table: "driverlocations" */
  driverlocations: Array<Driverlocations>;
  /** fetch aggregated fields from the table: "driverlocations" */
  driverlocations_aggregate: Driverlocations_Aggregate;
  /** fetch data from the table in a streaming manner: "driverlocations" */
  driverlocations_stream: Array<Driverlocations>;
  /** An array relationship */
  driverpayouts: Array<Driverpayouts>;
  /** An aggregate relationship */
  driverpayouts_aggregate: Driverpayouts_Aggregate;
  /** fetch data from the table: "driverpayouts" using primary key columns */
  driverpayouts_by_pk?: Maybe<Driverpayouts>;
  /** fetch data from the table in a streaming manner: "driverpayouts" */
  driverpayouts_stream: Array<Driverpayouts>;
  /** fetch data from the table: "driverpays" */
  driverpays: Array<Driverpays>;
  /** fetch aggregated fields from the table: "driverpays" */
  driverpays_aggregate: Driverpays_Aggregate;
  /** fetch data from the table: "driverpays" using primary key columns */
  driverpays_by_pk?: Maybe<Driverpays>;
  /** fetch data from the table in a streaming manner: "driverpays" */
  driverpays_stream: Array<Driverpays>;
  /** fetch data from the table: "drivers" */
  drivers: Array<Drivers>;
  /** fetch aggregated fields from the table: "drivers" */
  drivers_aggregate: Drivers_Aggregate;
  /** fetch data from the table: "drivers" using primary key columns */
  drivers_by_pk?: Maybe<Drivers>;
  /** fetch data from the table in a streaming manner: "drivers" */
  drivers_stream: Array<Drivers>;
  /** fetch data from the table: "driverscheduledetails" */
  driverscheduledetails: Array<Driverscheduledetails>;
  /** fetch aggregated fields from the table: "driverscheduledetails" */
  driverscheduledetails_aggregate: Driverscheduledetails_Aggregate;
  /** fetch data from the table: "driverscheduledetails" using primary key columns */
  driverscheduledetails_by_pk?: Maybe<Driverscheduledetails>;
  /** fetch data from the table in a streaming manner: "driverscheduledetails" */
  driverscheduledetails_stream: Array<Driverscheduledetails>;
  /** fetch data from the table: "driverschedules" */
  driverschedules: Array<Driverschedules>;
  /** fetch aggregated fields from the table: "driverschedules" */
  driverschedules_aggregate: Driverschedules_Aggregate;
  /** fetch data from the table: "driverschedules" using primary key columns */
  driverschedules_by_pk?: Maybe<Driverschedules>;
  /** fetch data from the table in a streaming manner: "driverschedules" */
  driverschedules_stream: Array<Driverschedules>;
  /** fetch data from the table: "driversinridegroupbymoveid" */
  driversinridegroupbymoveid: Array<Driversinridegroupbymoveid>;
  /** fetch aggregated fields from the table: "driversinridegroupbymoveid" */
  driversinridegroupbymoveid_aggregate: Driversinridegroupbymoveid_Aggregate;
  /** fetch data from the table in a streaming manner: "driversinridegroupbymoveid" */
  driversinridegroupbymoveid_stream: Array<Driversinridegroupbymoveid>;
  /** fetch data from the table: "driverstocertifications" */
  driverstocertifications: Array<Driverstocertifications>;
  /** fetch aggregated fields from the table: "driverstocertifications" */
  driverstocertifications_aggregate: Driverstocertifications_Aggregate;
  /** fetch data from the table: "driverstocertifications" using primary key columns */
  driverstocertifications_by_pk?: Maybe<Driverstocertifications>;
  /** fetch data from the table in a streaming manner: "driverstocertifications" */
  driverstocertifications_stream: Array<Driverstocertifications>;
  /** fetch data from the table: "driverstousecasesoptout" */
  driverstousecasesoptout: Array<Driverstousecasesoptout>;
  /** fetch aggregated fields from the table: "driverstousecasesoptout" */
  driverstousecasesoptout_aggregate: Driverstousecasesoptout_Aggregate;
  /** fetch data from the table: "driverstousecasesoptout" using primary key columns */
  driverstousecasesoptout_by_pk?: Maybe<Driverstousecasesoptout>;
  /** fetch data from the table in a streaming manner: "driverstousecasesoptout" */
  driverstousecasesoptout_stream: Array<Driverstousecasesoptout>;
  /** fetch data from the table: "email_events" */
  email_events: Array<Email_Events>;
  /** fetch aggregated fields from the table: "email_events" */
  email_events_aggregate: Email_Events_Aggregate;
  /** fetch data from the table: "email_events" using primary key columns */
  email_events_by_pk?: Maybe<Email_Events>;
  /** fetch data from the table in a streaming manner: "email_events" */
  email_events_stream: Array<Email_Events>;
  /** fetch data from the table: "equipment" */
  equipment: Array<Equipment>;
  /** fetch aggregated fields from the table: "equipment" */
  equipment_aggregate: Equipment_Aggregate;
  /** fetch data from the table: "equipment" using primary key columns */
  equipment_by_pk?: Maybe<Equipment>;
  /** fetch data from the table in a streaming manner: "equipment" */
  equipment_stream: Array<Equipment>;
  /** An array relationship */
  event_executions: Array<Event_Executions>;
  /** An aggregate relationship */
  event_executions_aggregate: Event_Executions_Aggregate;
  /** fetch data from the table: "event_executions" using primary key columns */
  event_executions_by_pk?: Maybe<Event_Executions>;
  /** fetch data from the table in a streaming manner: "event_executions" */
  event_executions_stream: Array<Event_Executions>;
  /** An array relationship */
  eventlogs: Array<Eventlogs>;
  /** An aggregate relationship */
  eventlogs_aggregate: Eventlogs_Aggregate;
  /** fetch data from the table: "eventlogs" using primary key columns */
  eventlogs_by_pk?: Maybe<Eventlogs>;
  /** fetch data from the table in a streaming manner: "eventlogs" */
  eventlogs_stream: Array<Eventlogs>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  events_aggregate: Events_Aggregate;
  /** fetch data from the table: "events" using primary key columns */
  events_by_pk?: Maybe<Events>;
  /** fetch data from the table in a streaming manner: "events" */
  events_stream: Array<Events>;
  /** fetch data from the table: "faqs" */
  faqs: Array<Faqs>;
  /** fetch aggregated fields from the table: "faqs" */
  faqs_aggregate: Faqs_Aggregate;
  /** fetch data from the table: "faqs" using primary key columns */
  faqs_by_pk?: Maybe<Faqs>;
  /** fetch data from the table in a streaming manner: "faqs" */
  faqs_stream: Array<Faqs>;
  /** An array relationship */
  favoritelanes: Array<Favoritelanes>;
  /** An aggregate relationship */
  favoritelanes_aggregate: Favoritelanes_Aggregate;
  /** fetch data from the table: "favoritelanes" using primary key columns */
  favoritelanes_by_pk?: Maybe<Favoritelanes>;
  /** fetch data from the table in a streaming manner: "favoritelanes" */
  favoritelanes_stream: Array<Favoritelanes>;
  /** An array relationship */
  favoritelocations: Array<Favoritelocations>;
  /** An aggregate relationship */
  favoritelocations_aggregate: Favoritelocations_Aggregate;
  /** fetch data from the table: "favoritelocations" using primary key columns */
  favoritelocations_by_pk?: Maybe<Favoritelocations>;
  /** fetch data from the table in a streaming manner: "favoritelocations" */
  favoritelocations_stream: Array<Favoritelocations>;
  /** fetch data from the table: "features" */
  features: Array<Features>;
  /** fetch aggregated fields from the table: "features" */
  features_aggregate: Features_Aggregate;
  /** fetch data from the table: "features" using primary key columns */
  features_by_pk?: Maybe<Features>;
  /** fetch data from the table in a streaming manner: "features" */
  features_stream: Array<Features>;
  /** fetch data from the table: "fuelprices" */
  fuelprices: Array<Fuelprices>;
  /** fetch aggregated fields from the table: "fuelprices" */
  fuelprices_aggregate: Fuelprices_Aggregate;
  /** fetch data from the table: "fuelprices" using primary key columns */
  fuelprices_by_pk?: Maybe<Fuelprices>;
  /** fetch data from the table in a streaming manner: "fuelprices" */
  fuelprices_stream: Array<Fuelprices>;
  /** An array relationship */
  groupable_moves: Array<Groupable_Moves>;
  /** An aggregate relationship */
  groupable_moves_aggregate: Groupable_Moves_Aggregate;
  /** fetch data from the table in a streaming manner: "groupable_moves" */
  groupable_moves_stream: Array<Groupable_Moves>;
  /** An array relationship */
  hangtags: Array<Hangtags>;
  /** An aggregate relationship */
  hangtags_aggregate: Hangtags_Aggregate;
  /** fetch data from the table: "hangtags" using primary key columns */
  hangtags_by_pk?: Maybe<Hangtags>;
  /** fetch data from the table in a streaming manner: "hangtags" */
  hangtags_stream: Array<Hangtags>;
  /** fetch data from the table: "insurancerates" */
  insurancerates: Array<Insurancerates>;
  /** fetch aggregated fields from the table: "insurancerates" */
  insurancerates_aggregate: Insurancerates_Aggregate;
  /** fetch data from the table: "insurancerates" using primary key columns */
  insurancerates_by_pk?: Maybe<Insurancerates>;
  /** fetch data from the table in a streaming manner: "insurancerates" */
  insurancerates_stream: Array<Insurancerates>;
  /** fetch data from the table: "invocations" */
  invocations: Array<Invocations>;
  /** fetch aggregated fields from the table: "invocations" */
  invocations_aggregate: Invocations_Aggregate;
  /** fetch data from the table: "invocations" using primary key columns */
  invocations_by_pk?: Maybe<Invocations>;
  /** fetch data from the table in a streaming manner: "invocations" */
  invocations_stream: Array<Invocations>;
  /** An array relationship */
  job_executions: Array<Job_Executions>;
  /** An aggregate relationship */
  job_executions_aggregate: Job_Executions_Aggregate;
  /** fetch data from the table: "job_executions" using primary key columns */
  job_executions_by_pk?: Maybe<Job_Executions>;
  /** fetch data from the table in a streaming manner: "job_executions" */
  job_executions_stream: Array<Job_Executions>;
  /** fetch data from the table: "lanemodifiers" */
  lanemodifiers: Array<Lanemodifiers>;
  /** fetch aggregated fields from the table: "lanemodifiers" */
  lanemodifiers_aggregate: Lanemodifiers_Aggregate;
  /** fetch data from the table: "lanemodifiers" using primary key columns */
  lanemodifiers_by_pk?: Maybe<Lanemodifiers>;
  /** fetch data from the table in a streaming manner: "lanemodifiers" */
  lanemodifiers_stream: Array<Lanemodifiers>;
  /** An array relationship */
  lanes: Array<Lanes>;
  /** An aggregate relationship */
  lanes_aggregate: Lanes_Aggregate;
  /** fetch data from the table: "lanes" using primary key columns */
  lanes_by_pk?: Maybe<Lanes>;
  /** fetch data from the table in a streaming manner: "lanes" */
  lanes_stream: Array<Lanes>;
  /** An array relationship */
  locations: Array<Locations>;
  /** An aggregate relationship */
  locations_aggregate: Locations_Aggregate;
  /** fetch data from the table: "locations" using primary key columns */
  locations_by_pk?: Maybe<Locations>;
  /** fetch data from the table in a streaming manner: "locations" */
  locations_stream: Array<Locations>;
  /** An array relationship */
  locationstocertifications: Array<Locationstocertifications>;
  /** An aggregate relationship */
  locationstocertifications_aggregate: Locationstocertifications_Aggregate;
  /** fetch data from the table: "locationstocertifications" using primary key columns */
  locationstocertifications_by_pk?: Maybe<Locationstocertifications>;
  /** fetch data from the table in a streaming manner: "locationstocertifications" */
  locationstocertifications_stream: Array<Locationstocertifications>;
  /** fetch data from the table: "lyftrideattempts" */
  lyftrideattempts: Array<Lyftrideattempts>;
  /** fetch aggregated fields from the table: "lyftrideattempts" */
  lyftrideattempts_aggregate: Lyftrideattempts_Aggregate;
  /** fetch data from the table: "lyftrideattempts" using primary key columns */
  lyftrideattempts_by_pk?: Maybe<Lyftrideattempts>;
  /** fetch data from the table in a streaming manner: "lyftrideattempts" */
  lyftrideattempts_stream: Array<Lyftrideattempts>;
  /** An array relationship */
  lyftrides: Array<Lyftrides>;
  /** An aggregate relationship */
  lyftrides_aggregate: Lyftrides_Aggregate;
  /** fetch data from the table: "lyftrides" using primary key columns */
  lyftrides_by_pk?: Maybe<Lyftrides>;
  /** fetch data from the table in a streaming manner: "lyftrides" */
  lyftrides_stream: Array<Lyftrides>;
  /** fetch data from the table: "metrics_hourly" */
  metrics_hourly: Array<Metrics_Hourly>;
  /** fetch aggregated fields from the table: "metrics_hourly" */
  metrics_hourly_aggregate: Metrics_Hourly_Aggregate;
  /** fetch data from the table: "metrics_hourly" using primary key columns */
  metrics_hourly_by_pk?: Maybe<Metrics_Hourly>;
  /** fetch data from the table in a streaming manner: "metrics_hourly" */
  metrics_hourly_stream: Array<Metrics_Hourly>;
  /** fetch data from the table: "move_counts_by_customer" */
  move_counts_by_customer: Array<Move_Counts_By_Customer>;
  /** fetch aggregated fields from the table: "move_counts_by_customer" */
  move_counts_by_customer_aggregate: Move_Counts_By_Customer_Aggregate;
  /** fetch data from the table in a streaming manner: "move_counts_by_customer" */
  move_counts_by_customer_stream: Array<Move_Counts_By_Customer>;
  /** fetch data from the table: "move_pricing" */
  move_pricing: Array<Move_Pricing>;
  /** fetch aggregated fields from the table: "move_pricing" */
  move_pricing_aggregate: Move_Pricing_Aggregate;
  /** fetch data from the table in a streaming manner: "move_pricing" */
  move_pricing_stream: Array<Move_Pricing>;
  /** fetch data from the table: "move_raterule" */
  move_raterule: Array<Move_Raterule>;
  /** fetch aggregated fields from the table: "move_raterule" */
  move_raterule_aggregate: Move_Raterule_Aggregate;
  /** fetch data from the table in a streaming manner: "move_raterule" */
  move_raterule_stream: Array<Move_Raterule>;
  /** fetch data from the table: "moveaudit" */
  moveaudit: Array<Moveaudit>;
  /** fetch aggregated fields from the table: "moveaudit" */
  moveaudit_aggregate: Moveaudit_Aggregate;
  /** fetch data from the table: "moveaudit" using primary key columns */
  moveaudit_by_pk?: Maybe<Moveaudit>;
  /** fetch data from the table in a streaming manner: "moveaudit" */
  moveaudit_stream: Array<Moveaudit>;
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** fetch data from the table: "moves" using primary key columns */
  moves_by_pk?: Maybe<Moves>;
  /** fetch data from the table in a streaming manner: "moves" */
  moves_stream: Array<Moves>;
  /** fetch data from the table: "notifications" */
  notifications: Array<Notifications>;
  /** fetch aggregated fields from the table: "notifications" */
  notifications_aggregate: Notifications_Aggregate;
  /** fetch data from the table: "notifications" using primary key columns */
  notifications_by_pk?: Maybe<Notifications>;
  /** fetch data from the table in a streaming manner: "notifications" */
  notifications_stream: Array<Notifications>;
  /** An array relationship */
  offers: Array<Offers>;
  /** An aggregate relationship */
  offers_aggregate: Offers_Aggregate;
  /** fetch data from the table: "offers" using primary key columns */
  offers_by_pk?: Maybe<Offers>;
  /** fetch data from the table in a streaming manner: "offers" */
  offers_stream: Array<Offers>;
  /** fetch data from the table: "organizations" */
  organizations: Array<Organizations>;
  /** fetch aggregated fields from the table: "organizations" */
  organizations_aggregate: Organizations_Aggregate;
  /** fetch data from the table: "organizations" using primary key columns */
  organizations_by_pk?: Maybe<Organizations>;
  /** fetch data from the table in a streaming manner: "organizations" */
  organizations_stream: Array<Organizations>;
  /** An array relationship */
  organizationstocertifications: Array<Organizationstocertifications>;
  /** An aggregate relationship */
  organizationstocertifications_aggregate: Organizationstocertifications_Aggregate;
  /** fetch data from the table: "organizationstocertifications" using primary key columns */
  organizationstocertifications_by_pk?: Maybe<Organizationstocertifications>;
  /** fetch data from the table in a streaming manner: "organizationstocertifications" */
  organizationstocertifications_stream: Array<Organizationstocertifications>;
  /** fetch data from the table: "pay_periods_by_driver" */
  pay_periods_by_driver: Array<Pay_Periods_By_Driver>;
  /** fetch aggregated fields from the table: "pay_periods_by_driver" */
  pay_periods_by_driver_aggregate: Pay_Periods_By_Driver_Aggregate;
  /** fetch data from the table in a streaming manner: "pay_periods_by_driver" */
  pay_periods_by_driver_stream: Array<Pay_Periods_By_Driver>;
  /** fetch data from the table: "paycycles" */
  paycycles: Array<Paycycles>;
  /** fetch aggregated fields from the table: "paycycles" */
  paycycles_aggregate: Paycycles_Aggregate;
  /** fetch data from the table: "paycycles" using primary key columns */
  paycycles_by_pk?: Maybe<Paycycles>;
  /** fetch data from the table in a streaming manner: "paycycles" */
  paycycles_stream: Array<Paycycles>;
  /** fetch data from the table: "paycycletodrivertodocuments" */
  paycycletodrivertodocuments: Array<Paycycletodrivertodocuments>;
  /** fetch aggregated fields from the table: "paycycletodrivertodocuments" */
  paycycletodrivertodocuments_aggregate: Paycycletodrivertodocuments_Aggregate;
  /** fetch data from the table: "paycycletodrivertodocuments" using primary key columns */
  paycycletodrivertodocuments_by_pk?: Maybe<Paycycletodrivertodocuments>;
  /** fetch data from the table in a streaming manner: "paycycletodrivertodocuments" */
  paycycletodrivertodocuments_stream: Array<Paycycletodrivertodocuments>;
  /** fetch data from the table: "payertocustomer" */
  payertocustomer: Array<Payertocustomer>;
  /** fetch aggregated fields from the table: "payertocustomer" */
  payertocustomer_aggregate: Payertocustomer_Aggregate;
  /** fetch data from the table: "payertocustomer" using primary key columns */
  payertocustomer_by_pk?: Maybe<Payertocustomer>;
  /** fetch data from the table in a streaming manner: "payertocustomer" */
  payertocustomer_stream: Array<Payertocustomer>;
  /** fetch data from the table: "payrategroups" */
  payrategroups: Array<Payrategroups>;
  /** fetch aggregated fields from the table: "payrategroups" */
  payrategroups_aggregate: Payrategroups_Aggregate;
  /** fetch data from the table: "payrategroups" using primary key columns */
  payrategroups_by_pk?: Maybe<Payrategroups>;
  /** fetch data from the table in a streaming manner: "payrategroups" */
  payrategroups_stream: Array<Payrategroups>;
  /** An array relationship */
  payraterules: Array<Payraterules>;
  /** An aggregate relationship */
  payraterules_aggregate: Payraterules_Aggregate;
  /** fetch data from the table: "payraterules" using primary key columns */
  payraterules_by_pk?: Maybe<Payraterules>;
  /** fetch data from the table in a streaming manner: "payraterules" */
  payraterules_stream: Array<Payraterules>;
  /** An array relationship */
  plans: Array<Plans>;
  /** An aggregate relationship */
  plans_aggregate: Plans_Aggregate;
  /** fetch data from the table: "plans" using primary key columns */
  plans_by_pk?: Maybe<Plans>;
  /** fetch data from the table in a streaming manner: "plans" */
  plans_stream: Array<Plans>;
  /** An array relationship */
  platedetails: Array<Platedetails>;
  /** An aggregate relationship */
  platedetails_aggregate: Platedetails_Aggregate;
  /** fetch data from the table: "platedetails" using primary key columns */
  platedetails_by_pk?: Maybe<Platedetails>;
  /** fetch data from the table in a streaming manner: "platedetails" */
  platedetails_stream: Array<Platedetails>;
  /** fetch data from the table: "plates" */
  plates: Array<Plates>;
  /** fetch aggregated fields from the table: "plates" */
  plates_aggregate: Plates_Aggregate;
  /** fetch data from the table: "plates" using primary key columns */
  plates_by_pk?: Maybe<Plates>;
  /** fetch data from the table in a streaming manner: "plates" */
  plates_stream: Array<Plates>;
  /** An array relationship */
  productfees: Array<Productfees>;
  /** An aggregate relationship */
  productfees_aggregate: Productfees_Aggregate;
  /** fetch data from the table: "productfees" using primary key columns */
  productfees_by_pk?: Maybe<Productfees>;
  /** fetch data from the table in a streaming manner: "productfees" */
  productfees_stream: Array<Productfees>;
  /** fetch data from the table: "products" */
  products: Array<Products>;
  /** fetch aggregated fields from the table: "products" */
  products_aggregate: Products_Aggregate;
  /** fetch data from the table: "products" using primary key columns */
  products_by_pk?: Maybe<Products>;
  /** fetch data from the table in a streaming manner: "products" */
  products_stream: Array<Products>;
  /** fetch data from the table: "promos" */
  promos: Array<Promos>;
  /** fetch aggregated fields from the table: "promos" */
  promos_aggregate: Promos_Aggregate;
  /** fetch data from the table: "promos" using primary key columns */
  promos_by_pk?: Maybe<Promos>;
  /** fetch data from the table in a streaming manner: "promos" */
  promos_stream: Array<Promos>;
  /** An array relationship */
  raterulegroups: Array<Raterulegroups>;
  /** An aggregate relationship */
  raterulegroups_aggregate: Raterulegroups_Aggregate;
  /** fetch data from the table: "raterulegroups" using primary key columns */
  raterulegroups_by_pk?: Maybe<Raterulegroups>;
  /** fetch data from the table in a streaming manner: "raterulegroups" */
  raterulegroups_stream: Array<Raterulegroups>;
  /** An array relationship */
  raterules: Array<Raterules>;
  /** An aggregate relationship */
  raterules_aggregate: Raterules_Aggregate;
  /** fetch data from the table: "raterules" using primary key columns */
  raterules_by_pk?: Maybe<Raterules>;
  /** fetch data from the table in a streaming manner: "raterules" */
  raterules_stream: Array<Raterules>;
  /** fetch data from the table: "regions" */
  regions: Array<Regions>;
  /** fetch aggregated fields from the table: "regions" */
  regions_aggregate: Regions_Aggregate;
  /** fetch data from the table: "regions" using primary key columns */
  regions_by_pk?: Maybe<Regions>;
  /** fetch data from the table in a streaming manner: "regions" */
  regions_stream: Array<Regions>;
  /** fetch data from the table: "ridegroups" */
  ridegroups: Array<Ridegroups>;
  /** fetch aggregated fields from the table: "ridegroups" */
  ridegroups_aggregate: Ridegroups_Aggregate;
  /** fetch data from the table: "ridegroups" using primary key columns */
  ridegroups_by_pk?: Maybe<Ridegroups>;
  /** fetch data from the table in a streaming manner: "ridegroups" */
  ridegroups_stream: Array<Ridegroups>;
  /** fetch data from the table: "ridesharefares" */
  ridesharefares: Array<Ridesharefares>;
  /** fetch aggregated fields from the table: "ridesharefares" */
  ridesharefares_aggregate: Ridesharefares_Aggregate;
  /** fetch data from the table: "ridesharefares" using primary key columns */
  ridesharefares_by_pk?: Maybe<Ridesharefares>;
  /** fetch data from the table in a streaming manner: "ridesharefares" */
  ridesharefares_stream: Array<Ridesharefares>;
  /** An array relationship */
  ridesharerates: Array<Ridesharerates>;
  /** An aggregate relationship */
  ridesharerates_aggregate: Ridesharerates_Aggregate;
  /** fetch data from the table: "ridesharerates" using primary key columns */
  ridesharerates_by_pk?: Maybe<Ridesharerates>;
  /** fetch data from the table in a streaming manner: "ridesharerates" */
  ridesharerates_stream: Array<Ridesharerates>;
  /** fetch data from the table: "rideshareratetoridesharefares" */
  rideshareratetoridesharefares: Array<Rideshareratetoridesharefares>;
  /** fetch aggregated fields from the table: "rideshareratetoridesharefares" */
  rideshareratetoridesharefares_aggregate: Rideshareratetoridesharefares_Aggregate;
  /** fetch data from the table: "rideshareratetoridesharefares" using primary key columns */
  rideshareratetoridesharefares_by_pk?: Maybe<Rideshareratetoridesharefares>;
  /** fetch data from the table in a streaming manner: "rideshareratetoridesharefares" */
  rideshareratetoridesharefares_stream: Array<Rideshareratetoridesharefares>;
  /** fetch data from the table: "roletypes" */
  roletypes: Array<Roletypes>;
  /** fetch aggregated fields from the table: "roletypes" */
  roletypes_aggregate: Roletypes_Aggregate;
  /** fetch data from the table: "roletypes" using primary key columns */
  roletypes_by_pk?: Maybe<Roletypes>;
  /** fetch data from the table in a streaming manner: "roletypes" */
  roletypes_stream: Array<Roletypes>;
  /** An array relationship */
  scenarios: Array<Scenarios>;
  /** An aggregate relationship */
  scenarios_aggregate: Scenarios_Aggregate;
  /** fetch data from the table: "scenarios" using primary key columns */
  scenarios_by_pk?: Maybe<Scenarios>;
  /** fetch data from the table in a streaming manner: "scenarios" */
  scenarios_stream: Array<Scenarios>;
  /** An array relationship */
  scenariotomoves: Array<Scenariotomoves>;
  /** An aggregate relationship */
  scenariotomoves_aggregate: Scenariotomoves_Aggregate;
  /** fetch data from the table: "scenariotomoves" using primary key columns */
  scenariotomoves_by_pk?: Maybe<Scenariotomoves>;
  /** fetch data from the table in a streaming manner: "scenariotomoves" */
  scenariotomoves_stream: Array<Scenariotomoves>;
  /** An array relationship */
  scenariotypes: Array<Scenariotypes>;
  /** An aggregate relationship */
  scenariotypes_aggregate: Scenariotypes_Aggregate;
  /** fetch data from the table: "scenariotypes" using primary key columns */
  scenariotypes_by_pk?: Maybe<Scenariotypes>;
  /** fetch data from the table in a streaming manner: "scenariotypes" */
  scenariotypes_stream: Array<Scenariotypes>;
  /** An array relationship */
  scenariotypestocertifications: Array<Scenariotypestocertifications>;
  /** An aggregate relationship */
  scenariotypestocertifications_aggregate: Scenariotypestocertifications_Aggregate;
  /** fetch data from the table: "scenariotypestocertifications" using primary key columns */
  scenariotypestocertifications_by_pk?: Maybe<Scenariotypestocertifications>;
  /** fetch data from the table in a streaming manner: "scenariotypestocertifications" */
  scenariotypestocertifications_stream: Array<Scenariotypestocertifications>;
  /** fetch data from the table: "sequelizemeta" */
  sequelizemeta: Array<Sequelizemeta>;
  /** fetch aggregated fields from the table: "sequelizemeta" */
  sequelizemeta_aggregate: Sequelizemeta_Aggregate;
  /** fetch data from the table: "sequelizemeta" using primary key columns */
  sequelizemeta_by_pk?: Maybe<Sequelizemeta>;
  /** fetch data from the table in a streaming manner: "sequelizemeta" */
  sequelizemeta_stream: Array<Sequelizemeta>;
  /** fetch data from the table: "slas" */
  slas: Array<Slas>;
  /** fetch aggregated fields from the table: "slas" */
  slas_aggregate: Slas_Aggregate;
  /** fetch data from the table: "slas" using primary key columns */
  slas_by_pk?: Maybe<Slas>;
  /** fetch data from the table in a streaming manner: "slas" */
  slas_stream: Array<Slas>;
  /** fetch data from the table: "slas_to_raterulegroups" */
  slas_to_raterulegroups: Array<Slas_To_Raterulegroups>;
  /** fetch aggregated fields from the table: "slas_to_raterulegroups" */
  slas_to_raterulegroups_aggregate: Slas_To_Raterulegroups_Aggregate;
  /** fetch data from the table: "slas_to_raterulegroups" using primary key columns */
  slas_to_raterulegroups_by_pk?: Maybe<Slas_To_Raterulegroups>;
  /** fetch data from the table in a streaming manner: "slas_to_raterulegroups" */
  slas_to_raterulegroups_stream: Array<Slas_To_Raterulegroups>;
  /** An array relationship */
  smsmedia: Array<Smsmedia>;
  /** An aggregate relationship */
  smsmedia_aggregate: Smsmedia_Aggregate;
  /** fetch data from the table: "smsmedia" using primary key columns */
  smsmedia_by_pk?: Maybe<Smsmedia>;
  /** fetch data from the table in a streaming manner: "smsmedia" */
  smsmedia_stream: Array<Smsmedia>;
  /** An array relationship */
  smsmessages: Array<Smsmessages>;
  /** An aggregate relationship */
  smsmessages_aggregate: Smsmessages_Aggregate;
  /** fetch data from the table: "smsmessages" using primary key columns */
  smsmessages_by_pk?: Maybe<Smsmessages>;
  /** fetch data from the table in a streaming manner: "smsmessages" */
  smsmessages_stream: Array<Smsmessages>;
  /** fetch data from the table: "smstemplates" */
  smstemplates: Array<Smstemplates>;
  /** fetch aggregated fields from the table: "smstemplates" */
  smstemplates_aggregate: Smstemplates_Aggregate;
  /** fetch data from the table: "smstemplates" using primary key columns */
  smstemplates_by_pk?: Maybe<Smstemplates>;
  /** fetch data from the table in a streaming manner: "smstemplates" */
  smstemplates_stream: Array<Smstemplates>;
  /** An array relationship */
  subscriptions: Array<Subscriptions>;
  /** An aggregate relationship */
  subscriptions_aggregate: Subscriptions_Aggregate;
  /** fetch data from the table: "subscriptions" using primary key columns */
  subscriptions_by_pk?: Maybe<Subscriptions>;
  /** fetch data from the table in a streaming manner: "subscriptions" */
  subscriptions_stream: Array<Subscriptions>;
  /** fetch data from the table: "templates" */
  templates: Array<Templates>;
  /** fetch aggregated fields from the table: "templates" */
  templates_aggregate: Templates_Aggregate;
  /** fetch data from the table: "templates" using primary key columns */
  templates_by_pk?: Maybe<Templates>;
  /** fetch data from the table in a streaming manner: "templates" */
  templates_stream: Array<Templates>;
  /** An array relationship */
  trips: Array<Trips>;
  /** An aggregate relationship */
  trips_aggregate: Trips_Aggregate;
  /** fetch data from the table: "trips" using primary key columns */
  trips_by_pk?: Maybe<Trips>;
  /** fetch data from the table in a streaming manner: "trips" */
  trips_stream: Array<Trips>;
  /** fetch data from the table: "usecases" */
  usecases: Array<Usecases>;
  /** fetch aggregated fields from the table: "usecases" */
  usecases_aggregate: Usecases_Aggregate;
  /** fetch data from the table: "usecases" using primary key columns */
  usecases_by_pk?: Maybe<Usecases>;
  /** fetch data from the table in a streaming manner: "usecases" */
  usecases_stream: Array<Usecases>;
  /** An array relationship */
  usecasetocertifications: Array<Usecasetocertifications>;
  /** An aggregate relationship */
  usecasetocertifications_aggregate: Usecasetocertifications_Aggregate;
  /** fetch data from the table: "usecasetocertifications" using primary key columns */
  usecasetocertifications_by_pk?: Maybe<Usecasetocertifications>;
  /** fetch data from the table in a streaming manner: "usecasetocertifications" */
  usecasetocertifications_stream: Array<Usecasetocertifications>;
  /** fetch data from the table: "usereventlogs" */
  usereventlogs: Array<Usereventlogs>;
  /** fetch aggregated fields from the table: "usereventlogs" */
  usereventlogs_aggregate: Usereventlogs_Aggregate;
  /** fetch data from the table: "usereventlogs" using primary key columns */
  usereventlogs_by_pk?: Maybe<Usereventlogs>;
  /** fetch data from the table in a streaming manner: "usereventlogs" */
  usereventlogs_stream: Array<Usereventlogs>;
  /** An array relationship */
  users: Array<Users>;
  /** An aggregate relationship */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
  /** fetch data from the table: "usertocustomers" */
  usertocustomers: Array<Usertocustomers>;
  /** fetch aggregated fields from the table: "usertocustomers" */
  usertocustomers_aggregate: Usertocustomers_Aggregate;
  /** fetch data from the table: "usertocustomers" using primary key columns */
  usertocustomers_by_pk?: Maybe<Usertocustomers>;
  /** fetch data from the table in a streaming manner: "usertocustomers" */
  usertocustomers_stream: Array<Usertocustomers>;
  /** fetch data from the table: "usertofeatures" */
  usertofeatures: Array<Usertofeatures>;
  /** fetch aggregated fields from the table: "usertofeatures" */
  usertofeatures_aggregate: Usertofeatures_Aggregate;
  /** fetch data from the table: "usertofeatures" using primary key columns */
  usertofeatures_by_pk?: Maybe<Usertofeatures>;
  /** fetch data from the table in a streaming manner: "usertofeatures" */
  usertofeatures_stream: Array<Usertofeatures>;
  /** fetch data from the table: "usertoregions" */
  usertoregions: Array<Usertoregions>;
  /** fetch aggregated fields from the table: "usertoregions" */
  usertoregions_aggregate: Usertoregions_Aggregate;
  /** fetch data from the table: "usertoregions" using primary key columns */
  usertoregions_by_pk?: Maybe<Usertoregions>;
  /** fetch data from the table in a streaming manner: "usertoregions" */
  usertoregions_stream: Array<Usertoregions>;
  /** fetch data from the table: "usertoroles" */
  usertoroles: Array<Usertoroles>;
  /** fetch aggregated fields from the table: "usertoroles" */
  usertoroles_aggregate: Usertoroles_Aggregate;
  /** fetch data from the table: "usertoroles" using primary key columns */
  usertoroles_by_pk?: Maybe<Usertoroles>;
  /** fetch data from the table in a streaming manner: "usertoroles" */
  usertoroles_stream: Array<Usertoroles>;
  /** fetch data from the table: "vehiclemakes" */
  vehiclemakes: Array<Vehiclemakes>;
  /** fetch aggregated fields from the table: "vehiclemakes" */
  vehiclemakes_aggregate: Vehiclemakes_Aggregate;
  /** fetch data from the table: "vehiclemakes" using primary key columns */
  vehiclemakes_by_pk?: Maybe<Vehiclemakes>;
  /** fetch data from the table in a streaming manner: "vehiclemakes" */
  vehiclemakes_stream: Array<Vehiclemakes>;
  /** An array relationship */
  vehiclemodels: Array<Vehiclemodels>;
  /** An aggregate relationship */
  vehiclemodels_aggregate: Vehiclemodels_Aggregate;
  /** fetch data from the table: "vehiclemodels" using primary key columns */
  vehiclemodels_by_pk?: Maybe<Vehiclemodels>;
  /** fetch data from the table in a streaming manner: "vehiclemodels" */
  vehiclemodels_stream: Array<Vehiclemodels>;
  /** An array relationship */
  vehiclephotos: Array<Vehiclephotos>;
  /** An aggregate relationship */
  vehiclephotos_aggregate: Vehiclephotos_Aggregate;
  /** fetch data from the table: "vehiclephotos" using primary key columns */
  vehiclephotos_by_pk?: Maybe<Vehiclephotos>;
  /** fetch data from the table in a streaming manner: "vehiclephotos" */
  vehiclephotos_stream: Array<Vehiclephotos>;
  /** fetch data from the table: "vehicles" */
  vehicles: Array<Vehicles>;
  /** fetch aggregated fields from the table: "vehicles" */
  vehicles_aggregate: Vehicles_Aggregate;
  /** fetch data from the table: "vehicles" using primary key columns */
  vehicles_by_pk?: Maybe<Vehicles>;
  /** fetch data from the table in a streaming manner: "vehicles" */
  vehicles_stream: Array<Vehicles>;
  /** An array relationship */
  webhook_events: Array<Webhook_Events>;
  /** An aggregate relationship */
  webhook_events_aggregate: Webhook_Events_Aggregate;
  /** fetch data from the table: "webhook_events" using primary key columns */
  webhook_events_by_pk?: Maybe<Webhook_Events>;
  /** fetch data from the table in a streaming manner: "webhook_events" */
  webhook_events_stream: Array<Webhook_Events>;
  /** fetch data from the table: "workflows" */
  workflows: Array<Workflows>;
  /** fetch aggregated fields from the table: "workflows" */
  workflows_aggregate: Workflows_Aggregate;
  /** fetch data from the table: "workflows" using primary key columns */
  workflows_by_pk?: Maybe<Workflows>;
  /** fetch data from the table in a streaming manner: "workflows" */
  workflows_stream: Array<Workflows>;
  /** An array relationship */
  workflowsets: Array<Workflowsets>;
  /** An aggregate relationship */
  workflowsets_aggregate: Workflowsets_Aggregate;
  /** fetch data from the table: "workflowsets" using primary key columns */
  workflowsets_by_pk?: Maybe<Workflowsets>;
  /** fetch data from the table in a streaming manner: "workflowsets" */
  workflowsets_stream: Array<Workflowsets>;
  /** An array relationship */
  workflowsettypes: Array<Workflowsettypes>;
  /** An aggregate relationship */
  workflowsettypes_aggregate: Workflowsettypes_Aggregate;
  /** fetch data from the table: "workflowsettypes" using primary key columns */
  workflowsettypes_by_pk?: Maybe<Workflowsettypes>;
  /** fetch data from the table in a streaming manner: "workflowsettypes" */
  workflowsettypes_stream: Array<Workflowsettypes>;
  /** fetch data from the table: "workflowsettypestocertifications" */
  workflowsettypestocertifications: Array<Workflowsettypestocertifications>;
  /** fetch aggregated fields from the table: "workflowsettypestocertifications" */
  workflowsettypestocertifications_aggregate: Workflowsettypestocertifications_Aggregate;
  /** fetch data from the table: "workflowsettypestocertifications" using primary key columns */
  workflowsettypestocertifications_by_pk?: Maybe<Workflowsettypestocertifications>;
  /** fetch data from the table in a streaming manner: "workflowsettypestocertifications" */
  workflowsettypestocertifications_stream: Array<Workflowsettypestocertifications>;
};


export type Subscription_RootAccessorialsArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


export type Subscription_RootAccessorials_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorials_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorials_Order_By>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


export type Subscription_RootAccessorials_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAccessorials_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Accessorials_Stream_Cursor_Input>>;
  where?: InputMaybe<Accessorials_Bool_Exp>;
};


export type Subscription_RootAccessorialstoalgorithmsArgs = {
  distinct_on?: InputMaybe<Array<Accessorialstoalgorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorialstoalgorithms_Order_By>>;
  where?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
};


export type Subscription_RootAccessorialstoalgorithms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Accessorialstoalgorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Accessorialstoalgorithms_Order_By>>;
  where?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
};


export type Subscription_RootAccessorialstoalgorithms_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAccessorialstoalgorithms_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Accessorialstoalgorithms_Stream_Cursor_Input>>;
  where?: InputMaybe<Accessorialstoalgorithms_Bool_Exp>;
};


export type Subscription_RootActiontypesArgs = {
  distinct_on?: InputMaybe<Array<Actiontypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Actiontypes_Order_By>>;
  where?: InputMaybe<Actiontypes_Bool_Exp>;
};


export type Subscription_RootActiontypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Actiontypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Actiontypes_Order_By>>;
  where?: InputMaybe<Actiontypes_Bool_Exp>;
};


export type Subscription_RootActiontypes_By_PkArgs = {
  id: Scalars['smallint']['input'];
};


export type Subscription_RootActiontypes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Actiontypes_Stream_Cursor_Input>>;
  where?: InputMaybe<Actiontypes_Bool_Exp>;
};


export type Subscription_RootActivetimesArgs = {
  distinct_on?: InputMaybe<Array<Activetimes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Activetimes_Order_By>>;
  where?: InputMaybe<Activetimes_Bool_Exp>;
};


export type Subscription_RootActivetimes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Activetimes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Activetimes_Order_By>>;
  where?: InputMaybe<Activetimes_Bool_Exp>;
};


export type Subscription_RootActivetimes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootActivetimes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Activetimes_Stream_Cursor_Input>>;
  where?: InputMaybe<Activetimes_Bool_Exp>;
};


export type Subscription_RootAlgorithmsArgs = {
  distinct_on?: InputMaybe<Array<Algorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Algorithms_Order_By>>;
  where?: InputMaybe<Algorithms_Bool_Exp>;
};


export type Subscription_RootAlgorithms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Algorithms_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Algorithms_Order_By>>;
  where?: InputMaybe<Algorithms_Bool_Exp>;
};


export type Subscription_RootAlgorithms_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAlgorithms_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Algorithms_Stream_Cursor_Input>>;
  where?: InputMaybe<Algorithms_Bool_Exp>;
};


export type Subscription_RootApchargesArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


export type Subscription_RootApcharges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apcharges_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Apcharges_Order_By>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


export type Subscription_RootApcharges_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootApcharges_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Apcharges_Stream_Cursor_Input>>;
  where?: InputMaybe<Apcharges_Bool_Exp>;
};


export type Subscription_RootAppaymentsArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


export type Subscription_RootAppayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appayments_Order_By>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


export type Subscription_RootAppayments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAppayments_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Appayments_Stream_Cursor_Input>>;
  where?: InputMaybe<Appayments_Bool_Exp>;
};


export type Subscription_RootAppointmentsArgs = {
  distinct_on?: InputMaybe<Array<Appointments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appointments_Order_By>>;
  where?: InputMaybe<Appointments_Bool_Exp>;
};


export type Subscription_RootAppointments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appointments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appointments_Order_By>>;
  where?: InputMaybe<Appointments_Bool_Exp>;
};


export type Subscription_RootAppointments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAppointments_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Appointments_Stream_Cursor_Input>>;
  where?: InputMaybe<Appointments_Bool_Exp>;
};


export type Subscription_RootAppraisal_VehiclesArgs = {
  distinct_on?: InputMaybe<Array<Appraisal_Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisal_Vehicles_Order_By>>;
  where?: InputMaybe<Appraisal_Vehicles_Bool_Exp>;
};


export type Subscription_RootAppraisal_Vehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appraisal_Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisal_Vehicles_Order_By>>;
  where?: InputMaybe<Appraisal_Vehicles_Bool_Exp>;
};


export type Subscription_RootAppraisal_Vehicles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Appraisal_Vehicles_Stream_Cursor_Input>>;
  where?: InputMaybe<Appraisal_Vehicles_Bool_Exp>;
};


export type Subscription_RootAppraisalsArgs = {
  distinct_on?: InputMaybe<Array<Appraisals_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisals_Order_By>>;
  where?: InputMaybe<Appraisals_Bool_Exp>;
};


export type Subscription_RootAppraisals_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Appraisals_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Appraisals_Order_By>>;
  where?: InputMaybe<Appraisals_Bool_Exp>;
};


export type Subscription_RootAppraisals_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAppraisals_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Appraisals_Stream_Cursor_Input>>;
  where?: InputMaybe<Appraisals_Bool_Exp>;
};


export type Subscription_RootAreventsArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


export type Subscription_RootArevents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arevents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arevents_Order_By>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


export type Subscription_RootArevents_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArevents_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arevents_Stream_Cursor_Input>>;
  where?: InputMaybe<Arevents_Bool_Exp>;
};


export type Subscription_RootArinvoicesArgs = {
  distinct_on?: InputMaybe<Array<Arinvoices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arinvoices_Order_By>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


export type Subscription_RootArinvoices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arinvoices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arinvoices_Order_By>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


export type Subscription_RootArinvoices_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArinvoices_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arinvoices_Stream_Cursor_Input>>;
  where?: InputMaybe<Arinvoices_Bool_Exp>;
};


export type Subscription_RootArmovedetailsArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


export type Subscription_RootArmovedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetails_Order_By>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


export type Subscription_RootArmovedetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArmovedetails_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Armovedetails_Stream_Cursor_Input>>;
  where?: InputMaybe<Armovedetails_Bool_Exp>;
};


export type Subscription_RootArmovedetailshistoryArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


export type Subscription_RootArmovedetailshistory_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armovedetailshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armovedetailshistory_Order_By>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


export type Subscription_RootArmovedetailshistory_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArmovedetailshistory_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Armovedetailshistory_Stream_Cursor_Input>>;
  where?: InputMaybe<Armovedetailshistory_Bool_Exp>;
};


export type Subscription_RootArmovesArgs = {
  distinct_on?: InputMaybe<Array<Armoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoves_Order_By>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


export type Subscription_RootArmoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoves_Order_By>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


export type Subscription_RootArmoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArmoves_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Armoves_Stream_Cursor_Input>>;
  where?: InputMaybe<Armoves_Bool_Exp>;
};


export type Subscription_RootArmoveshistoryArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


export type Subscription_RootArmoveshistory_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Armoveshistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Armoveshistory_Order_By>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


export type Subscription_RootArmoveshistory_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArmoveshistory_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Armoveshistory_Stream_Cursor_Input>>;
  where?: InputMaybe<Armoveshistory_Bool_Exp>;
};


export type Subscription_RootArpaymentdetailsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


export type Subscription_RootArpaymentdetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentdetails_Order_By>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


export type Subscription_RootArpaymentdetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArpaymentdetails_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arpaymentdetails_Stream_Cursor_Input>>;
  where?: InputMaybe<Arpaymentdetails_Bool_Exp>;
};


export type Subscription_RootArpaymentmethodsArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentmethods_Order_By>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


export type Subscription_RootArpaymentmethods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpaymentmethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpaymentmethods_Order_By>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


export type Subscription_RootArpaymentmethods_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArpaymentmethods_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arpaymentmethods_Stream_Cursor_Input>>;
  where?: InputMaybe<Arpaymentmethods_Bool_Exp>;
};


export type Subscription_RootArpaymentsArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


export type Subscription_RootArpayments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpayments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpayments_Order_By>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


export type Subscription_RootArpayments_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArpayments_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arpayments_Stream_Cursor_Input>>;
  where?: InputMaybe<Arpayments_Bool_Exp>;
};


export type Subscription_RootArpriceoverridesArgs = {
  distinct_on?: InputMaybe<Array<Arpriceoverrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpriceoverrides_Order_By>>;
  where?: InputMaybe<Arpriceoverrides_Bool_Exp>;
};


export type Subscription_RootArpriceoverrides_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arpriceoverrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arpriceoverrides_Order_By>>;
  where?: InputMaybe<Arpriceoverrides_Bool_Exp>;
};


export type Subscription_RootArpriceoverrides_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootArpriceoverrides_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arpriceoverrides_Stream_Cursor_Input>>;
  where?: InputMaybe<Arpriceoverrides_Bool_Exp>;
};


export type Subscription_RootAuthkeysArgs = {
  distinct_on?: InputMaybe<Array<Authkeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authkeys_Order_By>>;
  where?: InputMaybe<Authkeys_Bool_Exp>;
};


export type Subscription_RootAuthkeys_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Authkeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authkeys_Order_By>>;
  where?: InputMaybe<Authkeys_Bool_Exp>;
};


export type Subscription_RootAuthkeys_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAuthkeys_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Authkeys_Stream_Cursor_Input>>;
  where?: InputMaybe<Authkeys_Bool_Exp>;
};


export type Subscription_RootAuthorizationsArgs = {
  distinct_on?: InputMaybe<Array<Authorizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authorizations_Order_By>>;
  where?: InputMaybe<Authorizations_Bool_Exp>;
};


export type Subscription_RootAuthorizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Authorizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Authorizations_Order_By>>;
  where?: InputMaybe<Authorizations_Bool_Exp>;
};


export type Subscription_RootAuthorizations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootAuthorizations_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Authorizations_Stream_Cursor_Input>>;
  where?: InputMaybe<Authorizations_Bool_Exp>;
};


export type Subscription_RootBatch_JobsArgs = {
  distinct_on?: InputMaybe<Array<Batch_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Batch_Jobs_Order_By>>;
  where?: InputMaybe<Batch_Jobs_Bool_Exp>;
};


export type Subscription_RootBatch_Jobs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Batch_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Batch_Jobs_Order_By>>;
  where?: InputMaybe<Batch_Jobs_Bool_Exp>;
};


export type Subscription_RootBatch_Jobs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootBatch_Jobs_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Batch_Jobs_Stream_Cursor_Input>>;
  where?: InputMaybe<Batch_Jobs_Bool_Exp>;
};


export type Subscription_RootBundlesArgs = {
  distinct_on?: InputMaybe<Array<Bundles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundles_Order_By>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


export type Subscription_RootBundles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundles_Order_By>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


export type Subscription_RootBundles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootBundles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bundles_Stream_Cursor_Input>>;
  where?: InputMaybe<Bundles_Bool_Exp>;
};


export type Subscription_RootBundlesetsArgs = {
  distinct_on?: InputMaybe<Array<Bundlesets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundlesets_Order_By>>;
  where?: InputMaybe<Bundlesets_Bool_Exp>;
};


export type Subscription_RootBundlesets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundlesets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundlesets_Order_By>>;
  where?: InputMaybe<Bundlesets_Bool_Exp>;
};


export type Subscription_RootBundlesets_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootBundlesets_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bundlesets_Stream_Cursor_Input>>;
  where?: InputMaybe<Bundlesets_Bool_Exp>;
};


export type Subscription_RootBundletoscenariosArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


export type Subscription_RootBundletoscenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Bundletoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Bundletoscenarios_Order_By>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


export type Subscription_RootBundletoscenarios_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootBundletoscenarios_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Bundletoscenarios_Stream_Cursor_Input>>;
  where?: InputMaybe<Bundletoscenarios_Bool_Exp>;
};


export type Subscription_RootBusinesshoursArgs = {
  distinct_on?: InputMaybe<Array<Businesshours_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businesshours_Order_By>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


export type Subscription_RootBusinesshours_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businesshours_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businesshours_Order_By>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


export type Subscription_RootBusinesshours_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootBusinesshours_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Businesshours_Stream_Cursor_Input>>;
  where?: InputMaybe<Businesshours_Bool_Exp>;
};


export type Subscription_RootBusinessrulesArgs = {
  distinct_on?: InputMaybe<Array<Businessrules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessrules_Order_By>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};


export type Subscription_RootBusinessrules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businessrules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessrules_Order_By>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};


export type Subscription_RootBusinessrules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootBusinessrules_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Businessrules_Stream_Cursor_Input>>;
  where?: InputMaybe<Businessrules_Bool_Exp>;
};


export type Subscription_RootBusinessruletypesArgs = {
  distinct_on?: InputMaybe<Array<Businessruletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessruletypes_Order_By>>;
  where?: InputMaybe<Businessruletypes_Bool_Exp>;
};


export type Subscription_RootBusinessruletypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Businessruletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Businessruletypes_Order_By>>;
  where?: InputMaybe<Businessruletypes_Bool_Exp>;
};


export type Subscription_RootBusinessruletypes_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootBusinessruletypes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Businessruletypes_Stream_Cursor_Input>>;
  where?: InputMaybe<Businessruletypes_Bool_Exp>;
};


export type Subscription_RootCertificationsArgs = {
  distinct_on?: InputMaybe<Array<Certifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Certifications_Order_By>>;
  where?: InputMaybe<Certifications_Bool_Exp>;
};


export type Subscription_RootCertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Certifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Certifications_Order_By>>;
  where?: InputMaybe<Certifications_Bool_Exp>;
};


export type Subscription_RootCertifications_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Subscription_RootCertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Certifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Certifications_Bool_Exp>;
};


export type Subscription_RootChasevehiclesArgs = {
  distinct_on?: InputMaybe<Array<Chasevehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehicles_Order_By>>;
  where?: InputMaybe<Chasevehicles_Bool_Exp>;
};


export type Subscription_RootChasevehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chasevehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehicles_Order_By>>;
  where?: InputMaybe<Chasevehicles_Bool_Exp>;
};


export type Subscription_RootChasevehicles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootChasevehicles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Chasevehicles_Stream_Cursor_Input>>;
  where?: InputMaybe<Chasevehicles_Bool_Exp>;
};


export type Subscription_RootChasevehiclesassignedArgs = {
  distinct_on?: InputMaybe<Array<Chasevehiclesassigned_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehiclesassigned_Order_By>>;
  where?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
};


export type Subscription_RootChasevehiclesassigned_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chasevehiclesassigned_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chasevehiclesassigned_Order_By>>;
  where?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
};


export type Subscription_RootChasevehiclesassigned_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootChasevehiclesassigned_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Chasevehiclesassigned_Stream_Cursor_Input>>;
  where?: InputMaybe<Chasevehiclesassigned_Bool_Exp>;
};


export type Subscription_RootConsumer_NumbersArgs = {
  distinct_on?: InputMaybe<Array<Consumer_Numbers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Consumer_Numbers_Order_By>>;
  where?: InputMaybe<Consumer_Numbers_Bool_Exp>;
};


export type Subscription_RootConsumer_Numbers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Consumer_Numbers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Consumer_Numbers_Order_By>>;
  where?: InputMaybe<Consumer_Numbers_Bool_Exp>;
};


export type Subscription_RootConsumer_Numbers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootConsumer_Numbers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Consumer_Numbers_Stream_Cursor_Input>>;
  where?: InputMaybe<Consumer_Numbers_Bool_Exp>;
};


export type Subscription_RootCoordinatedplansArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplans_Order_By>>;
  where?: InputMaybe<Coordinatedplans_Bool_Exp>;
};


export type Subscription_RootCoordinatedplans_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplans_Order_By>>;
  where?: InputMaybe<Coordinatedplans_Bool_Exp>;
};


export type Subscription_RootCoordinatedplans_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootCoordinatedplans_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Coordinatedplans_Stream_Cursor_Input>>;
  where?: InputMaybe<Coordinatedplans_Bool_Exp>;
};


export type Subscription_RootCoordinatedplantoscenariosArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


export type Subscription_RootCoordinatedplantoscenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Coordinatedplantoscenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Coordinatedplantoscenarios_Order_By>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


export type Subscription_RootCoordinatedplantoscenarios_By_PkArgs = {
  coordinatedplan_id: Scalars['bigint']['input'];
  scenario_id: Scalars['bigint']['input'];
};


export type Subscription_RootCoordinatedplantoscenarios_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Coordinatedplantoscenarios_Stream_Cursor_Input>>;
  where?: InputMaybe<Coordinatedplantoscenarios_Bool_Exp>;
};


export type Subscription_RootCustomersArgs = {
  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customers_Order_By>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


export type Subscription_RootCustomers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Customers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customers_Order_By>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


export type Subscription_RootCustomers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootCustomers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Customers_Stream_Cursor_Input>>;
  where?: InputMaybe<Customers_Bool_Exp>;
};


export type Subscription_RootCustomerstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customerstocertifications_Order_By>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


export type Subscription_RootCustomerstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Customerstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Customerstocertifications_Order_By>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


export type Subscription_RootCustomerstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  customer_id: Scalars['bigint']['input'];
};


export type Subscription_RootCustomerstocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Customerstocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Customerstocertifications_Bool_Exp>;
};


export type Subscription_RootDealer_Viewable_Admin_InfoArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Admin_Info_Bool_Exp>;
};


export type Subscription_RootDealer_Viewable_Admin_Info_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Admin_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Admin_Info_Bool_Exp>;
};


export type Subscription_RootDealer_Viewable_Admin_Info_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Dealer_Viewable_Admin_Info_Stream_Cursor_Input>>;
  where?: InputMaybe<Dealer_Viewable_Admin_Info_Bool_Exp>;
};


export type Subscription_RootDealer_Viewable_Driver_InfoArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Driver_Info_Bool_Exp>;
};


export type Subscription_RootDealer_Viewable_Driver_Info_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Dealer_Viewable_Driver_Info_Order_By>>;
  where?: InputMaybe<Dealer_Viewable_Driver_Info_Bool_Exp>;
};


export type Subscription_RootDealer_Viewable_Driver_Info_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Dealer_Viewable_Driver_Info_Stream_Cursor_Input>>;
  where?: InputMaybe<Dealer_Viewable_Driver_Info_Bool_Exp>;
};


export type Subscription_RootDocumentsArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


export type Subscription_RootDocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Documents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Documents_Order_By>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


export type Subscription_RootDocuments_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootDocuments_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Documents_Stream_Cursor_Input>>;
  where?: InputMaybe<Documents_Bool_Exp>;
};


export type Subscription_RootDriver_Pay_By_MoveArgs = {
  distinct_on?: InputMaybe<Array<Driver_Pay_By_Move_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Pay_By_Move_Order_By>>;
  where?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
};


export type Subscription_RootDriver_Pay_By_Move_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driver_Pay_By_Move_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driver_Pay_By_Move_Order_By>>;
  where?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
};


export type Subscription_RootDriver_Pay_By_Move_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driver_Pay_By_Move_Stream_Cursor_Input>>;
  where?: InputMaybe<Driver_Pay_By_Move_Bool_Exp>;
};


export type Subscription_RootDriverappconfigArgs = {
  distinct_on?: InputMaybe<Array<Driverappconfig_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverappconfig_Order_By>>;
  where?: InputMaybe<Driverappconfig_Bool_Exp>;
};


export type Subscription_RootDriverappconfig_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverappconfig_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverappconfig_Order_By>>;
  where?: InputMaybe<Driverappconfig_Bool_Exp>;
};


export type Subscription_RootDriverappconfig_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootDriverappconfig_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverappconfig_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverappconfig_Bool_Exp>;
};


export type Subscription_RootDriverblacklistArgs = {
  distinct_on?: InputMaybe<Array<Driverblacklist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverblacklist_Order_By>>;
  where?: InputMaybe<Driverblacklist_Bool_Exp>;
};


export type Subscription_RootDriverblacklist_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverblacklist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverblacklist_Order_By>>;
  where?: InputMaybe<Driverblacklist_Bool_Exp>;
};


export type Subscription_RootDriverblacklist_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverblacklist_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverblacklist_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverblacklist_Bool_Exp>;
};


export type Subscription_RootDriverdetailsArgs = {
  distinct_on?: InputMaybe<Array<Driverdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverdetails_Order_By>>;
  where?: InputMaybe<Driverdetails_Bool_Exp>;
};


export type Subscription_RootDriverdetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverdetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverdetails_Order_By>>;
  where?: InputMaybe<Driverdetails_Bool_Exp>;
};


export type Subscription_RootDriverdetails_By_PkArgs = {
  driver_id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverdetails_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverdetails_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverdetails_Bool_Exp>;
};


export type Subscription_RootDriverequipmentArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


export type Subscription_RootDriverequipment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverequipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverequipment_Order_By>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


export type Subscription_RootDriverequipment_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverequipment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverequipment_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverequipment_Bool_Exp>;
};


export type Subscription_RootDriverlocationsArgs = {
  distinct_on?: InputMaybe<Array<Driverlocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverlocations_Order_By>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


export type Subscription_RootDriverlocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverlocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverlocations_Order_By>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


export type Subscription_RootDriverlocations_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverlocations_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverlocations_Bool_Exp>;
};


export type Subscription_RootDriverpayoutsArgs = {
  distinct_on?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpayouts_Order_By>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


export type Subscription_RootDriverpayouts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverpayouts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpayouts_Order_By>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


export type Subscription_RootDriverpayouts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverpayouts_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverpayouts_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverpayouts_Bool_Exp>;
};


export type Subscription_RootDriverpaysArgs = {
  distinct_on?: InputMaybe<Array<Driverpays_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpays_Order_By>>;
  where?: InputMaybe<Driverpays_Bool_Exp>;
};


export type Subscription_RootDriverpays_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverpays_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverpays_Order_By>>;
  where?: InputMaybe<Driverpays_Bool_Exp>;
};


export type Subscription_RootDriverpays_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverpays_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverpays_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverpays_Bool_Exp>;
};


export type Subscription_RootDriversArgs = {
  distinct_on?: InputMaybe<Array<Drivers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Drivers_Order_By>>;
  where?: InputMaybe<Drivers_Bool_Exp>;
};


export type Subscription_RootDrivers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Drivers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Drivers_Order_By>>;
  where?: InputMaybe<Drivers_Bool_Exp>;
};


export type Subscription_RootDrivers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDrivers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Drivers_Stream_Cursor_Input>>;
  where?: InputMaybe<Drivers_Bool_Exp>;
};


export type Subscription_RootDriverscheduledetailsArgs = {
  distinct_on?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverscheduledetails_Order_By>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};


export type Subscription_RootDriverscheduledetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverscheduledetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverscheduledetails_Order_By>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};


export type Subscription_RootDriverscheduledetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverscheduledetails_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverscheduledetails_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverscheduledetails_Bool_Exp>;
};


export type Subscription_RootDriverschedulesArgs = {
  distinct_on?: InputMaybe<Array<Driverschedules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverschedules_Order_By>>;
  where?: InputMaybe<Driverschedules_Bool_Exp>;
};


export type Subscription_RootDriverschedules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverschedules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverschedules_Order_By>>;
  where?: InputMaybe<Driverschedules_Bool_Exp>;
};


export type Subscription_RootDriverschedules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootDriverschedules_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverschedules_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverschedules_Bool_Exp>;
};


export type Subscription_RootDriversinridegroupbymoveidArgs = {
  distinct_on?: InputMaybe<Array<Driversinridegroupbymoveid_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driversinridegroupbymoveid_Order_By>>;
  where?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
};


export type Subscription_RootDriversinridegroupbymoveid_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driversinridegroupbymoveid_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driversinridegroupbymoveid_Order_By>>;
  where?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
};


export type Subscription_RootDriversinridegroupbymoveid_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driversinridegroupbymoveid_Stream_Cursor_Input>>;
  where?: InputMaybe<Driversinridegroupbymoveid_Bool_Exp>;
};


export type Subscription_RootDriverstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


export type Subscription_RootDriverstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstocertifications_Order_By>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


export type Subscription_RootDriverstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  driver_id: Scalars['bigint']['input'];
  effective_date: Scalars['timestamptz']['input'];
};


export type Subscription_RootDriverstocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverstocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverstocertifications_Bool_Exp>;
};


export type Subscription_RootDriverstousecasesoptoutArgs = {
  distinct_on?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstousecasesoptout_Order_By>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


export type Subscription_RootDriverstousecasesoptout_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstousecasesoptout_Order_By>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


export type Subscription_RootDriverstousecasesoptout_By_PkArgs = {
  driver_id: Scalars['bigint']['input'];
  usecase_key: Scalars['String']['input'];
};


export type Subscription_RootDriverstousecasesoptout_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Driverstousecasesoptout_Stream_Cursor_Input>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


export type Subscription_RootEmail_EventsArgs = {
  distinct_on?: InputMaybe<Array<Email_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Email_Events_Order_By>>;
  where?: InputMaybe<Email_Events_Bool_Exp>;
};


export type Subscription_RootEmail_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Email_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Email_Events_Order_By>>;
  where?: InputMaybe<Email_Events_Bool_Exp>;
};


export type Subscription_RootEmail_Events_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootEmail_Events_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Email_Events_Stream_Cursor_Input>>;
  where?: InputMaybe<Email_Events_Bool_Exp>;
};


export type Subscription_RootEquipmentArgs = {
  distinct_on?: InputMaybe<Array<Equipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Equipment_Order_By>>;
  where?: InputMaybe<Equipment_Bool_Exp>;
};


export type Subscription_RootEquipment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Equipment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Equipment_Order_By>>;
  where?: InputMaybe<Equipment_Bool_Exp>;
};


export type Subscription_RootEquipment_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootEquipment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Equipment_Stream_Cursor_Input>>;
  where?: InputMaybe<Equipment_Bool_Exp>;
};


export type Subscription_RootEvent_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Event_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Event_Executions_Order_By>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


export type Subscription_RootEvent_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Event_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Event_Executions_Order_By>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


export type Subscription_RootEvent_Executions_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootEvent_Executions_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Event_Executions_Stream_Cursor_Input>>;
  where?: InputMaybe<Event_Executions_Bool_Exp>;
};


export type Subscription_RootEventlogsArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


export type Subscription_RootEventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Eventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Eventlogs_Order_By>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


export type Subscription_RootEventlogs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootEventlogs_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Eventlogs_Stream_Cursor_Input>>;
  where?: InputMaybe<Eventlogs_Bool_Exp>;
};


export type Subscription_RootEventsArgs = {
  distinct_on?: InputMaybe<Array<Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Events_Order_By>>;
  where?: InputMaybe<Events_Bool_Exp>;
};


export type Subscription_RootEvents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Events_Order_By>>;
  where?: InputMaybe<Events_Bool_Exp>;
};


export type Subscription_RootEvents_By_PkArgs = {
  eventid: Scalars['String']['input'];
};


export type Subscription_RootEvents_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Events_Stream_Cursor_Input>>;
  where?: InputMaybe<Events_Bool_Exp>;
};


export type Subscription_RootFaqsArgs = {
  distinct_on?: InputMaybe<Array<Faqs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faqs_Order_By>>;
  where?: InputMaybe<Faqs_Bool_Exp>;
};


export type Subscription_RootFaqs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faqs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faqs_Order_By>>;
  where?: InputMaybe<Faqs_Bool_Exp>;
};


export type Subscription_RootFaqs_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootFaqs_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faqs_Stream_Cursor_Input>>;
  where?: InputMaybe<Faqs_Bool_Exp>;
};


export type Subscription_RootFavoritelanesArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


export type Subscription_RootFavoritelanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelanes_Order_By>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


export type Subscription_RootFavoritelanes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootFavoritelanes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Favoritelanes_Stream_Cursor_Input>>;
  where?: InputMaybe<Favoritelanes_Bool_Exp>;
};


export type Subscription_RootFavoritelocationsArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


export type Subscription_RootFavoritelocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Favoritelocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Favoritelocations_Order_By>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


export type Subscription_RootFavoritelocations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootFavoritelocations_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Favoritelocations_Stream_Cursor_Input>>;
  where?: InputMaybe<Favoritelocations_Bool_Exp>;
};


export type Subscription_RootFeaturesArgs = {
  distinct_on?: InputMaybe<Array<Features_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Features_Order_By>>;
  where?: InputMaybe<Features_Bool_Exp>;
};


export type Subscription_RootFeatures_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Features_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Features_Order_By>>;
  where?: InputMaybe<Features_Bool_Exp>;
};


export type Subscription_RootFeatures_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootFeatures_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Features_Stream_Cursor_Input>>;
  where?: InputMaybe<Features_Bool_Exp>;
};


export type Subscription_RootFuelpricesArgs = {
  distinct_on?: InputMaybe<Array<Fuelprices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fuelprices_Order_By>>;
  where?: InputMaybe<Fuelprices_Bool_Exp>;
};


export type Subscription_RootFuelprices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Fuelprices_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Fuelprices_Order_By>>;
  where?: InputMaybe<Fuelprices_Bool_Exp>;
};


export type Subscription_RootFuelprices_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootFuelprices_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Fuelprices_Stream_Cursor_Input>>;
  where?: InputMaybe<Fuelprices_Bool_Exp>;
};


export type Subscription_RootGroupable_MovesArgs = {
  distinct_on?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Groupable_Moves_Order_By>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


export type Subscription_RootGroupable_Moves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Groupable_Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Groupable_Moves_Order_By>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


export type Subscription_RootGroupable_Moves_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Groupable_Moves_Stream_Cursor_Input>>;
  where?: InputMaybe<Groupable_Moves_Bool_Exp>;
};


export type Subscription_RootHangtagsArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


export type Subscription_RootHangtags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Hangtags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Hangtags_Order_By>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


export type Subscription_RootHangtags_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootHangtags_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Hangtags_Stream_Cursor_Input>>;
  where?: InputMaybe<Hangtags_Bool_Exp>;
};


export type Subscription_RootInsuranceratesArgs = {
  distinct_on?: InputMaybe<Array<Insurancerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Insurancerates_Order_By>>;
  where?: InputMaybe<Insurancerates_Bool_Exp>;
};


export type Subscription_RootInsurancerates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Insurancerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Insurancerates_Order_By>>;
  where?: InputMaybe<Insurancerates_Bool_Exp>;
};


export type Subscription_RootInsurancerates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootInsurancerates_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Insurancerates_Stream_Cursor_Input>>;
  where?: InputMaybe<Insurancerates_Bool_Exp>;
};


export type Subscription_RootInvocationsArgs = {
  distinct_on?: InputMaybe<Array<Invocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Invocations_Order_By>>;
  where?: InputMaybe<Invocations_Bool_Exp>;
};


export type Subscription_RootInvocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Invocations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Invocations_Order_By>>;
  where?: InputMaybe<Invocations_Bool_Exp>;
};


export type Subscription_RootInvocations_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootInvocations_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Invocations_Stream_Cursor_Input>>;
  where?: InputMaybe<Invocations_Bool_Exp>;
};


export type Subscription_RootJob_ExecutionsArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


export type Subscription_RootJob_Executions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Job_Executions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Job_Executions_Order_By>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


export type Subscription_RootJob_Executions_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootJob_Executions_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Job_Executions_Stream_Cursor_Input>>;
  where?: InputMaybe<Job_Executions_Bool_Exp>;
};


export type Subscription_RootLanemodifiersArgs = {
  distinct_on?: InputMaybe<Array<Lanemodifiers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanemodifiers_Order_By>>;
  where?: InputMaybe<Lanemodifiers_Bool_Exp>;
};


export type Subscription_RootLanemodifiers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanemodifiers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanemodifiers_Order_By>>;
  where?: InputMaybe<Lanemodifiers_Bool_Exp>;
};


export type Subscription_RootLanemodifiers_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootLanemodifiers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Lanemodifiers_Stream_Cursor_Input>>;
  where?: InputMaybe<Lanemodifiers_Bool_Exp>;
};


export type Subscription_RootLanesArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


export type Subscription_RootLanes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lanes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lanes_Order_By>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


export type Subscription_RootLanes_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootLanes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Lanes_Stream_Cursor_Input>>;
  where?: InputMaybe<Lanes_Bool_Exp>;
};


export type Subscription_RootLocationsArgs = {
  distinct_on?: InputMaybe<Array<Locations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locations_Order_By>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


export type Subscription_RootLocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locations_Order_By>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


export type Subscription_RootLocations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootLocations_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Locations_Stream_Cursor_Input>>;
  where?: InputMaybe<Locations_Bool_Exp>;
};


export type Subscription_RootLocationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


export type Subscription_RootLocationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Locationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Locationstocertifications_Order_By>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


export type Subscription_RootLocationstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  location_id: Scalars['bigint']['input'];
};


export type Subscription_RootLocationstocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Locationstocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Locationstocertifications_Bool_Exp>;
};


export type Subscription_RootLyftrideattemptsArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


export type Subscription_RootLyftrideattempts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrideattempts_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrideattempts_Order_By>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


export type Subscription_RootLyftrideattempts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootLyftrideattempts_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Lyftrideattempts_Stream_Cursor_Input>>;
  where?: InputMaybe<Lyftrideattempts_Bool_Exp>;
};


export type Subscription_RootLyftridesArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


export type Subscription_RootLyftrides_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Lyftrides_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Lyftrides_Order_By>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


export type Subscription_RootLyftrides_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootLyftrides_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Lyftrides_Stream_Cursor_Input>>;
  where?: InputMaybe<Lyftrides_Bool_Exp>;
};


export type Subscription_RootMetrics_HourlyArgs = {
  distinct_on?: InputMaybe<Array<Metrics_Hourly_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Metrics_Hourly_Order_By>>;
  where?: InputMaybe<Metrics_Hourly_Bool_Exp>;
};


export type Subscription_RootMetrics_Hourly_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Metrics_Hourly_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Metrics_Hourly_Order_By>>;
  where?: InputMaybe<Metrics_Hourly_Bool_Exp>;
};


export type Subscription_RootMetrics_Hourly_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMetrics_Hourly_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Metrics_Hourly_Stream_Cursor_Input>>;
  where?: InputMaybe<Metrics_Hourly_Bool_Exp>;
};


export type Subscription_RootMove_Counts_By_CustomerArgs = {
  distinct_on?: InputMaybe<Array<Move_Counts_By_Customer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Counts_By_Customer_Order_By>>;
  where?: InputMaybe<Move_Counts_By_Customer_Bool_Exp>;
};


export type Subscription_RootMove_Counts_By_Customer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Move_Counts_By_Customer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Counts_By_Customer_Order_By>>;
  where?: InputMaybe<Move_Counts_By_Customer_Bool_Exp>;
};


export type Subscription_RootMove_Counts_By_Customer_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Move_Counts_By_Customer_Stream_Cursor_Input>>;
  where?: InputMaybe<Move_Counts_By_Customer_Bool_Exp>;
};


export type Subscription_RootMove_PricingArgs = {
  distinct_on?: InputMaybe<Array<Move_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Pricing_Order_By>>;
  where?: InputMaybe<Move_Pricing_Bool_Exp>;
};


export type Subscription_RootMove_Pricing_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Move_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Pricing_Order_By>>;
  where?: InputMaybe<Move_Pricing_Bool_Exp>;
};


export type Subscription_RootMove_Pricing_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Move_Pricing_Stream_Cursor_Input>>;
  where?: InputMaybe<Move_Pricing_Bool_Exp>;
};


export type Subscription_RootMove_RateruleArgs = {
  distinct_on?: InputMaybe<Array<Move_Raterule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Raterule_Order_By>>;
  where?: InputMaybe<Move_Raterule_Bool_Exp>;
};


export type Subscription_RootMove_Raterule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Move_Raterule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Move_Raterule_Order_By>>;
  where?: InputMaybe<Move_Raterule_Bool_Exp>;
};


export type Subscription_RootMove_Raterule_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Move_Raterule_Stream_Cursor_Input>>;
  where?: InputMaybe<Move_Raterule_Bool_Exp>;
};


export type Subscription_RootMoveauditArgs = {
  distinct_on?: InputMaybe<Array<Moveaudit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moveaudit_Order_By>>;
  where?: InputMaybe<Moveaudit_Bool_Exp>;
};


export type Subscription_RootMoveaudit_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moveaudit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moveaudit_Order_By>>;
  where?: InputMaybe<Moveaudit_Bool_Exp>;
};


export type Subscription_RootMoveaudit_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootMoveaudit_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Moveaudit_Stream_Cursor_Input>>;
  where?: InputMaybe<Moveaudit_Bool_Exp>;
};


export type Subscription_RootMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


export type Subscription_RootMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


export type Subscription_RootMoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootMoves_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Moves_Stream_Cursor_Input>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


export type Subscription_RootNotificationsArgs = {
  distinct_on?: InputMaybe<Array<Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notifications_Order_By>>;
  where?: InputMaybe<Notifications_Bool_Exp>;
};


export type Subscription_RootNotifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Notifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Notifications_Order_By>>;
  where?: InputMaybe<Notifications_Bool_Exp>;
};


export type Subscription_RootNotifications_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootNotifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Notifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Notifications_Bool_Exp>;
};


export type Subscription_RootOffersArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


export type Subscription_RootOffers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Offers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Offers_Order_By>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


export type Subscription_RootOffers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootOffers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Offers_Stream_Cursor_Input>>;
  where?: InputMaybe<Offers_Bool_Exp>;
};


export type Subscription_RootOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Subscription_RootOrganizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Subscription_RootOrganizations_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootOrganizations_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Organizations_Stream_Cursor_Input>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Subscription_RootOrganizationstocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


export type Subscription_RootOrganizationstocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizationstocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Organizationstocertifications_Order_By>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


export type Subscription_RootOrganizationstocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  organization_id: Scalars['bigint']['input'];
};


export type Subscription_RootOrganizationstocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Organizationstocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Organizationstocertifications_Bool_Exp>;
};


export type Subscription_RootPay_Periods_By_DriverArgs = {
  distinct_on?: InputMaybe<Array<Pay_Periods_By_Driver_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pay_Periods_By_Driver_Order_By>>;
  where?: InputMaybe<Pay_Periods_By_Driver_Bool_Exp>;
};


export type Subscription_RootPay_Periods_By_Driver_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pay_Periods_By_Driver_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pay_Periods_By_Driver_Order_By>>;
  where?: InputMaybe<Pay_Periods_By_Driver_Bool_Exp>;
};


export type Subscription_RootPay_Periods_By_Driver_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Pay_Periods_By_Driver_Stream_Cursor_Input>>;
  where?: InputMaybe<Pay_Periods_By_Driver_Bool_Exp>;
};


export type Subscription_RootPaycyclesArgs = {
  distinct_on?: InputMaybe<Array<Paycycles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycles_Order_By>>;
  where?: InputMaybe<Paycycles_Bool_Exp>;
};


export type Subscription_RootPaycycles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Paycycles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycles_Order_By>>;
  where?: InputMaybe<Paycycles_Bool_Exp>;
};


export type Subscription_RootPaycycles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPaycycles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Paycycles_Stream_Cursor_Input>>;
  where?: InputMaybe<Paycycles_Bool_Exp>;
};


export type Subscription_RootPaycycletodrivertodocumentsArgs = {
  distinct_on?: InputMaybe<Array<Paycycletodrivertodocuments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycletodrivertodocuments_Order_By>>;
  where?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
};


export type Subscription_RootPaycycletodrivertodocuments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Paycycletodrivertodocuments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Paycycletodrivertodocuments_Order_By>>;
  where?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
};


export type Subscription_RootPaycycletodrivertodocuments_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootPaycycletodrivertodocuments_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Paycycletodrivertodocuments_Stream_Cursor_Input>>;
  where?: InputMaybe<Paycycletodrivertodocuments_Bool_Exp>;
};


export type Subscription_RootPayertocustomerArgs = {
  distinct_on?: InputMaybe<Array<Payertocustomer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payertocustomer_Order_By>>;
  where?: InputMaybe<Payertocustomer_Bool_Exp>;
};


export type Subscription_RootPayertocustomer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payertocustomer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payertocustomer_Order_By>>;
  where?: InputMaybe<Payertocustomer_Bool_Exp>;
};


export type Subscription_RootPayertocustomer_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPayertocustomer_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Payertocustomer_Stream_Cursor_Input>>;
  where?: InputMaybe<Payertocustomer_Bool_Exp>;
};


export type Subscription_RootPayrategroupsArgs = {
  distinct_on?: InputMaybe<Array<Payrategroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payrategroups_Order_By>>;
  where?: InputMaybe<Payrategroups_Bool_Exp>;
};


export type Subscription_RootPayrategroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payrategroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payrategroups_Order_By>>;
  where?: InputMaybe<Payrategroups_Bool_Exp>;
};


export type Subscription_RootPayrategroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPayrategroups_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Payrategroups_Stream_Cursor_Input>>;
  where?: InputMaybe<Payrategroups_Bool_Exp>;
};


export type Subscription_RootPayraterulesArgs = {
  distinct_on?: InputMaybe<Array<Payraterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payraterules_Order_By>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


export type Subscription_RootPayraterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payraterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Payraterules_Order_By>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


export type Subscription_RootPayraterules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPayraterules_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Payraterules_Stream_Cursor_Input>>;
  where?: InputMaybe<Payraterules_Bool_Exp>;
};


export type Subscription_RootPlansArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Subscription_RootPlans_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Subscription_RootPlans_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPlans_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Plans_Stream_Cursor_Input>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Subscription_RootPlatedetailsArgs = {
  distinct_on?: InputMaybe<Array<Platedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Platedetails_Order_By>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};


export type Subscription_RootPlatedetails_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Platedetails_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Platedetails_Order_By>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};


export type Subscription_RootPlatedetails_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPlatedetails_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Platedetails_Stream_Cursor_Input>>;
  where?: InputMaybe<Platedetails_Bool_Exp>;
};


export type Subscription_RootPlatesArgs = {
  distinct_on?: InputMaybe<Array<Plates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plates_Order_By>>;
  where?: InputMaybe<Plates_Bool_Exp>;
};


export type Subscription_RootPlates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Plates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plates_Order_By>>;
  where?: InputMaybe<Plates_Bool_Exp>;
};


export type Subscription_RootPlates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPlates_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Plates_Stream_Cursor_Input>>;
  where?: InputMaybe<Plates_Bool_Exp>;
};


export type Subscription_RootProductfeesArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


export type Subscription_RootProductfees_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Productfees_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Productfees_Order_By>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


export type Subscription_RootProductfees_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootProductfees_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Productfees_Stream_Cursor_Input>>;
  where?: InputMaybe<Productfees_Bool_Exp>;
};


export type Subscription_RootProductsArgs = {
  distinct_on?: InputMaybe<Array<Products_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Products_Order_By>>;
  where?: InputMaybe<Products_Bool_Exp>;
};


export type Subscription_RootProducts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Products_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Products_Order_By>>;
  where?: InputMaybe<Products_Bool_Exp>;
};


export type Subscription_RootProducts_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootProducts_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Products_Stream_Cursor_Input>>;
  where?: InputMaybe<Products_Bool_Exp>;
};


export type Subscription_RootPromosArgs = {
  distinct_on?: InputMaybe<Array<Promos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Promos_Order_By>>;
  where?: InputMaybe<Promos_Bool_Exp>;
};


export type Subscription_RootPromos_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Promos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Promos_Order_By>>;
  where?: InputMaybe<Promos_Bool_Exp>;
};


export type Subscription_RootPromos_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootPromos_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Promos_Stream_Cursor_Input>>;
  where?: InputMaybe<Promos_Bool_Exp>;
};


export type Subscription_RootRaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


export type Subscription_RootRaterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


export type Subscription_RootRaterulegroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootRaterulegroups_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Raterulegroups_Stream_Cursor_Input>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


export type Subscription_RootRaterulesArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


export type Subscription_RootRaterules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterules_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterules_Order_By>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


export type Subscription_RootRaterules_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootRaterules_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Raterules_Stream_Cursor_Input>>;
  where?: InputMaybe<Raterules_Bool_Exp>;
};


export type Subscription_RootRegionsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Subscription_RootRegions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Subscription_RootRegions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootRegions_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Regions_Stream_Cursor_Input>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Subscription_RootRidegroupsArgs = {
  distinct_on?: InputMaybe<Array<Ridegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridegroups_Order_By>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};


export type Subscription_RootRidegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridegroups_Order_By>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};


export type Subscription_RootRidegroups_By_PkArgs = {
  drive_move_id: Scalars['bigint']['input'];
  group_id: Scalars['uuid']['input'];
};


export type Subscription_RootRidegroups_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Ridegroups_Stream_Cursor_Input>>;
  where?: InputMaybe<Ridegroups_Bool_Exp>;
};


export type Subscription_RootRidesharefaresArgs = {
  distinct_on?: InputMaybe<Array<Ridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharefares_Order_By>>;
  where?: InputMaybe<Ridesharefares_Bool_Exp>;
};


export type Subscription_RootRidesharefares_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharefares_Order_By>>;
  where?: InputMaybe<Ridesharefares_Bool_Exp>;
};


export type Subscription_RootRidesharefares_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootRidesharefares_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Ridesharefares_Stream_Cursor_Input>>;
  where?: InputMaybe<Ridesharefares_Bool_Exp>;
};


export type Subscription_RootRideshareratesArgs = {
  distinct_on?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharerates_Order_By>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};


export type Subscription_RootRidesharerates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ridesharerates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Ridesharerates_Order_By>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};


export type Subscription_RootRidesharerates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootRidesharerates_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Ridesharerates_Stream_Cursor_Input>>;
  where?: InputMaybe<Ridesharerates_Bool_Exp>;
};


export type Subscription_RootRideshareratetoridesharefaresArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


export type Subscription_RootRideshareratetoridesharefares_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rideshareratetoridesharefares_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rideshareratetoridesharefares_Order_By>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


export type Subscription_RootRideshareratetoridesharefares_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootRideshareratetoridesharefares_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rideshareratetoridesharefares_Stream_Cursor_Input>>;
  where?: InputMaybe<Rideshareratetoridesharefares_Bool_Exp>;
};


export type Subscription_RootRoletypesArgs = {
  distinct_on?: InputMaybe<Array<Roletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Roletypes_Order_By>>;
  where?: InputMaybe<Roletypes_Bool_Exp>;
};


export type Subscription_RootRoletypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Roletypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Roletypes_Order_By>>;
  where?: InputMaybe<Roletypes_Bool_Exp>;
};


export type Subscription_RootRoletypes_By_PkArgs = {
  id: Scalars['smallint']['input'];
};


export type Subscription_RootRoletypes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Roletypes_Stream_Cursor_Input>>;
  where?: InputMaybe<Roletypes_Bool_Exp>;
};


export type Subscription_RootScenariosArgs = {
  distinct_on?: InputMaybe<Array<Scenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenarios_Order_By>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


export type Subscription_RootScenarios_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenarios_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenarios_Order_By>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


export type Subscription_RootScenarios_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootScenarios_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Scenarios_Stream_Cursor_Input>>;
  where?: InputMaybe<Scenarios_Bool_Exp>;
};


export type Subscription_RootScenariotomovesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


export type Subscription_RootScenariotomoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotomoves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotomoves_Order_By>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


export type Subscription_RootScenariotomoves_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootScenariotomoves_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Scenariotomoves_Stream_Cursor_Input>>;
  where?: InputMaybe<Scenariotomoves_Bool_Exp>;
};


export type Subscription_RootScenariotypesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypes_Order_By>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


export type Subscription_RootScenariotypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypes_Order_By>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


export type Subscription_RootScenariotypes_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Subscription_RootScenariotypes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Scenariotypes_Stream_Cursor_Input>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


export type Subscription_RootScenariotypestocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


export type Subscription_RootScenariotypestocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypestocertifications_Order_By>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


export type Subscription_RootScenariotypestocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  scenario_key: Scalars['String']['input'];
};


export type Subscription_RootScenariotypestocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Scenariotypestocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Scenariotypestocertifications_Bool_Exp>;
};


export type Subscription_RootSequelizemetaArgs = {
  distinct_on?: InputMaybe<Array<Sequelizemeta_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Sequelizemeta_Order_By>>;
  where?: InputMaybe<Sequelizemeta_Bool_Exp>;
};


export type Subscription_RootSequelizemeta_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Sequelizemeta_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Sequelizemeta_Order_By>>;
  where?: InputMaybe<Sequelizemeta_Bool_Exp>;
};


export type Subscription_RootSequelizemeta_By_PkArgs = {
  name: Scalars['String']['input'];
};


export type Subscription_RootSequelizemeta_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Sequelizemeta_Stream_Cursor_Input>>;
  where?: InputMaybe<Sequelizemeta_Bool_Exp>;
};


export type Subscription_RootSlasArgs = {
  distinct_on?: InputMaybe<Array<Slas_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_Order_By>>;
  where?: InputMaybe<Slas_Bool_Exp>;
};


export type Subscription_RootSlas_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Slas_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_Order_By>>;
  where?: InputMaybe<Slas_Bool_Exp>;
};


export type Subscription_RootSlas_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSlas_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Slas_Stream_Cursor_Input>>;
  where?: InputMaybe<Slas_Bool_Exp>;
};


export type Subscription_RootSlas_To_RaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


export type Subscription_RootSlas_To_Raterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Slas_To_Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Slas_To_Raterulegroups_Order_By>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


export type Subscription_RootSlas_To_Raterulegroups_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSlas_To_Raterulegroups_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Slas_To_Raterulegroups_Stream_Cursor_Input>>;
  where?: InputMaybe<Slas_To_Raterulegroups_Bool_Exp>;
};


export type Subscription_RootSmsmediaArgs = {
  distinct_on?: InputMaybe<Array<Smsmedia_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmedia_Order_By>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};


export type Subscription_RootSmsmedia_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smsmedia_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmedia_Order_By>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};


export type Subscription_RootSmsmedia_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSmsmedia_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Smsmedia_Stream_Cursor_Input>>;
  where?: InputMaybe<Smsmedia_Bool_Exp>;
};


export type Subscription_RootSmsmessagesArgs = {
  distinct_on?: InputMaybe<Array<Smsmessages_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmessages_Order_By>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};


export type Subscription_RootSmsmessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smsmessages_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smsmessages_Order_By>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};


export type Subscription_RootSmsmessages_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSmsmessages_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Smsmessages_Stream_Cursor_Input>>;
  where?: InputMaybe<Smsmessages_Bool_Exp>;
};


export type Subscription_RootSmstemplatesArgs = {
  distinct_on?: InputMaybe<Array<Smstemplates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smstemplates_Order_By>>;
  where?: InputMaybe<Smstemplates_Bool_Exp>;
};


export type Subscription_RootSmstemplates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Smstemplates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Smstemplates_Order_By>>;
  where?: InputMaybe<Smstemplates_Bool_Exp>;
};


export type Subscription_RootSmstemplates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSmstemplates_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Smstemplates_Stream_Cursor_Input>>;
  where?: InputMaybe<Smstemplates_Bool_Exp>;
};


export type Subscription_RootSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Subscriptions_Order_By>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


export type Subscription_RootSubscriptions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Subscriptions_Order_By>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


export type Subscription_RootSubscriptions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSubscriptions_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Subscriptions_Stream_Cursor_Input>>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};


export type Subscription_RootTemplatesArgs = {
  distinct_on?: InputMaybe<Array<Templates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Templates_Order_By>>;
  where?: InputMaybe<Templates_Bool_Exp>;
};


export type Subscription_RootTemplates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Templates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Templates_Order_By>>;
  where?: InputMaybe<Templates_Bool_Exp>;
};


export type Subscription_RootTemplates_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootTemplates_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Templates_Stream_Cursor_Input>>;
  where?: InputMaybe<Templates_Bool_Exp>;
};


export type Subscription_RootTripsArgs = {
  distinct_on?: InputMaybe<Array<Trips_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Trips_Order_By>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


export type Subscription_RootTrips_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trips_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Trips_Order_By>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


export type Subscription_RootTrips_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootTrips_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Trips_Stream_Cursor_Input>>;
  where?: InputMaybe<Trips_Bool_Exp>;
};


export type Subscription_RootUsecasesArgs = {
  distinct_on?: InputMaybe<Array<Usecases_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecases_Order_By>>;
  where?: InputMaybe<Usecases_Bool_Exp>;
};


export type Subscription_RootUsecases_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usecases_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecases_Order_By>>;
  where?: InputMaybe<Usecases_Bool_Exp>;
};


export type Subscription_RootUsecases_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Subscription_RootUsecases_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usecases_Stream_Cursor_Input>>;
  where?: InputMaybe<Usecases_Bool_Exp>;
};


export type Subscription_RootUsecasetocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


export type Subscription_RootUsecasetocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


export type Subscription_RootUsecasetocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  usecase_key: Scalars['String']['input'];
};


export type Subscription_RootUsecasetocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usecasetocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


export type Subscription_RootUsereventlogsArgs = {
  distinct_on?: InputMaybe<Array<Usereventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usereventlogs_Order_By>>;
  where?: InputMaybe<Usereventlogs_Bool_Exp>;
};


export type Subscription_RootUsereventlogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usereventlogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usereventlogs_Order_By>>;
  where?: InputMaybe<Usereventlogs_Bool_Exp>;
};


export type Subscription_RootUsereventlogs_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootUsereventlogs_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usereventlogs_Stream_Cursor_Input>>;
  where?: InputMaybe<Usereventlogs_Bool_Exp>;
};


export type Subscription_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsertocustomersArgs = {
  distinct_on?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertocustomers_Order_By>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


export type Subscription_RootUsertocustomers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertocustomers_Order_By>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


export type Subscription_RootUsertocustomers_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootUsertocustomers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usertocustomers_Stream_Cursor_Input>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


export type Subscription_RootUsertofeaturesArgs = {
  distinct_on?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertofeatures_Order_By>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


export type Subscription_RootUsertofeatures_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertofeatures_Order_By>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


export type Subscription_RootUsertofeatures_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootUsertofeatures_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usertofeatures_Stream_Cursor_Input>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


export type Subscription_RootUsertoregionsArgs = {
  distinct_on?: InputMaybe<Array<Usertoregions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoregions_Order_By>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


export type Subscription_RootUsertoregions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertoregions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoregions_Order_By>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


export type Subscription_RootUsertoregions_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootUsertoregions_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usertoregions_Stream_Cursor_Input>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


export type Subscription_RootUsertorolesArgs = {
  distinct_on?: InputMaybe<Array<Usertoroles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoroles_Order_By>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};


export type Subscription_RootUsertoroles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertoroles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoroles_Order_By>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};


export type Subscription_RootUsertoroles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootUsertoroles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Usertoroles_Stream_Cursor_Input>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};


export type Subscription_RootVehiclemakesArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemakes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemakes_Order_By>>;
  where?: InputMaybe<Vehiclemakes_Bool_Exp>;
};


export type Subscription_RootVehiclemakes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemakes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemakes_Order_By>>;
  where?: InputMaybe<Vehiclemakes_Bool_Exp>;
};


export type Subscription_RootVehiclemakes_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootVehiclemakes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Vehiclemakes_Stream_Cursor_Input>>;
  where?: InputMaybe<Vehiclemakes_Bool_Exp>;
};


export type Subscription_RootVehiclemodelsArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemodels_Order_By>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};


export type Subscription_RootVehiclemodels_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemodels_Order_By>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};


export type Subscription_RootVehiclemodels_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootVehiclemodels_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Vehiclemodels_Stream_Cursor_Input>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};


export type Subscription_RootVehiclephotosArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


export type Subscription_RootVehiclephotos_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


export type Subscription_RootVehiclephotos_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootVehiclephotos_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Vehiclephotos_Stream_Cursor_Input>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


export type Subscription_RootVehiclesArgs = {
  distinct_on?: InputMaybe<Array<Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicles_Order_By>>;
  where?: InputMaybe<Vehicles_Bool_Exp>;
};


export type Subscription_RootVehicles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehicles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehicles_Order_By>>;
  where?: InputMaybe<Vehicles_Bool_Exp>;
};


export type Subscription_RootVehicles_By_PkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootVehicles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Vehicles_Stream_Cursor_Input>>;
  where?: InputMaybe<Vehicles_Bool_Exp>;
};


export type Subscription_RootWebhook_EventsArgs = {
  distinct_on?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Webhook_Events_Order_By>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};


export type Subscription_RootWebhook_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Webhook_Events_Order_By>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};


export type Subscription_RootWebhook_Events_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootWebhook_Events_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Webhook_Events_Stream_Cursor_Input>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};


export type Subscription_RootWorkflowsArgs = {
  distinct_on?: InputMaybe<Array<Workflows_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflows_Order_By>>;
  where?: InputMaybe<Workflows_Bool_Exp>;
};


export type Subscription_RootWorkflows_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflows_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflows_Order_By>>;
  where?: InputMaybe<Workflows_Bool_Exp>;
};


export type Subscription_RootWorkflows_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootWorkflows_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Workflows_Stream_Cursor_Input>>;
  where?: InputMaybe<Workflows_Bool_Exp>;
};


export type Subscription_RootWorkflowsetsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


export type Subscription_RootWorkflowsets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


export type Subscription_RootWorkflowsets_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootWorkflowsets_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Workflowsets_Stream_Cursor_Input>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


export type Subscription_RootWorkflowsettypesArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


export type Subscription_RootWorkflowsettypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


export type Subscription_RootWorkflowsettypes_By_PkArgs = {
  key: Scalars['String']['input'];
};


export type Subscription_RootWorkflowsettypes_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Workflowsettypes_Stream_Cursor_Input>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


export type Subscription_RootWorkflowsettypestocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypestocertifications_Order_By>>;
  where?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
};


export type Subscription_RootWorkflowsettypestocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypestocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypestocertifications_Order_By>>;
  where?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
};


export type Subscription_RootWorkflowsettypestocertifications_By_PkArgs = {
  certification_key: Scalars['String']['input'];
  workflow_set_type_key: Scalars['String']['input'];
};


export type Subscription_RootWorkflowsettypestocertifications_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Workflowsettypestocertifications_Stream_Cursor_Input>>;
  where?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
};

/** columns and relationships of "subscriptions" */
export type Subscriptions = {
  __typename?: 'subscriptions';
  active: Scalars['smallint']['output'];
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: Maybe<Scalars['String']['output']>;
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types: Scalars['jsonb']['output'];
  id: Scalars['bigint']['output'];
  /** An object relationship */
  organization?: Maybe<Organizations>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: Maybe<Scalars['String']['output']>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status: Scalars['String']['output'];
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version: Scalars['String']['output'];
  /** An array relationship */
  webhook_events: Array<Webhook_Events>;
  /** An aggregate relationship */
  webhook_events_aggregate: Webhook_Events_Aggregate;
};


/** columns and relationships of "subscriptions" */
export type SubscriptionsEvent_TypesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "subscriptions" */
export type SubscriptionsWebhook_EventsArgs = {
  distinct_on?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Webhook_Events_Order_By>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};


/** columns and relationships of "subscriptions" */
export type SubscriptionsWebhook_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Webhook_Events_Order_By>>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};

/** aggregated selection of "subscriptions" */
export type Subscriptions_Aggregate = {
  __typename?: 'subscriptions_aggregate';
  aggregate?: Maybe<Subscriptions_Aggregate_Fields>;
  nodes: Array<Subscriptions>;
};

export type Subscriptions_Aggregate_Bool_Exp = {
  count?: InputMaybe<Subscriptions_Aggregate_Bool_Exp_Count>;
};

export type Subscriptions_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Subscriptions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Subscriptions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "subscriptions" */
export type Subscriptions_Aggregate_Fields = {
  __typename?: 'subscriptions_aggregate_fields';
  avg?: Maybe<Subscriptions_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Subscriptions_Max_Fields>;
  min?: Maybe<Subscriptions_Min_Fields>;
  stddev?: Maybe<Subscriptions_Stddev_Fields>;
  stddev_pop?: Maybe<Subscriptions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Subscriptions_Stddev_Samp_Fields>;
  sum?: Maybe<Subscriptions_Sum_Fields>;
  var_pop?: Maybe<Subscriptions_Var_Pop_Fields>;
  var_samp?: Maybe<Subscriptions_Var_Samp_Fields>;
  variance?: Maybe<Subscriptions_Variance_Fields>;
};


/** aggregate fields of "subscriptions" */
export type Subscriptions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Subscriptions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "subscriptions" */
export type Subscriptions_Aggregate_Order_By = {
  avg?: InputMaybe<Subscriptions_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Subscriptions_Max_Order_By>;
  min?: InputMaybe<Subscriptions_Min_Order_By>;
  stddev?: InputMaybe<Subscriptions_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Subscriptions_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Subscriptions_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Subscriptions_Sum_Order_By>;
  var_pop?: InputMaybe<Subscriptions_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Subscriptions_Var_Samp_Order_By>;
  variance?: InputMaybe<Subscriptions_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Subscriptions_Append_Input = {
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "subscriptions" */
export type Subscriptions_Arr_Rel_Insert_Input = {
  data: Array<Subscriptions_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Subscriptions_On_Conflict>;
};

/** aggregate avg on columns */
export type Subscriptions_Avg_Fields = {
  __typename?: 'subscriptions_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "subscriptions" */
export type Subscriptions_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "subscriptions". All fields are combined with a logical 'AND'. */
export type Subscriptions_Bool_Exp = {
  _and?: InputMaybe<Array<Subscriptions_Bool_Exp>>;
  _not?: InputMaybe<Subscriptions_Bool_Exp>;
  _or?: InputMaybe<Array<Subscriptions_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  event_types?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  secret?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  target_url?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  version?: InputMaybe<String_Comparison_Exp>;
  webhook_events?: InputMaybe<Webhook_Events_Bool_Exp>;
  webhook_events_aggregate?: InputMaybe<Webhook_Events_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "subscriptions" */
export enum Subscriptions_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25791Primary = 'idx_25791_primary'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Subscriptions_Delete_At_Path_Input = {
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Subscriptions_Delete_Elem_Input = {
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Subscriptions_Delete_Key_Input = {
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "subscriptions" */
export type Subscriptions_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "subscriptions" */
export type Subscriptions_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: InputMaybe<Scalars['String']['input']>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: InputMaybe<Scalars['String']['input']>;
  webhook_events?: InputMaybe<Webhook_Events_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Subscriptions_Max_Fields = {
  __typename?: 'subscriptions_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: Maybe<Scalars['String']['output']>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: Maybe<Scalars['String']['output']>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "subscriptions" */
export type Subscriptions_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: InputMaybe<Order_By>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: InputMaybe<Order_By>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Subscriptions_Min_Fields = {
  __typename?: 'subscriptions_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: Maybe<Scalars['String']['output']>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: Maybe<Scalars['String']['output']>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "subscriptions" */
export type Subscriptions_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: InputMaybe<Order_By>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: InputMaybe<Order_By>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "subscriptions" */
export type Subscriptions_Mutation_Response = {
  __typename?: 'subscriptions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Subscriptions>;
};

/** input type for inserting object relation for remote table "subscriptions" */
export type Subscriptions_Obj_Rel_Insert_Input = {
  data: Subscriptions_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Subscriptions_On_Conflict>;
};

/** on_conflict condition type for table "subscriptions" */
export type Subscriptions_On_Conflict = {
  constraint: Subscriptions_Constraint;
  update_columns?: Array<Subscriptions_Update_Column>;
  where?: InputMaybe<Subscriptions_Bool_Exp>;
};

/** Ordering options when selecting data from "subscriptions". */
export type Subscriptions_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  event_types?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  secret?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  target_url?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  webhook_events_aggregate?: InputMaybe<Webhook_Events_Aggregate_Order_By>;
};

/** primary key columns input for table: subscriptions */
export type Subscriptions_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Subscriptions_Prepend_Input = {
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "subscriptions" */
export enum Subscriptions_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  EventTypes = 'event_types',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  Secret = 'secret',
  /** column name */
  Status = 'status',
  /** column name */
  TargetUrl = 'target_url',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "subscriptions" */
export type Subscriptions_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: InputMaybe<Scalars['String']['input']>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Subscriptions_Stddev_Fields = {
  __typename?: 'subscriptions_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "subscriptions" */
export type Subscriptions_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Subscriptions_Stddev_Pop_Fields = {
  __typename?: 'subscriptions_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "subscriptions" */
export type Subscriptions_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Subscriptions_Stddev_Samp_Fields = {
  __typename?: 'subscriptions_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "subscriptions" */
export type Subscriptions_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "subscriptions" */
export type Subscriptions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Subscriptions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Subscriptions_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Optional description provided by the customer's developer when they create the webhook subscription. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** An array of strings where each is an event type that this subscription is subscribing to. An example value would be ["move.pickedup_started", "move.pickup_successful", "move.delivery_successful"] */
  event_types?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Secret to use in the HMAC webhook signature header. If null, then the webhooks will not be signed. */
  secret?: InputMaybe<Scalars['String']['input']>;
  /** Always defaults to enabled, but through the developer portal or API, it can be changed to paused, or disabled. Possible values: enabled | paused | disabled */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The URL to send the event payload to and retry automatically if we do not receive an HTTP 200 response code before timeout. */
  target_url?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Version to be used when determining the schema format version of the webhook payload to send. */
  version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Subscriptions_Sum_Fields = {
  __typename?: 'subscriptions_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "subscriptions" */
export type Subscriptions_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** update columns of table "subscriptions" */
export enum Subscriptions_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  EventTypes = 'event_types',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  Secret = 'secret',
  /** column name */
  Status = 'status',
  /** column name */
  TargetUrl = 'target_url',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Version = 'version'
}

export type Subscriptions_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Subscriptions_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Subscriptions_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Subscriptions_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Subscriptions_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Subscriptions_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Subscriptions_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Subscriptions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Subscriptions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Subscriptions_Var_Pop_Fields = {
  __typename?: 'subscriptions_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "subscriptions" */
export type Subscriptions_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Subscriptions_Var_Samp_Fields = {
  __typename?: 'subscriptions_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "subscriptions" */
export type Subscriptions_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Subscriptions_Variance_Fields = {
  __typename?: 'subscriptions_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "subscriptions" */
export type Subscriptions_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "templates" */
export type Templates = {
  __typename?: 'templates';
  body: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "templates" */
export type Templates_Aggregate = {
  __typename?: 'templates_aggregate';
  aggregate?: Maybe<Templates_Aggregate_Fields>;
  nodes: Array<Templates>;
};

/** aggregate fields of "templates" */
export type Templates_Aggregate_Fields = {
  __typename?: 'templates_aggregate_fields';
  avg?: Maybe<Templates_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Templates_Max_Fields>;
  min?: Maybe<Templates_Min_Fields>;
  stddev?: Maybe<Templates_Stddev_Fields>;
  stddev_pop?: Maybe<Templates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Templates_Stddev_Samp_Fields>;
  sum?: Maybe<Templates_Sum_Fields>;
  var_pop?: Maybe<Templates_Var_Pop_Fields>;
  var_samp?: Maybe<Templates_Var_Samp_Fields>;
  variance?: Maybe<Templates_Variance_Fields>;
};


/** aggregate fields of "templates" */
export type Templates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Templates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Templates_Avg_Fields = {
  __typename?: 'templates_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "templates". All fields are combined with a logical 'AND'. */
export type Templates_Bool_Exp = {
  _and?: InputMaybe<Array<Templates_Bool_Exp>>;
  _not?: InputMaybe<Templates_Bool_Exp>;
  _or?: InputMaybe<Array<Templates_Bool_Exp>>;
  body?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "templates" */
export enum Templates_Constraint {
  /** unique or primary key constraint on columns "name" */
  TemplatesNameKey = 'templates_name_key',
  /** unique or primary key constraint on columns "id" */
  TemplatesPkey = 'templates_pkey'
}

/** input type for incrementing numeric columns in table "templates" */
export type Templates_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "templates" */
export type Templates_Insert_Input = {
  body?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Templates_Max_Fields = {
  __typename?: 'templates_max_fields';
  body?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Templates_Min_Fields = {
  __typename?: 'templates_min_fields';
  body?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "templates" */
export type Templates_Mutation_Response = {
  __typename?: 'templates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Templates>;
};

/** on_conflict condition type for table "templates" */
export type Templates_On_Conflict = {
  constraint: Templates_Constraint;
  update_columns?: Array<Templates_Update_Column>;
  where?: InputMaybe<Templates_Bool_Exp>;
};

/** Ordering options when selecting data from "templates". */
export type Templates_Order_By = {
  body?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: templates */
export type Templates_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "templates" */
export enum Templates_Select_Column {
  /** column name */
  Body = 'body',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "templates" */
export type Templates_Set_Input = {
  body?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Templates_Stddev_Fields = {
  __typename?: 'templates_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Templates_Stddev_Pop_Fields = {
  __typename?: 'templates_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Templates_Stddev_Samp_Fields = {
  __typename?: 'templates_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "templates" */
export type Templates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Templates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Templates_Stream_Cursor_Value_Input = {
  body?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Templates_Sum_Fields = {
  __typename?: 'templates_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "templates" */
export enum Templates_Update_Column {
  /** column name */
  Body = 'body',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Templates_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Templates_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Templates_Set_Input>;
  /** filter the rows which have to be updated */
  where: Templates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Templates_Var_Pop_Fields = {
  __typename?: 'templates_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Templates_Var_Samp_Fields = {
  __typename?: 'templates_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Templates_Variance_Fields = {
  __typename?: 'templates_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'. */
export type Time_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['time']['input']>;
  _gt?: InputMaybe<Scalars['time']['input']>;
  _gte?: InputMaybe<Scalars['time']['input']>;
  _in?: InputMaybe<Array<Scalars['time']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['time']['input']>;
  _lte?: InputMaybe<Scalars['time']['input']>;
  _neq?: InputMaybe<Scalars['time']['input']>;
  _nin?: InputMaybe<Array<Scalars['time']['input']>>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** columns and relationships of "trips" */
export type Trips = {
  __typename?: 'trips';
  active: Scalars['smallint']['output'];
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['bigint']['output'];
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** An array relationship */
  plans: Array<Plans>;
  /** An aggregate relationship */
  plans_aggregate: Plans_Aggregate;
  trip_start?: Maybe<Scalars['timestamptz']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "trips" */
export type TripsMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "trips" */
export type TripsMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** columns and relationships of "trips" */
export type TripsPlansArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


/** columns and relationships of "trips" */
export type TripsPlans_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};

/** aggregated selection of "trips" */
export type Trips_Aggregate = {
  __typename?: 'trips_aggregate';
  aggregate?: Maybe<Trips_Aggregate_Fields>;
  nodes: Array<Trips>;
};

export type Trips_Aggregate_Bool_Exp = {
  count?: InputMaybe<Trips_Aggregate_Bool_Exp_Count>;
};

export type Trips_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Trips_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Trips_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "trips" */
export type Trips_Aggregate_Fields = {
  __typename?: 'trips_aggregate_fields';
  avg?: Maybe<Trips_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Trips_Max_Fields>;
  min?: Maybe<Trips_Min_Fields>;
  stddev?: Maybe<Trips_Stddev_Fields>;
  stddev_pop?: Maybe<Trips_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Trips_Stddev_Samp_Fields>;
  sum?: Maybe<Trips_Sum_Fields>;
  var_pop?: Maybe<Trips_Var_Pop_Fields>;
  var_samp?: Maybe<Trips_Var_Samp_Fields>;
  variance?: Maybe<Trips_Variance_Fields>;
};


/** aggregate fields of "trips" */
export type Trips_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Trips_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "trips" */
export type Trips_Aggregate_Order_By = {
  avg?: InputMaybe<Trips_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Trips_Max_Order_By>;
  min?: InputMaybe<Trips_Min_Order_By>;
  stddev?: InputMaybe<Trips_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Trips_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Trips_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Trips_Sum_Order_By>;
  var_pop?: InputMaybe<Trips_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Trips_Var_Samp_Order_By>;
  variance?: InputMaybe<Trips_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "trips" */
export type Trips_Arr_Rel_Insert_Input = {
  data: Array<Trips_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Trips_On_Conflict>;
};

/** aggregate avg on columns */
export type Trips_Avg_Fields = {
  __typename?: 'trips_avg_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "trips" */
export type Trips_Avg_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "trips". All fields are combined with a logical 'AND'. */
export type Trips_Bool_Exp = {
  _and?: InputMaybe<Array<Trips_Bool_Exp>>;
  _not?: InputMaybe<Trips_Bool_Exp>;
  _or?: InputMaybe<Array<Trips_Bool_Exp>>;
  active?: InputMaybe<Smallint_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  plans?: InputMaybe<Plans_Bool_Exp>;
  plans_aggregate?: InputMaybe<Plans_Aggregate_Bool_Exp>;
  trip_start?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "trips" */
export enum Trips_Constraint {
  /** unique or primary key constraint on columns "id" */
  Idx_25801Primary = 'idx_25801_primary'
}

/** input type for incrementing numeric columns in table "trips" */
export type Trips_Inc_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "trips" */
export type Trips_Insert_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  plans?: InputMaybe<Plans_Arr_Rel_Insert_Input>;
  trip_start?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Trips_Max_Fields = {
  __typename?: 'trips_max_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  trip_start?: Maybe<Scalars['timestamptz']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "trips" */
export type Trips_Max_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  trip_start?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Trips_Min_Fields = {
  __typename?: 'trips_min_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  trip_start?: Maybe<Scalars['timestamptz']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "trips" */
export type Trips_Min_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  trip_start?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "trips" */
export type Trips_Mutation_Response = {
  __typename?: 'trips_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Trips>;
};

/** input type for inserting object relation for remote table "trips" */
export type Trips_Obj_Rel_Insert_Input = {
  data: Trips_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Trips_On_Conflict>;
};

/** on_conflict condition type for table "trips" */
export type Trips_On_Conflict = {
  constraint: Trips_Constraint;
  update_columns?: Array<Trips_Update_Column>;
  where?: InputMaybe<Trips_Bool_Exp>;
};

/** Ordering options when selecting data from "trips". */
export type Trips_Order_By = {
  active?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  plans_aggregate?: InputMaybe<Plans_Aggregate_Order_By>;
  trip_start?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
};

/** primary key columns input for table: trips */
export type Trips_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "trips" */
export enum Trips_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  TripStart = 'trip_start',
  /** column name */
  Updatedat = 'updatedat'
}

/** input type for updating data in table "trips" */
export type Trips_Set_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  trip_start?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Trips_Stddev_Fields = {
  __typename?: 'trips_stddev_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "trips" */
export type Trips_Stddev_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Trips_Stddev_Pop_Fields = {
  __typename?: 'trips_stddev_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "trips" */
export type Trips_Stddev_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Trips_Stddev_Samp_Fields = {
  __typename?: 'trips_stddev_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "trips" */
export type Trips_Stddev_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "trips" */
export type Trips_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Trips_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Trips_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['smallint']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  trip_start?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Trips_Sum_Fields = {
  __typename?: 'trips_sum_fields';
  active?: Maybe<Scalars['smallint']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "trips" */
export type Trips_Sum_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "trips" */
export enum Trips_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  TripStart = 'trip_start',
  /** column name */
  Updatedat = 'updatedat'
}

export type Trips_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Trips_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Trips_Set_Input>;
  /** filter the rows which have to be updated */
  where: Trips_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Trips_Var_Pop_Fields = {
  __typename?: 'trips_var_pop_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "trips" */
export type Trips_Var_Pop_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Trips_Var_Samp_Fields = {
  __typename?: 'trips_var_samp_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "trips" */
export type Trips_Var_Samp_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Trips_Variance_Fields = {
  __typename?: 'trips_variance_fields';
  active?: Maybe<Scalars['Float']['output']>;
  /** The related customer's ID */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "trips" */
export type Trips_Variance_Order_By = {
  active?: InputMaybe<Order_By>;
  /** The related customer's ID */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type Usecases = {
  __typename?: 'usecases';
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  /** a short-form description to provide context as to why it is different from others */
  description: Scalars['String']['output'];
  /** An array relationship */
  driverstousecasesoptouts: Array<Driverstousecasesoptout>;
  /** An aggregate relationship */
  driverstousecasesoptouts_aggregate: Driverstousecasesoptout_Aggregate;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['output'];
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** name to be used when displaying it on screen */
  name: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby: Scalars['String']['output'];
  /** An array relationship */
  usecasetocertifications: Array<Usecasetocertifications>;
  /** An aggregate relationship */
  usecasetocertifications_aggregate: Usecasetocertifications_Aggregate;
};


/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type UsecasesDriverstousecasesoptoutsArgs = {
  distinct_on?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstousecasesoptout_Order_By>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type UsecasesDriverstousecasesoptouts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Driverstousecasesoptout_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Driverstousecasesoptout_Order_By>>;
  where?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
};


/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type UsecasesMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type UsecasesMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type UsecasesUsecasetocertificationsArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};


/** A table to hold a master list of all unique use cases HopDrive supports. See the Use Case Identification spreadsheet for the defined use cases thought of so far. */
export type UsecasesUsecasetocertifications_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usecasetocertifications_Order_By>>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};

/** aggregated selection of "usecases" */
export type Usecases_Aggregate = {
  __typename?: 'usecases_aggregate';
  aggregate?: Maybe<Usecases_Aggregate_Fields>;
  nodes: Array<Usecases>;
};

/** aggregate fields of "usecases" */
export type Usecases_Aggregate_Fields = {
  __typename?: 'usecases_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Usecases_Max_Fields>;
  min?: Maybe<Usecases_Min_Fields>;
};


/** aggregate fields of "usecases" */
export type Usecases_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usecases_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "usecases". All fields are combined with a logical 'AND'. */
export type Usecases_Bool_Exp = {
  _and?: InputMaybe<Array<Usecases_Bool_Exp>>;
  _not?: InputMaybe<Usecases_Bool_Exp>;
  _or?: InputMaybe<Array<Usecases_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  driverstousecasesoptouts?: InputMaybe<Driverstousecasesoptout_Bool_Exp>;
  driverstousecasesoptouts_aggregate?: InputMaybe<Driverstousecasesoptout_Aggregate_Bool_Exp>;
  key?: InputMaybe<String_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  usecasetocertifications?: InputMaybe<Usecasetocertifications_Bool_Exp>;
  usecasetocertifications_aggregate?: InputMaybe<Usecasetocertifications_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "usecases" */
export enum Usecases_Constraint {
  /** unique or primary key constraint on columns "key" */
  UsecasesPkey = 'usecases_pkey'
}

/** input type for inserting data into table "usecases" */
export type Usecases_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a short-form description to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  driverstousecasesoptouts?: InputMaybe<Driverstousecasesoptout_Arr_Rel_Insert_Input>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  /** name to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecasetocertifications?: InputMaybe<Usecasetocertifications_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Usecases_Max_Fields = {
  __typename?: 'usecases_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** a short-form description to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  /** name to be used when displaying it on screen */
  name?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Usecases_Min_Fields = {
  __typename?: 'usecases_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  /** a short-form description to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  /** name to be used when displaying it on screen */
  name?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "usecases" */
export type Usecases_Mutation_Response = {
  __typename?: 'usecases_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usecases>;
};

/** input type for inserting object relation for remote table "usecases" */
export type Usecases_Obj_Rel_Insert_Input = {
  data: Usecases_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Usecases_On_Conflict>;
};

/** on_conflict condition type for table "usecases" */
export type Usecases_On_Conflict = {
  constraint: Usecases_Constraint;
  update_columns?: Array<Usecases_Update_Column>;
  where?: InputMaybe<Usecases_Bool_Exp>;
};

/** Ordering options when selecting data from "usecases". */
export type Usecases_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  driverstousecasesoptouts_aggregate?: InputMaybe<Driverstousecasesoptout_Aggregate_Order_By>;
  key?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecasetocertifications_aggregate?: InputMaybe<Usecasetocertifications_Aggregate_Order_By>;
};

/** primary key columns input for table: usecases */
export type Usecases_Pk_Columns_Input = {
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['input'];
};

/** select columns of table "usecases" */
export enum Usecases_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "usecases" */
export type Usecases_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a short-form description to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "usecases" */
export type Usecases_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usecases_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usecases_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  /** a short-form description to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "usecases" */
export enum Usecases_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Description = 'description',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Usecases_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usecases_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usecases_Bool_Exp;
};

/** This is the storage of which certifications are required in order for a driver to be qualified to perform a specific use case. For example a hangtag move or a concierge move. The combination of the two foreign keys must be unique. */
export type Usecasetocertifications = {
  __typename?: 'usecasetocertifications';
  /** An object relationship */
  certification: Certifications;
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  /** An object relationship */
  usecase: Usecases;
  usecase_key: Scalars['String']['output'];
};

/** aggregated selection of "usecasetocertifications" */
export type Usecasetocertifications_Aggregate = {
  __typename?: 'usecasetocertifications_aggregate';
  aggregate?: Maybe<Usecasetocertifications_Aggregate_Fields>;
  nodes: Array<Usecasetocertifications>;
};

export type Usecasetocertifications_Aggregate_Bool_Exp = {
  count?: InputMaybe<Usecasetocertifications_Aggregate_Bool_Exp_Count>;
};

export type Usecasetocertifications_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Usecasetocertifications_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "usecasetocertifications" */
export type Usecasetocertifications_Aggregate_Fields = {
  __typename?: 'usecasetocertifications_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Usecasetocertifications_Max_Fields>;
  min?: Maybe<Usecasetocertifications_Min_Fields>;
};


/** aggregate fields of "usecasetocertifications" */
export type Usecasetocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usecasetocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "usecasetocertifications" */
export type Usecasetocertifications_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Usecasetocertifications_Max_Order_By>;
  min?: InputMaybe<Usecasetocertifications_Min_Order_By>;
};

/** input type for inserting array relation for remote table "usecasetocertifications" */
export type Usecasetocertifications_Arr_Rel_Insert_Input = {
  data: Array<Usecasetocertifications_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Usecasetocertifications_On_Conflict>;
};

/** Boolean expression to filter rows from the table "usecasetocertifications". All fields are combined with a logical 'AND'. */
export type Usecasetocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Usecasetocertifications_Bool_Exp>>;
  _not?: InputMaybe<Usecasetocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Usecasetocertifications_Bool_Exp>>;
  certification?: InputMaybe<Certifications_Bool_Exp>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  usecase?: InputMaybe<Usecases_Bool_Exp>;
  usecase_key?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "usecasetocertifications" */
export enum Usecasetocertifications_Constraint {
  /** unique or primary key constraint on columns "usecase_key", "certification_key" */
  UsecasetocertificationsPkey = 'usecasetocertifications_pkey'
}

/** input type for inserting data into table "usecasetocertifications" */
export type Usecasetocertifications_Insert_Input = {
  certification?: InputMaybe<Certifications_Obj_Rel_Insert_Input>;
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecase?: InputMaybe<Usecases_Obj_Rel_Insert_Input>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Usecasetocertifications_Max_Fields = {
  __typename?: 'usecasetocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  usecase_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "usecasetocertifications" */
export type Usecasetocertifications_Max_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecase_key?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Usecasetocertifications_Min_Fields = {
  __typename?: 'usecasetocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  usecase_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "usecasetocertifications" */
export type Usecasetocertifications_Min_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecase_key?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "usecasetocertifications" */
export type Usecasetocertifications_Mutation_Response = {
  __typename?: 'usecasetocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usecasetocertifications>;
};

/** on_conflict condition type for table "usecasetocertifications" */
export type Usecasetocertifications_On_Conflict = {
  constraint: Usecasetocertifications_Constraint;
  update_columns?: Array<Usecasetocertifications_Update_Column>;
  where?: InputMaybe<Usecasetocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "usecasetocertifications". */
export type Usecasetocertifications_Order_By = {
  certification?: InputMaybe<Certifications_Order_By>;
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  usecase?: InputMaybe<Usecases_Order_By>;
  usecase_key?: InputMaybe<Order_By>;
};

/** primary key columns input for table: usecasetocertifications */
export type Usecasetocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  usecase_key: Scalars['String']['input'];
};

/** select columns of table "usecasetocertifications" */
export enum Usecasetocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  UsecaseKey = 'usecase_key'
}

/** input type for updating data in table "usecasetocertifications" */
export type Usecasetocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "usecasetocertifications" */
export type Usecasetocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usecasetocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usecasetocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  usecase_key?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "usecasetocertifications" */
export enum Usecasetocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  UsecaseKey = 'usecase_key'
}

export type Usecasetocertifications_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usecasetocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usecasetocertifications_Bool_Exp;
};

/** A table for tracking users login frequency, permissions updates, and IPs */
export type Usereventlogs = {
  __typename?: 'usereventlogs';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id: Scalars['smallint']['output'];
  /** The time at which the event was logged in this table */
  created_at: Scalars['timestamptz']['output'];
  /** Identity of the user (or system) who performed the action. We use email addresses to id human users */
  created_by: Scalars['String']['output'];
  /** Time when the event itself occurred */
  event_time: Scalars['timestamptz']['output'];
  id: Scalars['Int']['output'];
  /** IP address of the user on whom the action was performed */
  ip_address: Scalars['String']['output'];
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: Maybe<Scalars['jsonb']['output']>;
  /** Id of the user on whom the action was performed */
  user_id: Scalars['bigint']['output'];
};


/** A table for tracking users login frequency, permissions updates, and IPs */
export type UsereventlogsMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "usereventlogs" */
export type Usereventlogs_Aggregate = {
  __typename?: 'usereventlogs_aggregate';
  aggregate?: Maybe<Usereventlogs_Aggregate_Fields>;
  nodes: Array<Usereventlogs>;
};

/** aggregate fields of "usereventlogs" */
export type Usereventlogs_Aggregate_Fields = {
  __typename?: 'usereventlogs_aggregate_fields';
  avg?: Maybe<Usereventlogs_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Usereventlogs_Max_Fields>;
  min?: Maybe<Usereventlogs_Min_Fields>;
  stddev?: Maybe<Usereventlogs_Stddev_Fields>;
  stddev_pop?: Maybe<Usereventlogs_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Usereventlogs_Stddev_Samp_Fields>;
  sum?: Maybe<Usereventlogs_Sum_Fields>;
  var_pop?: Maybe<Usereventlogs_Var_Pop_Fields>;
  var_samp?: Maybe<Usereventlogs_Var_Samp_Fields>;
  variance?: Maybe<Usereventlogs_Variance_Fields>;
};


/** aggregate fields of "usereventlogs" */
export type Usereventlogs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usereventlogs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Usereventlogs_Append_Input = {
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Usereventlogs_Avg_Fields = {
  __typename?: 'usereventlogs_avg_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "usereventlogs". All fields are combined with a logical 'AND'. */
export type Usereventlogs_Bool_Exp = {
  _and?: InputMaybe<Array<Usereventlogs_Bool_Exp>>;
  _not?: InputMaybe<Usereventlogs_Bool_Exp>;
  _or?: InputMaybe<Array<Usereventlogs_Bool_Exp>>;
  actiontype_id?: InputMaybe<Smallint_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  event_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  ip_address?: InputMaybe<String_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "usereventlogs" */
export enum Usereventlogs_Constraint {
  /** unique or primary key constraint on columns "id" */
  UsereventlogsPkey = 'usereventlogs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Usereventlogs_Delete_At_Path_Input = {
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Usereventlogs_Delete_Elem_Input = {
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Usereventlogs_Delete_Key_Input = {
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "usereventlogs" */
export type Usereventlogs_Inc_Input = {
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Id of the user on whom the action was performed */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "usereventlogs" */
export type Usereventlogs_Insert_Input = {
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** The time at which the event was logged in this table */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Identity of the user (or system) who performed the action. We use email addresses to id human users */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Time when the event itself occurred */
  event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** IP address of the user on whom the action was performed */
  ip_address?: InputMaybe<Scalars['String']['input']>;
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Id of the user on whom the action was performed */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Usereventlogs_Max_Fields = {
  __typename?: 'usereventlogs_max_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['smallint']['output']>;
  /** The time at which the event was logged in this table */
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Identity of the user (or system) who performed the action. We use email addresses to id human users */
  created_by?: Maybe<Scalars['String']['output']>;
  /** Time when the event itself occurred */
  event_time?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** IP address of the user on whom the action was performed */
  ip_address?: Maybe<Scalars['String']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type Usereventlogs_Min_Fields = {
  __typename?: 'usereventlogs_min_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['smallint']['output']>;
  /** The time at which the event was logged in this table */
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Identity of the user (or system) who performed the action. We use email addresses to id human users */
  created_by?: Maybe<Scalars['String']['output']>;
  /** Time when the event itself occurred */
  event_time?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** IP address of the user on whom the action was performed */
  ip_address?: Maybe<Scalars['String']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "usereventlogs" */
export type Usereventlogs_Mutation_Response = {
  __typename?: 'usereventlogs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usereventlogs>;
};

/** on_conflict condition type for table "usereventlogs" */
export type Usereventlogs_On_Conflict = {
  constraint: Usereventlogs_Constraint;
  update_columns?: Array<Usereventlogs_Update_Column>;
  where?: InputMaybe<Usereventlogs_Bool_Exp>;
};

/** Ordering options when selecting data from "usereventlogs". */
export type Usereventlogs_Order_By = {
  actiontype_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  event_time?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ip_address?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: usereventlogs */
export type Usereventlogs_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Usereventlogs_Prepend_Input = {
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "usereventlogs" */
export enum Usereventlogs_Select_Column {
  /** column name */
  ActiontypeId = 'actiontype_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  EventTime = 'event_time',
  /** column name */
  Id = 'id',
  /** column name */
  IpAddress = 'ip_address',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "usereventlogs" */
export type Usereventlogs_Set_Input = {
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** The time at which the event was logged in this table */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Identity of the user (or system) who performed the action. We use email addresses to id human users */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Time when the event itself occurred */
  event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** IP address of the user on whom the action was performed */
  ip_address?: InputMaybe<Scalars['String']['input']>;
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Id of the user on whom the action was performed */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Usereventlogs_Stddev_Fields = {
  __typename?: 'usereventlogs_stddev_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Usereventlogs_Stddev_Pop_Fields = {
  __typename?: 'usereventlogs_stddev_pop_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Usereventlogs_Stddev_Samp_Fields = {
  __typename?: 'usereventlogs_stddev_samp_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "usereventlogs" */
export type Usereventlogs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usereventlogs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usereventlogs_Stream_Cursor_Value_Input = {
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: InputMaybe<Scalars['smallint']['input']>;
  /** The time at which the event was logged in this table */
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Identity of the user (or system) who performed the action. We use email addresses to id human users */
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** Time when the event itself occurred */
  event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  /** IP address of the user on whom the action was performed */
  ip_address?: InputMaybe<Scalars['String']['input']>;
  /** Catch-all for any metadata or additional info to be stored (eg. permissions before and after update). Should be match the action types metadata schema */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Id of the user on whom the action was performed */
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Usereventlogs_Sum_Fields = {
  __typename?: 'usereventlogs_sum_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "usereventlogs" */
export enum Usereventlogs_Update_Column {
  /** column name */
  ActiontypeId = 'actiontype_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  EventTime = 'event_time',
  /** column name */
  Id = 'id',
  /** column name */
  IpAddress = 'ip_address',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  UserId = 'user_id'
}

export type Usereventlogs_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Usereventlogs_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Usereventlogs_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Usereventlogs_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Usereventlogs_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Usereventlogs_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Usereventlogs_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usereventlogs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usereventlogs_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Usereventlogs_Var_Pop_Fields = {
  __typename?: 'usereventlogs_var_pop_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Usereventlogs_Var_Samp_Fields = {
  __typename?: 'usereventlogs_var_samp_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Usereventlogs_Variance_Fields = {
  __typename?: 'usereventlogs_variance_fields';
  /** Code that represents the type of action being recorded (eg. updating a users permissions). The name and description of the action can be found in the actiontypes table */
  actiontype_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** Id of the user on whom the action was performed */
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type Users = {
  __typename?: 'users';
  /** Is the user active in our system (soft delete). */
  active: Scalars['Boolean']['output'];
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: Maybe<Scalars['String']['output']>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: Maybe<Scalars['String']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  customer?: Maybe<Customers>;
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** String that determines the level of access to our applications. */
  default_role: Scalars['String']['output'];
  /** Display name of user in our system apps. */
  display_name: Scalars['String']['output'];
  /** An object relationship */
  driver?: Maybe<Drivers>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: Maybe<Scalars['String']['output']>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  /** Users phone number used for calls and SMS. */
  phone?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  roletype: Roletypes;
  updated_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  users_usertocustomers: Array<Usertocustomers>;
  /** An aggregate relationship */
  users_usertocustomers_aggregate: Usertocustomers_Aggregate;
  /** An array relationship */
  users_usertofeatures: Array<Usertofeatures>;
  /** An aggregate relationship */
  users_usertofeatures_aggregate: Usertofeatures_Aggregate;
  /** An array relationship */
  users_usertoregions: Array<Usertoregions>;
  /** An aggregate relationship */
  users_usertoregions_aggregate: Usertoregions_Aggregate;
  /** An array relationship */
  users_usertoroles: Array<Usertoroles>;
  /** An aggregate relationship */
  users_usertoroles_aggregate: Usertoroles_Aggregate;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_UsertocustomersArgs = {
  distinct_on?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertocustomers_Order_By>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_Usertocustomers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertocustomers_Order_By>>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_UsertofeaturesArgs = {
  distinct_on?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertofeatures_Order_By>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_Usertofeatures_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertofeatures_Order_By>>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_UsertoregionsArgs = {
  distinct_on?: InputMaybe<Array<Usertoregions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoregions_Order_By>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_Usertoregions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertoregions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoregions_Order_By>>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_UsertorolesArgs = {
  distinct_on?: InputMaybe<Array<Usertoroles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoroles_Order_By>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};


/** This table stores our authentication records used for logins and token grants. It also stores the level of access to different aspects of our database. */
export type UsersUsers_Usertoroles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Usertoroles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Usertoroles_Order_By>>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

export type Users_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Users_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Users_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Users_Aggregate_Bool_Exp_Count>;
};

export type Users_Aggregate_Bool_Exp_Bool_And = {
  arguments: Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Users_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Users_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Users_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Users_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Users_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  avg?: Maybe<Users_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
  stddev?: Maybe<Users_Stddev_Fields>;
  stddev_pop?: Maybe<Users_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Users_Stddev_Samp_Fields>;
  sum?: Maybe<Users_Sum_Fields>;
  var_pop?: Maybe<Users_Var_Pop_Fields>;
  var_samp?: Maybe<Users_Var_Samp_Fields>;
  variance?: Maybe<Users_Variance_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "users" */
export type Users_Aggregate_Order_By = {
  avg?: InputMaybe<Users_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Users_Max_Order_By>;
  min?: InputMaybe<Users_Min_Order_By>;
  stddev?: InputMaybe<Users_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Users_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Users_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Users_Sum_Order_By>;
  var_pop?: InputMaybe<Users_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Users_Var_Samp_Order_By>;
  variance?: InputMaybe<Users_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "users" */
export type Users_Arr_Rel_Insert_Input = {
  data: Array<Users_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** aggregate avg on columns */
export type Users_Avg_Fields = {
  __typename?: 'users_avg_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "users" */
export type Users_Avg_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: InputMaybe<Array<Users_Bool_Exp>>;
  _not?: InputMaybe<Users_Bool_Exp>;
  _or?: InputMaybe<Array<Users_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  auth0_id?: InputMaybe<String_Comparison_Exp>;
  avatar_url?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  default_role?: InputMaybe<String_Comparison_Exp>;
  display_name?: InputMaybe<String_Comparison_Exp>;
  driver?: InputMaybe<Drivers_Bool_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  firebase_id?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  roletype?: InputMaybe<Roletypes_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  users_usertocustomers?: InputMaybe<Usertocustomers_Bool_Exp>;
  users_usertocustomers_aggregate?: InputMaybe<Usertocustomers_Aggregate_Bool_Exp>;
  users_usertofeatures?: InputMaybe<Usertofeatures_Bool_Exp>;
  users_usertofeatures_aggregate?: InputMaybe<Usertofeatures_Aggregate_Bool_Exp>;
  users_usertoregions?: InputMaybe<Usertoregions_Bool_Exp>;
  users_usertoregions_aggregate?: InputMaybe<Usertoregions_Aggregate_Bool_Exp>;
  users_usertoroles?: InputMaybe<Usertoroles_Bool_Exp>;
  users_usertoroles_aggregate?: InputMaybe<Usertoroles_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for incrementing numeric columns in table "users" */
export type Users_Inc_Input = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  /** Is the user active in our system (soft delete). */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: InputMaybe<Scalars['String']['input']>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** String that determines the level of access to our applications. */
  default_role?: InputMaybe<Scalars['String']['input']>;
  /** Display name of user in our system apps. */
  display_name?: InputMaybe<Scalars['String']['input']>;
  driver?: InputMaybe<Drivers_Obj_Rel_Insert_Input>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Users phone number used for calls and SMS. */
  phone?: InputMaybe<Scalars['String']['input']>;
  roletype?: InputMaybe<Roletypes_Obj_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  users_usertocustomers?: InputMaybe<Usertocustomers_Arr_Rel_Insert_Input>;
  users_usertofeatures?: InputMaybe<Usertofeatures_Arr_Rel_Insert_Input>;
  users_usertoregions?: InputMaybe<Usertoregions_Arr_Rel_Insert_Input>;
  users_usertoroles?: InputMaybe<Usertoroles_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: Maybe<Scalars['String']['output']>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** String that determines the level of access to our applications. */
  default_role?: Maybe<Scalars['String']['output']>;
  /** Display name of user in our system apps. */
  display_name?: Maybe<Scalars['String']['output']>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: Maybe<Scalars['String']['output']>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Users phone number used for calls and SMS. */
  phone?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "users" */
export type Users_Max_Order_By = {
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: InputMaybe<Order_By>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  /** String that determines the level of access to our applications. */
  default_role?: InputMaybe<Order_By>;
  /** Display name of user in our system apps. */
  display_name?: InputMaybe<Order_By>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: InputMaybe<Order_By>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Users phone number used for calls and SMS. */
  phone?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: Maybe<Scalars['String']['output']>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** String that determines the level of access to our applications. */
  default_role?: Maybe<Scalars['String']['output']>;
  /** Display name of user in our system apps. */
  display_name?: Maybe<Scalars['String']['output']>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: Maybe<Scalars['String']['output']>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Users phone number used for calls and SMS. */
  phone?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "users" */
export type Users_Min_Order_By = {
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: InputMaybe<Order_By>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  /** String that determines the level of access to our applications. */
  default_role?: InputMaybe<Order_By>;
  /** Display name of user in our system apps. */
  display_name?: InputMaybe<Order_By>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: InputMaybe<Order_By>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** Users phone number used for calls and SMS. */
  phone?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  active?: InputMaybe<Order_By>;
  auth0_id?: InputMaybe<Order_By>;
  avatar_url?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  default_role?: InputMaybe<Order_By>;
  display_name?: InputMaybe<Order_By>;
  driver?: InputMaybe<Drivers_Order_By>;
  email?: InputMaybe<Order_By>;
  firebase_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  roletype?: InputMaybe<Roletypes_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  users_usertocustomers_aggregate?: InputMaybe<Usertocustomers_Aggregate_Order_By>;
  users_usertofeatures_aggregate?: InputMaybe<Usertofeatures_Aggregate_Order_By>;
  users_usertoregions_aggregate?: InputMaybe<Usertoregions_Aggregate_Order_By>;
  users_usertoroles_aggregate?: InputMaybe<Usertoroles_Aggregate_Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Auth0Id = 'auth0_id',
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DefaultRole = 'default_role',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  Email = 'email',
  /** column name */
  FirebaseId = 'firebase_id',
  /** column name */
  Id = 'id',
  /** column name */
  Phone = 'phone',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users" */
export enum Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users" */
export enum Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active'
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  /** Is the user active in our system (soft delete). */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: InputMaybe<Scalars['String']['input']>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** String that determines the level of access to our applications. */
  default_role?: InputMaybe<Scalars['String']['input']>;
  /** Display name of user in our system apps. */
  display_name?: InputMaybe<Scalars['String']['input']>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Users phone number used for calls and SMS. */
  phone?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Users_Stddev_Fields = {
  __typename?: 'users_stddev_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "users" */
export type Users_Stddev_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Users_Stddev_Pop_Fields = {
  __typename?: 'users_stddev_pop_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "users" */
export type Users_Stddev_Pop_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Users_Stddev_Samp_Fields = {
  __typename?: 'users_stddev_samp_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "users" */
export type Users_Stddev_Samp_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  /** Is the user active in our system (soft delete). */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Authentication identifier used to relate the user record to our 3rd party auth0 record (which holds username and password). */
  auth0_id?: InputMaybe<Scalars['String']['input']>;
  /** Profile image link/URL (image stored in an image bucket). */
  avatar_url?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  /** String that determines the level of access to our applications. */
  default_role?: InputMaybe<Scalars['String']['input']>;
  /** Display name of user in our system apps. */
  display_name?: InputMaybe<Scalars['String']['input']>;
  /** Users email address, used for verification, notifications, alerts, etc. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Authentication identifier used to relate the user record to our 3rd party firebase auth record (which holds username and password). */
  firebase_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Users phone number used for calls and SMS. */
  phone?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Users_Sum_Fields = {
  __typename?: 'users_sum_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "users" */
export type Users_Sum_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Auth0Id = 'auth0_id',
  /** column name */
  AvatarUrl = 'avatar_url',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DefaultRole = 'default_role',
  /** column name */
  DisplayName = 'display_name',
  /** column name */
  Email = 'email',
  /** column name */
  FirebaseId = 'firebase_id',
  /** column name */
  Id = 'id',
  /** column name */
  Phone = 'phone',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Users_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Users_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Users_Var_Pop_Fields = {
  __typename?: 'users_var_pop_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "users" */
export type Users_Var_Pop_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Users_Var_Samp_Fields = {
  __typename?: 'users_var_samp_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "users" */
export type Users_Var_Samp_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Users_Variance_Fields = {
  __typename?: 'users_variance_fields';
  /** Relates a customer record to a user record. */
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "users" */
export type Users_Variance_Order_By = {
  /** Relates a customer record to a user record. */
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "usertocustomers" */
export type Usertocustomers = {
  __typename?: 'usertocustomers';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by: Scalars['String']['output'];
  /** An object relationship */
  customer: Customers;
  customer_id: Scalars['bigint']['output'];
  id: Scalars['bigint']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by: Scalars['String']['output'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['bigint']['output'];
};

/** aggregated selection of "usertocustomers" */
export type Usertocustomers_Aggregate = {
  __typename?: 'usertocustomers_aggregate';
  aggregate?: Maybe<Usertocustomers_Aggregate_Fields>;
  nodes: Array<Usertocustomers>;
};

export type Usertocustomers_Aggregate_Bool_Exp = {
  count?: InputMaybe<Usertocustomers_Aggregate_Bool_Exp_Count>;
};

export type Usertocustomers_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Usertocustomers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "usertocustomers" */
export type Usertocustomers_Aggregate_Fields = {
  __typename?: 'usertocustomers_aggregate_fields';
  avg?: Maybe<Usertocustomers_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Usertocustomers_Max_Fields>;
  min?: Maybe<Usertocustomers_Min_Fields>;
  stddev?: Maybe<Usertocustomers_Stddev_Fields>;
  stddev_pop?: Maybe<Usertocustomers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Usertocustomers_Stddev_Samp_Fields>;
  sum?: Maybe<Usertocustomers_Sum_Fields>;
  var_pop?: Maybe<Usertocustomers_Var_Pop_Fields>;
  var_samp?: Maybe<Usertocustomers_Var_Samp_Fields>;
  variance?: Maybe<Usertocustomers_Variance_Fields>;
};


/** aggregate fields of "usertocustomers" */
export type Usertocustomers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usertocustomers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "usertocustomers" */
export type Usertocustomers_Aggregate_Order_By = {
  avg?: InputMaybe<Usertocustomers_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Usertocustomers_Max_Order_By>;
  min?: InputMaybe<Usertocustomers_Min_Order_By>;
  stddev?: InputMaybe<Usertocustomers_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Usertocustomers_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Usertocustomers_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Usertocustomers_Sum_Order_By>;
  var_pop?: InputMaybe<Usertocustomers_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Usertocustomers_Var_Samp_Order_By>;
  variance?: InputMaybe<Usertocustomers_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "usertocustomers" */
export type Usertocustomers_Arr_Rel_Insert_Input = {
  data: Array<Usertocustomers_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Usertocustomers_On_Conflict>;
};

/** aggregate avg on columns */
export type Usertocustomers_Avg_Fields = {
  __typename?: 'usertocustomers_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "usertocustomers" */
export type Usertocustomers_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "usertocustomers". All fields are combined with a logical 'AND'. */
export type Usertocustomers_Bool_Exp = {
  _and?: InputMaybe<Array<Usertocustomers_Bool_Exp>>;
  _not?: InputMaybe<Usertocustomers_Bool_Exp>;
  _or?: InputMaybe<Array<Usertocustomers_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "usertocustomers" */
export enum Usertocustomers_Constraint {
  /** unique or primary key constraint on columns "id" */
  UsertocustomersPkey = 'usertocustomers_pkey',
  /** unique or primary key constraint on columns "user_id", "customer_id" */
  UsertocustomersUserIdCustomerIdKey = 'usertocustomers_user_id_customer_id_key'
}

/** input type for incrementing numeric columns in table "usertocustomers" */
export type Usertocustomers_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "usertocustomers" */
export type Usertocustomers_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Usertocustomers_Max_Fields = {
  __typename?: 'usertocustomers_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "usertocustomers" */
export type Usertocustomers_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Usertocustomers_Min_Fields = {
  __typename?: 'usertocustomers_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "usertocustomers" */
export type Usertocustomers_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "usertocustomers" */
export type Usertocustomers_Mutation_Response = {
  __typename?: 'usertocustomers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usertocustomers>;
};

/** on_conflict condition type for table "usertocustomers" */
export type Usertocustomers_On_Conflict = {
  constraint: Usertocustomers_Constraint;
  update_columns?: Array<Usertocustomers_Update_Column>;
  where?: InputMaybe<Usertocustomers_Bool_Exp>;
};

/** Ordering options when selecting data from "usertocustomers". */
export type Usertocustomers_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: usertocustomers */
export type Usertocustomers_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "usertocustomers" */
export enum Usertocustomers_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "usertocustomers" */
export type Usertocustomers_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Usertocustomers_Stddev_Fields = {
  __typename?: 'usertocustomers_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "usertocustomers" */
export type Usertocustomers_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Usertocustomers_Stddev_Pop_Fields = {
  __typename?: 'usertocustomers_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "usertocustomers" */
export type Usertocustomers_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Usertocustomers_Stddev_Samp_Fields = {
  __typename?: 'usertocustomers_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "usertocustomers" */
export type Usertocustomers_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "usertocustomers" */
export type Usertocustomers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usertocustomers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usertocustomers_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Usertocustomers_Sum_Fields = {
  __typename?: 'usertocustomers_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "usertocustomers" */
export type Usertocustomers_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** update columns of table "usertocustomers" */
export enum Usertocustomers_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

export type Usertocustomers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Usertocustomers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usertocustomers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usertocustomers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Usertocustomers_Var_Pop_Fields = {
  __typename?: 'usertocustomers_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "usertocustomers" */
export type Usertocustomers_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Usertocustomers_Var_Samp_Fields = {
  __typename?: 'usertocustomers_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "usertocustomers" */
export type Usertocustomers_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Usertocustomers_Variance_Fields = {
  __typename?: 'usertocustomers_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "usertocustomers" */
export type Usertocustomers_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Tracks users' access to site features */
export type Usertofeatures = {
  __typename?: 'usertofeatures';
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['String']['output'];
  /** An object relationship */
  feature: Features;
  feature_id: Scalars['bigint']['output'];
  id: Scalars['bigint']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by: Scalars['String']['output'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['bigint']['output'];
};

/** aggregated selection of "usertofeatures" */
export type Usertofeatures_Aggregate = {
  __typename?: 'usertofeatures_aggregate';
  aggregate?: Maybe<Usertofeatures_Aggregate_Fields>;
  nodes: Array<Usertofeatures>;
};

export type Usertofeatures_Aggregate_Bool_Exp = {
  count?: InputMaybe<Usertofeatures_Aggregate_Bool_Exp_Count>;
};

export type Usertofeatures_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Usertofeatures_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "usertofeatures" */
export type Usertofeatures_Aggregate_Fields = {
  __typename?: 'usertofeatures_aggregate_fields';
  avg?: Maybe<Usertofeatures_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Usertofeatures_Max_Fields>;
  min?: Maybe<Usertofeatures_Min_Fields>;
  stddev?: Maybe<Usertofeatures_Stddev_Fields>;
  stddev_pop?: Maybe<Usertofeatures_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Usertofeatures_Stddev_Samp_Fields>;
  sum?: Maybe<Usertofeatures_Sum_Fields>;
  var_pop?: Maybe<Usertofeatures_Var_Pop_Fields>;
  var_samp?: Maybe<Usertofeatures_Var_Samp_Fields>;
  variance?: Maybe<Usertofeatures_Variance_Fields>;
};


/** aggregate fields of "usertofeatures" */
export type Usertofeatures_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usertofeatures_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "usertofeatures" */
export type Usertofeatures_Aggregate_Order_By = {
  avg?: InputMaybe<Usertofeatures_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Usertofeatures_Max_Order_By>;
  min?: InputMaybe<Usertofeatures_Min_Order_By>;
  stddev?: InputMaybe<Usertofeatures_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Usertofeatures_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Usertofeatures_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Usertofeatures_Sum_Order_By>;
  var_pop?: InputMaybe<Usertofeatures_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Usertofeatures_Var_Samp_Order_By>;
  variance?: InputMaybe<Usertofeatures_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "usertofeatures" */
export type Usertofeatures_Arr_Rel_Insert_Input = {
  data: Array<Usertofeatures_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Usertofeatures_On_Conflict>;
};

/** aggregate avg on columns */
export type Usertofeatures_Avg_Fields = {
  __typename?: 'usertofeatures_avg_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "usertofeatures" */
export type Usertofeatures_Avg_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "usertofeatures". All fields are combined with a logical 'AND'. */
export type Usertofeatures_Bool_Exp = {
  _and?: InputMaybe<Array<Usertofeatures_Bool_Exp>>;
  _not?: InputMaybe<Usertofeatures_Bool_Exp>;
  _or?: InputMaybe<Array<Usertofeatures_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  feature?: InputMaybe<Features_Bool_Exp>;
  feature_id?: InputMaybe<Bigint_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "usertofeatures" */
export enum Usertofeatures_Constraint {
  /** unique or primary key constraint on columns "feature_id", "user_id" */
  UsertofeaturesFeatureIdUserIdKey = 'usertofeatures_feature_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  UsertofeaturesPkey = 'usertofeatures_pkey'
}

/** input type for incrementing numeric columns in table "usertofeatures" */
export type Usertofeatures_Inc_Input = {
  feature_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "usertofeatures" */
export type Usertofeatures_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  feature?: InputMaybe<Features_Obj_Rel_Insert_Input>;
  feature_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Usertofeatures_Max_Fields = {
  __typename?: 'usertofeatures_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  feature_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "usertofeatures" */
export type Usertofeatures_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Usertofeatures_Min_Fields = {
  __typename?: 'usertofeatures_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  feature_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "usertofeatures" */
export type Usertofeatures_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "usertofeatures" */
export type Usertofeatures_Mutation_Response = {
  __typename?: 'usertofeatures_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usertofeatures>;
};

/** on_conflict condition type for table "usertofeatures" */
export type Usertofeatures_On_Conflict = {
  constraint: Usertofeatures_Constraint;
  update_columns?: Array<Usertofeatures_Update_Column>;
  where?: InputMaybe<Usertofeatures_Bool_Exp>;
};

/** Ordering options when selecting data from "usertofeatures". */
export type Usertofeatures_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  feature?: InputMaybe<Features_Order_By>;
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: usertofeatures */
export type Usertofeatures_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "usertofeatures" */
export enum Usertofeatures_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  FeatureId = 'feature_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "usertofeatures" */
export type Usertofeatures_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  feature_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Usertofeatures_Stddev_Fields = {
  __typename?: 'usertofeatures_stddev_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "usertofeatures" */
export type Usertofeatures_Stddev_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Usertofeatures_Stddev_Pop_Fields = {
  __typename?: 'usertofeatures_stddev_pop_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "usertofeatures" */
export type Usertofeatures_Stddev_Pop_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Usertofeatures_Stddev_Samp_Fields = {
  __typename?: 'usertofeatures_stddev_samp_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "usertofeatures" */
export type Usertofeatures_Stddev_Samp_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "usertofeatures" */
export type Usertofeatures_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usertofeatures_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usertofeatures_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  feature_id?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Usertofeatures_Sum_Fields = {
  __typename?: 'usertofeatures_sum_fields';
  feature_id?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "usertofeatures" */
export type Usertofeatures_Sum_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** update columns of table "usertofeatures" */
export enum Usertofeatures_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  FeatureId = 'feature_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

export type Usertofeatures_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Usertofeatures_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usertofeatures_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usertofeatures_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Usertofeatures_Var_Pop_Fields = {
  __typename?: 'usertofeatures_var_pop_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "usertofeatures" */
export type Usertofeatures_Var_Pop_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Usertofeatures_Var_Samp_Fields = {
  __typename?: 'usertofeatures_var_samp_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "usertofeatures" */
export type Usertofeatures_Var_Samp_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Usertofeatures_Variance_Fields = {
  __typename?: 'usertofeatures_variance_fields';
  feature_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "usertofeatures" */
export type Usertofeatures_Variance_Order_By = {
  feature_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Tracks which regions a user has access to */
export type Usertoregions = {
  __typename?: 'usertoregions';
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  /** An object relationship */
  region: Regions;
  region_id: Scalars['bigint']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by: Scalars['String']['output'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['bigint']['output'];
};

/** aggregated selection of "usertoregions" */
export type Usertoregions_Aggregate = {
  __typename?: 'usertoregions_aggregate';
  aggregate?: Maybe<Usertoregions_Aggregate_Fields>;
  nodes: Array<Usertoregions>;
};

export type Usertoregions_Aggregate_Bool_Exp = {
  count?: InputMaybe<Usertoregions_Aggregate_Bool_Exp_Count>;
};

export type Usertoregions_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Usertoregions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Usertoregions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "usertoregions" */
export type Usertoregions_Aggregate_Fields = {
  __typename?: 'usertoregions_aggregate_fields';
  avg?: Maybe<Usertoregions_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Usertoregions_Max_Fields>;
  min?: Maybe<Usertoregions_Min_Fields>;
  stddev?: Maybe<Usertoregions_Stddev_Fields>;
  stddev_pop?: Maybe<Usertoregions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Usertoregions_Stddev_Samp_Fields>;
  sum?: Maybe<Usertoregions_Sum_Fields>;
  var_pop?: Maybe<Usertoregions_Var_Pop_Fields>;
  var_samp?: Maybe<Usertoregions_Var_Samp_Fields>;
  variance?: Maybe<Usertoregions_Variance_Fields>;
};


/** aggregate fields of "usertoregions" */
export type Usertoregions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usertoregions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "usertoregions" */
export type Usertoregions_Aggregate_Order_By = {
  avg?: InputMaybe<Usertoregions_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Usertoregions_Max_Order_By>;
  min?: InputMaybe<Usertoregions_Min_Order_By>;
  stddev?: InputMaybe<Usertoregions_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Usertoregions_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Usertoregions_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Usertoregions_Sum_Order_By>;
  var_pop?: InputMaybe<Usertoregions_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Usertoregions_Var_Samp_Order_By>;
  variance?: InputMaybe<Usertoregions_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "usertoregions" */
export type Usertoregions_Arr_Rel_Insert_Input = {
  data: Array<Usertoregions_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Usertoregions_On_Conflict>;
};

/** aggregate avg on columns */
export type Usertoregions_Avg_Fields = {
  __typename?: 'usertoregions_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "usertoregions" */
export type Usertoregions_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "usertoregions". All fields are combined with a logical 'AND'. */
export type Usertoregions_Bool_Exp = {
  _and?: InputMaybe<Array<Usertoregions_Bool_Exp>>;
  _not?: InputMaybe<Usertoregions_Bool_Exp>;
  _or?: InputMaybe<Array<Usertoregions_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "usertoregions" */
export enum Usertoregions_Constraint {
  /** unique or primary key constraint on columns "id" */
  UsertoregionsPkey = 'usertoregions_pkey',
  /** unique or primary key constraint on columns "region_id", "user_id" */
  UsertoregionsUserIdRegionIdKey = 'usertoregions_user_id_region_id_key'
}

/** input type for incrementing numeric columns in table "usertoregions" */
export type Usertoregions_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "usertoregions" */
export type Usertoregions_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Usertoregions_Max_Fields = {
  __typename?: 'usertoregions_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "usertoregions" */
export type Usertoregions_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Usertoregions_Min_Fields = {
  __typename?: 'usertoregions_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "usertoregions" */
export type Usertoregions_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "usertoregions" */
export type Usertoregions_Mutation_Response = {
  __typename?: 'usertoregions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usertoregions>;
};

/** on_conflict condition type for table "usertoregions" */
export type Usertoregions_On_Conflict = {
  constraint: Usertoregions_Constraint;
  update_columns?: Array<Usertoregions_Update_Column>;
  where?: InputMaybe<Usertoregions_Bool_Exp>;
};

/** Ordering options when selecting data from "usertoregions". */
export type Usertoregions_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: usertoregions */
export type Usertoregions_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "usertoregions" */
export enum Usertoregions_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "usertoregions" */
export type Usertoregions_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Usertoregions_Stddev_Fields = {
  __typename?: 'usertoregions_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "usertoregions" */
export type Usertoregions_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Usertoregions_Stddev_Pop_Fields = {
  __typename?: 'usertoregions_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "usertoregions" */
export type Usertoregions_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Usertoregions_Stddev_Samp_Fields = {
  __typename?: 'usertoregions_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "usertoregions" */
export type Usertoregions_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "usertoregions" */
export type Usertoregions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usertoregions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usertoregions_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  region_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Usertoregions_Sum_Fields = {
  __typename?: 'usertoregions_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  region_id?: Maybe<Scalars['bigint']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "usertoregions" */
export type Usertoregions_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** update columns of table "usertoregions" */
export enum Usertoregions_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

export type Usertoregions_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Usertoregions_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usertoregions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usertoregions_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Usertoregions_Var_Pop_Fields = {
  __typename?: 'usertoregions_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "usertoregions" */
export type Usertoregions_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Usertoregions_Var_Samp_Fields = {
  __typename?: 'usertoregions_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "usertoregions" */
export type Usertoregions_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Usertoregions_Variance_Fields = {
  __typename?: 'usertoregions_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  region_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "usertoregions" */
export type Usertoregions_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Tracks users' allowed roles for Hasura claims */
export type Usertoroles = {
  __typename?: 'usertoroles';
  created_at: Scalars['timestamptz']['output'];
  created_by: Scalars['String']['output'];
  id: Scalars['bigint']['output'];
  role_id: Scalars['bigint']['output'];
  /** An object relationship */
  roletype: Roletypes;
  updated_at: Scalars['timestamptz']['output'];
  updated_by: Scalars['String']['output'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['bigint']['output'];
};

/** aggregated selection of "usertoroles" */
export type Usertoroles_Aggregate = {
  __typename?: 'usertoroles_aggregate';
  aggregate?: Maybe<Usertoroles_Aggregate_Fields>;
  nodes: Array<Usertoroles>;
};

export type Usertoroles_Aggregate_Bool_Exp = {
  count?: InputMaybe<Usertoroles_Aggregate_Bool_Exp_Count>;
};

export type Usertoroles_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Usertoroles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Usertoroles_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "usertoroles" */
export type Usertoroles_Aggregate_Fields = {
  __typename?: 'usertoroles_aggregate_fields';
  avg?: Maybe<Usertoroles_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Usertoroles_Max_Fields>;
  min?: Maybe<Usertoroles_Min_Fields>;
  stddev?: Maybe<Usertoroles_Stddev_Fields>;
  stddev_pop?: Maybe<Usertoroles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Usertoroles_Stddev_Samp_Fields>;
  sum?: Maybe<Usertoroles_Sum_Fields>;
  var_pop?: Maybe<Usertoroles_Var_Pop_Fields>;
  var_samp?: Maybe<Usertoroles_Var_Samp_Fields>;
  variance?: Maybe<Usertoroles_Variance_Fields>;
};


/** aggregate fields of "usertoroles" */
export type Usertoroles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Usertoroles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "usertoroles" */
export type Usertoroles_Aggregate_Order_By = {
  avg?: InputMaybe<Usertoroles_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Usertoroles_Max_Order_By>;
  min?: InputMaybe<Usertoroles_Min_Order_By>;
  stddev?: InputMaybe<Usertoroles_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Usertoroles_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Usertoroles_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Usertoroles_Sum_Order_By>;
  var_pop?: InputMaybe<Usertoroles_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Usertoroles_Var_Samp_Order_By>;
  variance?: InputMaybe<Usertoroles_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "usertoroles" */
export type Usertoroles_Arr_Rel_Insert_Input = {
  data: Array<Usertoroles_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Usertoroles_On_Conflict>;
};

/** aggregate avg on columns */
export type Usertoroles_Avg_Fields = {
  __typename?: 'usertoroles_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "usertoroles" */
export type Usertoroles_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "usertoroles". All fields are combined with a logical 'AND'. */
export type Usertoroles_Bool_Exp = {
  _and?: InputMaybe<Array<Usertoroles_Bool_Exp>>;
  _not?: InputMaybe<Usertoroles_Bool_Exp>;
  _or?: InputMaybe<Array<Usertoroles_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  role_id?: InputMaybe<Bigint_Comparison_Exp>;
  roletype?: InputMaybe<Roletypes_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "usertoroles" */
export enum Usertoroles_Constraint {
  /** unique or primary key constraint on columns "id" */
  UsertorolesPkey = 'usertoroles_pkey',
  /** unique or primary key constraint on columns "role_id", "user_id" */
  UsertorolesUserIdRoleIdKey = 'usertoroles_user_id_role_id_key'
}

/** input type for incrementing numeric columns in table "usertoroles" */
export type Usertoroles_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  role_id?: InputMaybe<Scalars['bigint']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "usertoroles" */
export type Usertoroles_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  role_id?: InputMaybe<Scalars['bigint']['input']>;
  roletype?: InputMaybe<Roletypes_Obj_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type Usertoroles_Max_Fields = {
  __typename?: 'usertoroles_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  role_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "usertoroles" */
export type Usertoroles_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Usertoroles_Min_Fields = {
  __typename?: 'usertoroles_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  role_id?: Maybe<Scalars['bigint']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "usertoroles" */
export type Usertoroles_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "usertoroles" */
export type Usertoroles_Mutation_Response = {
  __typename?: 'usertoroles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Usertoroles>;
};

/** on_conflict condition type for table "usertoroles" */
export type Usertoroles_On_Conflict = {
  constraint: Usertoroles_Constraint;
  update_columns?: Array<Usertoroles_Update_Column>;
  where?: InputMaybe<Usertoroles_Bool_Exp>;
};

/** Ordering options when selecting data from "usertoroles". */
export type Usertoroles_Order_By = {
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  roletype?: InputMaybe<Roletypes_Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: usertoroles */
export type Usertoroles_Pk_Columns_Input = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "usertoroles" */
export enum Usertoroles_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'role_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "usertoroles" */
export type Usertoroles_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  role_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type Usertoroles_Stddev_Fields = {
  __typename?: 'usertoroles_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "usertoroles" */
export type Usertoroles_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Usertoroles_Stddev_Pop_Fields = {
  __typename?: 'usertoroles_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "usertoroles" */
export type Usertoroles_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Usertoroles_Stddev_Samp_Fields = {
  __typename?: 'usertoroles_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "usertoroles" */
export type Usertoroles_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "usertoroles" */
export type Usertoroles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Usertoroles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Usertoroles_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  role_id?: InputMaybe<Scalars['bigint']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  user_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type Usertoroles_Sum_Fields = {
  __typename?: 'usertoroles_sum_fields';
  id?: Maybe<Scalars['bigint']['output']>;
  role_id?: Maybe<Scalars['bigint']['output']>;
  user_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "usertoroles" */
export type Usertoroles_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** update columns of table "usertoroles" */
export enum Usertoroles_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'role_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  UserId = 'user_id'
}

export type Usertoroles_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Usertoroles_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Usertoroles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Usertoroles_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Usertoroles_Var_Pop_Fields = {
  __typename?: 'usertoroles_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "usertoroles" */
export type Usertoroles_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Usertoroles_Var_Samp_Fields = {
  __typename?: 'usertoroles_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "usertoroles" */
export type Usertoroles_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Usertoroles_Variance_Fields = {
  __typename?: 'usertoroles_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  role_id?: Maybe<Scalars['Float']['output']>;
  user_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "usertoroles" */
export type Usertoroles_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

/** one-to-many with vehiclemodels */
export type Vehiclemakes = {
  __typename?: 'vehiclemakes';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  vehiclemodels: Array<Vehiclemodels>;
  /** An aggregate relationship */
  vehiclemodels_aggregate: Vehiclemodels_Aggregate;
};


/** one-to-many with vehiclemodels */
export type VehiclemakesVehiclemodelsArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemodels_Order_By>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};


/** one-to-many with vehiclemodels */
export type VehiclemakesVehiclemodels_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclemodels_Order_By>>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};

/** aggregated selection of "vehiclemakes" */
export type Vehiclemakes_Aggregate = {
  __typename?: 'vehiclemakes_aggregate';
  aggregate?: Maybe<Vehiclemakes_Aggregate_Fields>;
  nodes: Array<Vehiclemakes>;
};

/** aggregate fields of "vehiclemakes" */
export type Vehiclemakes_Aggregate_Fields = {
  __typename?: 'vehiclemakes_aggregate_fields';
  avg?: Maybe<Vehiclemakes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Vehiclemakes_Max_Fields>;
  min?: Maybe<Vehiclemakes_Min_Fields>;
  stddev?: Maybe<Vehiclemakes_Stddev_Fields>;
  stddev_pop?: Maybe<Vehiclemakes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Vehiclemakes_Stddev_Samp_Fields>;
  sum?: Maybe<Vehiclemakes_Sum_Fields>;
  var_pop?: Maybe<Vehiclemakes_Var_Pop_Fields>;
  var_samp?: Maybe<Vehiclemakes_Var_Samp_Fields>;
  variance?: Maybe<Vehiclemakes_Variance_Fields>;
};


/** aggregate fields of "vehiclemakes" */
export type Vehiclemakes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Vehiclemakes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Vehiclemakes_Avg_Fields = {
  __typename?: 'vehiclemakes_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "vehiclemakes". All fields are combined with a logical 'AND'. */
export type Vehiclemakes_Bool_Exp = {
  _and?: InputMaybe<Array<Vehiclemakes_Bool_Exp>>;
  _not?: InputMaybe<Vehiclemakes_Bool_Exp>;
  _or?: InputMaybe<Array<Vehiclemakes_Bool_Exp>>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  vehiclemodels?: InputMaybe<Vehiclemodels_Bool_Exp>;
  vehiclemodels_aggregate?: InputMaybe<Vehiclemodels_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "vehiclemakes" */
export enum Vehiclemakes_Constraint {
  /** unique or primary key constraint on columns "name" */
  VehiclemakesNameKey = 'vehiclemakes_name_key',
  /** unique or primary key constraint on columns "id" */
  VehiclemakesPkey = 'vehiclemakes_pkey'
}

/** input type for incrementing numeric columns in table "vehiclemakes" */
export type Vehiclemakes_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vehiclemakes" */
export type Vehiclemakes_Insert_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  vehiclemodels?: InputMaybe<Vehiclemodels_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Vehiclemakes_Max_Fields = {
  __typename?: 'vehiclemakes_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Vehiclemakes_Min_Fields = {
  __typename?: 'vehiclemakes_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "vehiclemakes" */
export type Vehiclemakes_Mutation_Response = {
  __typename?: 'vehiclemakes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Vehiclemakes>;
};

/** input type for inserting object relation for remote table "vehiclemakes" */
export type Vehiclemakes_Obj_Rel_Insert_Input = {
  data: Vehiclemakes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Vehiclemakes_On_Conflict>;
};

/** on_conflict condition type for table "vehiclemakes" */
export type Vehiclemakes_On_Conflict = {
  constraint: Vehiclemakes_Constraint;
  update_columns?: Array<Vehiclemakes_Update_Column>;
  where?: InputMaybe<Vehiclemakes_Bool_Exp>;
};

/** Ordering options when selecting data from "vehiclemakes". */
export type Vehiclemakes_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  vehiclemodels_aggregate?: InputMaybe<Vehiclemodels_Aggregate_Order_By>;
};

/** primary key columns input for table: vehiclemakes */
export type Vehiclemakes_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "vehiclemakes" */
export enum Vehiclemakes_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "vehiclemakes" */
export type Vehiclemakes_Set_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Vehiclemakes_Stddev_Fields = {
  __typename?: 'vehiclemakes_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Vehiclemakes_Stddev_Pop_Fields = {
  __typename?: 'vehiclemakes_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Vehiclemakes_Stddev_Samp_Fields = {
  __typename?: 'vehiclemakes_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "vehiclemakes" */
export type Vehiclemakes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vehiclemakes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vehiclemakes_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Vehiclemakes_Sum_Fields = {
  __typename?: 'vehiclemakes_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "vehiclemakes" */
export enum Vehiclemakes_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Vehiclemakes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Vehiclemakes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Vehiclemakes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vehiclemakes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Vehiclemakes_Var_Pop_Fields = {
  __typename?: 'vehiclemakes_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Vehiclemakes_Var_Samp_Fields = {
  __typename?: 'vehiclemakes_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Vehiclemakes_Variance_Fields = {
  __typename?: 'vehiclemakes_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "vehiclemodels" */
export type Vehiclemodels = {
  __typename?: 'vehiclemodels';
  id: Scalars['Int']['output'];
  make_id?: Maybe<Scalars['Int']['output']>;
  model_year?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  type?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  vehiclemake?: Maybe<Vehiclemakes>;
};

/** aggregated selection of "vehiclemodels" */
export type Vehiclemodels_Aggregate = {
  __typename?: 'vehiclemodels_aggregate';
  aggregate?: Maybe<Vehiclemodels_Aggregate_Fields>;
  nodes: Array<Vehiclemodels>;
};

export type Vehiclemodels_Aggregate_Bool_Exp = {
  count?: InputMaybe<Vehiclemodels_Aggregate_Bool_Exp_Count>;
};

export type Vehiclemodels_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Vehiclemodels_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "vehiclemodels" */
export type Vehiclemodels_Aggregate_Fields = {
  __typename?: 'vehiclemodels_aggregate_fields';
  avg?: Maybe<Vehiclemodels_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Vehiclemodels_Max_Fields>;
  min?: Maybe<Vehiclemodels_Min_Fields>;
  stddev?: Maybe<Vehiclemodels_Stddev_Fields>;
  stddev_pop?: Maybe<Vehiclemodels_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Vehiclemodels_Stddev_Samp_Fields>;
  sum?: Maybe<Vehiclemodels_Sum_Fields>;
  var_pop?: Maybe<Vehiclemodels_Var_Pop_Fields>;
  var_samp?: Maybe<Vehiclemodels_Var_Samp_Fields>;
  variance?: Maybe<Vehiclemodels_Variance_Fields>;
};


/** aggregate fields of "vehiclemodels" */
export type Vehiclemodels_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Vehiclemodels_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vehiclemodels" */
export type Vehiclemodels_Aggregate_Order_By = {
  avg?: InputMaybe<Vehiclemodels_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Vehiclemodels_Max_Order_By>;
  min?: InputMaybe<Vehiclemodels_Min_Order_By>;
  stddev?: InputMaybe<Vehiclemodels_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Vehiclemodels_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Vehiclemodels_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Vehiclemodels_Sum_Order_By>;
  var_pop?: InputMaybe<Vehiclemodels_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Vehiclemodels_Var_Samp_Order_By>;
  variance?: InputMaybe<Vehiclemodels_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "vehiclemodels" */
export type Vehiclemodels_Arr_Rel_Insert_Input = {
  data: Array<Vehiclemodels_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Vehiclemodels_On_Conflict>;
};

/** aggregate avg on columns */
export type Vehiclemodels_Avg_Fields = {
  __typename?: 'vehiclemodels_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "vehiclemodels" */
export type Vehiclemodels_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "vehiclemodels". All fields are combined with a logical 'AND'. */
export type Vehiclemodels_Bool_Exp = {
  _and?: InputMaybe<Array<Vehiclemodels_Bool_Exp>>;
  _not?: InputMaybe<Vehiclemodels_Bool_Exp>;
  _or?: InputMaybe<Array<Vehiclemodels_Bool_Exp>>;
  id?: InputMaybe<Int_Comparison_Exp>;
  make_id?: InputMaybe<Int_Comparison_Exp>;
  model_year?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  vehiclemake?: InputMaybe<Vehiclemakes_Bool_Exp>;
};

/** unique or primary key constraints on table "vehiclemodels" */
export enum Vehiclemodels_Constraint {
  /** unique or primary key constraint on columns "id" */
  VehiclemodelsPkey = 'vehiclemodels_pkey'
}

/** input type for incrementing numeric columns in table "vehiclemodels" */
export type Vehiclemodels_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  make_id?: InputMaybe<Scalars['Int']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vehiclemodels" */
export type Vehiclemodels_Insert_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  make_id?: InputMaybe<Scalars['Int']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  vehiclemake?: InputMaybe<Vehiclemakes_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Vehiclemodels_Max_Fields = {
  __typename?: 'vehiclemodels_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  make_id?: Maybe<Scalars['Int']['output']>;
  model_year?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "vehiclemodels" */
export type Vehiclemodels_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Vehiclemodels_Min_Fields = {
  __typename?: 'vehiclemodels_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  make_id?: Maybe<Scalars['Int']['output']>;
  model_year?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "vehiclemodels" */
export type Vehiclemodels_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "vehiclemodels" */
export type Vehiclemodels_Mutation_Response = {
  __typename?: 'vehiclemodels_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Vehiclemodels>;
};

/** on_conflict condition type for table "vehiclemodels" */
export type Vehiclemodels_On_Conflict = {
  constraint: Vehiclemodels_Constraint;
  update_columns?: Array<Vehiclemodels_Update_Column>;
  where?: InputMaybe<Vehiclemodels_Bool_Exp>;
};

/** Ordering options when selecting data from "vehiclemodels". */
export type Vehiclemodels_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  vehiclemake?: InputMaybe<Vehiclemakes_Order_By>;
};

/** primary key columns input for table: vehiclemodels */
export type Vehiclemodels_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "vehiclemodels" */
export enum Vehiclemodels_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  MakeId = 'make_id',
  /** column name */
  ModelYear = 'model_year',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "vehiclemodels" */
export type Vehiclemodels_Set_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  make_id?: InputMaybe<Scalars['Int']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Vehiclemodels_Stddev_Fields = {
  __typename?: 'vehiclemodels_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "vehiclemodels" */
export type Vehiclemodels_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Vehiclemodels_Stddev_Pop_Fields = {
  __typename?: 'vehiclemodels_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "vehiclemodels" */
export type Vehiclemodels_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Vehiclemodels_Stddev_Samp_Fields = {
  __typename?: 'vehiclemodels_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "vehiclemodels" */
export type Vehiclemodels_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "vehiclemodels" */
export type Vehiclemodels_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vehiclemodels_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vehiclemodels_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  make_id?: InputMaybe<Scalars['Int']['input']>;
  model_year?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Vehiclemodels_Sum_Fields = {
  __typename?: 'vehiclemodels_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  make_id?: Maybe<Scalars['Int']['output']>;
  model_year?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "vehiclemodels" */
export type Vehiclemodels_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** update columns of table "vehiclemodels" */
export enum Vehiclemodels_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  MakeId = 'make_id',
  /** column name */
  ModelYear = 'model_year',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type'
}

export type Vehiclemodels_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Vehiclemodels_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Vehiclemodels_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vehiclemodels_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Vehiclemodels_Var_Pop_Fields = {
  __typename?: 'vehiclemodels_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "vehiclemodels" */
export type Vehiclemodels_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Vehiclemodels_Var_Samp_Fields = {
  __typename?: 'vehiclemodels_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "vehiclemodels" */
export type Vehiclemodels_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Vehiclemodels_Variance_Fields = {
  __typename?: 'vehiclemodels_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  make_id?: Maybe<Scalars['Float']['output']>;
  model_year?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "vehiclemodels" */
export type Vehiclemodels_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  make_id?: InputMaybe<Order_By>;
  model_year?: InputMaybe<Order_By>;
};

/** Photos of the vehicles captured by the drivers in the driver app during pickup and delivery. */
export type Vehiclephotos = {
  __typename?: 'vehiclephotos';
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  location?: Maybe<Scalars['geography']['output']>;
  /** An object relationship */
  move: Moves;
  move_id: Scalars['bigint']['output'];
  name: Scalars['String']['output'];
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status: Scalars['String']['output'];
  /** The step id from the workflow the photo was captured from */
  step_id: Scalars['String']['output'];
  url?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  workflow: Workflows;
  /** Related workflow the image was captured from */
  workflow_id: Scalars['Int']['output'];
};

/** aggregated selection of "vehiclephotos" */
export type Vehiclephotos_Aggregate = {
  __typename?: 'vehiclephotos_aggregate';
  aggregate?: Maybe<Vehiclephotos_Aggregate_Fields>;
  nodes: Array<Vehiclephotos>;
};

export type Vehiclephotos_Aggregate_Bool_Exp = {
  count?: InputMaybe<Vehiclephotos_Aggregate_Bool_Exp_Count>;
};

export type Vehiclephotos_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Vehiclephotos_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "vehiclephotos" */
export type Vehiclephotos_Aggregate_Fields = {
  __typename?: 'vehiclephotos_aggregate_fields';
  avg?: Maybe<Vehiclephotos_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Vehiclephotos_Max_Fields>;
  min?: Maybe<Vehiclephotos_Min_Fields>;
  stddev?: Maybe<Vehiclephotos_Stddev_Fields>;
  stddev_pop?: Maybe<Vehiclephotos_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Vehiclephotos_Stddev_Samp_Fields>;
  sum?: Maybe<Vehiclephotos_Sum_Fields>;
  var_pop?: Maybe<Vehiclephotos_Var_Pop_Fields>;
  var_samp?: Maybe<Vehiclephotos_Var_Samp_Fields>;
  variance?: Maybe<Vehiclephotos_Variance_Fields>;
};


/** aggregate fields of "vehiclephotos" */
export type Vehiclephotos_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vehiclephotos" */
export type Vehiclephotos_Aggregate_Order_By = {
  avg?: InputMaybe<Vehiclephotos_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Vehiclephotos_Max_Order_By>;
  min?: InputMaybe<Vehiclephotos_Min_Order_By>;
  stddev?: InputMaybe<Vehiclephotos_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Vehiclephotos_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Vehiclephotos_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Vehiclephotos_Sum_Order_By>;
  var_pop?: InputMaybe<Vehiclephotos_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Vehiclephotos_Var_Samp_Order_By>;
  variance?: InputMaybe<Vehiclephotos_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "vehiclephotos" */
export type Vehiclephotos_Arr_Rel_Insert_Input = {
  data: Array<Vehiclephotos_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Vehiclephotos_On_Conflict>;
};

/** aggregate avg on columns */
export type Vehiclephotos_Avg_Fields = {
  __typename?: 'vehiclephotos_avg_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "vehiclephotos" */
export type Vehiclephotos_Avg_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "vehiclephotos". All fields are combined with a logical 'AND'. */
export type Vehiclephotos_Bool_Exp = {
  _and?: InputMaybe<Array<Vehiclephotos_Bool_Exp>>;
  _not?: InputMaybe<Vehiclephotos_Bool_Exp>;
  _or?: InputMaybe<Array<Vehiclephotos_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  location?: InputMaybe<Geography_Comparison_Exp>;
  move?: InputMaybe<Moves_Bool_Exp>;
  move_id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  step_id?: InputMaybe<String_Comparison_Exp>;
  url?: InputMaybe<String_Comparison_Exp>;
  workflow?: InputMaybe<Workflows_Bool_Exp>;
  workflow_id?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "vehiclephotos" */
export enum Vehiclephotos_Constraint {
  /** unique or primary key constraint on columns "name", "workflow_id", "move_id" */
  VehiclephotosNameMoveIdWorkflowIdKey = 'vehiclephotos_name_move_id_workflow_id_key',
  /** unique or primary key constraint on columns "id" */
  VehiclephotosPkey = 'vehiclephotos_pkey'
}

/** input type for incrementing numeric columns in table "vehiclephotos" */
export type Vehiclephotos_Inc_Input = {
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vehiclephotos" */
export type Vehiclephotos_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  move?: InputMaybe<Moves_Obj_Rel_Insert_Input>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The step id from the workflow the photo was captured from */
  step_id?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Vehiclephotos_Max_Fields = {
  __typename?: 'vehiclephotos_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: Maybe<Scalars['String']['output']>;
  /** The step id from the workflow the photo was captured from */
  step_id?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "vehiclephotos" */
export type Vehiclephotos_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: InputMaybe<Order_By>;
  /** The step id from the workflow the photo was captured from */
  step_id?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Vehiclephotos_Min_Fields = {
  __typename?: 'vehiclephotos_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  move_id?: Maybe<Scalars['bigint']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: Maybe<Scalars['String']['output']>;
  /** The step id from the workflow the photo was captured from */
  step_id?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "vehiclephotos" */
export type Vehiclephotos_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  move_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: InputMaybe<Order_By>;
  /** The step id from the workflow the photo was captured from */
  step_id?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "vehiclephotos" */
export type Vehiclephotos_Mutation_Response = {
  __typename?: 'vehiclephotos_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Vehiclephotos>;
};

/** on_conflict condition type for table "vehiclephotos" */
export type Vehiclephotos_On_Conflict = {
  constraint: Vehiclephotos_Constraint;
  update_columns?: Array<Vehiclephotos_Update_Column>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};

/** Ordering options when selecting data from "vehiclephotos". */
export type Vehiclephotos_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  location?: InputMaybe<Order_By>;
  move?: InputMaybe<Moves_Order_By>;
  move_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  step_id?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
  workflow?: InputMaybe<Workflows_Order_By>;
  workflow_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: vehiclephotos */
export type Vehiclephotos_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "vehiclephotos" */
export enum Vehiclephotos_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  Location = 'location',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Name = 'name',
  /** column name */
  Status = 'status',
  /** column name */
  StepId = 'step_id',
  /** column name */
  Url = 'url',
  /** column name */
  WorkflowId = 'workflow_id'
}

/** input type for updating data in table "vehiclephotos" */
export type Vehiclephotos_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The step id from the workflow the photo was captured from */
  step_id?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Vehiclephotos_Stddev_Fields = {
  __typename?: 'vehiclephotos_stddev_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "vehiclephotos" */
export type Vehiclephotos_Stddev_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Vehiclephotos_Stddev_Pop_Fields = {
  __typename?: 'vehiclephotos_stddev_pop_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "vehiclephotos" */
export type Vehiclephotos_Stddev_Pop_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Vehiclephotos_Stddev_Samp_Fields = {
  __typename?: 'vehiclephotos_stddev_samp_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "vehiclephotos" */
export type Vehiclephotos_Stddev_Samp_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "vehiclephotos" */
export type Vehiclephotos_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vehiclephotos_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vehiclephotos_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  location?: InputMaybe<Scalars['geography']['input']>;
  move_id?: InputMaybe<Scalars['bigint']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** Status of the upload of the photo to the S3 bucket. Valid values are uploading | done | error */
  status?: InputMaybe<Scalars['String']['input']>;
  /** The step id from the workflow the photo was captured from */
  step_id?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Vehiclephotos_Sum_Fields = {
  __typename?: 'vehiclephotos_sum_fields';
  move_id?: Maybe<Scalars['bigint']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "vehiclephotos" */
export type Vehiclephotos_Sum_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** update columns of table "vehiclephotos" */
export enum Vehiclephotos_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Id = 'id',
  /** column name */
  Location = 'location',
  /** column name */
  MoveId = 'move_id',
  /** column name */
  Name = 'name',
  /** column name */
  Status = 'status',
  /** column name */
  StepId = 'step_id',
  /** column name */
  Url = 'url',
  /** column name */
  WorkflowId = 'workflow_id'
}

export type Vehiclephotos_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Vehiclephotos_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Vehiclephotos_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vehiclephotos_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Vehiclephotos_Var_Pop_Fields = {
  __typename?: 'vehiclephotos_var_pop_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "vehiclephotos" */
export type Vehiclephotos_Var_Pop_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Vehiclephotos_Var_Samp_Fields = {
  __typename?: 'vehiclephotos_var_samp_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "vehiclephotos" */
export type Vehiclephotos_Var_Samp_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Vehiclephotos_Variance_Fields = {
  __typename?: 'vehiclephotos_variance_fields';
  move_id?: Maybe<Scalars['Float']['output']>;
  /** Related workflow the image was captured from */
  workflow_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "vehiclephotos" */
export type Vehiclephotos_Variance_Order_By = {
  move_id?: InputMaybe<Order_By>;
  /** Related workflow the image was captured from */
  workflow_id?: InputMaybe<Order_By>;
};

/** Extensive data on each sub-model of vehicle from 1984 to the current vehicle year with data sourced from the DOE via fueleconomy.gov. Table is updated yearly. */
export type Vehicles = {
  __typename?: 'vehicles';
  /** type of alternative fuel or advanced technology vehicle e.g. Diesel, Hybrid, EV */
  atv_type?: Maybe<Scalars['String']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['numeric']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['numeric']['output']>;
  /** electric vehicle charger description */
  charger_description?: Maybe<Scalars['String']['output']>;
  /** electric vehicle alternate charger description */
  charger_description_alt?: Maybe<Scalars['String']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg: Scalars['numeric']['output'];
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg: Scalars['numeric']['output'];
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  created_at: Scalars['timestamptz']['output'];
  created_by?: Maybe<Scalars['String']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Int']['output']>;
  /** Date the DOE record was created */
  doe_created_on: Scalars['timestamptz']['output'];
  /** Date DOE record was modified */
  doe_modified_on: Scalars['timestamptz']['output'];
  drive_axle_type?: Maybe<Scalars['String']['output']>;
  electric_motor?: Maybe<Scalars['String']['output']>;
  /** Engine descriptor code e.g. DI for Direct Injeection, HEV for Hybrid Electric Vehicle, etc. See http://www.fueleconomy.gov/feg/findacarhelp.shtml#engine for all descriptors */
  engine_descriptor?: Maybe<Scalars['String']['output']>;
  engine_displacement_liters?: Maybe<Scalars['numeric']['output']>;
  /** EPA model type index */
  engine_id?: Maybe<Scalars['String']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual: Scalars['numeric']['output'];
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Int']['output']>;
  /** Fuel type with fuel_type_one and fuel_type_two (if applicable) */
  fuel_type: Scalars['String']['output'];
  /** fuel type 1. For single fuel vehicles, this will be the only fuel. For dual fuel vehicles, this will be the conventional fuel. */
  fuel_type_one: Scalars['String']['output'];
  /** fuel type 2. For dual fuel vehicles, this will be the alternative fuel (e.g. E85, Electricity, CNG, LPG). For single fuel vehicles, this field is not used */
  fuel_type_two?: Maybe<Scalars['String']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Int']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Int']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg: Scalars['numeric']['output'];
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** vehicle id from DOE dataset */
  id: Scalars['bigint']['output'];
  /** manufacturer (division) */
  make: Scalars['String']['output'];
  /** 3-character manufacturer code */
  manufacturer_code?: Maybe<Scalars['String']['output']>;
  /** model name (carline) */
  model?: Maybe<Scalars['String']['output']>;
  /** base model name e.g. for model F150 Pickup 2WD, the base model is F150 */
  model_base?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  /** if true, this vehicle operates on a blend of gasoline and electricity in charge depleting mode */
  phev_blended: Scalars['Boolean']['output'];
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['numeric']['output']>;
  /** vehicle has stop-start technology */
  start_stop_tech: Scalars['Boolean']['output'];
  supercharged: Scalars['Boolean']['output'];
  transmission?: Maybe<Scalars['String']['output']>;
  /** transmission descriptor; see http://www.fueleconomy.gov/feg/findacarhelp.shtml#trany */
  transmission_descriptor?: Maybe<Scalars['String']['output']>;
  turbocharged: Scalars['Boolean']['output'];
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg: Scalars['numeric']['output'];
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt: Scalars['numeric']['output'];
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg: Scalars['numeric']['output'];
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt: Scalars['numeric']['output'];
  updated_at: Scalars['timestamptz']['output'];
  updated_by?: Maybe<Scalars['String']['output']>;
  /** EPA vehicle size class e.g. Two-Seaters, Compact Cars, Minivans, Small Pickup Trucks, etc */
  vehicle_class_size?: Maybe<Scalars['String']['output']>;
  /** model year */
  year: Scalars['Int']['output'];
};


/** Extensive data on each sub-model of vehicle from 1984 to the current vehicle year with data sourced from the DOE via fueleconomy.gov. Table is updated yearly. */
export type VehiclesMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** Extensive data on each sub-model of vehicle from 1984 to the current vehicle year with data sourced from the DOE via fueleconomy.gov. Table is updated yearly. */
export type VehiclesMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};

/** aggregated selection of "vehicles" */
export type Vehicles_Aggregate = {
  __typename?: 'vehicles_aggregate';
  aggregate?: Maybe<Vehicles_Aggregate_Fields>;
  nodes: Array<Vehicles>;
};

/** aggregate fields of "vehicles" */
export type Vehicles_Aggregate_Fields = {
  __typename?: 'vehicles_aggregate_fields';
  avg?: Maybe<Vehicles_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Vehicles_Max_Fields>;
  min?: Maybe<Vehicles_Min_Fields>;
  stddev?: Maybe<Vehicles_Stddev_Fields>;
  stddev_pop?: Maybe<Vehicles_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Vehicles_Stddev_Samp_Fields>;
  sum?: Maybe<Vehicles_Sum_Fields>;
  var_pop?: Maybe<Vehicles_Var_Pop_Fields>;
  var_samp?: Maybe<Vehicles_Var_Samp_Fields>;
  variance?: Maybe<Vehicles_Variance_Fields>;
};


/** aggregate fields of "vehicles" */
export type Vehicles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Vehicles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Vehicles_Avg_Fields = {
  __typename?: 'vehicles_avg_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "vehicles". All fields are combined with a logical 'AND'. */
export type Vehicles_Bool_Exp = {
  _and?: InputMaybe<Array<Vehicles_Bool_Exp>>;
  _not?: InputMaybe<Vehicles_Bool_Exp>;
  _or?: InputMaybe<Array<Vehicles_Bool_Exp>>;
  atv_type?: InputMaybe<String_Comparison_Exp>;
  barrels_per_year?: InputMaybe<Numeric_Comparison_Exp>;
  barrels_per_year_alt?: InputMaybe<Numeric_Comparison_Exp>;
  charge_time_120_volts?: InputMaybe<Numeric_Comparison_Exp>;
  charge_time_240_volts?: InputMaybe<Numeric_Comparison_Exp>;
  charge_time_240_volts_alt?: InputMaybe<Numeric_Comparison_Exp>;
  charger_description?: InputMaybe<String_Comparison_Exp>;
  charger_description_alt?: InputMaybe<String_Comparison_Exp>;
  city_hybrid_utility_factor?: InputMaybe<Numeric_Comparison_Exp>;
  city_mpg?: InputMaybe<Numeric_Comparison_Exp>;
  city_mpg_alt?: InputMaybe<Numeric_Comparison_Exp>;
  city_mpg_charge_depleted?: InputMaybe<Numeric_Comparison_Exp>;
  city_mpg_electric?: InputMaybe<Numeric_Comparison_Exp>;
  city_mpg_hydrogen?: InputMaybe<Numeric_Comparison_Exp>;
  combined_hybrid_utility_factor?: InputMaybe<Numeric_Comparison_Exp>;
  combined_mpg?: InputMaybe<Numeric_Comparison_Exp>;
  combined_mpg_alt?: InputMaybe<Numeric_Comparison_Exp>;
  combined_mpg_electric?: InputMaybe<Numeric_Comparison_Exp>;
  combined_mpg_hydrogen?: InputMaybe<Numeric_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  created_by?: InputMaybe<String_Comparison_Exp>;
  cylinders?: InputMaybe<Int_Comparison_Exp>;
  doe_created_on?: InputMaybe<Timestamptz_Comparison_Exp>;
  doe_modified_on?: InputMaybe<Timestamptz_Comparison_Exp>;
  drive_axle_type?: InputMaybe<String_Comparison_Exp>;
  electric_motor?: InputMaybe<String_Comparison_Exp>;
  engine_descriptor?: InputMaybe<String_Comparison_Exp>;
  engine_displacement_liters?: InputMaybe<Numeric_Comparison_Exp>;
  engine_id?: InputMaybe<String_Comparison_Exp>;
  fuel_cost_annual?: InputMaybe<Numeric_Comparison_Exp>;
  fuel_cost_annual_alt?: InputMaybe<Numeric_Comparison_Exp>;
  fuel_economy_score?: InputMaybe<Int_Comparison_Exp>;
  fuel_type?: InputMaybe<String_Comparison_Exp>;
  fuel_type_one?: InputMaybe<String_Comparison_Exp>;
  fuel_type_two?: InputMaybe<String_Comparison_Exp>;
  ghg_score?: InputMaybe<Int_Comparison_Exp>;
  ghg_score_alt?: InputMaybe<Int_Comparison_Exp>;
  highway_hybrid_utility_factor?: InputMaybe<Numeric_Comparison_Exp>;
  highway_mpg?: InputMaybe<Numeric_Comparison_Exp>;
  highway_mpg_alt?: InputMaybe<Numeric_Comparison_Exp>;
  highway_mpg_charge_depleted?: InputMaybe<Numeric_Comparison_Exp>;
  highway_mpg_electric?: InputMaybe<Numeric_Comparison_Exp>;
  highway_mpg_hydrogen?: InputMaybe<Numeric_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  make?: InputMaybe<String_Comparison_Exp>;
  manufacturer_code?: InputMaybe<String_Comparison_Exp>;
  model?: InputMaybe<String_Comparison_Exp>;
  model_base?: InputMaybe<String_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  phev_blended?: InputMaybe<Boolean_Comparison_Exp>;
  range?: InputMaybe<Numeric_Comparison_Exp>;
  range_alt?: InputMaybe<Numeric_Comparison_Exp>;
  range_alt_city?: InputMaybe<Numeric_Comparison_Exp>;
  range_alt_highway?: InputMaybe<Numeric_Comparison_Exp>;
  range_city?: InputMaybe<Numeric_Comparison_Exp>;
  range_highway?: InputMaybe<Numeric_Comparison_Exp>;
  start_stop_tech?: InputMaybe<Boolean_Comparison_Exp>;
  supercharged?: InputMaybe<Boolean_Comparison_Exp>;
  transmission?: InputMaybe<String_Comparison_Exp>;
  transmission_descriptor?: InputMaybe<String_Comparison_Exp>;
  turbocharged?: InputMaybe<Boolean_Comparison_Exp>;
  unadjusted_city_mpg?: InputMaybe<Numeric_Comparison_Exp>;
  unadjusted_city_mpg_alt?: InputMaybe<Numeric_Comparison_Exp>;
  unadjusted_highway_mpg?: InputMaybe<Numeric_Comparison_Exp>;
  unadjusted_highway_mpg_alt?: InputMaybe<Numeric_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  updated_by?: InputMaybe<String_Comparison_Exp>;
  vehicle_class_size?: InputMaybe<String_Comparison_Exp>;
  year?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "vehicles" */
export enum Vehicles_Constraint {
  /** unique or primary key constraint on columns "id" */
  VehiclesPkey = 'vehicles_pkey'
}

/** input type for incrementing numeric columns in table "vehicles" */
export type Vehicles_Inc_Input = {
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: InputMaybe<Scalars['numeric']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_one */
  city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** engine cylinders */
  cylinders?: InputMaybe<Scalars['Int']['input']>;
  engine_displacement_liters?: InputMaybe<Scalars['numeric']['input']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: InputMaybe<Scalars['numeric']['input']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: InputMaybe<Scalars['Int']['input']>;
  /** EPA GHG score */
  ghg_score?: InputMaybe<Scalars['Int']['input']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: InputMaybe<Scalars['Int']['input']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle id from DOE dataset */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** EPA range for fuel_type_one */
  range?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_one */
  range_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** model year */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vehicles" */
export type Vehicles_Insert_Input = {
  /** type of alternative fuel or advanced technology vehicle e.g. Diesel, Hybrid, EV */
  atv_type?: InputMaybe<Scalars['String']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: InputMaybe<Scalars['numeric']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** electric vehicle charger description */
  charger_description?: InputMaybe<Scalars['String']['input']>;
  /** electric vehicle alternate charger description */
  charger_description_alt?: InputMaybe<Scalars['String']['input']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_one */
  city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** engine cylinders */
  cylinders?: InputMaybe<Scalars['Int']['input']>;
  /** Date the DOE record was created */
  doe_created_on?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date DOE record was modified */
  doe_modified_on?: InputMaybe<Scalars['timestamptz']['input']>;
  drive_axle_type?: InputMaybe<Scalars['String']['input']>;
  electric_motor?: InputMaybe<Scalars['String']['input']>;
  /** Engine descriptor code e.g. DI for Direct Injeection, HEV for Hybrid Electric Vehicle, etc. See http://www.fueleconomy.gov/feg/findacarhelp.shtml#engine for all descriptors */
  engine_descriptor?: InputMaybe<Scalars['String']['input']>;
  engine_displacement_liters?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA model type index */
  engine_id?: InputMaybe<Scalars['String']['input']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: InputMaybe<Scalars['numeric']['input']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: InputMaybe<Scalars['Int']['input']>;
  /** Fuel type with fuel_type_one and fuel_type_two (if applicable) */
  fuel_type?: InputMaybe<Scalars['String']['input']>;
  /** fuel type 1. For single fuel vehicles, this will be the only fuel. For dual fuel vehicles, this will be the conventional fuel. */
  fuel_type_one?: InputMaybe<Scalars['String']['input']>;
  /** fuel type 2. For dual fuel vehicles, this will be the alternative fuel (e.g. E85, Electricity, CNG, LPG). For single fuel vehicles, this field is not used */
  fuel_type_two?: InputMaybe<Scalars['String']['input']>;
  /** EPA GHG score */
  ghg_score?: InputMaybe<Scalars['Int']['input']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: InputMaybe<Scalars['Int']['input']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle id from DOE dataset */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** manufacturer (division) */
  make?: InputMaybe<Scalars['String']['input']>;
  /** 3-character manufacturer code */
  manufacturer_code?: InputMaybe<Scalars['String']['input']>;
  /** model name (carline) */
  model?: InputMaybe<Scalars['String']['input']>;
  /** base model name e.g. for model F150 Pickup 2WD, the base model is F150 */
  model_base?: InputMaybe<Scalars['String']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  /** if true, this vehicle operates on a blend of gasoline and electricity in charge depleting mode */
  phev_blended?: InputMaybe<Scalars['Boolean']['input']>;
  /** EPA range for fuel_type_one */
  range?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_one */
  range_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle has stop-start technology */
  start_stop_tech?: InputMaybe<Scalars['Boolean']['input']>;
  supercharged?: InputMaybe<Scalars['Boolean']['input']>;
  transmission?: InputMaybe<Scalars['String']['input']>;
  /** transmission descriptor; see http://www.fueleconomy.gov/feg/findacarhelp.shtml#trany */
  transmission_descriptor?: InputMaybe<Scalars['String']['input']>;
  turbocharged?: InputMaybe<Scalars['Boolean']['input']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  /** EPA vehicle size class e.g. Two-Seaters, Compact Cars, Minivans, Small Pickup Trucks, etc */
  vehicle_class_size?: InputMaybe<Scalars['String']['input']>;
  /** model year */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Vehicles_Max_Fields = {
  __typename?: 'vehicles_max_fields';
  /** type of alternative fuel or advanced technology vehicle e.g. Diesel, Hybrid, EV */
  atv_type?: Maybe<Scalars['String']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['numeric']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['numeric']['output']>;
  /** electric vehicle charger description */
  charger_description?: Maybe<Scalars['String']['output']>;
  /** electric vehicle alternate charger description */
  charger_description_alt?: Maybe<Scalars['String']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Int']['output']>;
  /** Date the DOE record was created */
  doe_created_on?: Maybe<Scalars['timestamptz']['output']>;
  /** Date DOE record was modified */
  doe_modified_on?: Maybe<Scalars['timestamptz']['output']>;
  drive_axle_type?: Maybe<Scalars['String']['output']>;
  electric_motor?: Maybe<Scalars['String']['output']>;
  /** Engine descriptor code e.g. DI for Direct Injeection, HEV for Hybrid Electric Vehicle, etc. See http://www.fueleconomy.gov/feg/findacarhelp.shtml#engine for all descriptors */
  engine_descriptor?: Maybe<Scalars['String']['output']>;
  engine_displacement_liters?: Maybe<Scalars['numeric']['output']>;
  /** EPA model type index */
  engine_id?: Maybe<Scalars['String']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['numeric']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Int']['output']>;
  /** Fuel type with fuel_type_one and fuel_type_two (if applicable) */
  fuel_type?: Maybe<Scalars['String']['output']>;
  /** fuel type 1. For single fuel vehicles, this will be the only fuel. For dual fuel vehicles, this will be the conventional fuel. */
  fuel_type_one?: Maybe<Scalars['String']['output']>;
  /** fuel type 2. For dual fuel vehicles, this will be the alternative fuel (e.g. E85, Electricity, CNG, LPG). For single fuel vehicles, this field is not used */
  fuel_type_two?: Maybe<Scalars['String']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Int']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Int']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['bigint']['output']>;
  /** manufacturer (division) */
  make?: Maybe<Scalars['String']['output']>;
  /** 3-character manufacturer code */
  manufacturer_code?: Maybe<Scalars['String']['output']>;
  /** model name (carline) */
  model?: Maybe<Scalars['String']['output']>;
  /** base model name e.g. for model F150 Pickup 2WD, the base model is F150 */
  model_base?: Maybe<Scalars['String']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['numeric']['output']>;
  transmission?: Maybe<Scalars['String']['output']>;
  /** transmission descriptor; see http://www.fueleconomy.gov/feg/findacarhelp.shtml#trany */
  transmission_descriptor?: Maybe<Scalars['String']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  /** EPA vehicle size class e.g. Two-Seaters, Compact Cars, Minivans, Small Pickup Trucks, etc */
  vehicle_class_size?: Maybe<Scalars['String']['output']>;
  /** model year */
  year?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Vehicles_Min_Fields = {
  __typename?: 'vehicles_min_fields';
  /** type of alternative fuel or advanced technology vehicle e.g. Diesel, Hybrid, EV */
  atv_type?: Maybe<Scalars['String']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['numeric']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['numeric']['output']>;
  /** electric vehicle charger description */
  charger_description?: Maybe<Scalars['String']['output']>;
  /** electric vehicle alternate charger description */
  charger_description_alt?: Maybe<Scalars['String']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  created_by?: Maybe<Scalars['String']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Int']['output']>;
  /** Date the DOE record was created */
  doe_created_on?: Maybe<Scalars['timestamptz']['output']>;
  /** Date DOE record was modified */
  doe_modified_on?: Maybe<Scalars['timestamptz']['output']>;
  drive_axle_type?: Maybe<Scalars['String']['output']>;
  electric_motor?: Maybe<Scalars['String']['output']>;
  /** Engine descriptor code e.g. DI for Direct Injeection, HEV for Hybrid Electric Vehicle, etc. See http://www.fueleconomy.gov/feg/findacarhelp.shtml#engine for all descriptors */
  engine_descriptor?: Maybe<Scalars['String']['output']>;
  engine_displacement_liters?: Maybe<Scalars['numeric']['output']>;
  /** EPA model type index */
  engine_id?: Maybe<Scalars['String']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['numeric']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Int']['output']>;
  /** Fuel type with fuel_type_one and fuel_type_two (if applicable) */
  fuel_type?: Maybe<Scalars['String']['output']>;
  /** fuel type 1. For single fuel vehicles, this will be the only fuel. For dual fuel vehicles, this will be the conventional fuel. */
  fuel_type_one?: Maybe<Scalars['String']['output']>;
  /** fuel type 2. For dual fuel vehicles, this will be the alternative fuel (e.g. E85, Electricity, CNG, LPG). For single fuel vehicles, this field is not used */
  fuel_type_two?: Maybe<Scalars['String']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Int']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Int']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['bigint']['output']>;
  /** manufacturer (division) */
  make?: Maybe<Scalars['String']['output']>;
  /** 3-character manufacturer code */
  manufacturer_code?: Maybe<Scalars['String']['output']>;
  /** model name (carline) */
  model?: Maybe<Scalars['String']['output']>;
  /** base model name e.g. for model F150 Pickup 2WD, the base model is F150 */
  model_base?: Maybe<Scalars['String']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['numeric']['output']>;
  transmission?: Maybe<Scalars['String']['output']>;
  /** transmission descriptor; see http://www.fueleconomy.gov/feg/findacarhelp.shtml#trany */
  transmission_descriptor?: Maybe<Scalars['String']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  updated_by?: Maybe<Scalars['String']['output']>;
  /** EPA vehicle size class e.g. Two-Seaters, Compact Cars, Minivans, Small Pickup Trucks, etc */
  vehicle_class_size?: Maybe<Scalars['String']['output']>;
  /** model year */
  year?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "vehicles" */
export type Vehicles_Mutation_Response = {
  __typename?: 'vehicles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Vehicles>;
};

/** input type for inserting object relation for remote table "vehicles" */
export type Vehicles_Obj_Rel_Insert_Input = {
  data: Vehicles_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Vehicles_On_Conflict>;
};

/** on_conflict condition type for table "vehicles" */
export type Vehicles_On_Conflict = {
  constraint: Vehicles_Constraint;
  update_columns?: Array<Vehicles_Update_Column>;
  where?: InputMaybe<Vehicles_Bool_Exp>;
};

/** Ordering options when selecting data from "vehicles". */
export type Vehicles_Order_By = {
  atv_type?: InputMaybe<Order_By>;
  barrels_per_year?: InputMaybe<Order_By>;
  barrels_per_year_alt?: InputMaybe<Order_By>;
  charge_time_120_volts?: InputMaybe<Order_By>;
  charge_time_240_volts?: InputMaybe<Order_By>;
  charge_time_240_volts_alt?: InputMaybe<Order_By>;
  charger_description?: InputMaybe<Order_By>;
  charger_description_alt?: InputMaybe<Order_By>;
  city_hybrid_utility_factor?: InputMaybe<Order_By>;
  city_mpg?: InputMaybe<Order_By>;
  city_mpg_alt?: InputMaybe<Order_By>;
  city_mpg_charge_depleted?: InputMaybe<Order_By>;
  city_mpg_electric?: InputMaybe<Order_By>;
  city_mpg_hydrogen?: InputMaybe<Order_By>;
  combined_hybrid_utility_factor?: InputMaybe<Order_By>;
  combined_mpg?: InputMaybe<Order_By>;
  combined_mpg_alt?: InputMaybe<Order_By>;
  combined_mpg_electric?: InputMaybe<Order_By>;
  combined_mpg_hydrogen?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  created_by?: InputMaybe<Order_By>;
  cylinders?: InputMaybe<Order_By>;
  doe_created_on?: InputMaybe<Order_By>;
  doe_modified_on?: InputMaybe<Order_By>;
  drive_axle_type?: InputMaybe<Order_By>;
  electric_motor?: InputMaybe<Order_By>;
  engine_descriptor?: InputMaybe<Order_By>;
  engine_displacement_liters?: InputMaybe<Order_By>;
  engine_id?: InputMaybe<Order_By>;
  fuel_cost_annual?: InputMaybe<Order_By>;
  fuel_cost_annual_alt?: InputMaybe<Order_By>;
  fuel_economy_score?: InputMaybe<Order_By>;
  fuel_type?: InputMaybe<Order_By>;
  fuel_type_one?: InputMaybe<Order_By>;
  fuel_type_two?: InputMaybe<Order_By>;
  ghg_score?: InputMaybe<Order_By>;
  ghg_score_alt?: InputMaybe<Order_By>;
  highway_hybrid_utility_factor?: InputMaybe<Order_By>;
  highway_mpg?: InputMaybe<Order_By>;
  highway_mpg_alt?: InputMaybe<Order_By>;
  highway_mpg_charge_depleted?: InputMaybe<Order_By>;
  highway_mpg_electric?: InputMaybe<Order_By>;
  highway_mpg_hydrogen?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  make?: InputMaybe<Order_By>;
  manufacturer_code?: InputMaybe<Order_By>;
  model?: InputMaybe<Order_By>;
  model_base?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  phev_blended?: InputMaybe<Order_By>;
  range?: InputMaybe<Order_By>;
  range_alt?: InputMaybe<Order_By>;
  range_alt_city?: InputMaybe<Order_By>;
  range_alt_highway?: InputMaybe<Order_By>;
  range_city?: InputMaybe<Order_By>;
  range_highway?: InputMaybe<Order_By>;
  start_stop_tech?: InputMaybe<Order_By>;
  supercharged?: InputMaybe<Order_By>;
  transmission?: InputMaybe<Order_By>;
  transmission_descriptor?: InputMaybe<Order_By>;
  turbocharged?: InputMaybe<Order_By>;
  unadjusted_city_mpg?: InputMaybe<Order_By>;
  unadjusted_city_mpg_alt?: InputMaybe<Order_By>;
  unadjusted_highway_mpg?: InputMaybe<Order_By>;
  unadjusted_highway_mpg_alt?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  updated_by?: InputMaybe<Order_By>;
  vehicle_class_size?: InputMaybe<Order_By>;
  year?: InputMaybe<Order_By>;
};

/** primary key columns input for table: vehicles */
export type Vehicles_Pk_Columns_Input = {
  /** vehicle id from DOE dataset */
  id: Scalars['bigint']['input'];
};

/** select columns of table "vehicles" */
export enum Vehicles_Select_Column {
  /** column name */
  AtvType = 'atv_type',
  /** column name */
  BarrelsPerYear = 'barrels_per_year',
  /** column name */
  BarrelsPerYearAlt = 'barrels_per_year_alt',
  /** column name */
  ChargeTime_120Volts = 'charge_time_120_volts',
  /** column name */
  ChargeTime_240Volts = 'charge_time_240_volts',
  /** column name */
  ChargeTime_240VoltsAlt = 'charge_time_240_volts_alt',
  /** column name */
  ChargerDescription = 'charger_description',
  /** column name */
  ChargerDescriptionAlt = 'charger_description_alt',
  /** column name */
  CityHybridUtilityFactor = 'city_hybrid_utility_factor',
  /** column name */
  CityMpg = 'city_mpg',
  /** column name */
  CityMpgAlt = 'city_mpg_alt',
  /** column name */
  CityMpgChargeDepleted = 'city_mpg_charge_depleted',
  /** column name */
  CityMpgElectric = 'city_mpg_electric',
  /** column name */
  CityMpgHydrogen = 'city_mpg_hydrogen',
  /** column name */
  CombinedHybridUtilityFactor = 'combined_hybrid_utility_factor',
  /** column name */
  CombinedMpg = 'combined_mpg',
  /** column name */
  CombinedMpgAlt = 'combined_mpg_alt',
  /** column name */
  CombinedMpgElectric = 'combined_mpg_electric',
  /** column name */
  CombinedMpgHydrogen = 'combined_mpg_hydrogen',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Cylinders = 'cylinders',
  /** column name */
  DoeCreatedOn = 'doe_created_on',
  /** column name */
  DoeModifiedOn = 'doe_modified_on',
  /** column name */
  DriveAxleType = 'drive_axle_type',
  /** column name */
  ElectricMotor = 'electric_motor',
  /** column name */
  EngineDescriptor = 'engine_descriptor',
  /** column name */
  EngineDisplacementLiters = 'engine_displacement_liters',
  /** column name */
  EngineId = 'engine_id',
  /** column name */
  FuelCostAnnual = 'fuel_cost_annual',
  /** column name */
  FuelCostAnnualAlt = 'fuel_cost_annual_alt',
  /** column name */
  FuelEconomyScore = 'fuel_economy_score',
  /** column name */
  FuelType = 'fuel_type',
  /** column name */
  FuelTypeOne = 'fuel_type_one',
  /** column name */
  FuelTypeTwo = 'fuel_type_two',
  /** column name */
  GhgScore = 'ghg_score',
  /** column name */
  GhgScoreAlt = 'ghg_score_alt',
  /** column name */
  HighwayHybridUtilityFactor = 'highway_hybrid_utility_factor',
  /** column name */
  HighwayMpg = 'highway_mpg',
  /** column name */
  HighwayMpgAlt = 'highway_mpg_alt',
  /** column name */
  HighwayMpgChargeDepleted = 'highway_mpg_charge_depleted',
  /** column name */
  HighwayMpgElectric = 'highway_mpg_electric',
  /** column name */
  HighwayMpgHydrogen = 'highway_mpg_hydrogen',
  /** column name */
  Id = 'id',
  /** column name */
  Make = 'make',
  /** column name */
  ManufacturerCode = 'manufacturer_code',
  /** column name */
  Model = 'model',
  /** column name */
  ModelBase = 'model_base',
  /** column name */
  PhevBlended = 'phev_blended',
  /** column name */
  Range = 'range',
  /** column name */
  RangeAlt = 'range_alt',
  /** column name */
  RangeAltCity = 'range_alt_city',
  /** column name */
  RangeAltHighway = 'range_alt_highway',
  /** column name */
  RangeCity = 'range_city',
  /** column name */
  RangeHighway = 'range_highway',
  /** column name */
  StartStopTech = 'start_stop_tech',
  /** column name */
  Supercharged = 'supercharged',
  /** column name */
  Transmission = 'transmission',
  /** column name */
  TransmissionDescriptor = 'transmission_descriptor',
  /** column name */
  Turbocharged = 'turbocharged',
  /** column name */
  UnadjustedCityMpg = 'unadjusted_city_mpg',
  /** column name */
  UnadjustedCityMpgAlt = 'unadjusted_city_mpg_alt',
  /** column name */
  UnadjustedHighwayMpg = 'unadjusted_highway_mpg',
  /** column name */
  UnadjustedHighwayMpgAlt = 'unadjusted_highway_mpg_alt',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  VehicleClassSize = 'vehicle_class_size',
  /** column name */
  Year = 'year'
}

/** input type for updating data in table "vehicles" */
export type Vehicles_Set_Input = {
  /** type of alternative fuel or advanced technology vehicle e.g. Diesel, Hybrid, EV */
  atv_type?: InputMaybe<Scalars['String']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: InputMaybe<Scalars['numeric']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** electric vehicle charger description */
  charger_description?: InputMaybe<Scalars['String']['input']>;
  /** electric vehicle alternate charger description */
  charger_description_alt?: InputMaybe<Scalars['String']['input']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_one */
  city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** engine cylinders */
  cylinders?: InputMaybe<Scalars['Int']['input']>;
  /** Date the DOE record was created */
  doe_created_on?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date DOE record was modified */
  doe_modified_on?: InputMaybe<Scalars['timestamptz']['input']>;
  drive_axle_type?: InputMaybe<Scalars['String']['input']>;
  electric_motor?: InputMaybe<Scalars['String']['input']>;
  /** Engine descriptor code e.g. DI for Direct Injeection, HEV for Hybrid Electric Vehicle, etc. See http://www.fueleconomy.gov/feg/findacarhelp.shtml#engine for all descriptors */
  engine_descriptor?: InputMaybe<Scalars['String']['input']>;
  engine_displacement_liters?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA model type index */
  engine_id?: InputMaybe<Scalars['String']['input']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: InputMaybe<Scalars['numeric']['input']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: InputMaybe<Scalars['Int']['input']>;
  /** Fuel type with fuel_type_one and fuel_type_two (if applicable) */
  fuel_type?: InputMaybe<Scalars['String']['input']>;
  /** fuel type 1. For single fuel vehicles, this will be the only fuel. For dual fuel vehicles, this will be the conventional fuel. */
  fuel_type_one?: InputMaybe<Scalars['String']['input']>;
  /** fuel type 2. For dual fuel vehicles, this will be the alternative fuel (e.g. E85, Electricity, CNG, LPG). For single fuel vehicles, this field is not used */
  fuel_type_two?: InputMaybe<Scalars['String']['input']>;
  /** EPA GHG score */
  ghg_score?: InputMaybe<Scalars['Int']['input']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: InputMaybe<Scalars['Int']['input']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle id from DOE dataset */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** manufacturer (division) */
  make?: InputMaybe<Scalars['String']['input']>;
  /** 3-character manufacturer code */
  manufacturer_code?: InputMaybe<Scalars['String']['input']>;
  /** model name (carline) */
  model?: InputMaybe<Scalars['String']['input']>;
  /** base model name e.g. for model F150 Pickup 2WD, the base model is F150 */
  model_base?: InputMaybe<Scalars['String']['input']>;
  /** if true, this vehicle operates on a blend of gasoline and electricity in charge depleting mode */
  phev_blended?: InputMaybe<Scalars['Boolean']['input']>;
  /** EPA range for fuel_type_one */
  range?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_one */
  range_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle has stop-start technology */
  start_stop_tech?: InputMaybe<Scalars['Boolean']['input']>;
  supercharged?: InputMaybe<Scalars['Boolean']['input']>;
  transmission?: InputMaybe<Scalars['String']['input']>;
  /** transmission descriptor; see http://www.fueleconomy.gov/feg/findacarhelp.shtml#trany */
  transmission_descriptor?: InputMaybe<Scalars['String']['input']>;
  turbocharged?: InputMaybe<Scalars['Boolean']['input']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  /** EPA vehicle size class e.g. Two-Seaters, Compact Cars, Minivans, Small Pickup Trucks, etc */
  vehicle_class_size?: InputMaybe<Scalars['String']['input']>;
  /** model year */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Vehicles_Stddev_Fields = {
  __typename?: 'vehicles_stddev_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Vehicles_Stddev_Pop_Fields = {
  __typename?: 'vehicles_stddev_pop_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Vehicles_Stddev_Samp_Fields = {
  __typename?: 'vehicles_stddev_samp_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "vehicles" */
export type Vehicles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vehicles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vehicles_Stream_Cursor_Value_Input = {
  /** type of alternative fuel or advanced technology vehicle e.g. Diesel, Hybrid, EV */
  atv_type?: InputMaybe<Scalars['String']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: InputMaybe<Scalars['numeric']['input']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: InputMaybe<Scalars['numeric']['input']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** electric vehicle charger description */
  charger_description?: InputMaybe<Scalars['String']['input']>;
  /** electric vehicle alternate charger description */
  charger_description_alt?: InputMaybe<Scalars['String']['input']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_one */
  city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  created_by?: InputMaybe<Scalars['String']['input']>;
  /** engine cylinders */
  cylinders?: InputMaybe<Scalars['Int']['input']>;
  /** Date the DOE record was created */
  doe_created_on?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date DOE record was modified */
  doe_modified_on?: InputMaybe<Scalars['timestamptz']['input']>;
  drive_axle_type?: InputMaybe<Scalars['String']['input']>;
  electric_motor?: InputMaybe<Scalars['String']['input']>;
  /** Engine descriptor code e.g. DI for Direct Injeection, HEV for Hybrid Electric Vehicle, etc. See http://www.fueleconomy.gov/feg/findacarhelp.shtml#engine for all descriptors */
  engine_descriptor?: InputMaybe<Scalars['String']['input']>;
  engine_displacement_liters?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA model type index */
  engine_id?: InputMaybe<Scalars['String']['input']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: InputMaybe<Scalars['numeric']['input']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: InputMaybe<Scalars['Int']['input']>;
  /** Fuel type with fuel_type_one and fuel_type_two (if applicable) */
  fuel_type?: InputMaybe<Scalars['String']['input']>;
  /** fuel type 1. For single fuel vehicles, this will be the only fuel. For dual fuel vehicles, this will be the conventional fuel. */
  fuel_type_one?: InputMaybe<Scalars['String']['input']>;
  /** fuel type 2. For dual fuel vehicles, this will be the alternative fuel (e.g. E85, Electricity, CNG, LPG). For single fuel vehicles, this field is not used */
  fuel_type_two?: InputMaybe<Scalars['String']['input']>;
  /** EPA GHG score */
  ghg_score?: InputMaybe<Scalars['Int']['input']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: InputMaybe<Scalars['Int']['input']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: InputMaybe<Scalars['numeric']['input']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: InputMaybe<Scalars['numeric']['input']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle id from DOE dataset */
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** manufacturer (division) */
  make?: InputMaybe<Scalars['String']['input']>;
  /** 3-character manufacturer code */
  manufacturer_code?: InputMaybe<Scalars['String']['input']>;
  /** model name (carline) */
  model?: InputMaybe<Scalars['String']['input']>;
  /** base model name e.g. for model F150 Pickup 2WD, the base model is F150 */
  model_base?: InputMaybe<Scalars['String']['input']>;
  /** if true, this vehicle operates on a blend of gasoline and electricity in charge depleting mode */
  phev_blended?: InputMaybe<Scalars['Boolean']['input']>;
  /** EPA range for fuel_type_one */
  range?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA city range for fuel_type_one */
  range_city?: InputMaybe<Scalars['numeric']['input']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: InputMaybe<Scalars['numeric']['input']>;
  /** vehicle has stop-start technology */
  start_stop_tech?: InputMaybe<Scalars['Boolean']['input']>;
  supercharged?: InputMaybe<Scalars['Boolean']['input']>;
  transmission?: InputMaybe<Scalars['String']['input']>;
  /** transmission descriptor; see http://www.fueleconomy.gov/feg/findacarhelp.shtml#trany */
  transmission_descriptor?: InputMaybe<Scalars['String']['input']>;
  turbocharged?: InputMaybe<Scalars['Boolean']['input']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: InputMaybe<Scalars['numeric']['input']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: InputMaybe<Scalars['numeric']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  updated_by?: InputMaybe<Scalars['String']['input']>;
  /** EPA vehicle size class e.g. Two-Seaters, Compact Cars, Minivans, Small Pickup Trucks, etc */
  vehicle_class_size?: InputMaybe<Scalars['String']['input']>;
  /** model year */
  year?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Vehicles_Sum_Fields = {
  __typename?: 'vehicles_sum_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['numeric']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['numeric']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['numeric']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['numeric']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Int']['output']>;
  engine_displacement_liters?: Maybe<Scalars['numeric']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['numeric']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Int']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Int']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Int']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['numeric']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['numeric']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['numeric']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['numeric']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['bigint']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['numeric']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['numeric']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['numeric']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['numeric']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['numeric']['output']>;
  /** model year */
  year?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "vehicles" */
export enum Vehicles_Update_Column {
  /** column name */
  AtvType = 'atv_type',
  /** column name */
  BarrelsPerYear = 'barrels_per_year',
  /** column name */
  BarrelsPerYearAlt = 'barrels_per_year_alt',
  /** column name */
  ChargeTime_120Volts = 'charge_time_120_volts',
  /** column name */
  ChargeTime_240Volts = 'charge_time_240_volts',
  /** column name */
  ChargeTime_240VoltsAlt = 'charge_time_240_volts_alt',
  /** column name */
  ChargerDescription = 'charger_description',
  /** column name */
  ChargerDescriptionAlt = 'charger_description_alt',
  /** column name */
  CityHybridUtilityFactor = 'city_hybrid_utility_factor',
  /** column name */
  CityMpg = 'city_mpg',
  /** column name */
  CityMpgAlt = 'city_mpg_alt',
  /** column name */
  CityMpgChargeDepleted = 'city_mpg_charge_depleted',
  /** column name */
  CityMpgElectric = 'city_mpg_electric',
  /** column name */
  CityMpgHydrogen = 'city_mpg_hydrogen',
  /** column name */
  CombinedHybridUtilityFactor = 'combined_hybrid_utility_factor',
  /** column name */
  CombinedMpg = 'combined_mpg',
  /** column name */
  CombinedMpgAlt = 'combined_mpg_alt',
  /** column name */
  CombinedMpgElectric = 'combined_mpg_electric',
  /** column name */
  CombinedMpgHydrogen = 'combined_mpg_hydrogen',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Cylinders = 'cylinders',
  /** column name */
  DoeCreatedOn = 'doe_created_on',
  /** column name */
  DoeModifiedOn = 'doe_modified_on',
  /** column name */
  DriveAxleType = 'drive_axle_type',
  /** column name */
  ElectricMotor = 'electric_motor',
  /** column name */
  EngineDescriptor = 'engine_descriptor',
  /** column name */
  EngineDisplacementLiters = 'engine_displacement_liters',
  /** column name */
  EngineId = 'engine_id',
  /** column name */
  FuelCostAnnual = 'fuel_cost_annual',
  /** column name */
  FuelCostAnnualAlt = 'fuel_cost_annual_alt',
  /** column name */
  FuelEconomyScore = 'fuel_economy_score',
  /** column name */
  FuelType = 'fuel_type',
  /** column name */
  FuelTypeOne = 'fuel_type_one',
  /** column name */
  FuelTypeTwo = 'fuel_type_two',
  /** column name */
  GhgScore = 'ghg_score',
  /** column name */
  GhgScoreAlt = 'ghg_score_alt',
  /** column name */
  HighwayHybridUtilityFactor = 'highway_hybrid_utility_factor',
  /** column name */
  HighwayMpg = 'highway_mpg',
  /** column name */
  HighwayMpgAlt = 'highway_mpg_alt',
  /** column name */
  HighwayMpgChargeDepleted = 'highway_mpg_charge_depleted',
  /** column name */
  HighwayMpgElectric = 'highway_mpg_electric',
  /** column name */
  HighwayMpgHydrogen = 'highway_mpg_hydrogen',
  /** column name */
  Id = 'id',
  /** column name */
  Make = 'make',
  /** column name */
  ManufacturerCode = 'manufacturer_code',
  /** column name */
  Model = 'model',
  /** column name */
  ModelBase = 'model_base',
  /** column name */
  PhevBlended = 'phev_blended',
  /** column name */
  Range = 'range',
  /** column name */
  RangeAlt = 'range_alt',
  /** column name */
  RangeAltCity = 'range_alt_city',
  /** column name */
  RangeAltHighway = 'range_alt_highway',
  /** column name */
  RangeCity = 'range_city',
  /** column name */
  RangeHighway = 'range_highway',
  /** column name */
  StartStopTech = 'start_stop_tech',
  /** column name */
  Supercharged = 'supercharged',
  /** column name */
  Transmission = 'transmission',
  /** column name */
  TransmissionDescriptor = 'transmission_descriptor',
  /** column name */
  Turbocharged = 'turbocharged',
  /** column name */
  UnadjustedCityMpg = 'unadjusted_city_mpg',
  /** column name */
  UnadjustedCityMpgAlt = 'unadjusted_city_mpg_alt',
  /** column name */
  UnadjustedHighwayMpg = 'unadjusted_highway_mpg',
  /** column name */
  UnadjustedHighwayMpgAlt = 'unadjusted_highway_mpg_alt',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
  /** column name */
  VehicleClassSize = 'vehicle_class_size',
  /** column name */
  Year = 'year'
}

export type Vehicles_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Vehicles_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Vehicles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vehicles_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Vehicles_Var_Pop_Fields = {
  __typename?: 'vehicles_var_pop_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Vehicles_Var_Samp_Fields = {
  __typename?: 'vehicles_var_samp_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Vehicles_Variance_Fields = {
  __typename?: 'vehicles_variance_fields';
  /** annual petroleum consumption in barrels for fuel_type_one (electric and other alt fuels are converted) */
  barrels_per_year?: Maybe<Scalars['Float']['output']>;
  /** annual petroleum consumption in barrels for fuel_type_two (electric and other alt fuels are converted) */
  barrels_per_year_alt?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 120 V */
  charge_time_120_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V */
  charge_time_240_volts?: Maybe<Scalars['Float']['output']>;
  /** time to charge an electric vehicle in hours at 240 V with alternate charger */
  charge_time_240_volts_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  city_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_one */
  city_mpg?: Maybe<Scalars['Float']['output']>;
  /** city mpg for fuel_type_two */
  city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** city gasoline consumption (gallons/100 miles) in charge depleting mode (Hybrid-only field) */
  city_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** city electricity consumption in kw-hrs/100 miles */
  city_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** city miles per Kilogram for Hydrogen */
  city_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** EPA combined utility factor (share of electricity) for PHEV (Hybrid vehicles) */
  combined_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_one */
  combined_mpg?: Maybe<Scalars['Float']['output']>;
  /** combined mpg for fuel_type_two */
  combined_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** combined electricity consumption in kw-hrs/100 miles */
  combined_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** combined miles per Kilogram for Hydrogen */
  combined_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** engine cylinders */
  cylinders?: Maybe<Scalars['Float']['output']>;
  engine_displacement_liters?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_one */
  fuel_cost_annual?: Maybe<Scalars['Float']['output']>;
  /** Annual estimated fuel cost for fuel_type_two */
  fuel_cost_annual_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA Fuel Economy Score */
  fuel_economy_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score */
  ghg_score?: Maybe<Scalars['Float']['output']>;
  /** EPA GHG score for dual fuel vehicle running on the alternative fuel */
  ghg_score_alt?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen (Hybrid only field) */
  highway_hybrid_utility_factor?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_one */
  highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** highway mpg for fuel_type_two */
  highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** highway gasoline consumption (gallons/100miles) in charge depleting mode (Hybrid only) */
  highway_mpg_charge_depleted?: Maybe<Scalars['Float']['output']>;
  /** highway electricity consumption in kw-hrs/100 miles */
  highway_mpg_electric?: Maybe<Scalars['Float']['output']>;
  /** highway miles per Kilogram for Hydrogen */
  highway_mpg_hydrogen?: Maybe<Scalars['Float']['output']>;
  /** vehicle id from DOE dataset */
  id?: Maybe<Scalars['Float']['output']>;
  /** EPA range for fuel_type_one */
  range?: Maybe<Scalars['Float']['output']>;
  /** EPA combined range for fuel_type_two */
  range_alt?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_two */
  range_alt_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_two */
  range_alt_highway?: Maybe<Scalars['Float']['output']>;
  /** EPA city range for fuel_type_one */
  range_city?: Maybe<Scalars['Float']['output']>;
  /** EPA highway range for fuel_type_one */
  range_highway?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted city MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_city_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_one; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg?: Maybe<Scalars['Float']['output']>;
  /** unadjusted highway MPG for fuel_type_two; see the description of the see https://www.fueleconomy.gov/feg/fe_test_schedules.shtml for EPA test description */
  unadjusted_highway_mpg_alt?: Maybe<Scalars['Float']['output']>;
  /** model year */
  year?: Maybe<Scalars['Float']['output']>;
};

/** Instances of events that are triggered by the database and then sent ultimately to the URL in the row. */
export type Webhook_Events = {
  __typename?: 'webhook_events';
  createdat: Scalars['timestamptz']['output'];
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time: Scalars['timestamptz']['output'];
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['smallint']['output']>;
  id: Scalars['uuid']['output'];
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: Maybe<Scalars['timestamptz']['output']>;
  request: Scalars['jsonb']['output'];
  response?: Maybe<Scalars['String']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count: Scalars['smallint']['output'];
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: Maybe<Scalars['String']['output']>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status: Scalars['String']['output'];
  /** An object relationship */
  subscription: Subscriptions;
  subscription_id: Scalars['bigint']['output'];
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type: Scalars['String']['output'];
  url: Scalars['String']['output'];
};


/** Instances of events that are triggered by the database and then sent ultimately to the URL in the row. */
export type Webhook_EventsRequestArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "webhook_events" */
export type Webhook_Events_Aggregate = {
  __typename?: 'webhook_events_aggregate';
  aggregate?: Maybe<Webhook_Events_Aggregate_Fields>;
  nodes: Array<Webhook_Events>;
};

export type Webhook_Events_Aggregate_Bool_Exp = {
  count?: InputMaybe<Webhook_Events_Aggregate_Bool_Exp_Count>;
};

export type Webhook_Events_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Webhook_Events_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "webhook_events" */
export type Webhook_Events_Aggregate_Fields = {
  __typename?: 'webhook_events_aggregate_fields';
  avg?: Maybe<Webhook_Events_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Webhook_Events_Max_Fields>;
  min?: Maybe<Webhook_Events_Min_Fields>;
  stddev?: Maybe<Webhook_Events_Stddev_Fields>;
  stddev_pop?: Maybe<Webhook_Events_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Webhook_Events_Stddev_Samp_Fields>;
  sum?: Maybe<Webhook_Events_Sum_Fields>;
  var_pop?: Maybe<Webhook_Events_Var_Pop_Fields>;
  var_samp?: Maybe<Webhook_Events_Var_Samp_Fields>;
  variance?: Maybe<Webhook_Events_Variance_Fields>;
};


/** aggregate fields of "webhook_events" */
export type Webhook_Events_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Webhook_Events_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "webhook_events" */
export type Webhook_Events_Aggregate_Order_By = {
  avg?: InputMaybe<Webhook_Events_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Webhook_Events_Max_Order_By>;
  min?: InputMaybe<Webhook_Events_Min_Order_By>;
  stddev?: InputMaybe<Webhook_Events_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Webhook_Events_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Webhook_Events_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Webhook_Events_Sum_Order_By>;
  var_pop?: InputMaybe<Webhook_Events_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Webhook_Events_Var_Samp_Order_By>;
  variance?: InputMaybe<Webhook_Events_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Webhook_Events_Append_Input = {
  request?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "webhook_events" */
export type Webhook_Events_Arr_Rel_Insert_Input = {
  data: Array<Webhook_Events_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Webhook_Events_On_Conflict>;
};

/** aggregate avg on columns */
export type Webhook_Events_Avg_Fields = {
  __typename?: 'webhook_events_avg_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "webhook_events" */
export type Webhook_Events_Avg_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "webhook_events". All fields are combined with a logical 'AND'. */
export type Webhook_Events_Bool_Exp = {
  _and?: InputMaybe<Array<Webhook_Events_Bool_Exp>>;
  _not?: InputMaybe<Webhook_Events_Bool_Exp>;
  _or?: InputMaybe<Array<Webhook_Events_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  event_time?: InputMaybe<Timestamptz_Comparison_Exp>;
  http_status?: InputMaybe<Smallint_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  next_retry?: InputMaybe<Timestamptz_Comparison_Exp>;
  request?: InputMaybe<Jsonb_Comparison_Exp>;
  response?: InputMaybe<String_Comparison_Exp>;
  retry_count?: InputMaybe<Smallint_Comparison_Exp>;
  signature?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  subscription?: InputMaybe<Subscriptions_Bool_Exp>;
  subscription_id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  url?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "webhook_events" */
export enum Webhook_Events_Constraint {
  /** unique or primary key constraint on columns "id" */
  WebhookEventsPkey = 'webhook_events_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Webhook_Events_Delete_At_Path_Input = {
  request?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Webhook_Events_Delete_Elem_Input = {
  request?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Webhook_Events_Delete_Key_Input = {
  request?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "webhook_events" */
export type Webhook_Events_Inc_Input = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Scalars['smallint']['input']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Scalars['smallint']['input']>;
  subscription_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "webhook_events" */
export type Webhook_Events_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: InputMaybe<Scalars['timestamptz']['input']>;
  request?: InputMaybe<Scalars['jsonb']['input']>;
  response?: InputMaybe<Scalars['String']['input']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Scalars['smallint']['input']>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: InputMaybe<Scalars['String']['input']>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: InputMaybe<Scalars['String']['input']>;
  subscription?: InputMaybe<Subscriptions_Obj_Rel_Insert_Input>;
  subscription_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Webhook_Events_Max_Fields = {
  __typename?: 'webhook_events_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: Maybe<Scalars['timestamptz']['output']>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: Maybe<Scalars['timestamptz']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['smallint']['output']>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: Maybe<Scalars['String']['output']>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: Maybe<Scalars['String']['output']>;
  subscription_id?: Maybe<Scalars['bigint']['output']>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "webhook_events" */
export type Webhook_Events_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: InputMaybe<Order_By>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: InputMaybe<Order_By>;
  response?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: InputMaybe<Order_By>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Webhook_Events_Min_Fields = {
  __typename?: 'webhook_events_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: Maybe<Scalars['timestamptz']['output']>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['smallint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: Maybe<Scalars['timestamptz']['output']>;
  response?: Maybe<Scalars['String']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['smallint']['output']>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: Maybe<Scalars['String']['output']>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: Maybe<Scalars['String']['output']>;
  subscription_id?: Maybe<Scalars['bigint']['output']>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "webhook_events" */
export type Webhook_Events_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: InputMaybe<Order_By>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: InputMaybe<Order_By>;
  response?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: InputMaybe<Order_By>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "webhook_events" */
export type Webhook_Events_Mutation_Response = {
  __typename?: 'webhook_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Webhook_Events>;
};

/** on_conflict condition type for table "webhook_events" */
export type Webhook_Events_On_Conflict = {
  constraint: Webhook_Events_Constraint;
  update_columns?: Array<Webhook_Events_Update_Column>;
  where?: InputMaybe<Webhook_Events_Bool_Exp>;
};

/** Ordering options when selecting data from "webhook_events". */
export type Webhook_Events_Order_By = {
  createdat?: InputMaybe<Order_By>;
  event_time?: InputMaybe<Order_By>;
  http_status?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_retry?: InputMaybe<Order_By>;
  request?: InputMaybe<Order_By>;
  response?: InputMaybe<Order_By>;
  retry_count?: InputMaybe<Order_By>;
  signature?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  subscription?: InputMaybe<Subscriptions_Order_By>;
  subscription_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  url?: InputMaybe<Order_By>;
};

/** primary key columns input for table: webhook_events */
export type Webhook_Events_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Webhook_Events_Prepend_Input = {
  request?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "webhook_events" */
export enum Webhook_Events_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  EventTime = 'event_time',
  /** column name */
  HttpStatus = 'http_status',
  /** column name */
  Id = 'id',
  /** column name */
  NextRetry = 'next_retry',
  /** column name */
  Request = 'request',
  /** column name */
  Response = 'response',
  /** column name */
  RetryCount = 'retry_count',
  /** column name */
  Signature = 'signature',
  /** column name */
  Status = 'status',
  /** column name */
  SubscriptionId = 'subscription_id',
  /** column name */
  Type = 'type',
  /** column name */
  Url = 'url'
}

/** input type for updating data in table "webhook_events" */
export type Webhook_Events_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: InputMaybe<Scalars['timestamptz']['input']>;
  request?: InputMaybe<Scalars['jsonb']['input']>;
  response?: InputMaybe<Scalars['String']['input']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Scalars['smallint']['input']>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: InputMaybe<Scalars['String']['input']>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: InputMaybe<Scalars['String']['input']>;
  subscription_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Webhook_Events_Stddev_Fields = {
  __typename?: 'webhook_events_stddev_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "webhook_events" */
export type Webhook_Events_Stddev_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Webhook_Events_Stddev_Pop_Fields = {
  __typename?: 'webhook_events_stddev_pop_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "webhook_events" */
export type Webhook_Events_Stddev_Pop_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Webhook_Events_Stddev_Samp_Fields = {
  __typename?: 'webhook_events_stddev_samp_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "webhook_events" */
export type Webhook_Events_Stddev_Samp_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "webhook_events" */
export type Webhook_Events_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Webhook_Events_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Webhook_Events_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time that the event occurred in reality (not when a webhook record was inserted, but when the event that webhook represents actually happened). */
  event_time?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Scalars['smallint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** If a send fails, the retry_count is incremented, and this column is set to the expected next retry time based on the event's retry configuration. */
  next_retry?: InputMaybe<Scalars['timestamptz']['input']>;
  request?: InputMaybe<Scalars['jsonb']['input']>;
  response?: InputMaybe<Scalars['String']['input']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Scalars['smallint']['input']>;
  /** Calculated signature using webhook event_time, subscription secret, and the request JSONB object, stringified without formatting. */
  signature?: InputMaybe<Scalars['String']['input']>;
  /** Status of the webhook event. Possible values: pending (awaiting to be sent) | sent | retrying | failed (if all retries are exhausted, then on the last failed attempt, this will be set and then no more attempts to send the webhook will be made) */
  status?: InputMaybe<Scalars['String']['input']>;
  subscription_id?: InputMaybe<Scalars['bigint']['input']>;
  /** The type of event from the list of subscribable webhook events. An example would be "move.pickup_successful" */
  type?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Webhook_Events_Sum_Fields = {
  __typename?: 'webhook_events_sum_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['smallint']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['smallint']['output']>;
  subscription_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "webhook_events" */
export type Webhook_Events_Sum_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** update columns of table "webhook_events" */
export enum Webhook_Events_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  EventTime = 'event_time',
  /** column name */
  HttpStatus = 'http_status',
  /** column name */
  Id = 'id',
  /** column name */
  NextRetry = 'next_retry',
  /** column name */
  Request = 'request',
  /** column name */
  Response = 'response',
  /** column name */
  RetryCount = 'retry_count',
  /** column name */
  Signature = 'signature',
  /** column name */
  Status = 'status',
  /** column name */
  SubscriptionId = 'subscription_id',
  /** column name */
  Type = 'type',
  /** column name */
  Url = 'url'
}

export type Webhook_Events_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Webhook_Events_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Webhook_Events_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Webhook_Events_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Webhook_Events_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Webhook_Events_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Webhook_Events_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Webhook_Events_Set_Input>;
  /** filter the rows which have to be updated */
  where: Webhook_Events_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Webhook_Events_Var_Pop_Fields = {
  __typename?: 'webhook_events_var_pop_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "webhook_events" */
export type Webhook_Events_Var_Pop_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Webhook_Events_Var_Samp_Fields = {
  __typename?: 'webhook_events_var_samp_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "webhook_events" */
export type Webhook_Events_Var_Samp_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Webhook_Events_Variance_Fields = {
  __typename?: 'webhook_events_variance_fields';
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: Maybe<Scalars['Float']['output']>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: Maybe<Scalars['Float']['output']>;
  subscription_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "webhook_events" */
export type Webhook_Events_Variance_Order_By = {
  /** The HTTP response code returned by the URL when the webhook request (payload) was POSTed to it. */
  http_status?: InputMaybe<Order_By>;
  /** Defaults to 0 and will only ever be higher if there was at least one failure. Set to one after the first failure when awaiting retry. */
  retry_count?: InputMaybe<Order_By>;
  subscription_id?: InputMaybe<Order_By>;
};

/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type Workflows = {
  __typename?: 'workflows';
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  label?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  scenariotypes: Array<Scenariotypes>;
  /** An aggregate relationship */
  scenariotypes_aggregate: Scenariotypes_Aggregate;
  steps: Scalars['jsonb']['output'];
  type: Scalars['String']['output'];
  /** An array relationship */
  vehiclephotos: Array<Vehiclephotos>;
  /** An aggregate relationship */
  vehiclephotos_aggregate: Vehiclephotos_Aggregate;
  version: Scalars['String']['output'];
  /** An array relationship */
  workflowsets: Array<Workflowsets>;
  /** An array relationship */
  workflowsetsByFuelWorkflowId: Array<Workflowsets>;
  /** An aggregate relationship */
  workflowsetsByFuelWorkflowId_aggregate: Workflowsets_Aggregate;
  /** An array relationship */
  workflowsetsByPickupWorkflowId: Array<Workflowsets>;
  /** An aggregate relationship */
  workflowsetsByPickupWorkflowId_aggregate: Workflowsets_Aggregate;
  /** An aggregate relationship */
  workflowsets_aggregate: Workflowsets_Aggregate;
  /** An array relationship */
  workflowsettypes: Array<Workflowsettypes>;
  /** An array relationship */
  workflowsettypesByFuelWorkflowId: Array<Workflowsettypes>;
  /** An aggregate relationship */
  workflowsettypesByFuelWorkflowId_aggregate: Workflowsettypes_Aggregate;
  /** An array relationship */
  workflowsettypesByPickupWorkflowId: Array<Workflowsettypes>;
  /** An aggregate relationship */
  workflowsettypesByPickupWorkflowId_aggregate: Workflowsettypes_Aggregate;
  /** An aggregate relationship */
  workflowsettypes_aggregate: Workflowsettypes_Aggregate;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsScenariotypesArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypes_Order_By>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsScenariotypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Scenariotypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Scenariotypes_Order_By>>;
  where?: InputMaybe<Scenariotypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsStepsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsVehiclephotosArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsVehiclephotos_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Vehiclephotos_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Vehiclephotos_Order_By>>;
  where?: InputMaybe<Vehiclephotos_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsetsArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsetsByFuelWorkflowIdArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsetsByFuelWorkflowId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsetsByPickupWorkflowIdArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsetsByPickupWorkflowId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsets_Order_By>>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsettypesArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsettypesByFuelWorkflowIdArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsettypesByFuelWorkflowId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsettypesByPickupWorkflowIdArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsettypesByPickupWorkflowId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};


/** Custom driver app workflows to control steps the driver should perform at pickup and delivery of a move. */
export type WorkflowsWorkflowsettypes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Workflowsettypes_Order_By>>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};

/** aggregated selection of "workflows" */
export type Workflows_Aggregate = {
  __typename?: 'workflows_aggregate';
  aggregate?: Maybe<Workflows_Aggregate_Fields>;
  nodes: Array<Workflows>;
};

/** aggregate fields of "workflows" */
export type Workflows_Aggregate_Fields = {
  __typename?: 'workflows_aggregate_fields';
  avg?: Maybe<Workflows_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Workflows_Max_Fields>;
  min?: Maybe<Workflows_Min_Fields>;
  stddev?: Maybe<Workflows_Stddev_Fields>;
  stddev_pop?: Maybe<Workflows_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Workflows_Stddev_Samp_Fields>;
  sum?: Maybe<Workflows_Sum_Fields>;
  var_pop?: Maybe<Workflows_Var_Pop_Fields>;
  var_samp?: Maybe<Workflows_Var_Samp_Fields>;
  variance?: Maybe<Workflows_Variance_Fields>;
};


/** aggregate fields of "workflows" */
export type Workflows_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Workflows_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Workflows_Append_Input = {
  steps?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Workflows_Avg_Fields = {
  __typename?: 'workflows_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "workflows". All fields are combined with a logical 'AND'. */
export type Workflows_Bool_Exp = {
  _and?: InputMaybe<Array<Workflows_Bool_Exp>>;
  _not?: InputMaybe<Workflows_Bool_Exp>;
  _or?: InputMaybe<Array<Workflows_Bool_Exp>>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  label?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  scenariotypes?: InputMaybe<Scenariotypes_Bool_Exp>;
  scenariotypes_aggregate?: InputMaybe<Scenariotypes_Aggregate_Bool_Exp>;
  steps?: InputMaybe<Jsonb_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  vehiclephotos?: InputMaybe<Vehiclephotos_Bool_Exp>;
  vehiclephotos_aggregate?: InputMaybe<Vehiclephotos_Aggregate_Bool_Exp>;
  version?: InputMaybe<String_Comparison_Exp>;
  workflowsets?: InputMaybe<Workflowsets_Bool_Exp>;
  workflowsetsByFuelWorkflowId?: InputMaybe<Workflowsets_Bool_Exp>;
  workflowsetsByFuelWorkflowId_aggregate?: InputMaybe<Workflowsets_Aggregate_Bool_Exp>;
  workflowsetsByPickupWorkflowId?: InputMaybe<Workflowsets_Bool_Exp>;
  workflowsetsByPickupWorkflowId_aggregate?: InputMaybe<Workflowsets_Aggregate_Bool_Exp>;
  workflowsets_aggregate?: InputMaybe<Workflowsets_Aggregate_Bool_Exp>;
  workflowsettypes?: InputMaybe<Workflowsettypes_Bool_Exp>;
  workflowsettypesByFuelWorkflowId?: InputMaybe<Workflowsettypes_Bool_Exp>;
  workflowsettypesByFuelWorkflowId_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Bool_Exp>;
  workflowsettypesByPickupWorkflowId?: InputMaybe<Workflowsettypes_Bool_Exp>;
  workflowsettypesByPickupWorkflowId_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Bool_Exp>;
  workflowsettypes_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "workflows" */
export enum Workflows_Constraint {
  /** unique or primary key constraint on columns "id" */
  WorkflowsPkey = 'workflows_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Workflows_Delete_At_Path_Input = {
  steps?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Workflows_Delete_Elem_Input = {
  steps?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Workflows_Delete_Key_Input = {
  steps?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "workflows" */
export type Workflows_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "workflows" */
export type Workflows_Insert_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  scenariotypes?: InputMaybe<Scenariotypes_Arr_Rel_Insert_Input>;
  steps?: InputMaybe<Scalars['jsonb']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  vehiclephotos?: InputMaybe<Vehiclephotos_Arr_Rel_Insert_Input>;
  version?: InputMaybe<Scalars['String']['input']>;
  workflowsets?: InputMaybe<Workflowsets_Arr_Rel_Insert_Input>;
  workflowsetsByFuelWorkflowId?: InputMaybe<Workflowsets_Arr_Rel_Insert_Input>;
  workflowsetsByPickupWorkflowId?: InputMaybe<Workflowsets_Arr_Rel_Insert_Input>;
  workflowsettypes?: InputMaybe<Workflowsettypes_Arr_Rel_Insert_Input>;
  workflowsettypesByFuelWorkflowId?: InputMaybe<Workflowsettypes_Arr_Rel_Insert_Input>;
  workflowsettypesByPickupWorkflowId?: InputMaybe<Workflowsettypes_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Workflows_Max_Fields = {
  __typename?: 'workflows_max_fields';
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Workflows_Min_Fields = {
  __typename?: 'workflows_min_fields';
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "workflows" */
export type Workflows_Mutation_Response = {
  __typename?: 'workflows_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Workflows>;
};

/** input type for inserting object relation for remote table "workflows" */
export type Workflows_Obj_Rel_Insert_Input = {
  data: Workflows_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Workflows_On_Conflict>;
};

/** on_conflict condition type for table "workflows" */
export type Workflows_On_Conflict = {
  constraint: Workflows_Constraint;
  update_columns?: Array<Workflows_Update_Column>;
  where?: InputMaybe<Workflows_Bool_Exp>;
};

/** Ordering options when selecting data from "workflows". */
export type Workflows_Order_By = {
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  scenariotypes_aggregate?: InputMaybe<Scenariotypes_Aggregate_Order_By>;
  steps?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  vehiclephotos_aggregate?: InputMaybe<Vehiclephotos_Aggregate_Order_By>;
  version?: InputMaybe<Order_By>;
  workflowsetsByFuelWorkflowId_aggregate?: InputMaybe<Workflowsets_Aggregate_Order_By>;
  workflowsetsByPickupWorkflowId_aggregate?: InputMaybe<Workflowsets_Aggregate_Order_By>;
  workflowsets_aggregate?: InputMaybe<Workflowsets_Aggregate_Order_By>;
  workflowsettypesByFuelWorkflowId_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Order_By>;
  workflowsettypesByPickupWorkflowId_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Order_By>;
  workflowsettypes_aggregate?: InputMaybe<Workflowsettypes_Aggregate_Order_By>;
};

/** primary key columns input for table: workflows */
export type Workflows_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Workflows_Prepend_Input = {
  steps?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "workflows" */
export enum Workflows_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  Steps = 'steps',
  /** column name */
  Type = 'type',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "workflows" */
export type Workflows_Set_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  steps?: InputMaybe<Scalars['jsonb']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Workflows_Stddev_Fields = {
  __typename?: 'workflows_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Workflows_Stddev_Pop_Fields = {
  __typename?: 'workflows_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Workflows_Stddev_Samp_Fields = {
  __typename?: 'workflows_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "workflows" */
export type Workflows_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Workflows_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Workflows_Stream_Cursor_Value_Input = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  steps?: InputMaybe<Scalars['jsonb']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Workflows_Sum_Fields = {
  __typename?: 'workflows_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "workflows" */
export enum Workflows_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  Steps = 'steps',
  /** column name */
  Type = 'type',
  /** column name */
  Version = 'version'
}

export type Workflows_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Workflows_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Workflows_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Workflows_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Workflows_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Workflows_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Workflows_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Workflows_Set_Input>;
  /** filter the rows which have to be updated */
  where: Workflows_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Workflows_Var_Pop_Fields = {
  __typename?: 'workflows_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Workflows_Var_Samp_Fields = {
  __typename?: 'workflows_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Workflows_Variance_Fields = {
  __typename?: 'workflows_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Named pairs of pickup and delivery workflow intended to be used together on a move. */
export type Workflowsets = {
  __typename?: 'workflowsets';
  createdat: Scalars['timestamptz']['output'];
  createdby?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  customer?: Maybe<Customers>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  deliveryWorkflow?: Maybe<Workflows>;
  delivery_workflow_id: Scalars['Int']['output'];
  description: Scalars['String']['output'];
  /** An object relationship */
  fuelWorkflow?: Maybe<Workflows>;
  fuel_workflow_id?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** An array relationship */
  moves: Array<Moves>;
  /** An aggregate relationship */
  moves_aggregate: Moves_Aggregate;
  name: Scalars['String']['output'];
  /** An object relationship */
  organization?: Maybe<Organizations>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  pickupWorkflow?: Maybe<Workflows>;
  pickup_workflow_id: Scalars['Int']['output'];
  public: Scalars['Boolean']['output'];
  /** An array relationship */
  raterulegroups: Array<Raterulegroups>;
  /** An aggregate relationship */
  raterulegroups_aggregate: Raterulegroups_Aggregate;
  /** An object relationship */
  sla?: Maybe<Slas>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  type: Scalars['String']['output'];
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};


/** Named pairs of pickup and delivery workflow intended to be used together on a move. */
export type WorkflowsetsMovesArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** Named pairs of pickup and delivery workflow intended to be used together on a move. */
export type WorkflowsetsMoves_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Moves_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Moves_Order_By>>;
  where?: InputMaybe<Moves_Bool_Exp>;
};


/** Named pairs of pickup and delivery workflow intended to be used together on a move. */
export type WorkflowsetsRaterulegroupsArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};


/** Named pairs of pickup and delivery workflow intended to be used together on a move. */
export type WorkflowsetsRaterulegroups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Raterulegroups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Raterulegroups_Order_By>>;
  where?: InputMaybe<Raterulegroups_Bool_Exp>;
};

/** aggregated selection of "workflowsets" */
export type Workflowsets_Aggregate = {
  __typename?: 'workflowsets_aggregate';
  aggregate?: Maybe<Workflowsets_Aggregate_Fields>;
  nodes: Array<Workflowsets>;
};

export type Workflowsets_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Workflowsets_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Workflowsets_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Workflowsets_Aggregate_Bool_Exp_Count>;
};

export type Workflowsets_Aggregate_Bool_Exp_Bool_And = {
  arguments: Workflowsets_Select_Column_Workflowsets_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Workflowsets_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Workflowsets_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Workflowsets_Select_Column_Workflowsets_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Workflowsets_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Workflowsets_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Workflowsets_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Workflowsets_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "workflowsets" */
export type Workflowsets_Aggregate_Fields = {
  __typename?: 'workflowsets_aggregate_fields';
  avg?: Maybe<Workflowsets_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Workflowsets_Max_Fields>;
  min?: Maybe<Workflowsets_Min_Fields>;
  stddev?: Maybe<Workflowsets_Stddev_Fields>;
  stddev_pop?: Maybe<Workflowsets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Workflowsets_Stddev_Samp_Fields>;
  sum?: Maybe<Workflowsets_Sum_Fields>;
  var_pop?: Maybe<Workflowsets_Var_Pop_Fields>;
  var_samp?: Maybe<Workflowsets_Var_Samp_Fields>;
  variance?: Maybe<Workflowsets_Variance_Fields>;
};


/** aggregate fields of "workflowsets" */
export type Workflowsets_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Workflowsets_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "workflowsets" */
export type Workflowsets_Aggregate_Order_By = {
  avg?: InputMaybe<Workflowsets_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Workflowsets_Max_Order_By>;
  min?: InputMaybe<Workflowsets_Min_Order_By>;
  stddev?: InputMaybe<Workflowsets_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Workflowsets_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Workflowsets_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Workflowsets_Sum_Order_By>;
  var_pop?: InputMaybe<Workflowsets_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Workflowsets_Var_Samp_Order_By>;
  variance?: InputMaybe<Workflowsets_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "workflowsets" */
export type Workflowsets_Arr_Rel_Insert_Input = {
  data: Array<Workflowsets_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Workflowsets_On_Conflict>;
};

/** aggregate avg on columns */
export type Workflowsets_Avg_Fields = {
  __typename?: 'workflowsets_avg_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "workflowsets" */
export type Workflowsets_Avg_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "workflowsets". All fields are combined with a logical 'AND'. */
export type Workflowsets_Bool_Exp = {
  _and?: InputMaybe<Array<Workflowsets_Bool_Exp>>;
  _not?: InputMaybe<Workflowsets_Bool_Exp>;
  _or?: InputMaybe<Array<Workflowsets_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  customer?: InputMaybe<Customers_Bool_Exp>;
  customer_id?: InputMaybe<Bigint_Comparison_Exp>;
  deliveryWorkflow?: InputMaybe<Workflows_Bool_Exp>;
  delivery_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  fuelWorkflow?: InputMaybe<Workflows_Bool_Exp>;
  fuel_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  moves?: InputMaybe<Moves_Bool_Exp>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organization_id?: InputMaybe<Bigint_Comparison_Exp>;
  pickupWorkflow?: InputMaybe<Workflows_Bool_Exp>;
  pickup_workflow_id?: InputMaybe<Int_Comparison_Exp>;
  public?: InputMaybe<Boolean_Comparison_Exp>;
  raterulegroups?: InputMaybe<Raterulegroups_Bool_Exp>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Bool_Exp>;
  sla?: InputMaybe<Slas_Bool_Exp>;
  sla_id?: InputMaybe<Bigint_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "workflowsets" */
export enum Workflowsets_Constraint {
  /** unique or primary key constraint on columns "id" */
  WorkflowsetsPkey = 'workflowsets_pkey'
}

/** input type for incrementing numeric columns in table "workflowsets" */
export type Workflowsets_Inc_Input = {
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "workflowsets" */
export type Workflowsets_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer?: InputMaybe<Customers_Obj_Rel_Insert_Input>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  deliveryWorkflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fuelWorkflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  fuel_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  moves?: InputMaybe<Moves_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  pickupWorkflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  public?: InputMaybe<Scalars['Boolean']['input']>;
  raterulegroups?: InputMaybe<Raterulegroups_Arr_Rel_Insert_Input>;
  sla?: InputMaybe<Slas_Obj_Rel_Insert_Input>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Workflowsets_Max_Fields = {
  __typename?: 'workflowsets_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "workflowsets" */
export type Workflowsets_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Workflowsets_Min_Fields = {
  __typename?: 'workflowsets_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  customer_id?: Maybe<Scalars['bigint']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "workflowsets" */
export type Workflowsets_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "workflowsets" */
export type Workflowsets_Mutation_Response = {
  __typename?: 'workflowsets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Workflowsets>;
};

/** input type for inserting object relation for remote table "workflowsets" */
export type Workflowsets_Obj_Rel_Insert_Input = {
  data: Workflowsets_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Workflowsets_On_Conflict>;
};

/** on_conflict condition type for table "workflowsets" */
export type Workflowsets_On_Conflict = {
  constraint: Workflowsets_Constraint;
  update_columns?: Array<Workflowsets_Update_Column>;
  where?: InputMaybe<Workflowsets_Bool_Exp>;
};

/** Ordering options when selecting data from "workflowsets". */
export type Workflowsets_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  customer?: InputMaybe<Customers_Order_By>;
  customer_id?: InputMaybe<Order_By>;
  deliveryWorkflow?: InputMaybe<Workflows_Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fuelWorkflow?: InputMaybe<Workflows_Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moves_aggregate?: InputMaybe<Moves_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickupWorkflow?: InputMaybe<Workflows_Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  public?: InputMaybe<Order_By>;
  raterulegroups_aggregate?: InputMaybe<Raterulegroups_Aggregate_Order_By>;
  sla?: InputMaybe<Slas_Order_By>;
  sla_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** primary key columns input for table: workflowsets */
export type Workflowsets_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "workflowsets" */
export enum Workflowsets_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  Description = 'description',
  /** column name */
  FuelWorkflowId = 'fuel_workflow_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  Public = 'public',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** select "workflowsets_aggregate_bool_exp_bool_and_arguments_columns" columns of table "workflowsets" */
export enum Workflowsets_Select_Column_Workflowsets_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Public = 'public'
}

/** select "workflowsets_aggregate_bool_exp_bool_or_arguments_columns" columns of table "workflowsets" */
export enum Workflowsets_Select_Column_Workflowsets_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Public = 'public'
}

/** input type for updating data in table "workflowsets" */
export type Workflowsets_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  public?: InputMaybe<Scalars['Boolean']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Workflowsets_Stddev_Fields = {
  __typename?: 'workflowsets_stddev_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "workflowsets" */
export type Workflowsets_Stddev_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Workflowsets_Stddev_Pop_Fields = {
  __typename?: 'workflowsets_stddev_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "workflowsets" */
export type Workflowsets_Stddev_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Workflowsets_Stddev_Samp_Fields = {
  __typename?: 'workflowsets_stddev_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "workflowsets" */
export type Workflowsets_Stddev_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "workflowsets" */
export type Workflowsets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Workflowsets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Workflowsets_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  customer_id?: InputMaybe<Scalars['bigint']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organization_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['Int']['input']>;
  public?: InputMaybe<Scalars['Boolean']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Workflowsets_Sum_Fields = {
  __typename?: 'workflowsets_sum_fields';
  customer_id?: Maybe<Scalars['bigint']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Int']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  organization_id?: Maybe<Scalars['bigint']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Int']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "workflowsets" */
export type Workflowsets_Sum_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** update columns of table "workflowsets" */
export enum Workflowsets_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  Description = 'description',
  /** column name */
  FuelWorkflowId = 'fuel_workflow_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  Public = 'public',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Type = 'type',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Workflowsets_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Workflowsets_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Workflowsets_Set_Input>;
  /** filter the rows which have to be updated */
  where: Workflowsets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Workflowsets_Var_Pop_Fields = {
  __typename?: 'workflowsets_var_pop_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "workflowsets" */
export type Workflowsets_Var_Pop_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Workflowsets_Var_Samp_Fields = {
  __typename?: 'workflowsets_var_samp_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "workflowsets" */
export type Workflowsets_Var_Samp_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Workflowsets_Variance_Fields = {
  __typename?: 'workflowsets_variance_fields';
  customer_id?: Maybe<Scalars['Float']['output']>;
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  organization_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "workflowsets" */
export type Workflowsets_Variance_Order_By = {
  customer_id?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** Contains the master list of workflow set types which effectively act as the templates for workflow sets. Any new workflow set created to house pricing for a specific customer would be derived from a parent workflowsettype here. The workflow ids would be copied from here and used in the child workflowset record rather than just having a reference to this parent table only. Doing so will maximize flexibility and allow one instance of a workflowset to be customized under a single rooftop if needed. A parent to WorkflowSets, this table also allows a certification to be attached to the type of workflow set vs needed to be repeatedly attached at the workflowset level. */
export type Workflowsettypes = {
  __typename?: 'workflowsettypes';
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  delivery_workflow_id: Scalars['bigint']['output'];
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  fuel_workflow_id: Scalars['bigint']['output'];
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['output'];
  /** name of the type to be used when displaying it on screen */
  name: Scalars['String']['output'];
  pickup_workflow_id: Scalars['bigint']['output'];
  /** An object relationship */
  sla: Slas;
  sla_id: Scalars['bigint']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  /** An object relationship */
  workflow: Workflows;
  /** An object relationship */
  workflowByFuelWorkflowId: Workflows;
  /** An object relationship */
  workflowByPickupWorkflowId: Workflows;
};

/** aggregated selection of "workflowsettypes" */
export type Workflowsettypes_Aggregate = {
  __typename?: 'workflowsettypes_aggregate';
  aggregate?: Maybe<Workflowsettypes_Aggregate_Fields>;
  nodes: Array<Workflowsettypes>;
};

export type Workflowsettypes_Aggregate_Bool_Exp = {
  count?: InputMaybe<Workflowsettypes_Aggregate_Bool_Exp_Count>;
};

export type Workflowsettypes_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Workflowsettypes_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "workflowsettypes" */
export type Workflowsettypes_Aggregate_Fields = {
  __typename?: 'workflowsettypes_aggregate_fields';
  avg?: Maybe<Workflowsettypes_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Workflowsettypes_Max_Fields>;
  min?: Maybe<Workflowsettypes_Min_Fields>;
  stddev?: Maybe<Workflowsettypes_Stddev_Fields>;
  stddev_pop?: Maybe<Workflowsettypes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Workflowsettypes_Stddev_Samp_Fields>;
  sum?: Maybe<Workflowsettypes_Sum_Fields>;
  var_pop?: Maybe<Workflowsettypes_Var_Pop_Fields>;
  var_samp?: Maybe<Workflowsettypes_Var_Samp_Fields>;
  variance?: Maybe<Workflowsettypes_Variance_Fields>;
};


/** aggregate fields of "workflowsettypes" */
export type Workflowsettypes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Workflowsettypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "workflowsettypes" */
export type Workflowsettypes_Aggregate_Order_By = {
  avg?: InputMaybe<Workflowsettypes_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Workflowsettypes_Max_Order_By>;
  min?: InputMaybe<Workflowsettypes_Min_Order_By>;
  stddev?: InputMaybe<Workflowsettypes_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Workflowsettypes_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Workflowsettypes_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Workflowsettypes_Sum_Order_By>;
  var_pop?: InputMaybe<Workflowsettypes_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Workflowsettypes_Var_Samp_Order_By>;
  variance?: InputMaybe<Workflowsettypes_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "workflowsettypes" */
export type Workflowsettypes_Arr_Rel_Insert_Input = {
  data: Array<Workflowsettypes_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Workflowsettypes_On_Conflict>;
};

/** aggregate avg on columns */
export type Workflowsettypes_Avg_Fields = {
  __typename?: 'workflowsettypes_avg_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "workflowsettypes" */
export type Workflowsettypes_Avg_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "workflowsettypes". All fields are combined with a logical 'AND'. */
export type Workflowsettypes_Bool_Exp = {
  _and?: InputMaybe<Array<Workflowsettypes_Bool_Exp>>;
  _not?: InputMaybe<Workflowsettypes_Bool_Exp>;
  _or?: InputMaybe<Array<Workflowsettypes_Bool_Exp>>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  delivery_workflow_id?: InputMaybe<Bigint_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  fuel_workflow_id?: InputMaybe<Bigint_Comparison_Exp>;
  key?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pickup_workflow_id?: InputMaybe<Bigint_Comparison_Exp>;
  sla?: InputMaybe<Slas_Bool_Exp>;
  sla_id?: InputMaybe<Bigint_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  workflow?: InputMaybe<Workflows_Bool_Exp>;
  workflowByFuelWorkflowId?: InputMaybe<Workflows_Bool_Exp>;
  workflowByPickupWorkflowId?: InputMaybe<Workflows_Bool_Exp>;
};

/** unique or primary key constraints on table "workflowsettypes" */
export enum Workflowsettypes_Constraint {
  /** unique or primary key constraint on columns "key" */
  WorkflowsettypesPkey = 'workflowsettypes_pkey'
}

/** input type for incrementing numeric columns in table "workflowsettypes" */
export type Workflowsettypes_Inc_Input = {
  delivery_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "workflowsettypes" */
export type Workflowsettypes_Insert_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name of the type to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  sla?: InputMaybe<Slas_Obj_Rel_Insert_Input>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflow?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  workflowByFuelWorkflowId?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
  workflowByPickupWorkflowId?: InputMaybe<Workflows_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Workflowsettypes_Max_Fields = {
  __typename?: 'workflowsettypes_max_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  delivery_workflow_id?: Maybe<Scalars['bigint']['output']>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  fuel_workflow_id?: Maybe<Scalars['bigint']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  /** name of the type to be used when displaying it on screen */
  name?: Maybe<Scalars['String']['output']>;
  pickup_workflow_id?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "workflowsettypes" */
export type Workflowsettypes_Max_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Order_By>;
  /** name of the type to be used when displaying it on screen */
  name?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Workflowsettypes_Min_Fields = {
  __typename?: 'workflowsettypes_min_fields';
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  delivery_workflow_id?: Maybe<Scalars['bigint']['output']>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: Maybe<Scalars['String']['output']>;
  fuel_workflow_id?: Maybe<Scalars['bigint']['output']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: Maybe<Scalars['String']['output']>;
  /** name of the type to be used when displaying it on screen */
  name?: Maybe<Scalars['String']['output']>;
  pickup_workflow_id?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "workflowsettypes" */
export type Workflowsettypes_Min_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Order_By>;
  /** name of the type to be used when displaying it on screen */
  name?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "workflowsettypes" */
export type Workflowsettypes_Mutation_Response = {
  __typename?: 'workflowsettypes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Workflowsettypes>;
};

/** on_conflict condition type for table "workflowsettypes" */
export type Workflowsettypes_On_Conflict = {
  constraint: Workflowsettypes_Constraint;
  update_columns?: Array<Workflowsettypes_Update_Column>;
  where?: InputMaybe<Workflowsettypes_Bool_Exp>;
};

/** Ordering options when selecting data from "workflowsettypes". */
export type Workflowsettypes_Order_By = {
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  delivery_workflow_id?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  key?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla?: InputMaybe<Slas_Order_By>;
  sla_id?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflow?: InputMaybe<Workflows_Order_By>;
  workflowByFuelWorkflowId?: InputMaybe<Workflows_Order_By>;
  workflowByPickupWorkflowId?: InputMaybe<Workflows_Order_By>;
};

/** primary key columns input for table: workflowsettypes */
export type Workflowsettypes_Pk_Columns_Input = {
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key: Scalars['String']['input'];
};

/** select columns of table "workflowsettypes" */
export enum Workflowsettypes_Select_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  Description = 'description',
  /** column name */
  FuelWorkflowId = 'fuel_workflow_id',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

/** input type for updating data in table "workflowsettypes" */
export type Workflowsettypes_Set_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name of the type to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Workflowsettypes_Stddev_Fields = {
  __typename?: 'workflowsettypes_stddev_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "workflowsettypes" */
export type Workflowsettypes_Stddev_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Workflowsettypes_Stddev_Pop_Fields = {
  __typename?: 'workflowsettypes_stddev_pop_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "workflowsettypes" */
export type Workflowsettypes_Stddev_Pop_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Workflowsettypes_Stddev_Samp_Fields = {
  __typename?: 'workflowsettypes_stddev_samp_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "workflowsettypes" */
export type Workflowsettypes_Stddev_Samp_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "workflowsettypes" */
export type Workflowsettypes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Workflowsettypes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Workflowsettypes_Stream_Cursor_Value_Input = {
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  delivery_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a long-form description of the workflow set type to provide context as to why it is different from others */
  description?: InputMaybe<Scalars['String']['input']>;
  fuel_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  /** a unique string with all lowercase and no spaces and separated by dashes */
  key?: InputMaybe<Scalars['String']['input']>;
  /** name of the type to be used when displaying it on screen */
  name?: InputMaybe<Scalars['String']['input']>;
  pickup_workflow_id?: InputMaybe<Scalars['bigint']['input']>;
  sla_id?: InputMaybe<Scalars['bigint']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Workflowsettypes_Sum_Fields = {
  __typename?: 'workflowsettypes_sum_fields';
  delivery_workflow_id?: Maybe<Scalars['bigint']['output']>;
  fuel_workflow_id?: Maybe<Scalars['bigint']['output']>;
  pickup_workflow_id?: Maybe<Scalars['bigint']['output']>;
  sla_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "workflowsettypes" */
export type Workflowsettypes_Sum_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** update columns of table "workflowsettypes" */
export enum Workflowsettypes_Update_Column {
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  DeliveryWorkflowId = 'delivery_workflow_id',
  /** column name */
  Description = 'description',
  /** column name */
  FuelWorkflowId = 'fuel_workflow_id',
  /** column name */
  Key = 'key',
  /** column name */
  Name = 'name',
  /** column name */
  PickupWorkflowId = 'pickup_workflow_id',
  /** column name */
  SlaId = 'sla_id',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby'
}

export type Workflowsettypes_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Workflowsettypes_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Workflowsettypes_Set_Input>;
  /** filter the rows which have to be updated */
  where: Workflowsettypes_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Workflowsettypes_Var_Pop_Fields = {
  __typename?: 'workflowsettypes_var_pop_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "workflowsettypes" */
export type Workflowsettypes_Var_Pop_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Workflowsettypes_Var_Samp_Fields = {
  __typename?: 'workflowsettypes_var_samp_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "workflowsettypes" */
export type Workflowsettypes_Var_Samp_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Workflowsettypes_Variance_Fields = {
  __typename?: 'workflowsettypes_variance_fields';
  delivery_workflow_id?: Maybe<Scalars['Float']['output']>;
  fuel_workflow_id?: Maybe<Scalars['Float']['output']>;
  pickup_workflow_id?: Maybe<Scalars['Float']['output']>;
  sla_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "workflowsettypes" */
export type Workflowsettypes_Variance_Order_By = {
  delivery_workflow_id?: InputMaybe<Order_By>;
  fuel_workflow_id?: InputMaybe<Order_By>;
  pickup_workflow_id?: InputMaybe<Order_By>;
  sla_id?: InputMaybe<Order_By>;
};

/** Many to Many relationships, this could be used if a specific workflowset type marks the move as special. Ie if a hangtag is tied to a workflow.  */
export type Workflowsettypestocertifications = {
  __typename?: 'workflowsettypestocertifications';
  certification_key: Scalars['String']['output'];
  createdat: Scalars['timestamptz']['output'];
  createdby: Scalars['String']['output'];
  updatedat: Scalars['timestamptz']['output'];
  updatedby: Scalars['String']['output'];
  workflow_set_type_key: Scalars['String']['output'];
};

/** aggregated selection of "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Aggregate = {
  __typename?: 'workflowsettypestocertifications_aggregate';
  aggregate?: Maybe<Workflowsettypestocertifications_Aggregate_Fields>;
  nodes: Array<Workflowsettypestocertifications>;
};

/** aggregate fields of "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Aggregate_Fields = {
  __typename?: 'workflowsettypestocertifications_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Workflowsettypestocertifications_Max_Fields>;
  min?: Maybe<Workflowsettypestocertifications_Min_Fields>;
};


/** aggregate fields of "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Workflowsettypestocertifications_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "workflowsettypestocertifications". All fields are combined with a logical 'AND'. */
export type Workflowsettypestocertifications_Bool_Exp = {
  _and?: InputMaybe<Array<Workflowsettypestocertifications_Bool_Exp>>;
  _not?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
  _or?: InputMaybe<Array<Workflowsettypestocertifications_Bool_Exp>>;
  certification_key?: InputMaybe<String_Comparison_Exp>;
  createdat?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdby?: InputMaybe<String_Comparison_Exp>;
  updatedat?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedby?: InputMaybe<String_Comparison_Exp>;
  workflow_set_type_key?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "workflowsettypestocertifications" */
export enum Workflowsettypestocertifications_Constraint {
  /** unique or primary key constraint on columns "workflow_set_type_key", "certification_key" */
  WorkflowsettypestocertificationsPkey = 'workflowsettypestocertifications_pkey'
}

/** input type for inserting data into table "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Insert_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflow_set_type_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Workflowsettypestocertifications_Max_Fields = {
  __typename?: 'workflowsettypestocertifications_max_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  workflow_set_type_key?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Workflowsettypestocertifications_Min_Fields = {
  __typename?: 'workflowsettypestocertifications_min_fields';
  certification_key?: Maybe<Scalars['String']['output']>;
  createdat?: Maybe<Scalars['timestamptz']['output']>;
  createdby?: Maybe<Scalars['String']['output']>;
  updatedat?: Maybe<Scalars['timestamptz']['output']>;
  updatedby?: Maybe<Scalars['String']['output']>;
  workflow_set_type_key?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Mutation_Response = {
  __typename?: 'workflowsettypestocertifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Workflowsettypestocertifications>;
};

/** on_conflict condition type for table "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_On_Conflict = {
  constraint: Workflowsettypestocertifications_Constraint;
  update_columns?: Array<Workflowsettypestocertifications_Update_Column>;
  where?: InputMaybe<Workflowsettypestocertifications_Bool_Exp>;
};

/** Ordering options when selecting data from "workflowsettypestocertifications". */
export type Workflowsettypestocertifications_Order_By = {
  certification_key?: InputMaybe<Order_By>;
  createdat?: InputMaybe<Order_By>;
  createdby?: InputMaybe<Order_By>;
  updatedat?: InputMaybe<Order_By>;
  updatedby?: InputMaybe<Order_By>;
  workflow_set_type_key?: InputMaybe<Order_By>;
};

/** primary key columns input for table: workflowsettypestocertifications */
export type Workflowsettypestocertifications_Pk_Columns_Input = {
  certification_key: Scalars['String']['input'];
  workflow_set_type_key: Scalars['String']['input'];
};

/** select columns of table "workflowsettypestocertifications" */
export enum Workflowsettypestocertifications_Select_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowSetTypeKey = 'workflow_set_type_key'
}

/** input type for updating data in table "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Set_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflow_set_type_key?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "workflowsettypestocertifications" */
export type Workflowsettypestocertifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Workflowsettypestocertifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Workflowsettypestocertifications_Stream_Cursor_Value_Input = {
  certification_key?: InputMaybe<Scalars['String']['input']>;
  createdat?: InputMaybe<Scalars['timestamptz']['input']>;
  createdby?: InputMaybe<Scalars['String']['input']>;
  updatedat?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedby?: InputMaybe<Scalars['String']['input']>;
  workflow_set_type_key?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "workflowsettypestocertifications" */
export enum Workflowsettypestocertifications_Update_Column {
  /** column name */
  CertificationKey = 'certification_key',
  /** column name */
  Createdat = 'createdat',
  /** column name */
  Createdby = 'createdby',
  /** column name */
  Updatedat = 'updatedat',
  /** column name */
  Updatedby = 'updatedby',
  /** column name */
  WorkflowSetTypeKey = 'workflow_set_type_key'
}

export type Workflowsettypestocertifications_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Workflowsettypestocertifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Workflowsettypestocertifications_Bool_Exp;
};

export type AnalyticsOverviewQueryVariables = Exact<{
  timeRange: Scalars['timestamptz']['input'];
}>;


export type AnalyticsOverviewQuery = { __typename?: 'query_root', invocations_aggregate: { __typename?: 'invocations_aggregate', aggregate?: { __typename?: 'invocations_aggregate_fields', count: number, avg?: { __typename?: 'invocations_avg_fields', total_duration_ms?: number | null } | null, sum?: { __typename?: 'invocations_sum_fields', total_jobs_run?: number | null, total_jobs_succeeded?: number | null, total_jobs_failed?: number | null } | null } | null }, job_executions: Array<{ __typename?: 'job_executions', id: string, job_name: string, error_message?: string | null, created_at: string, duration_ms?: number | null, correlation_id?: string | null, invocation: { __typename?: 'invocations', source_function: string, source_user_email?: string | null }, event_execution: { __typename?: 'event_executions', event_name: string } }>, event_executions_aggregate: { __typename?: 'event_executions_aggregate', aggregate?: { __typename?: 'event_executions_aggregate_fields', count: number } | null, nodes: Array<{ __typename?: 'event_executions', event_name: string, detected: boolean }> } };

export type SystemHealthQueryVariables = Exact<{
  timeRange: Scalars['timestamptz']['input'];
}>;


export type SystemHealthQuery = { __typename?: 'query_root', invocations_aggregate: { __typename?: 'invocations_aggregate', aggregate?: { __typename?: 'invocations_aggregate_fields', count: number, avg?: { __typename?: 'invocations_avg_fields', total_duration_ms?: number | null } | null } | null }, job_executions_aggregate: { __typename?: 'job_executions_aggregate', aggregate?: { __typename?: 'job_executions_aggregate_fields', count: number, avg?: { __typename?: 'job_executions_avg_fields', duration_ms?: number | null } | null } | null }, event_executions_aggregate: { __typename?: 'event_executions_aggregate', aggregate?: { __typename?: 'event_executions_aggregate_fields', count: number } | null } };

export type OverviewDashboardQueryVariables = Exact<{
  timeRange: Scalars['timestamptz']['input'];
}>;


export type OverviewDashboardQuery = { __typename?: 'query_root', invocations: Array<{ __typename?: 'invocations', id: string, source_function: string, created_at: string, total_duration_ms?: number | null, status: string, events_detected_count?: number | null, total_jobs_run?: number | null, total_jobs_succeeded?: number | null, total_jobs_failed?: number | null, correlation_id?: string | null, source_user_email?: string | null, source_user_role?: string | null }>, invocations_aggregate: { __typename?: 'invocations_aggregate', aggregate?: { __typename?: 'invocations_aggregate_fields', count: number, avg?: { __typename?: 'invocations_avg_fields', total_duration_ms?: number | null } | null, sum?: { __typename?: 'invocations_sum_fields', total_jobs_run?: number | null, total_jobs_succeeded?: number | null, total_jobs_failed?: number | null } | null } | null }, event_executions_aggregate: { __typename?: 'event_executions_aggregate', aggregate?: { __typename?: 'event_executions_aggregate_fields', count: number } | null, nodes: Array<{ __typename?: 'event_executions', event_name: string }> } };

export type InvocationsRealtimeSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type InvocationsRealtimeSubscription = { __typename?: 'subscription_root', invocations: Array<{ __typename?: 'invocations', id: string, created_at: string, source_function: string, status: string, total_duration_ms?: number | null, events_detected_count?: number | null, total_jobs_run?: number | null, total_jobs_succeeded?: number | null, total_jobs_failed?: number | null, correlation_id?: string | null }> };

export type EventFlowQueryVariables = Exact<{
  invocationId: Scalars['uuid']['input'];
}>;


export type EventFlowQuery = { __typename?: 'query_root', invocations_by_pk?: { __typename?: 'invocations', id: string, source_function: string, status: string, total_duration_ms?: number | null, events_detected_count?: number | null, correlation_id?: string | null, event_executions: Array<{ __typename?: 'event_executions', id: string, event_name: string, detected: boolean, status: string, detection_duration_ms?: number | null, handler_duration_ms?: number | null, jobs_count?: number | null, job_executions: Array<{ __typename?: 'job_executions', id: string, job_name: string, job_function_name?: string | null, status: string, duration_ms?: number | null, result?: object | null, error_message?: string | null }> }> } | null };

export type CorrelationChainsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CorrelationChainsListQuery = { __typename?: 'query_root', invocations: Array<{ __typename?: 'invocations', correlation_id?: string | null, created_at: string, source_function: string }> };

export type CorrelationChainFlowQueryVariables = Exact<{
  correlationId: Scalars['String']['input'];
}>;


export type CorrelationChainFlowQuery = { __typename?: 'query_root', invocations: Array<{ __typename?: 'invocations', id: string, source_function: string, created_at: string, status: string, total_duration_ms?: number | null, events_detected_count?: number | null, correlation_id?: string | null, event_executions: Array<{ __typename?: 'event_executions', id: string, event_name: string, detected: boolean, status: string, detection_duration_ms?: number | null, handler_duration_ms?: number | null, jobs_count?: number | null, jobs_succeeded?: number | null, jobs_failed?: number | null, job_executions: Array<{ __typename?: 'job_executions', id: string, job_name: string, job_function_name?: string | null, status: string, duration_ms?: number | null, result?: object | null, error_message?: string | null, correlation_id?: string | null, created_at: string }> }> }> };

export type InvocationsListQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<Invocations_Bool_Exp>;
  order_by?: InputMaybe<Array<Invocations_Order_By> | Invocations_Order_By>;
}>;


export type InvocationsListQuery = { __typename?: 'query_root', invocations: Array<{ __typename?: 'invocations', id: string, created_at: string, updated_at: string, source_function: string, source_table?: string | null, source_operation?: string | null, source_system?: string | null, correlation_id?: string | null, source_user_email?: string | null, source_user_role?: string | null, total_duration_ms?: number | null, events_detected_count?: number | null, total_jobs_run?: number | null, total_jobs_succeeded?: number | null, total_jobs_failed?: number | null, status: string, error_message?: string | null }>, invocations_aggregate: { __typename?: 'invocations_aggregate', aggregate?: { __typename?: 'invocations_aggregate_fields', count: number } | null } };

export type InvocationDetailQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type InvocationDetailQuery = { __typename?: 'query_root', invocations_by_pk?: { __typename?: 'invocations', id: string, created_at: string, updated_at: string, correlation_id?: string | null, source_function: string, source_table?: string | null, source_operation?: string | null, source_system?: string | null, source_event_id?: string | null, source_event_payload: object, source_event_time?: string | null, source_user_email?: string | null, source_user_role?: string | null, total_duration_ms?: number | null, events_detected_count?: number | null, total_jobs_run?: number | null, total_jobs_succeeded?: number | null, total_jobs_failed?: number | null, auto_load_modules?: boolean | null, event_modules_directory?: string | null, status: string, error_message?: string | null, error_stack?: string | null, context_data?: object | null, event_executions: Array<{ __typename?: 'event_executions', id: string, created_at: string, updated_at: string, correlation_id?: string | null, event_name: string, event_module_path?: string | null, detected: boolean, detection_duration_ms?: number | null, detection_error?: string | null, detection_error_stack?: string | null, handler_duration_ms?: number | null, handler_error?: string | null, handler_error_stack?: string | null, jobs_count?: number | null, jobs_succeeded?: number | null, jobs_failed?: number | null, status: string, job_executions: Array<{ __typename?: 'job_executions', id: string, created_at: string, updated_at: string, correlation_id?: string | null, job_name: string, job_function_name?: string | null, job_options?: object | null, duration_ms?: number | null, status: string, result?: object | null, error_message?: string | null, error_stack?: string | null }> }> } | null };

export type CorrelationSearchQueryVariables = Exact<{
  searchTerm: Scalars['String']['input'];
}>;


export type CorrelationSearchQuery = { __typename?: 'query_root', invocations: Array<{ __typename?: 'invocations', id: string, correlation_id?: string | null, source_function: string, source_user_email?: string | null, created_at: string, status: string, total_duration_ms?: number | null, events_detected_count?: number | null, total_jobs_run?: number | null }> };


export const AnalyticsOverviewDocument = gql`
    query AnalyticsOverview($timeRange: timestamptz!) {
  invocations_aggregate(where: {created_at: {_gte: $timeRange}}) {
    aggregate {
      count
      avg {
        total_duration_ms
      }
      sum {
        total_jobs_run
        total_jobs_succeeded
        total_jobs_failed
      }
    }
  }
  job_executions(
    where: {created_at: {_gte: $timeRange}, status: {_eq: "failed"}}
    order_by: {created_at: desc}
    limit: 10
  ) {
    id
    job_name
    error_message
    created_at
    duration_ms
    correlation_id
    invocation {
      source_function
      source_user_email
    }
    event_execution {
      event_name
    }
  }
  event_executions_aggregate(where: {created_at: {_gte: $timeRange}}) {
    aggregate {
      count
    }
    nodes {
      event_name
      detected
    }
  }
}
    `;

/**
 * __useAnalyticsOverviewQuery__
 *
 * To run a query within a React component, call `useAnalyticsOverviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useAnalyticsOverviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAnalyticsOverviewQuery({
 *   variables: {
 *      timeRange: // value for 'timeRange'
 *   },
 * });
 */
export function useAnalyticsOverviewQuery(baseOptions: Apollo.QueryHookOptions<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables> & ({ variables: AnalyticsOverviewQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables>(AnalyticsOverviewDocument, options);
      }
export function useAnalyticsOverviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables>(AnalyticsOverviewDocument, options);
        }
export function useAnalyticsOverviewSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables>(AnalyticsOverviewDocument, options);
        }
export type AnalyticsOverviewQueryHookResult = ReturnType<typeof useAnalyticsOverviewQuery>;
export type AnalyticsOverviewLazyQueryHookResult = ReturnType<typeof useAnalyticsOverviewLazyQuery>;
export type AnalyticsOverviewSuspenseQueryHookResult = ReturnType<typeof useAnalyticsOverviewSuspenseQuery>;
export type AnalyticsOverviewQueryResult = Apollo.QueryResult<AnalyticsOverviewQuery, AnalyticsOverviewQueryVariables>;
export const SystemHealthDocument = gql`
    query SystemHealth($timeRange: timestamptz!) {
  invocations_aggregate(where: {created_at: {_gte: $timeRange}}) {
    aggregate {
      count
      avg {
        total_duration_ms
      }
    }
  }
  job_executions_aggregate(where: {created_at: {_gte: $timeRange}}) {
    aggregate {
      count
      avg {
        duration_ms
      }
    }
  }
  event_executions_aggregate(where: {created_at: {_gte: $timeRange}}) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useSystemHealthQuery__
 *
 * To run a query within a React component, call `useSystemHealthQuery` and pass it any options that fit your needs.
 * When your component renders, `useSystemHealthQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSystemHealthQuery({
 *   variables: {
 *      timeRange: // value for 'timeRange'
 *   },
 * });
 */
export function useSystemHealthQuery(baseOptions: Apollo.QueryHookOptions<SystemHealthQuery, SystemHealthQueryVariables> & ({ variables: SystemHealthQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SystemHealthQuery, SystemHealthQueryVariables>(SystemHealthDocument, options);
      }
export function useSystemHealthLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SystemHealthQuery, SystemHealthQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SystemHealthQuery, SystemHealthQueryVariables>(SystemHealthDocument, options);
        }
export function useSystemHealthSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SystemHealthQuery, SystemHealthQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SystemHealthQuery, SystemHealthQueryVariables>(SystemHealthDocument, options);
        }
export type SystemHealthQueryHookResult = ReturnType<typeof useSystemHealthQuery>;
export type SystemHealthLazyQueryHookResult = ReturnType<typeof useSystemHealthLazyQuery>;
export type SystemHealthSuspenseQueryHookResult = ReturnType<typeof useSystemHealthSuspenseQuery>;
export type SystemHealthQueryResult = Apollo.QueryResult<SystemHealthQuery, SystemHealthQueryVariables>;
export const OverviewDashboardDocument = gql`
    query OverviewDashboard($timeRange: timestamptz!) {
  invocations(
    where: {created_at: {_gte: $timeRange}}
    order_by: {created_at: desc}
    limit: 10
  ) {
    id
    source_function
    created_at
    total_duration_ms
    status
    events_detected_count
    total_jobs_run
    total_jobs_succeeded
    total_jobs_failed
    correlation_id
    source_user_email
    source_user_role
  }
  invocations_aggregate(where: {created_at: {_gte: $timeRange}}) {
    aggregate {
      count
      avg {
        total_duration_ms
      }
      sum {
        total_jobs_run
        total_jobs_succeeded
        total_jobs_failed
      }
    }
  }
  event_executions_aggregate(
    where: {detected: {_eq: true}, created_at: {_gte: $timeRange}}
  ) {
    aggregate {
      count
    }
    nodes {
      event_name
    }
  }
}
    `;

/**
 * __useOverviewDashboardQuery__
 *
 * To run a query within a React component, call `useOverviewDashboardQuery` and pass it any options that fit your needs.
 * When your component renders, `useOverviewDashboardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOverviewDashboardQuery({
 *   variables: {
 *      timeRange: // value for 'timeRange'
 *   },
 * });
 */
export function useOverviewDashboardQuery(baseOptions: Apollo.QueryHookOptions<OverviewDashboardQuery, OverviewDashboardQueryVariables> & ({ variables: OverviewDashboardQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OverviewDashboardQuery, OverviewDashboardQueryVariables>(OverviewDashboardDocument, options);
      }
export function useOverviewDashboardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OverviewDashboardQuery, OverviewDashboardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OverviewDashboardQuery, OverviewDashboardQueryVariables>(OverviewDashboardDocument, options);
        }
export function useOverviewDashboardSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<OverviewDashboardQuery, OverviewDashboardQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OverviewDashboardQuery, OverviewDashboardQueryVariables>(OverviewDashboardDocument, options);
        }
export type OverviewDashboardQueryHookResult = ReturnType<typeof useOverviewDashboardQuery>;
export type OverviewDashboardLazyQueryHookResult = ReturnType<typeof useOverviewDashboardLazyQuery>;
export type OverviewDashboardSuspenseQueryHookResult = ReturnType<typeof useOverviewDashboardSuspenseQuery>;
export type OverviewDashboardQueryResult = Apollo.QueryResult<OverviewDashboardQuery, OverviewDashboardQueryVariables>;
export const InvocationsRealtimeDocument = gql`
    subscription InvocationsRealtime {
  invocations(
    limit: 20
    order_by: {created_at: desc}
    where: {status: {_in: ["running", "completed", "failed"]}}
  ) {
    id
    created_at
    source_function
    status
    total_duration_ms
    events_detected_count
    total_jobs_run
    total_jobs_succeeded
    total_jobs_failed
    correlation_id
  }
}
    `;

/**
 * __useInvocationsRealtimeSubscription__
 *
 * To run a query within a React component, call `useInvocationsRealtimeSubscription` and pass it any options that fit your needs.
 * When your component renders, `useInvocationsRealtimeSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvocationsRealtimeSubscription({
 *   variables: {
 *   },
 * });
 */
export function useInvocationsRealtimeSubscription(baseOptions?: Apollo.SubscriptionHookOptions<InvocationsRealtimeSubscription, InvocationsRealtimeSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<InvocationsRealtimeSubscription, InvocationsRealtimeSubscriptionVariables>(InvocationsRealtimeDocument, options);
      }
export type InvocationsRealtimeSubscriptionHookResult = ReturnType<typeof useInvocationsRealtimeSubscription>;
export type InvocationsRealtimeSubscriptionResult = Apollo.SubscriptionResult<InvocationsRealtimeSubscription>;
export const EventFlowDocument = gql`
    query EventFlow($invocationId: uuid!) {
  invocations_by_pk(id: $invocationId) {
    id
    source_function
    status
    total_duration_ms
    events_detected_count
    correlation_id
    event_executions {
      id
      event_name
      detected
      status
      detection_duration_ms
      handler_duration_ms
      jobs_count
      job_executions {
        id
        job_name
        job_function_name
        status
        duration_ms
        result
        error_message
      }
    }
  }
}
    `;

/**
 * __useEventFlowQuery__
 *
 * To run a query within a React component, call `useEventFlowQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventFlowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventFlowQuery({
 *   variables: {
 *      invocationId: // value for 'invocationId'
 *   },
 * });
 */
export function useEventFlowQuery(baseOptions: Apollo.QueryHookOptions<EventFlowQuery, EventFlowQueryVariables> & ({ variables: EventFlowQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventFlowQuery, EventFlowQueryVariables>(EventFlowDocument, options);
      }
export function useEventFlowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventFlowQuery, EventFlowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventFlowQuery, EventFlowQueryVariables>(EventFlowDocument, options);
        }
export function useEventFlowSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<EventFlowQuery, EventFlowQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventFlowQuery, EventFlowQueryVariables>(EventFlowDocument, options);
        }
export type EventFlowQueryHookResult = ReturnType<typeof useEventFlowQuery>;
export type EventFlowLazyQueryHookResult = ReturnType<typeof useEventFlowLazyQuery>;
export type EventFlowSuspenseQueryHookResult = ReturnType<typeof useEventFlowSuspenseQuery>;
export type EventFlowQueryResult = Apollo.QueryResult<EventFlowQuery, EventFlowQueryVariables>;
export const CorrelationChainsListDocument = gql`
    query CorrelationChainsList($limit: Int = 20) {
  invocations(
    where: {correlation_id: {_is_null: false}}
    distinct_on: correlation_id
    order_by: [{correlation_id: asc}, {created_at: desc}]
    limit: $limit
  ) {
    correlation_id
    created_at
    source_function
  }
}
    `;

/**
 * __useCorrelationChainsListQuery__
 *
 * To run a query within a React component, call `useCorrelationChainsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useCorrelationChainsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCorrelationChainsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useCorrelationChainsListQuery(baseOptions?: Apollo.QueryHookOptions<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>(CorrelationChainsListDocument, options);
      }
export function useCorrelationChainsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>(CorrelationChainsListDocument, options);
        }
export function useCorrelationChainsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>(CorrelationChainsListDocument, options);
        }
export type CorrelationChainsListQueryHookResult = ReturnType<typeof useCorrelationChainsListQuery>;
export type CorrelationChainsListLazyQueryHookResult = ReturnType<typeof useCorrelationChainsListLazyQuery>;
export type CorrelationChainsListSuspenseQueryHookResult = ReturnType<typeof useCorrelationChainsListSuspenseQuery>;
export type CorrelationChainsListQueryResult = Apollo.QueryResult<CorrelationChainsListQuery, CorrelationChainsListQueryVariables>;
export const CorrelationChainFlowDocument = gql`
    query CorrelationChainFlow($correlationId: String!) {
  invocations(
    where: {correlation_id: {_eq: $correlationId}}
    order_by: {created_at: asc}
  ) {
    id
    source_function
    created_at
    status
    total_duration_ms
    events_detected_count
    correlation_id
    event_executions {
      id
      event_name
      detected
      status
      detection_duration_ms
      handler_duration_ms
      jobs_count
      jobs_succeeded
      jobs_failed
      job_executions {
        id
        job_name
        job_function_name
        status
        duration_ms
        result
        error_message
        correlation_id
        created_at
      }
    }
  }
}
    `;

/**
 * __useCorrelationChainFlowQuery__
 *
 * To run a query within a React component, call `useCorrelationChainFlowQuery` and pass it any options that fit your needs.
 * When your component renders, `useCorrelationChainFlowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCorrelationChainFlowQuery({
 *   variables: {
 *      correlationId: // value for 'correlationId'
 *   },
 * });
 */
export function useCorrelationChainFlowQuery(baseOptions: Apollo.QueryHookOptions<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables> & ({ variables: CorrelationChainFlowQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables>(CorrelationChainFlowDocument, options);
      }
export function useCorrelationChainFlowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables>(CorrelationChainFlowDocument, options);
        }
export function useCorrelationChainFlowSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables>(CorrelationChainFlowDocument, options);
        }
export type CorrelationChainFlowQueryHookResult = ReturnType<typeof useCorrelationChainFlowQuery>;
export type CorrelationChainFlowLazyQueryHookResult = ReturnType<typeof useCorrelationChainFlowLazyQuery>;
export type CorrelationChainFlowSuspenseQueryHookResult = ReturnType<typeof useCorrelationChainFlowSuspenseQuery>;
export type CorrelationChainFlowQueryResult = Apollo.QueryResult<CorrelationChainFlowQuery, CorrelationChainFlowQueryVariables>;
export const InvocationsListDocument = gql`
    query InvocationsList($limit: Int = 20, $offset: Int = 0, $where: invocations_bool_exp = {}, $order_by: [invocations_order_by!] = {created_at: desc}) {
  invocations(limit: $limit, offset: $offset, where: $where, order_by: $order_by) {
    id
    created_at
    updated_at
    source_function
    source_table
    source_operation
    source_system
    correlation_id
    source_user_email
    source_user_role
    total_duration_ms
    events_detected_count
    total_jobs_run
    total_jobs_succeeded
    total_jobs_failed
    status
    error_message
  }
  invocations_aggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useInvocationsListQuery__
 *
 * To run a query within a React component, call `useInvocationsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useInvocationsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvocationsListQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      where: // value for 'where'
 *      order_by: // value for 'order_by'
 *   },
 * });
 */
export function useInvocationsListQuery(baseOptions?: Apollo.QueryHookOptions<InvocationsListQuery, InvocationsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InvocationsListQuery, InvocationsListQueryVariables>(InvocationsListDocument, options);
      }
export function useInvocationsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InvocationsListQuery, InvocationsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InvocationsListQuery, InvocationsListQueryVariables>(InvocationsListDocument, options);
        }
export function useInvocationsListSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<InvocationsListQuery, InvocationsListQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InvocationsListQuery, InvocationsListQueryVariables>(InvocationsListDocument, options);
        }
export type InvocationsListQueryHookResult = ReturnType<typeof useInvocationsListQuery>;
export type InvocationsListLazyQueryHookResult = ReturnType<typeof useInvocationsListLazyQuery>;
export type InvocationsListSuspenseQueryHookResult = ReturnType<typeof useInvocationsListSuspenseQuery>;
export type InvocationsListQueryResult = Apollo.QueryResult<InvocationsListQuery, InvocationsListQueryVariables>;
export const InvocationDetailDocument = gql`
    query InvocationDetail($id: uuid!) {
  invocations_by_pk(id: $id) {
    id
    created_at
    updated_at
    correlation_id
    source_function
    source_table
    source_operation
    source_system
    source_event_id
    source_event_payload
    source_event_time
    source_user_email
    source_user_role
    total_duration_ms
    events_detected_count
    total_jobs_run
    total_jobs_succeeded
    total_jobs_failed
    auto_load_modules
    event_modules_directory
    status
    error_message
    error_stack
    context_data
    event_executions {
      id
      created_at
      updated_at
      correlation_id
      event_name
      event_module_path
      detected
      detection_duration_ms
      detection_error
      detection_error_stack
      handler_duration_ms
      handler_error
      handler_error_stack
      jobs_count
      jobs_succeeded
      jobs_failed
      status
      job_executions {
        id
        created_at
        updated_at
        correlation_id
        job_name
        job_function_name
        job_options
        duration_ms
        status
        result
        error_message
        error_stack
      }
    }
  }
}
    `;

/**
 * __useInvocationDetailQuery__
 *
 * To run a query within a React component, call `useInvocationDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useInvocationDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvocationDetailQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useInvocationDetailQuery(baseOptions: Apollo.QueryHookOptions<InvocationDetailQuery, InvocationDetailQueryVariables> & ({ variables: InvocationDetailQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InvocationDetailQuery, InvocationDetailQueryVariables>(InvocationDetailDocument, options);
      }
export function useInvocationDetailLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InvocationDetailQuery, InvocationDetailQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InvocationDetailQuery, InvocationDetailQueryVariables>(InvocationDetailDocument, options);
        }
export function useInvocationDetailSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<InvocationDetailQuery, InvocationDetailQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InvocationDetailQuery, InvocationDetailQueryVariables>(InvocationDetailDocument, options);
        }
export type InvocationDetailQueryHookResult = ReturnType<typeof useInvocationDetailQuery>;
export type InvocationDetailLazyQueryHookResult = ReturnType<typeof useInvocationDetailLazyQuery>;
export type InvocationDetailSuspenseQueryHookResult = ReturnType<typeof useInvocationDetailSuspenseQuery>;
export type InvocationDetailQueryResult = Apollo.QueryResult<InvocationDetailQuery, InvocationDetailQueryVariables>;
export const CorrelationSearchDocument = gql`
    query CorrelationSearch($searchTerm: String!) {
  invocations(
    where: {_or: [{correlation_id: {_ilike: $searchTerm}}, {source_function: {_ilike: $searchTerm}}, {source_user_email: {_ilike: $searchTerm}}]}
    order_by: {created_at: desc}
    limit: 20
  ) {
    id
    correlation_id
    source_function
    source_user_email
    created_at
    status
    total_duration_ms
    events_detected_count
    total_jobs_run
  }
}
    `;

/**
 * __useCorrelationSearchQuery__
 *
 * To run a query within a React component, call `useCorrelationSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useCorrelationSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCorrelationSearchQuery({
 *   variables: {
 *      searchTerm: // value for 'searchTerm'
 *   },
 * });
 */
export function useCorrelationSearchQuery(baseOptions: Apollo.QueryHookOptions<CorrelationSearchQuery, CorrelationSearchQueryVariables> & ({ variables: CorrelationSearchQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CorrelationSearchQuery, CorrelationSearchQueryVariables>(CorrelationSearchDocument, options);
      }
export function useCorrelationSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CorrelationSearchQuery, CorrelationSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CorrelationSearchQuery, CorrelationSearchQueryVariables>(CorrelationSearchDocument, options);
        }
export function useCorrelationSearchSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CorrelationSearchQuery, CorrelationSearchQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CorrelationSearchQuery, CorrelationSearchQueryVariables>(CorrelationSearchDocument, options);
        }
export type CorrelationSearchQueryHookResult = ReturnType<typeof useCorrelationSearchQuery>;
export type CorrelationSearchLazyQueryHookResult = ReturnType<typeof useCorrelationSearchLazyQuery>;
export type CorrelationSearchSuspenseQueryHookResult = ReturnType<typeof useCorrelationSearchSuspenseQuery>;
export type CorrelationSearchQueryResult = Apollo.QueryResult<CorrelationSearchQuery, CorrelationSearchQueryVariables>;